{
  "address": "0xF2f7f3dE4bF4bAF9eBe91FE36BE28B7aE04EE176",
  "abi": [
    {
      "inputs": [],
      "name": "PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "s",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "up",
          "type": "bool"
        }
      ],
      "name": "amountOutGivenIn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountDelta",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "resultPrice",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "s",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        }
      ],
      "name": "areaUnderCurve",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "area",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "s",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        }
      ],
      "name": "areaUnderCurveRoundUp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "area",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        }
      ],
      "name": "min",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "curPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "targetPrice",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "amountRemaining",
          "type": "int256"
        },
        {
          "internalType": "uint24",
          "name": "feePips",
          "type": "uint24"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "a",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "s",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "b",
              "type": "uint256"
            }
          ],
          "internalType": "struct GranularBondingCurve.swapVars",
          "name": "vars",
          "type": "tuple"
        }
      ],
      "name": "swapStep",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nextPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "feeAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "curPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        }
      ],
      "name": "xMax",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xeaf1966a081368793ee23d1d081e4e4c016636cef074dfb04c0315aeaf2c1d8a",
  "receipt": {
    "to": null,
    "from": "0x2C7Cb3cB22Ba9B322af60747017acb06deB10933",
    "contractAddress": "0xF2f7f3dE4bF4bAF9eBe91FE36BE28B7aE04EE176",
    "transactionIndex": 0,
    "gasUsed": "633477",
    "logsBloom": "0x00000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000020000000000000000080000000000000000000000000000000000000000000000000000100000000000000000000000000200000000000000020000001000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x5ae962d3a8d56719fdbd8cf37349d5dbdf6be3fa4308222f253b5cecd212a60d",
    "transactionHash": "0xeaf1966a081368793ee23d1d081e4e4c016636cef074dfb04c0315aeaf2c1d8a",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 30043874,
        "transactionHash": "0xeaf1966a081368793ee23d1d081e4e4c016636cef074dfb04c0315aeaf2c1d8a",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000002c7cb3cb22ba9b322af60747017acb06deb10933",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000e10e65c3458a350000000000000000000000000000000000000000000000007d56402e494c5b9f00000000000000000000000000000000000000000000189506d81230b88cf95d0000000000000000000000000000000000000000000000007c7531c88606d16a00000000000000000000000000000000000000000000189507b920967bd28392",
        "logIndex": 0,
        "blockHash": "0x5ae962d3a8d56719fdbd8cf37349d5dbdf6be3fa4308222f253b5cecd212a60d"
      }
    ],
    "blockNumber": 30043874,
    "cumulativeGasUsed": "633477",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 7,
  "solcInputHash": "5fddb7b3189cdd9cadb105fc356950ca",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"up\",\"type\":\"bool\"}],\"name\":\"amountOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDelta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resultPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"areaUnderCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"area\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"areaUnderCurveRoundUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"area\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"curPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetPrice\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"amountRemaining\",\"type\":\"int256\"},{\"internalType\":\"uint24\",\"name\":\"feePips\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"internalType\":\"struct GranularBondingCurve.swapVars\",\"name\":\"vars\",\"type\":\"tuple\"}],\"name\":\"swapStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"curPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"xMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"amountOutGivenIn(uint256,uint256,uint256,uint256,bool)\":{\"details\":\"tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\",\"params\":{\"amount\":\": amount of base in returns amountDelta wanted token returned \"}},\"swapStep(uint256,uint256,int256,uint24,GranularBondingCurve.swapVars)\":{\"params\":{\"feePips\":\"The fee taken from the input amount, expressed in hundredths of a bip b is 0 and s is curPrice/a during variable liquidity phase\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"areaUnderCurve(uint256,uint256,uint256,uint256)\":{\"notice\":\"calculates area under the curve from s to s+amount result = a * amount / 2  * (2* supply + amount) + b * amount returned in collateral decimals\"},\"swapStep(uint256,uint256,int256,uint24,GranularBondingCurve.swapVars)\":{\"notice\":\"Compute results of swap given amount in and params\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/bonds/GBC.sol\":\"LinearCurve\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363731373930313533373133\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/bonds/GBC.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\n// import {ERC20} from \\\"./aave/Libraries.sol\\\"; \\nimport {SafeCast, FixedPointMath, ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \\n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \\n/// @dev all funds will be handled in the child contract \\ncontract GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using Tick for mapping(uint16 => Tick.Info);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n    using SafeCast for uint256; \\n\\n\\n    modifier onlyEntry(){\\n        require(entry == msg.sender  ,\\\"Not Entry\\\"); \\n        _;\\n    }\\n    \\n    bool private _mutex;\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    constructor(\\n        address _baseToken,\\n        address _tradeToken\\n        //uint256 _priceDelta\\n        ) {\\n        tradeToken = _tradeToken; \\n        baseToken = _baseToken; \\n        //priceDelta = _priceDelta; \\n        fee =0; \\n        factory = address(0); \\n        tickSpacing = 0; \\n        //Start liquidity \\n        liquidity = 100 * uint128(PRECISION); \\n\\n        owner = msg.sender; \\n    }\\n\\n    address public immutable owner; \\n    uint24 public immutable  fee;\\n    Slot0 public slot0; // global state?\\n    address public immutable  factory;\\n    address public immutable  tradeToken;\\n    address public immutable  baseToken;\\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\\n\\n    uint128 public liquidity;\\n\\n    mapping(uint16 => Tick.Info) public  ticks;\\n\\n    mapping(bytes32 => Position.Info) public  positions;\\n\\n    // mapping(uint16=> PricePoint) Points; \\n\\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\\n    uint256 public constant ROUNDLIMIT = 1e4; \\n    uint256 public constant PRECISION = 1e18; \\n    address public entry; \\n\\n    /// @notice previliged function called by the market maker \\n    /// if he is the one providing all the liquidity \\n    function setLiquidity(uint128 liq) internal  \\n    //onlyEntry\\n    {\\n        liquidity = liq; \\n    }\\n\\n    function setEntry(address _entry) external onlyEntry{\\n        entry = _entry; \\n    }\\n    function lock() external onlyEntry{\\n        slot0.unlocked = !slot0.unlocked; \\n    }\\n\\n    function positionIsFilled(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk\\n    ) \\n        public view returns(bool){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        return (liq>0 && numCross > crossId); \\n    }\\n\\n    function setPriceAndPoint(uint256 price) internal  \\n    //onlyOwner\\n    {\\n        slot0.point = priceToPoint(price);         \\n        slot0.curPrice = price.toUint160(); \\n    }\\n\\n    function getCurPrice() external view returns(uint256){\\n        return slot0.curPrice; \\n    }\\n\\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\\n        return uint256(ticks.oneTimeLiquidity(point)); \\n    }    \\n\\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\\n        return ticks.getNumCross(point, moveUp); \\n    }\\n\\n\\n    struct Slot0 {\\n        // the current price\\n        uint160 curPrice;\\n        // the current tick\\n        uint16 point;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n\\n        // Whether liquidity provision is amortized \\n        bool amortized; \\n\\n        // Where to modify liquidity \\n        uint16 modifyLiqPoint; \\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        uint256 amountCalculated;\\n        // current sqrt(price)\\n        uint256 curPrice;\\n        // the tick associated with the current price\\n        uint16 point;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobal;\\n        // amount of input token paid as protocol fee\\n        uint128 protocolFee;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n        uint128 liquidityStart; \\n\\n\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint256 priceStart;\\n        // the next tick to swap to from the current tick in the swap direction\\n        uint16 pointNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // price for the next tick (1/0)\\n        uint256 priceNextLimit;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n\\n        uint128 liqDir; \\n    }\\n\\n    struct swapVars{\\n        uint256 a;\\n        uint256 s; \\n        uint256 b; \\n    }\\n\\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\\n    /// -amountSpecified is in trade if moveUp, else is in base \\n    /// returns amountIn if moveUp, cash, else token\\n    /// returns amountOut if moveUp, token, else cash \\n    function trade(\\n        address recipient, \\n        bool moveUp, \\n        int256 amountSpecified, \\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\\n        console.logString('---New Trade---'); \\n\\n        Slot0 memory slot0Start = slot0; \\n        uint256 pDelta = priceDelta; \\n\\n        SwapState memory state = SwapState({\\n            amountSpecifiedRemaining: amountSpecified, \\n            amountCalculated: 0, \\n            curPrice: uint256(slot0Start.curPrice),\\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\\n            protocolFee: 0, \\n            liquidity: liquidity, \\n            liquidityStart: liquidity,\\n            point: slot0.point\\n            }); \\n        swapVars memory vars = swapVars({\\n            a:0,\\n            b:0,\\n            s:0\\n            });\\n\\n        bool exactInput = amountSpecified > 0;\\n\\n        // increment price by 1/1e18 if at boundary, and go back up a point,\\n        // should be negligible compared to fees TODO \\n        if (mod0(state.curPrice, pDelta) && !moveUp) {\\n            state.curPrice += 1; \\n            state.point = priceToPoint(state.curPrice);\\n            slot0.point = state.point; \\n            slot0Start.point = state.point; \\n        }\\n\\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\\n            StepComputations memory step; \\n\\n            step.priceStart = state.curPrice; \\n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \\n            step.pointNext = moveUp? state.point + 1 : state.point-1; \\n\\n            // Need liquidity for both move up and move down for path independence within a \\n            // given point range. Either one of them should be 0 \\n            step.liqDir = ticks.oneTimeLiquidity(state.point);\\n            vars.a = exactInput \\n                ? inv(state.liquidity + step.liqDir)\\n                : invRoundUp(state.liquidity + step.liqDir); \\n            vars.b = yInt(state.curPrice, moveUp); \\n            vars.s = xMax(state.curPrice, vars.b, vars.a); \\n\\n            //If moveup, amountIn is in cash, amountOut is token and vice versa \\n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\\n                state.curPrice, \\n                step.priceNextLimit,    \\n                state.amountSpecifiedRemaining, \\n                fee, \\n                vars               \\n                ); \\n\\n            {console.log('________'); \\n            console.log('CURPRICE', state.curPrice); \\n            console.log('trading; liquidity, amountleft', state.liquidity); \\n            console.log(uint256(-state.amountSpecifiedRemaining));\\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \\n            console.log('a', vars.a); }\\n            console.log('amountinandout', step.amountIn, step.amountOut); \\n            console.log('s,b', vars.s, vars.b); \\n\\n            if (exactInput){\\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \\n            }\\n            else{\\n                state.amountSpecifiedRemaining += int256(step.amountIn); \\n            }\\n            state.amountCalculated += step.amountOut; \\n\\n            if (state.liquidity>0)\\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \\n\\n            // If next limit reached, cross price range and change slope(liquidity)\\n            if (state.curPrice == step.priceNextLimit){\\n\\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\\n                // Else if crossing DOWN, bids are all filled \\n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \\n\\n                int128 liquidityNet = ticks.cross(\\n                    step.pointNext, \\n                    feeGrowthGlobalBase,\\n                    feeGrowthGlobalTrade\\n                    ); \\n\\n                if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint)\\n                    liquidityNet = liquidityNet += dynamicLiq[step.pointNext]; \\n                    console.log('dynamicLiq', uint256(int256(dynamicLiq[step.pointNext])), uint256(int256(liquidityNet))); \\n\\n                if (!moveUp) liquidityNet = -liquidityNet; \\n\\n\\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\\n\\n                state.point = step.pointNext;  \\n            }\\n        }\\n\\n        slot0.curPrice = state.curPrice.toUint160(); \\n        if(state.point != slot0Start.point) slot0.point = state.point; \\n            \\n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\\n\\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \\n            \\n        // (amountIn, amountOut) = exactInput\\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n\\n        (amountIn, amountOut) = exactInput\\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n    }\\n\\n    function placeLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk  \\n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \\n\\n        // Should only accept asks for price above the current point range\\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\\\"ask below prie\\\"); \\n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\\\"bids above prie\\\"); \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        numCross = ticks.getNumCross(point, isAsk); \\n        position.updateLimit(int128(amount), isAsk, numCross); \\n\\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \\n\\n        // If placing bids, need to escrow baseAsset, vice versa \\n        address tokenToEscrow = isAsk? tradeToken : baseToken;\\n\\n        amountToEscrow = isAsk\\n                ? tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    )\\n            \\n                : baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    ); \\n\\n        console.log('amountbid', amountToEscrow); \\n\\n    }\\n\\n    function reduceLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \\\"Can't reduce order for current tick\\\"); \\n\\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\\n\\n        position.updateLimit(-int128(amount), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \\n\\n        address tokenToReturn = isAsk? tradeToken : baseToken;\\n        \\n        amountToReturn = isAsk\\n            ? tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                )\\n         \\n            : baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                );\\n    }\\n\\n    /// @notice called when maker wants to claim when the the price is at the \\n    /// point he submitted the order\\n    function claimPartiallyFilledOrder(\\n        address recipient, \\n        uint16 point,\\n        bool isAsk\\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\\n        Slot0 memory _slot0 = slot0; \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n        require(priceToPoint(uint256(slot0.curPrice)) == point, \\\"Not current price\\\"); \\n\\n        // Assume trying to withdraw all liquidity provided \\n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \\n       \\n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \\n\\n        // Get total trade filled OR remaining\\n        tradeAmount = tradeGivenLiquidity(\\n            pointToPrice(point+1),\\n            _slot0.curPrice, \\n            liqToWithdraw\\n        ); \\n           \\n        // Get total base filled OR remaining \\n        baseAmount = baseGivenLiquidity(\\n            _slot0.curPrice, \\n            pointToPrice(point), \\n            liqToWithdraw\\n            ); \\n\\n    }\\n\\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \\n    /// or crossDown \\n    function claimFilledOrder(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        require(numCross > crossId, \\\"Position not filled\\\");\\n\\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        // Sold to base when asks are filled\\n        if(isAsk) claimedAmount = baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        // Bought when bids are filled so want tradeTokens\\n        else claimedAmount = tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        position.updateLimit(-int128(liq), isAsk, 0); \\n        \\n        // Need to burn AND \\n\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        uint16 pointLower;\\n        uint16 pointUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n    }\\n\\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\\n    function provide(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount, \\n        bytes calldata data \\n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\\n        require(amount > 0, \\\"0 amount\\\"); \\n\\n        (,  amount0,  amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        //mintCallback\\n\\n    }\\n\\n    function remove(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount\\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\\n\\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: -int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        if(amount0>0 || amount1> 0){\\n            (position.tokensOwed0, position.tokensOwed1) = (\\n                position.tokensOwed0 + amount0,\\n                position.tokensOwed1 + amount1\\n            );\\n        }\\n        return (amount0, amount1); \\n    }\\n\\n    function collect(\\n        address recipient,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\\n\\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\\n\\n        if (amount0 > 0) {\\n            position.tokensOwed0 -= amount0;\\n        }\\n        if (amount1 > 0) {\\n            position.tokensOwed1 -= amount1;\\n        }\\n    }\\n\\n\\n    function _modifyPosition(ModifyPositionParams memory params)\\n    private \\n    returns(\\n        Position.Info storage position, \\n        uint256 baseAmount, \\n        uint256 tradeAmount\\n        )\\n    {\\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\\n\\n        position = _updatePosition(\\n            params.owner,\\n            params.pointLower,\\n            params.pointUpper,\\n            params.liquidityDelta,\\n            _slot0.point\\n        );\\n\\n        if (params.liquidityDelta != 0){\\n            if (_slot0.point < params.pointLower){\\n                // in case where liquidity is just asks waiting to be sold into, \\n                // so need to only provide tradeAsset \\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n            } else if( _slot0.point < params.pointUpper){\\n                uint128 liquidityBefore = liquidity; \\n\\n                // Get total asks to be submitted above current price\\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper),\\n                    _slot0.curPrice, \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Get total bids to be submitted below current price \\n                baseAmount = baseGivenLiquidity(\\n                    _slot0.curPrice, \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Slope changes since current price is in this range \\n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\\n\\n            } else{\\n                // liquidity is just bids waiting to be bought into \\n                baseAmount = baseGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                ); \\n            }\\n        }\\n    }\\n\\n    uint256 public feeGrowthGlobalBase;\\n    uint256 public feeGrowthGlobalTrade;\\n\\n    function _updatePosition(\\n        address owner, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        int128 liquidityDelta, \\n        uint16 point \\n        ) private returns(Position.Info storage position){\\n\\n        position = positions.get(owner, pointLower, pointUpper); \\n\\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \\n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \\n\\n        if(liquidityDelta != 0){\\n\\n            ticks.update(\\n                pointLower, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                false\\n                ); \\n\\n            ticks.update(\\n                pointUpper, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                true\\n                ); \\n        } \\n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \\n    }\\n\\n\\n    mapping(uint16=> int128) dynamicLiq; \\n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\\n        dynamicLiq[point] = liq; \\n    }\\n    function setModifyLiqPoint(uint16 point) internal{\\n        slot0.modifyLiqPoint = point;  \\n    }\\n    function amortizeLiq() internal{\\n        slot0.amortized = true; \\n    }\\n\\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return (p2-p1).mulWadDown(L); \\n    }\\n\\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \\n    }\\n\\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return T.divWadDown(p2-p1); \\n    }\\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \\n    }\\n\\n    function pointToPrice(uint16 point) public pure returns(uint160){\\n        return(uint256(point) * priceDelta).toUint160(); \\n    }\\n\\n    /// @notice will round down to nearest integer \\n    function priceToPoint(uint256 price) public pure returns(uint16){\\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        return (curPrice-b).divWadUp(a); \\n    }\\n\\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\\n    /// the current point\\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\\n        uint16 point = priceToPoint(curPrice); \\n\\n        // If at boundary when moving down, decrement point by one\\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \\n    }\\n\\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\\n        if (moveUp) return uint256(point+1) * pDelta; \\n        else return uint256(point) * pDelta; \\n    }\\n\\n    function inv(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \\n    }\\n    function invRoundUp(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \\n    }\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\\n        return (a%b ==0); \\n    }\\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\\n    /// @param x The liquidity before change\\n    /// @param y The delta by which liquidity should be changed\\n    /// @return z The liquidity delta\\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\\n        return  isAsk\\n                ? positions.get(to, point, point+1).askLiq\\n                : positions.get(to, point, point+1).bidLiq; \\n    }\\n\\n}\\n\\nlibrary LinearCurve{\\n    uint256 public constant PRECISION = 1e18; \\n    using FixedPointMath for uint256; \\n\\n\\n    /// @notice Compute results of swap given amount in and params\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// b is 0 and s is curPrice/a during variable liquidity phase\\n    function swapStep(\\n        uint256 curPrice, \\n        uint256 targetPrice, \\n        int256 amountRemaining, \\n        uint24 feePips,    \\n        GranularBondingCurve.swapVars memory vars       \\n        ) \\n        public \\n        pure \\n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\\n\\n        bool moveUp = targetPrice >= curPrice; \\n        bool exactInput = amountRemaining >= 0; \\n\\n        // If move up and exactInput, amountIn is base, amountOut is trade \\n        if (exactInput){\\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\\n\\n            if (moveUp){\\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \\n\\n                // If overshoot go to next point\\n                if (nextPrice >= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out for a given price range is Pdelta / a \\n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \\n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \\n                }            \\n                else {\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }   \\n            }\\n\\n            // amountIn is trade, amountOut is base \\n            else {\\n                // If amount is greater than s, then need to cap it \\n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \\n                // If undershoot go to previous point \\n                if(nextPrice <= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out is area under curve \\n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \\n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \\n\\n                }\\n                else{\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }\\n            }\\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \\n        }\\n\\n        else {\\n            if(moveUp){\\n                uint256 remaining = uint256(-amountRemaining); \\n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \\n\\n                // if overshoot\\n                if(nextPrice>=targetPrice){\\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \\n                    nextPrice = targetPrice; \\n\\n                    // Prevent stuck cases where point is almost filled but not quite \\n                    if(remaining - amountIn<=1e4){\\n                        amountIn = remaining; \\n                    } \\n                }\\n                else amountIn = remaining; \\n\\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\\n\\n            }\\n            else{\\n                //TODO \\n            }\\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\\n            amountOut = amountOut + feeAmount;\\n        }\\n    }\\n\\n\\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\\n    /// @param amount: amount of base in\\n    /// returns amountDelta wanted token returned \\n    function amountOutGivenIn( \\n        uint256 amount,\\n        uint256 s, \\n        uint256 a, \\n        uint256 b, \\n        bool up) \\n        public \\n        pure \\n        returns(uint256 amountDelta, uint256 resultPrice) {\\n        \\n        // If liquidity is not infinite \\n        if(a > 0){\\n            if (up){\\n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \\n                uint256 y = 2*( a.mulWadDown(amount)); \\n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\\n                uint256 z = (a.mulWadDown(s) + b); \\n                amountDelta = (x_y_sqrt-z).divWadDown(a);\\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \\n            }\\n\\n            else{\\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \\n                amountDelta = amount.mulWadDown(z); \\n                resultPrice = a.mulWadDown(s-amount) + b; \\n            }\\n        }\\n\\n        // When a = 0, infinite liquidity and constant price\\n        else{\\n            amountDelta = amount.divWadDown(b); \\n            resultPrice = b; \\n        }\\n\\n    }\\n\\n    /// @notice calculates area under the curve from s to s+amount\\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\\n     /// returned in collateral decimals\\n    function areaUnderCurve(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \\n    }\\n    function areaUnderCurveRoundUp(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        // you want area to be big for a given amount \\n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n\\n}\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    using FixedPointMath for uint256;\\n\\n    // info stored for each user's position\\n    struct Info {\\n        uint128 bidCrossId; \\n        uint128 askCrossId; \\n        uint128 askLiq; \\n        uint128 bidLiq; \\n\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // the fees owed to the position owner in token0/token1\\n        uint256 tokensOwed0;\\n        uint256 tokensOwed1;\\n\\n        \\n    }\\n\\n    function updateLimit(\\n        Info storage self,\\n        int128 limitLiqudityDelta, \\n        bool isAsk, \\n        uint128 crossId\\n        ) internal {\\n\\n        if (isAsk) {\\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \\n        } \\n\\n        else {\\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \\n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \\n        }\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        uint16 tickLower,\\n        uint16 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees\\n        uint128 tokensOwed0 = uint128(\\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n        uint128 tokensOwed1 =uint128(\\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n            \\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\\n            self.tokensOwed0 += tokensOwed0;\\n            self.tokensOwed1 += tokensOwed1;\\n        }\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n}\\n\\n/// @title Tick\\n/// @notice Contains functions for managing tick processes and relevant calculations\\nlibrary Tick {\\n    using FixedPointMath for uint256;\\n\\n    using SafeCast for int256;\\n\\n    // info stored for each initialized individual tick\\n    struct Info {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutsideBase;\\n        uint256 feeGrowthOutsideTrade;\\n        // the cumulative tick value on the other side of the tick\\n        int56 tickCumulativeOutside;\\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint160 secondsPerLiquidityOutsideX128;\\n        // the seconds spent on the other side of the tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint32 secondsOutside;\\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\\n        bool initialized;\\n\\n        uint128 askLiquidityGross; \\n        uint128 bidLiquidityGross;\\n        uint128 askNumCross; \\n        uint128 bidNumCross; \\n    }\\n\\n    function getNumCross(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal view returns(uint128){\\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \\n    }\\n\\n    function oneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick \\n        ) internal view returns(uint128){\\n        Tick.Info memory info = self[tick]; \\n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \\n        return info.askLiquidityGross + info.bidLiquidityGross; \\n    }\\n\\n    function deleteOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal {\\n        Tick.Info storage info = self[tick]; \\n        if(isAsk) {\\n            info.askLiquidityGross = 0;\\n            info.askNumCross++; \\n            console.log('tick??', tick); \\n        }\\n        else {\\n            info.bidLiquidityGross = 0; \\n            info.bidNumCross++; \\n        }\\n    }\\n\\n    function updateOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        int128 oneTimeLiquidityDelta,\\n        bool isAsk\\n        ) internal {\\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \\n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\\n    }\\n\\n    function update(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick,\\n        uint16 tickCurrent,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthGlobalBase, \\n        uint256 feeGrowthGlobalTrade, \\n        bool upper\\n    ) internal returns (bool flipped) {\\n        Tick.Info storage info = self[tick];\\n\\n        uint128 liquidityGrossBefore = info.liquidityGross; \\n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if(liquidityGrossBefore == 0) {\\n            if(tick<=tickCurrent){\\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \\n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \\n            }\\n            info.initialized = true; \\n        }\\n        info.liquidityGross = liquidityGrossAfter;\\n\\n        info.liquidityNet = upper \\n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \\n    }\\n\\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\\n        delete self[tick];\\n    }\\n\\n    function cross(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick, \\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal returns (int128 liquidityNet) {\\n        Tick.Info storage info = self[tick]; \\n\\n        liquidityNet = info.liquidityNet; \\n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \\n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n\\n    function getFeeGrowthInside(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint16 tickCurrent,\\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\\n        Info storage lower = self[tickLower];\\n        Info storage upper = self[tickUpper];\\n\\n        // calculate fee growth below\\n        uint256 feeGrowthBelowBase;\\n        uint256 feeGrowthBelowTrade;\\n        if (tickCurrent >= tickLower) {\\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\\n        }\\n\\n        // calculate fee growth above\\n        uint256 feeGrowthAboveBase;\\n        uint256 feeGrowthAboveTrade;\\n        if (tickCurrent < tickUpper) {\\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\\n        }\\n\\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\\n    }\\n}\\n\\n\\ncontract SpotPool is GranularBondingCurve{\\n\\n    ERC20 BaseToken; //junior\\n    ERC20 TradeToken; //senior \\n    // GranularBondingCurve public pool; \\n\\n    constructor(\\n        address _baseToken, \\n        address _tradeToken\\n        )GranularBondingCurve(_baseToken,_tradeToken){\\n        BaseToken = ERC20(_baseToken); \\n        TradeToken = ERC20(_tradeToken); \\n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \\n    }\\n\\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\\n\\n        if(up){\\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\\n            console.log('togive', amountOut, amountIn); \\n            TradeToken.transfer(recipient, amountOut); \\n            console.log('balofre', BaseToken.balanceOf(recipient));\\n            BaseToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n\\n        else{\\n            BaseToken.transfer(recipient, amountOut); \\n            TradeToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n    }\\n\\n    // function getCurPrice() external view returns(uint256){\\n    //     return uint256(pool.getCurPrice());\\n    // }\\n\\n    /// @notice if buyTradeForBase, move up, and vice versa \\n    function takerTrade(\\n        address recipient, \\n        bool buyTradeForBase, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data        \\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        (poolamountIn, poolamountOut) = this.trade(\\n            recipient, \\n            buyTradeForBase, \\n            amountIn,  \\n            priceLimit, \\n            data\\n        ); \\n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \\n    }\\n\\n    /// @notice specify how much trade trader intends to sell/buy \\n    function makerTrade(\\n        bool buyTradeForBase,\\n        uint256 amountIn,\\n        uint16 point\\n        ) external {\\n        (uint256 toEscrowAmount, uint128 crossId) \\n                = this.placeLimitOrder(msg.sender, \\n                    point, \\n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \\n                    !buyTradeForBase); \\n\\n        // Collateral for bids\\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n\\n        // or asks\\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n    }\\n\\n    function makerClaim(\\n        uint16 point, \\n        bool buyTradeForBase\\n        ) external {\\n        uint256 claimedAmount = this.claimFilledOrder(\\n            msg.sender, \\n            point, \\n            !buyTradeForBase\\n        ); \\n\\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\\n        else BaseToken.transfer(msg.sender, claimedAmount); \\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\",\"keccak256\":\"0x10039ee3eecf56b8891ccc2d1c996baa0510a53f24f13a9d9a6b50ba3129f821\",\"license\":\"UNLICENSED\"},\"contracts/bonds/libraries.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMath {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint256(y)) == y);\\n    // }\\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint160(y)) == y);\\n    // }\\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\\n        require((z = uint128(y)) == y);\\n    }\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\\n\\ncontract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n    function mint(address to, uint256 amount) public {\\n      _mint(to, amount); \\n    }\\n    function burn(address to, uint256 amount) public {\\n      _burn(to, amount); \\n    }\\n}\",\"keccak256\":\"0x6f4b41b0a3a677144ec92ae040f756a7af61ffe54f497f92d7f20a729b3cb091\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x610a8061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80637ae2b5c7116100655780637ae2b5c71461010d5780638423132014610120578063aaf5eb6814610133578063b29d9b6e1461014257600080fd5b8063018b03511461008c578063324404ea146100b95780636ca35e9e146100ec575b600080fd5b61009f61009a366004610714565b610155565b604080519283526020830191909152015b60405180910390f35b6100cc6100c7366004610766565b6102bc565b6040805194855260208501939093529183015260608201526080016100b0565b6100ff6100fa36600461081b565b6104de565b6040519081526020016100b0565b6100ff61011b36600461084d565b610532565b6100ff61012e36600461081b565b61054d565b6100ff670de0b6b3a764000081565b6100ff61015036600461086f565b61058e565b60008084156102a2578215610237576000670de0b6b3a764000060028661017c898b6105b9565b61018691906108b1565b61019091906109a8565b61019a91906109b7565b905060006101a8878a6105b9565b6101b39060026109d9565b905060006101dc670de0b6b3a76400006101cd84866108b1565b6101d791906109d9565b6105ce565b90506000876101eb8a8c6105b9565b6101f591906108b1565b905061020b8961020583856109f8565b906106a7565b95508761022261021b8c896108b1565b8b906105b9565b61022c91906108b1565b9450505050506102b2565b60006002610245878a6105b9565b61024f91906109b7565b61025987896105b9565b61026390876108b1565b61026d91906109f8565b905061027988826105b9565b9250846102906102898a8a6109f8565b88906105b9565b61029a91906108b1565b9150506102b2565b6102ac87856106a7565b91508390505b9550959350505050565b60008080808888101581881280159061043157811561036e576102ef89886020015189600001518a604001516001610155565b9650935089861061034e5786518a965061030d906102058d896109f8565b935061034761031f89620f4240610a0b565b62ffffff16620f4240610340878b602001518c600001518d604001516104de565b91906106b8565b94506103fc565b61034761035e89620f4240610a0b565b8a9062ffffff16620f42406106b8565b61039261037f8a8960200151610532565b6020890151895160408b01516000610155565b965093508986116103e95786518a96506103b090610205888e6109f8565b94506103c785600089600001518a604001516104de565b93506103476103d989620f4240610a0b565b869062ffffff16620f42406106b8565b6103f961035e89620f4240610a0b565b94505b61042a61041f620f42406104108b82610a0b565b62ffffff8c81169291166106b8565b8690620f42406106b8565b92506104d0565b81156104ae5760006104428a610a2e565b88519091508c9061045390836106d7565b61045d91906108b1565b96508a8710610495576104758b8d8a6000015161058e565b8b9750955061271061048787836109f8565b11610490578095505b610499565b8095505b6104aa8660008a600001518f61054d565b9450505b6104c18462ffffff8a16620f42406106b8565b92506104cd83856108b1565b93505b505095509550955095915050565b60006104ea82866105b9565b61051f866104f98760026109d9565b61050391906108b1565b600261050f878a6105b9565b61051991906109b7565b906105b9565b61052991906108b1565b95945050505050565b6000818311156105425781610544565b825b90505b92915050565b600061055982866106d7565b61051f866105688760026109d9565b61057291906108b1565b600261057e878a6106d7565b61058891906109b7565b906106d7565b6000816000036105a157506000196105b2565b6105af8261020585876109f8565b90505b9392505050565b60006105448383670de0b6b3a76400006106b8565b600181600160801b81106105e75760409190911b9060801c5b6801000000000000000081106106025760209190911b9060401c5b64010000000081106106195760109190911b9060201c5b62010000811061062e5760089190911b9060101c5b61010081106106425760049190911b9060081c5b601081106106555760029190911b9060041c5b60088110610664578160011b91505b5080820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c808204818110156106a1578091505b50919050565b600061054483670de0b6b3a7640000845b8282028115158415858304851417166106d057600080fd5b0492915050565b60006105448383670de0b6b3a764000081830283810483148415176001166106fe57600080fd5b6001826001830304018115150290509392505050565b600080600080600060a0868803121561072c57600080fd5b853594506020860135935060408601359250606086013591506080860135801515811461075857600080fd5b809150509295509295909350565b600080600080600085870360e081121561077f57600080fd5b863595506020870135945060408701359350606087013562ffffff811681146107a757600080fd5b92506060607f19820112156107bb57600080fd5b506040516060810181811067ffffffffffffffff821117156107ed57634e487b7160e01b600052604160045260246000fd5b80604052506080870135815260a0870135602082015260c08701356040820152809150509295509295909350565b6000806000806080858703121561083157600080fd5b5050823594602084013594506040840135936060013592509050565b6000806040838503121561086057600080fd5b50508035926020909101359150565b60008060006060848603121561088457600080fd5b505081359360208301359350604090920135919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156105475761054761089b565b600181815b808511156108ff5781600019048211156108e5576108e561089b565b808516156108f257918102915b93841c93908002906108c9565b509250929050565b60008261091657506001610547565b8161092357506000610547565b816001811461093957600281146109435761095f565b6001915050610547565b60ff8411156109545761095461089b565b50506001821b610547565b5060208310610133831016604e8410600b8410161715610982575081810a610547565b61098c83836108c4565b80600019048211156109a0576109a061089b565b029392505050565b600061054460ff841683610907565b6000826109d457634e487b7160e01b600052601260045260246000fd5b500490565b60008160001904831182151516156109f3576109f361089b565b500290565b818103818111156105475761054761089b565b62ffffff818116838216019080821115610a2757610a2761089b565b5092915050565b6000600160ff1b8201610a4357610a4361089b565b506000039056fea2646970667358221220b825166f7de02fd002ecf39ab02766b65b121168a7c5821098c937dd5fe8c5dd64736f6c63430008100033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80637ae2b5c7116100655780637ae2b5c71461010d5780638423132014610120578063aaf5eb6814610133578063b29d9b6e1461014257600080fd5b8063018b03511461008c578063324404ea146100b95780636ca35e9e146100ec575b600080fd5b61009f61009a366004610714565b610155565b604080519283526020830191909152015b60405180910390f35b6100cc6100c7366004610766565b6102bc565b6040805194855260208501939093529183015260608201526080016100b0565b6100ff6100fa36600461081b565b6104de565b6040519081526020016100b0565b6100ff61011b36600461084d565b610532565b6100ff61012e36600461081b565b61054d565b6100ff670de0b6b3a764000081565b6100ff61015036600461086f565b61058e565b60008084156102a2578215610237576000670de0b6b3a764000060028661017c898b6105b9565b61018691906108b1565b61019091906109a8565b61019a91906109b7565b905060006101a8878a6105b9565b6101b39060026109d9565b905060006101dc670de0b6b3a76400006101cd84866108b1565b6101d791906109d9565b6105ce565b90506000876101eb8a8c6105b9565b6101f591906108b1565b905061020b8961020583856109f8565b906106a7565b95508761022261021b8c896108b1565b8b906105b9565b61022c91906108b1565b9450505050506102b2565b60006002610245878a6105b9565b61024f91906109b7565b61025987896105b9565b61026390876108b1565b61026d91906109f8565b905061027988826105b9565b9250846102906102898a8a6109f8565b88906105b9565b61029a91906108b1565b9150506102b2565b6102ac87856106a7565b91508390505b9550959350505050565b60008080808888101581881280159061043157811561036e576102ef89886020015189600001518a604001516001610155565b9650935089861061034e5786518a965061030d906102058d896109f8565b935061034761031f89620f4240610a0b565b62ffffff16620f4240610340878b602001518c600001518d604001516104de565b91906106b8565b94506103fc565b61034761035e89620f4240610a0b565b8a9062ffffff16620f42406106b8565b61039261037f8a8960200151610532565b6020890151895160408b01516000610155565b965093508986116103e95786518a96506103b090610205888e6109f8565b94506103c785600089600001518a604001516104de565b93506103476103d989620f4240610a0b565b869062ffffff16620f42406106b8565b6103f961035e89620f4240610a0b565b94505b61042a61041f620f42406104108b82610a0b565b62ffffff8c81169291166106b8565b8690620f42406106b8565b92506104d0565b81156104ae5760006104428a610a2e565b88519091508c9061045390836106d7565b61045d91906108b1565b96508a8710610495576104758b8d8a6000015161058e565b8b9750955061271061048787836109f8565b11610490578095505b610499565b8095505b6104aa8660008a600001518f61054d565b9450505b6104c18462ffffff8a16620f42406106b8565b92506104cd83856108b1565b93505b505095509550955095915050565b60006104ea82866105b9565b61051f866104f98760026109d9565b61050391906108b1565b600261050f878a6105b9565b61051991906109b7565b906105b9565b61052991906108b1565b95945050505050565b6000818311156105425781610544565b825b90505b92915050565b600061055982866106d7565b61051f866105688760026109d9565b61057291906108b1565b600261057e878a6106d7565b61058891906109b7565b906106d7565b6000816000036105a157506000196105b2565b6105af8261020585876109f8565b90505b9392505050565b60006105448383670de0b6b3a76400006106b8565b600181600160801b81106105e75760409190911b9060801c5b6801000000000000000081106106025760209190911b9060401c5b64010000000081106106195760109190911b9060201c5b62010000811061062e5760089190911b9060101c5b61010081106106425760049190911b9060081c5b601081106106555760029190911b9060041c5b60088110610664578160011b91505b5080820401600190811c80830401811c80830401811c80830401811c80830401811c80830401811c80830401901c808204818110156106a1578091505b50919050565b600061054483670de0b6b3a7640000845b8282028115158415858304851417166106d057600080fd5b0492915050565b60006105448383670de0b6b3a764000081830283810483148415176001166106fe57600080fd5b6001826001830304018115150290509392505050565b600080600080600060a0868803121561072c57600080fd5b853594506020860135935060408601359250606086013591506080860135801515811461075857600080fd5b809150509295509295909350565b600080600080600085870360e081121561077f57600080fd5b863595506020870135945060408701359350606087013562ffffff811681146107a757600080fd5b92506060607f19820112156107bb57600080fd5b506040516060810181811067ffffffffffffffff821117156107ed57634e487b7160e01b600052604160045260246000fd5b80604052506080870135815260a0870135602082015260c08701356040820152809150509295509295909350565b6000806000806080858703121561083157600080fd5b5050823594602084013594506040840135936060013592509050565b6000806040838503121561086057600080fd5b50508035926020909101359150565b60008060006060848603121561088457600080fd5b505081359360208301359350604090920135919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156105475761054761089b565b600181815b808511156108ff5781600019048211156108e5576108e561089b565b808516156108f257918102915b93841c93908002906108c9565b509250929050565b60008261091657506001610547565b8161092357506000610547565b816001811461093957600281146109435761095f565b6001915050610547565b60ff8411156109545761095461089b565b50506001821b610547565b5060208310610133831016604e8410600b8410161715610982575081810a610547565b61098c83836108c4565b80600019048211156109a0576109a061089b565b029392505050565b600061054460ff841683610907565b6000826109d457634e487b7160e01b600052601260045260246000fd5b500490565b60008160001904831182151516156109f3576109f361089b565b500290565b818103818111156105475761054761089b565b62ffffff818116838216019080821115610a2757610a2761089b565b5092915050565b6000600160ff1b8201610a4357610a4361089b565b506000039056fea2646970667358221220b825166f7de02fd002ecf39ab02766b65b121168a7c5821098c937dd5fe8c5dd64736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "amountOutGivenIn(uint256,uint256,uint256,uint256,bool)": {
        "details": "tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a",
        "params": {
          "amount": ": amount of base in returns amountDelta wanted token returned "
        }
      },
      "swapStep(uint256,uint256,int256,uint24,GranularBondingCurve.swapVars)": {
        "params": {
          "feePips": "The fee taken from the input amount, expressed in hundredths of a bip b is 0 and s is curPrice/a during variable liquidity phase"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "areaUnderCurve(uint256,uint256,uint256,uint256)": {
        "notice": "calculates area under the curve from s to s+amount result = a * amount / 2  * (2* supply + amount) + b * amount returned in collateral decimals"
      },
      "swapStep(uint256,uint256,int256,uint24,GranularBondingCurve.swapVars)": {
        "notice": "Compute results of swap given amount in and params"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}