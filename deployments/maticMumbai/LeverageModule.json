{
  "address": "0xd889b81a80d9f956dFa7fE50D0243C56A56246F2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_ad",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "pool",
          "type": "address"
        }
      ],
      "name": "addLeveragePool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "deletePosition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getPosition",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vaultAd",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalShares",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "suppliedCapital",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowedCapital",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowTimeStamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endStateBalance",
              "type": "uint256"
            }
          ],
          "internalType": "struct LeverageModule.Position",
          "name": "position",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "getPositions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "vaultAd",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalShares",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "suppliedCapital",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowedCapital",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowTimeStamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endStateBalance",
              "type": "uint256"
            }
          ],
          "internalType": "struct LeverageModule.Position[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "getTokenIds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "suppliedCapital",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "leverageFactor",
          "type": "uint256"
        }
      ],
      "name": "mintWithLeverage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "vaultAd",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalShares",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "suppliedCapital",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowedCapital",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowTimeStamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endStateBalance",
              "type": "uint256"
            }
          ],
          "internalType": "struct LeverageModule.Position",
          "name": "newPosition",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "positions",
      "outputs": [
        {
          "internalType": "address",
          "name": "vaultAd",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "totalShares",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "suppliedCapital",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "borrowedCapital",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "borrowTimeStamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "endStateBalance",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewindFull",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "withdrawAmount",
          "type": "uint256"
        }
      ],
      "name": "rewindPartialLeverage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenOfOwnerByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "viewPNL",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xa038dfb1ba3b0d99b6cc2c6e68323e18244a6dbf4c02ead8923ec461e5645620",
  "receipt": {
    "to": null,
    "from": "0x2C7Cb3cB22Ba9B322af60747017acb06deB10933",
    "contractAddress": "0xd889b81a80d9f956dFa7fE50D0243C56A56246F2",
    "transactionIndex": 1,
    "gasUsed": "2655351",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000002000000000000000000000000000000000000000000000000000800000000000000000040100000000000000000000000000000000000000000020000000000000000080000000000000000000000000000000000000000000000000000100000000000000000000000000200000000000000000000001000000000000000000000000000040000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x6edb3f2e3535956d1cad583c296c095921c968b0ceac344b6e3775328a733342",
    "transactionHash": "0xa038dfb1ba3b0d99b6cc2c6e68323e18244a6dbf4c02ead8923ec461e5645620",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 30794629,
        "transactionHash": "0xa038dfb1ba3b0d99b6cc2c6e68323e18244a6dbf4c02ead8923ec461e5645620",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000002c7cb3cb22ba9b322af60747017acb06deb10933",
          "0x000000000000000000000000c275dc8be39f50d12f66b6a63629c39da5bae5bd"
        ],
        "data": "0x00000000000000000000000000000000000000000000000003af5ec43c861507000000000000000000000000000000000000000000000000dd3ec5afcff42625000000000000000000000000000000000000000000000c2ad78cc4b360e278cf000000000000000000000000000000000000000000000000d98f66eb936e111e000000000000000000000000000000000000000000000c2adb3c23779d688dd6",
        "logIndex": 2,
        "blockHash": "0x6edb3f2e3535956d1cad583c296c095921c968b0ceac344b6e3775328a733342"
      }
    ],
    "blockNumber": 30794629,
    "cumulativeGasUsed": "5506307",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xEb5b16a6f73e201DEfa7E80be66Bf24552671ea3"
  ],
  "numDeployments": 2,
  "solcInputHash": "cd2417fdd2033875cb0ff225b85cd300",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_ad\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"addLeveragePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deletePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPosition\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endStateBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct LeverageModule.Position\",\"name\":\"position\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endStateBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct LeverageModule.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverageFactor\",\"type\":\"uint256\"}],\"name\":\"mintWithLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endStateBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct LeverageModule.Position\",\"name\":\"newPosition\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultAd\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"suppliedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowedCapital\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endStateBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewindFull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"rewindPartialLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPNL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"details\":\"See {IERC721-approve}.\"},\"balanceOf(address)\":{\"details\":\"See {IERC721-balanceOf}.\"},\"getApproved(uint256)\":{\"details\":\"See {IERC721-getApproved}.\"},\"isApprovedForAll(address,address)\":{\"details\":\"See {IERC721-isApprovedForAll}.\"},\"name()\":{\"details\":\"See {IERC721Metadata-name}.\"},\"ownerOf(uint256)\":{\"details\":\"See {IERC721-ownerOf}.\"},\"rewindPartialLeverage(uint256,uint256,uint256)\":{\"details\":\"step goes 1. repay to instrument,  \"},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"See {IERC721-safeTransferFrom}.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"details\":\"See {IERC721-safeTransferFrom}.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"See {IERC721-setApprovalForAll}.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"symbol()\":{\"details\":\"See {IERC721Metadata-symbol}.\"},\"tokenByIndex(uint256)\":{\"details\":\"See {IERC721Enumerable-tokenByIndex}.\"},\"tokenOfOwnerByIndex(address,uint256)\":{\"details\":\"See {IERC721Enumerable-tokenOfOwnerByIndex}.\"},\"totalSupply()\":{\"details\":\"See {IERC721Enumerable-totalSupply}.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"See {IERC721-transferFrom}.\"}},\"stateVariables\":{\"_nextId\":{\"details\":\"The ID of the next token that will be minted. Skips 0\"},\"_nextPoolId\":{\"details\":\"The ID of the next pool that is used for the first time. Skips 0\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"param leverageVault is where the capital is for borrowing\"},\"deletePosition()\":{\"notice\":\"when debt is 0, user can claim their endstate balance \"},\"mintWithLeverage(uint256,uint256,uint256)\":{\"notice\":\"Implements a leverage loop \"},\"rewindPartialLeverage(uint256,uint256,uint256)\":{\"notice\":\"Allows leverage minters to close their positions, and share profit with the leverageVault\"}},\"notice\":\"borrow from leverageVault to leverage mint vaults\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/LeverageModule.sol\":\"LeverageModule\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363733333234343137343731\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/bonds/GBC.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\n// import {ERC20} from \\\"./aave/Libraries.sol\\\"; \\nimport {SafeCast, FixedPointMath, ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \\n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \\n/// @dev all funds will be handled in the child contract \\ncontract GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using Tick for mapping(uint16 => Tick.Info);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n    using SafeCast for uint256; \\n\\n\\n    modifier onlyEntry(){\\n        require(entry == msg.sender  ,\\\"Not Entry\\\"); \\n        _;\\n    }\\n    \\n    bool private _mutex;\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    constructor(\\n        address _baseToken,\\n        address _tradeToken\\n        //uint256 _priceDelta\\n        ) {\\n        tradeToken = _tradeToken; \\n        baseToken = _baseToken; \\n        //priceDelta = _priceDelta; \\n        fee =0; \\n        factory = address(0); \\n        tickSpacing = 0; \\n        //Start liquidity \\n        liquidity = 100 * uint128(PRECISION); \\n\\n        owner = msg.sender; \\n    }\\n\\n    address public immutable owner; \\n    uint24 public immutable  fee;\\n    Slot0 public slot0; // global state?\\n    address public immutable  factory;\\n    address public immutable  tradeToken;\\n    address public immutable  baseToken;\\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\\n\\n    uint128 public liquidity;\\n\\n    mapping(uint16 => Tick.Info) public  ticks;\\n\\n    mapping(bytes32 => Position.Info) public  positions;\\n\\n    // mapping(uint16=> PricePoint) Points; \\n\\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\\n    uint256 public constant ROUNDLIMIT = 1e4; \\n    uint256 public constant PRECISION = 1e18; \\n    address public entry; \\n\\n    /// @notice previliged function called by the market maker \\n    /// if he is the one providing all the liquidity \\n    function setLiquidity(uint128 liq) internal  \\n    //onlyEntry\\n    {\\n        liquidity = liq; \\n    }\\n\\n    function setEntry(address _entry) external onlyEntry{\\n        entry = _entry; \\n    }\\n    function lock() external onlyEntry{\\n        slot0.unlocked = !slot0.unlocked; \\n    }\\n\\n    function positionIsFilled(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk\\n    ) \\n        public view returns(bool){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        return (liq>0 && numCross > crossId); \\n    }\\n\\n    function setPriceAndPoint(uint256 price) internal  \\n    //onlyOwner\\n    {\\n        slot0.point = priceToPoint(price);         \\n        slot0.curPrice = price.toUint160(); \\n    }\\n\\n    function getCurPrice() external view returns(uint256){\\n        return slot0.curPrice; \\n    }\\n\\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\\n        return uint256(ticks.oneTimeLiquidity(point)); \\n    }    \\n\\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\\n        return ticks.getNumCross(point, moveUp); \\n    }\\n\\n\\n    struct Slot0 {\\n        // the current price\\n        uint160 curPrice;\\n        // the current tick\\n        uint16 point;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n\\n        // Whether liquidity provision is amortized \\n        bool amortized; \\n\\n        // Where to modify liquidity \\n        uint16 modifyLiqPoint; \\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        uint256 amountCalculated;\\n        // current sqrt(price)\\n        uint256 curPrice;\\n        // the tick associated with the current price\\n        uint16 point;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobal;\\n        // amount of input token paid as protocol fee\\n        uint128 protocolFee;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n        uint128 liquidityStart; \\n\\n\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint256 priceStart;\\n        // the next tick to swap to from the current tick in the swap direction\\n        uint16 pointNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // price for the next tick (1/0)\\n        uint256 priceNextLimit;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n\\n        uint128 liqDir; \\n    }\\n\\n    struct swapVars{\\n        uint256 a;\\n        uint256 s; \\n        uint256 b; \\n    }\\n\\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\\n    /// -amountSpecified is in trade if moveUp, else is in base \\n    /// returns amountIn if moveUp, cash, else token\\n    /// returns amountOut if moveUp, token, else cash \\n    function trade(\\n        address recipient, \\n        bool moveUp, \\n        int256 amountSpecified, \\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\\n        console.logString('---New Trade---'); \\n\\n        Slot0 memory slot0Start = slot0; \\n        uint256 pDelta = priceDelta; \\n\\n        SwapState memory state = SwapState({\\n            amountSpecifiedRemaining: amountSpecified, \\n            amountCalculated: 0, \\n            curPrice: uint256(slot0Start.curPrice),\\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\\n            protocolFee: 0, \\n            liquidity: liquidity, \\n            liquidityStart: liquidity,\\n            point: slot0.point\\n            }); \\n        swapVars memory vars = swapVars({\\n            a:0,\\n            b:0,\\n            s:0\\n            });\\n\\n        bool exactInput = amountSpecified > 0;\\n\\n        // increment price by 1/1e18 if at boundary, and go back up a point,\\n        // should be negligible compared to fees TODO \\n        if (mod0(state.curPrice, pDelta) && !moveUp) {\\n            state.curPrice += 1; \\n            state.point = priceToPoint(state.curPrice);\\n            slot0.point = state.point; \\n            slot0Start.point = state.point; \\n        }\\n        \\n        require(moveUp? priceLimit>= state.curPrice : priceLimit<= state.curPrice, \\\"plimitERR\\\" ); \\n        priceLimit = pointToPrice(priceToPoint(priceLimit)); \\n\\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\\n            StepComputations memory step; \\n\\n            step.priceStart = state.curPrice; \\n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \\n            step.pointNext = moveUp? state.point + 1 : state.point-1; \\n\\n            // Need liquidity for both move up and move down for path independence within a \\n            // given point range. Either one of them should be 0 \\n            step.liqDir = ticks.oneTimeLiquidity(state.point);\\n            vars.a = exactInput \\n                ? inv(state.liquidity + step.liqDir)\\n                : invRoundUp(state.liquidity + step.liqDir); \\n            vars.b = yInt(state.curPrice, moveUp); \\n            vars.s = xMax(state.curPrice, vars.b, vars.a); \\n\\n            //If moveup, amountIn is in cash, amountOut is token and vice versa \\n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\\n                state.curPrice, \\n                step.priceNextLimit,    \\n                state.amountSpecifiedRemaining, \\n                fee, \\n                vars               \\n                ); \\n\\n            {console.log('________'); \\n            console.log('CURPRICE', state.curPrice); \\n            console.log('trading; liquidity, amountleft', state.liquidity); \\n            console.log(uint256(state.amountSpecifiedRemaining));\\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \\n            console.log('a', vars.a); }\\n            console.log('amountinandout', step.amountIn, step.amountOut); \\n            console.log('s,b', vars.s, vars.b); \\n\\n            if (exactInput){\\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \\n            }\\n            else{\\n                state.amountSpecifiedRemaining += int256(step.amountIn); \\n            }\\n            state.amountCalculated += step.amountOut; \\n\\n            if (state.liquidity>0)\\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \\n\\n            // If next limit reached, cross price range and change slope(liquidity)\\n            if (state.curPrice == step.priceNextLimit){\\n\\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\\n                // Else if crossing DOWN, bids are all filled \\n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \\n\\n                int128 liquidityNet = ticks.cross(\\n                    step.pointNext, \\n                    feeGrowthGlobalBase,\\n                    feeGrowthGlobalTrade\\n                    ); \\n\\n                if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint)\\n                    liquidityNet = liquidityNet += dynamicLiq[step.pointNext]; \\n                    console.log('dynamicLiq', uint256(int256(dynamicLiq[step.pointNext])), uint256(int256(liquidityNet))); \\n\\n                if (!moveUp) liquidityNet = -liquidityNet; \\n\\n\\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\\n\\n                state.point = step.pointNext;  \\n            }\\n        }\\n\\n        slot0.curPrice = state.curPrice.toUint160(); \\n        if(state.point != slot0Start.point) slot0.point = state.point; \\n            \\n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\\n\\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \\n            \\n        // (amountIn, amountOut) = exactInput\\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n\\n        (amountIn, amountOut) = exactInput\\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n    }\\n\\n    function placeLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk  \\n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \\n        //TODO mint NFT \\n        // Should only accept asks for price above the current point range\\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\\\"ask below prie\\\"); \\n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\\\"bids above prie\\\"); \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        numCross = ticks.getNumCross(point, isAsk); \\n        position.updateLimit(int128(amount), isAsk, numCross); \\n\\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \\n\\n        // If placing bids, need to escrow baseAsset, vice versa \\n        address tokenToEscrow = isAsk? tradeToken : baseToken;\\n\\n        amountToEscrow = isAsk\\n                ? tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    )\\n            \\n                : baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    ); \\n\\n        console.log('amountbid', amountToEscrow); \\n\\n    }\\n\\n    function reduceLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \\\"Can't reduce order for current tick\\\"); \\n\\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\\n\\n        position.updateLimit(-int128(amount), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \\n\\n        address tokenToReturn = isAsk? tradeToken : baseToken;\\n        \\n        amountToReturn = isAsk\\n            ? tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                )\\n         \\n            : baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                );\\n    }\\n\\n    /// @notice called when maker wants to claim when the the price is at the \\n    /// point he submitted the order\\n    function claimPartiallyFilledOrder(\\n        address recipient, \\n        uint16 point,\\n        bool isAsk\\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\\n        Slot0 memory _slot0 = slot0; \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n        require(priceToPoint(uint256(_slot0.curPrice)) == point, \\\"Not cur price\\\"); \\n\\n        // Assume trying to withdraw all liquidity provided \\n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \\n       \\n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \\n\\n        // Get total trade filled OR remaining\\n        tradeAmount = tradeGivenLiquidity(\\n            pointToPrice(point+1),\\n            _slot0.curPrice, \\n            liqToWithdraw\\n        ); \\n           \\n        // Get total base filled OR remaining \\n        baseAmount = baseGivenLiquidity(\\n            _slot0.curPrice, \\n            pointToPrice(point), \\n            liqToWithdraw\\n            ); \\n\\n    }\\n\\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \\n    /// or crossDown \\n    function claimFilledOrder(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        require(numCross > crossId, \\\"Position not filled\\\");\\n\\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        // Sold to base when asks are filled\\n        if(isAsk) claimedAmount = baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        // Bought when bids are filled so want tradeTokens\\n        else claimedAmount = tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        position.updateLimit(-int128(liq), isAsk, 0); \\n        \\n        // Need to burn AND \\n\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        uint16 pointLower;\\n        uint16 pointUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n    }\\n\\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\\n    function provide(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount, \\n        bytes calldata data \\n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\\n        require(amount > 0, \\\"0 amount\\\"); \\n\\n        (,  amount0,  amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        //mintCallback\\n\\n    }\\n\\n    function remove(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount\\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\\n\\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: -int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        if(amount0>0 || amount1> 0){\\n            (position.tokensOwed0, position.tokensOwed1) = (\\n                position.tokensOwed0 + amount0,\\n                position.tokensOwed1 + amount1\\n            );\\n        }\\n        return (amount0, amount1); \\n    }\\n\\n    function collect(\\n        address recipient,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\\n\\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\\n\\n        if (amount0 > 0) {\\n            position.tokensOwed0 -= amount0;\\n        }\\n        if (amount1 > 0) {\\n            position.tokensOwed1 -= amount1;\\n        }\\n    }\\n\\n\\n    function _modifyPosition(ModifyPositionParams memory params)\\n    private \\n    returns(\\n        Position.Info storage position, \\n        uint256 baseAmount, \\n        uint256 tradeAmount\\n        )\\n    {\\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\\n\\n        position = _updatePosition(\\n            params.owner,\\n            params.pointLower,\\n            params.pointUpper,\\n            params.liquidityDelta,\\n            _slot0.point\\n        );\\n\\n        if (params.liquidityDelta != 0){\\n            if (_slot0.point < params.pointLower){\\n                // in case where liquidity is just asks waiting to be sold into, \\n                // so need to only provide tradeAsset \\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n            } else if( _slot0.point < params.pointUpper){\\n                uint128 liquidityBefore = liquidity; \\n\\n                // Get total asks to be submitted above current price\\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper),\\n                    _slot0.curPrice, \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Get total bids to be submitted below current price \\n                baseAmount = baseGivenLiquidity(\\n                    _slot0.curPrice, \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Slope changes since current price is in this range \\n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\\n\\n            } else{\\n                // liquidity is just bids waiting to be bought into \\n                baseAmount = baseGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                ); \\n            }\\n        }\\n    }\\n\\n    uint256 public feeGrowthGlobalBase;\\n    uint256 public feeGrowthGlobalTrade;\\n\\n    function _updatePosition(\\n        address owner, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        int128 liquidityDelta, \\n        uint16 point \\n        ) private returns(Position.Info storage position){\\n\\n        position = positions.get(owner, pointLower, pointUpper); \\n\\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \\n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \\n\\n        if(liquidityDelta != 0){\\n\\n            ticks.update(\\n                pointLower, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                false\\n                ); \\n\\n            ticks.update(\\n                pointUpper, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                true\\n                ); \\n        } \\n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \\n    }\\n\\n\\n    mapping(uint16=> int128) dynamicLiq; \\n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\\n        dynamicLiq[point] = liq; \\n    }\\n    function setModifyLiqPoint(uint16 point) internal{\\n        slot0.modifyLiqPoint = point;  \\n    }\\n    function amortizeLiq() internal{\\n        slot0.amortized = true; \\n    }\\n\\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return (p2-p1).mulWadDown(L); \\n    }\\n\\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \\n    }\\n\\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return T.divWadDown(p2-p1); \\n    }\\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \\n    }\\n\\n    function pointToPrice(uint16 point) public pure returns(uint160){\\n        return(uint256(point) * priceDelta).toUint160(); \\n    }\\n\\n    /// @notice will round down to nearest integer \\n    function priceToPoint(uint256 price) public pure returns(uint16){\\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        return (curPrice-b).divWadUp(a); \\n    }\\n\\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\\n    /// the current point\\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\\n        uint16 point = priceToPoint(curPrice); \\n\\n        // If at boundary when moving down, decrement point by one\\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \\n    }\\n\\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\\n        if (moveUp) return uint256(point+1) * pDelta; \\n        else return uint256(point) * pDelta; \\n    }\\n\\n    function inv(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \\n    }\\n    function invRoundUp(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \\n    }\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\\n        return (a%b ==0); \\n    }\\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\\n    /// @param x The liquidity before change\\n    /// @param y The delta by which liquidity should be changed\\n    /// @return z The liquidity delta\\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\\n        return  isAsk\\n                ? positions.get(to, point, point+1).askLiq\\n                : positions.get(to, point, point+1).bidLiq; \\n    }\\n\\n}\\n\\nlibrary LinearCurve{\\n    uint256 public constant PRECISION = 1e18; \\n    using FixedPointMath for uint256; \\n\\n\\n    /// @notice Compute results of swap given amount in and params\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// b is 0 and s is curPrice/a during variable liquidity phase\\n    function swapStep(\\n        uint256 curPrice, \\n        uint256 targetPrice, \\n        int256 amountRemaining, \\n        uint24 feePips,    \\n        GranularBondingCurve.swapVars memory vars       \\n        ) \\n        public \\n        pure \\n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\\n\\n        bool moveUp = targetPrice >= curPrice; \\n        bool exactInput = amountRemaining >= 0; \\n\\n        // If move up and exactInput, amountIn is base, amountOut is trade \\n        if (exactInput){\\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\\n\\n            if (moveUp){\\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \\n\\n                // If overshoot go to next point\\n                if (nextPrice >= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out for a given price range is Pdelta / a \\n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \\n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \\n                }            \\n                else {\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }   \\n            }\\n\\n            // amountIn is trade, amountOut is base \\n            else {\\n                // If amount is greater than s, then need to cap it \\n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \\n                // If undershoot go to previous point \\n                if(nextPrice <= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out is area under curve \\n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \\n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \\n\\n                }\\n                else{\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }\\n            }\\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \\n        }\\n\\n        else {\\n            if(moveUp){\\n                uint256 remaining = uint256(-amountRemaining); \\n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \\n\\n                // if overshoot\\n                if(nextPrice>=targetPrice){\\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \\n                    nextPrice = targetPrice; \\n\\n                    // Prevent stuck cases where point is almost filled but not quite \\n                    if(remaining - amountIn<=1e4){\\n                        amountIn = remaining; \\n                    } \\n                }\\n                else amountIn = remaining; \\n\\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\\n\\n            }\\n            else{\\n                //TODO \\n            }\\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\\n            amountOut = amountOut + feeAmount;\\n        }\\n    }\\n\\n\\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\\n    /// @param amount: amount of base in\\n    /// returns amountDelta wanted token returned \\n    function amountOutGivenIn( \\n        uint256 amount,\\n        uint256 s, \\n        uint256 a, \\n        uint256 b, \\n        bool up\\n        ) \\n        public \\n        pure \\n        returns(uint256 amountDelta, uint256 resultPrice) {\\n        \\n        // If liquidity is not infinite \\n        if(a > 0){\\n            if (up){\\n                //TODO overflow on small amount \\n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \\n                uint256 y = 2*( a.mulWadDown(amount)); \\n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\\n                uint256 z = (a.mulWadDown(s) + b); \\n                amountDelta = (x_y_sqrt-z).divWadDown(a);\\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \\n            }\\n\\n            else{\\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \\n                amountDelta = amount.mulWadDown(z); \\n                resultPrice = a.mulWadDown(s-amount) + b; \\n            }\\n        }\\n\\n        // When a = 0, infinite liquidity and constant price\\n        else{\\n            amountDelta = amount.divWadDown(b); \\n            resultPrice = b; \\n        }\\n\\n    }\\n\\n    /// @notice calculates area under the curve from s to s+amount\\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\\n     /// returned in collateral decimals\\n    function areaUnderCurve(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \\n    }\\n    function areaUnderCurveRoundUp(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        // you want area to be big for a given amount \\n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n\\n}\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    using FixedPointMath for uint256;\\n\\n    // info stored for each user's position\\n    struct Info {\\n        uint128 bidCrossId; \\n        uint128 askCrossId; \\n        uint128 askLiq; \\n        uint128 bidLiq; \\n\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // the fees owed to the position owner in token0/token1\\n        uint256 tokensOwed0;\\n        uint256 tokensOwed1;\\n\\n        \\n    }\\n\\n    function updateLimit(\\n        Info storage self,\\n        int128 limitLiqudityDelta, \\n        bool isAsk, \\n        uint128 crossId\\n        ) internal {\\n\\n        if (isAsk) {\\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \\n        } \\n\\n        else {\\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \\n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \\n        }\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        uint16 tickLower,\\n        uint16 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees\\n        uint128 tokensOwed0 = uint128(\\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n        uint128 tokensOwed1 =uint128(\\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n            \\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\\n            self.tokensOwed0 += tokensOwed0;\\n            self.tokensOwed1 += tokensOwed1;\\n        }\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n}\\n\\n/// @title Tick\\n/// @notice Contains functions for managing tick processes and relevant calculations\\nlibrary Tick {\\n    using FixedPointMath for uint256;\\n\\n    using SafeCast for int256;\\n\\n    // info stored for each initialized individual tick\\n    struct Info {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutsideBase;\\n        uint256 feeGrowthOutsideTrade;\\n        // the cumulative tick value on the other side of the tick\\n        int56 tickCumulativeOutside;\\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint160 secondsPerLiquidityOutsideX128;\\n        // the seconds spent on the other side of the tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint32 secondsOutside;\\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\\n        bool initialized;\\n\\n        uint128 askLiquidityGross; \\n        uint128 bidLiquidityGross;\\n        uint128 askNumCross; \\n        uint128 bidNumCross; \\n    }\\n\\n    function getNumCross(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal view returns(uint128){\\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \\n    }\\n\\n    function oneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick \\n        ) internal view returns(uint128){\\n        Tick.Info memory info = self[tick]; \\n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \\n        return info.askLiquidityGross + info.bidLiquidityGross; \\n    }\\n\\n    function deleteOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal {\\n        Tick.Info storage info = self[tick]; \\n        if(isAsk) {\\n            info.askLiquidityGross = 0;\\n            info.askNumCross++; \\n            console.log('tick??', tick); \\n        }\\n        else {\\n            info.bidLiquidityGross = 0; \\n            info.bidNumCross++; \\n        }\\n    }\\n\\n    function updateOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        int128 oneTimeLiquidityDelta,\\n        bool isAsk\\n        ) internal {\\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \\n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\\n    }\\n\\n    function update(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick,\\n        uint16 tickCurrent,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthGlobalBase, \\n        uint256 feeGrowthGlobalTrade, \\n        bool upper\\n    ) internal returns (bool flipped) {\\n        Tick.Info storage info = self[tick];\\n\\n        uint128 liquidityGrossBefore = info.liquidityGross; \\n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if(liquidityGrossBefore == 0) {\\n            if(tick<=tickCurrent){\\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \\n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \\n            }\\n            info.initialized = true; \\n        }\\n        info.liquidityGross = liquidityGrossAfter;\\n\\n        info.liquidityNet = upper \\n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \\n    }\\n\\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\\n        delete self[tick];\\n    }\\n\\n    function cross(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick, \\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal returns (int128 liquidityNet) {\\n        Tick.Info storage info = self[tick]; \\n\\n        liquidityNet = info.liquidityNet; \\n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \\n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n\\n    function getFeeGrowthInside(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint16 tickCurrent,\\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\\n        Info storage lower = self[tickLower];\\n        Info storage upper = self[tickUpper];\\n\\n        // calculate fee growth below\\n        uint256 feeGrowthBelowBase;\\n        uint256 feeGrowthBelowTrade;\\n        if (tickCurrent >= tickLower) {\\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\\n        }\\n\\n        // calculate fee growth above\\n        uint256 feeGrowthAboveBase;\\n        uint256 feeGrowthAboveTrade;\\n        if (tickCurrent < tickUpper) {\\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\\n        }\\n\\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\\n    }\\n}\\n\\n\\ncontract SpotPool is GranularBondingCurve{\\n\\n    ERC20 BaseToken; //junior\\n    ERC20 TradeToken; //senior \\n    // GranularBondingCurve public pool; \\n\\n    constructor(\\n        address _baseToken, \\n        address _tradeToken\\n        )GranularBondingCurve(_baseToken,_tradeToken){\\n        BaseToken = ERC20(_baseToken); \\n        TradeToken = ERC20(_tradeToken); \\n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \\n    }\\n\\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\\n\\n        if(up){\\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\\n            console.log('togive', amountOut, amountIn); \\n            TradeToken.transfer(recipient, amountOut); \\n            console.log('balofre', BaseToken.balanceOf(recipient));\\n            BaseToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n\\n        else{\\n            BaseToken.transfer(recipient, amountOut); \\n            TradeToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n    }\\n\\n    // function getCurPrice() external view returns(uint256){\\n    //     return uint256(pool.getCurPrice());\\n    // }\\n\\n    /// @notice if buyTradeForBase, move up, and vice versa \\n    function takerTrade(\\n        address recipient, \\n        bool buyTradeForBase, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data        \\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        (poolamountIn, poolamountOut) = this.trade(\\n            recipient, \\n            buyTradeForBase, \\n            amountIn,  \\n            priceLimit, \\n            data\\n        ); \\n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \\n    }\\n\\n    /// @notice specify how much trade trader intends to sell/buy \\n    function makerTrade(\\n        bool buyTradeForBase,\\n        uint256 amountIn,\\n        uint16 point\\n        ) external {\\n        (uint256 toEscrowAmount, uint128 crossId) \\n                = this.placeLimitOrder(msg.sender, \\n                    point, \\n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \\n                    !buyTradeForBase); \\n\\n        // Collateral for bids\\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n\\n        // or asks\\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n    }\\n\\n    function makerClaim(\\n        uint16 point, \\n        bool buyTradeForBase\\n        ) external {\\n        uint256 claimedAmount = this.claimFilledOrder(\\n            msg.sender, \\n            point, \\n            !buyTradeForBase\\n        ); \\n\\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\\n        else BaseToken.transfer(msg.sender, claimedAmount); \\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\",\"keccak256\":\"0x48e107175a94889ecde1a315128d6c5179003d5c214d391d0eff8e03052b56ce\",\"license\":\"UNLICENSED\"},\"contracts/bonds/boundedDerivatives.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport \\\"./GBC.sol\\\"; \\n// import {BoundedDerivativesPool, LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice Uses AMM as a derivatives market,where the price is bounded between two price\\n/// and mints/burns tradeTokens. \\n/// stores all baseTokens for trading, and also stores tradetokens when providing liquidity, \\n/// @dev Short loss is bounded as the price is bounded, no need to program liquidations logic \\ncontract BoundedDerivativesPool is GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using SafeCast for uint256; \\n    // using Position for Position.Info;\\n    // uint256 constant PRECISION = 1e18; \\n    ERC20 public  BaseToken; \\n    ERC20 public  TradeToken; \\n    ERC20 public  s_tradeToken; \\n    uint256 public constant maxPrice = 1e18; \\n\\n    bool immutable noCallBack; \\n    constructor(\\n        address base, \\n        address trade, \\n        address s_trade, \\n        bool _noCallBack\\n        // address _pool \\n        ) GranularBondingCurve(base, trade){\\n        BaseToken =  ERC20(base);\\n        TradeToken = ERC20(trade);\\n        s_tradeToken = ERC20(s_trade);\\n        noCallBack = _noCallBack; \\n    }\\n\\n    /// @notice recipient recieves amountOut in exchange for giving this contract amountIn (base)\\n    function mintAndPull(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        \\n        // Mint and Pull \\n        if(isLong) TradeToken.mint(recipient, amountOut); \\n        else s_tradeToken.mint(recipient, amountOut); \\n        BaseToken.transferFrom(recipient,address(this), amountIn); \\n    }\\n\\n    function burnAndPush(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        // Burn and Push \\n        if(isLong) TradeToken.burn(recipient, amountIn); \\n        else s_tradeToken.burn(recipient, amountIn); \\n   \\n        BaseToken.transfer(recipient, amountOut); \\n    }\\n\\n    function baseBal() internal view returns(uint256){\\n        return BaseToken.balanceOf(address(this)); \\n    }\\n\\n    /// @notice Long up the curve, or short down the curve \\n    /// @param amountIn is base if long, trade if short\\n    /// @param priceLimit is slippage tolerance\\n    function takerOpen(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external  returns(uint256 poolamountIn, uint256 poolamountOut ){\\n        if(isLong){\\n            // Buy up \\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            if (noCallBack) mintAndPull(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else {\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \\n                require(baseBal() >= poolamountIn + bal, \\\"balERR\\\"); \\n                TradeToken.mint(abi.decode(data, (address)), poolamountOut); \\n            }\\n        }\\n\\n        else{\\n            // just shift pool state\\n            (poolamountIn, poolamountOut) = trade(\\n                address(this), \\n                false, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountOut = poolamountOut; \\n            // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\\n            poolamountOut = poolamountIn.mulWadDown(maxPrice) - poolamountOut;\\n\\n            // One s_tradeToken is a representation of debt+sell of one tradetoken\\n            // Escrow collateral required for shorting, where price for long + short = maxPrice, \\n            // so (maxPrice-price of trade) * quantity\\n            if (noCallBack) mintAndPull(msg.sender, poolamountIn, poolamountOut, false);\\n\\n            else{\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \\n                require(baseBal() >= poolamountOut + bal, \\\"balERR\\\"); \\n                s_tradeToken.mint(abi.decode(data,(address)), poolamountIn); \\n\\n                // need to send cached poolamountOut(the area under the curve) data for accounting purposes\\n                poolamountIn = cached_poolamountOut; \\n            }\\n\\n            // BaseToken.transferFrom(msg.sender, address(this), poolamountIn.mulWadDown(maxPrice) - poolamountOut); \\n            // s_tradeToken.mint(msg.sender, uint256(amountIn)); \\n        }\\n\\n    }\\n\\n    /// @param amountIn is trade if long, ALSO trade if short, since getting rid of s_trade \\n    function takerClose(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        // Sell down\\n        if(isLong){\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender,\\n                false, \\n                amountIn, //this should be trade tokens\\n                priceLimit, \\n                data\\n            ); \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else burnAndPush(abi.decode(data, (address)), poolamountOut, poolamountIn, true );                             \\n        }\\n\\n        else{            \\n            // buy up with the baseToken that was transferred to this contract when opened, in is base out is trade\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountIn = poolamountIn; \\n\\n            // collateral used to buy short \\n            poolamountIn = poolamountOut.mulWadDown(maxPrice) - poolamountIn; \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountIn,poolamountOut, false);\\n            else {\\n                burnAndPush(abi.decode(data, (address)), poolamountIn, poolamountOut,false ); \\n                poolamountOut = cached_poolamountIn; \\n            }\\n\\n            // s_tradeToken.burn(msg.sender, poolamountOut); \\n            // BaseToken.transfer(msg.sender, poolamountOut.mulWadDown(maxPrice) - poolamountIn);\\n        }\\n    }\\n\\n    /// @notice provides oneTimeliquidity in the range (point,point+1)\\n    /// @param amount is in base if long, trade if in short  \\n    function makerOpen(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong,\\n        address recipient\\n        )external  returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // escrowAmount is base \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient,\\n                point, \\n                uint128(liquidityGivenBase(pointToPrice(point+1), pointToPrice(point), amount)), \\n                false\\n                ); \\n            BaseToken.transferFrom(recipient, address(this), toEscrowAmount); \\n        }\\n\\n        // need to set limit for sells, but claiming process is different then regular sells \\n        else{\\n            // escrowAmount is trade \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)) , \\n                true\\n                ); \\n\\n            // escrow amount is (maxPrice - avgPrice) * quantity \\n            uint256 escrowCollateral = toEscrowAmount - baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) //positive since adding asks, not subtracting \\n                    ); \\n            BaseToken.transferFrom(recipient, address(this), escrowCollateral); \\n            toEscrowAmount = escrowCollateral; \\n        }\\n\\n    }\\n\\n    function makerClaimOpen(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            uint256 claimedAmount = claimFilledOrder(recipient, point, false ); \\n\\n            // user already escrowed funds, so need to send him tradeTokens \\n            TradeToken.mint(recipient, claimedAmount);          \\n        }\\n\\n        else{           \\n            s_tradeToken.mint(recipient, \\n                tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    getLiq(msg.sender, point, true)\\n                    )\\n                ); \\n\\n            // open short is filled sells, check if sells are filled. If it is,\\n            // claimedAmount of basetokens should already be in this contract \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n        }\\n\\n    }\\n    /// @notice amount is trade if long, but ALSO trade if short(since trade quantity also coincides\\n    /// with shortTrade quantity )\\n    function makerClose(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // close long is putting up trades for sells, \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point, \\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                true\\n                ); \\n            //maybe burn it when claiming, and just escrow? \\n            TradeToken.burn(recipient, toEscrowAmount); \\n        }\\n\\n        else{\\n            // Place limit orders for buys \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                false\\n                ); \\n\\n            // burn s_tradeTokens, \\n            s_tradeToken.burn(recipient, amount); \\n\\n        }\\n    }\\n\\n    function makerClaimClose(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        ) external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            // Sell is filled, so need to transfer back base \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n            BaseToken.transfer(recipient, claimedAmount); \\n        }\\n        else{\\n            uint128 liq = getLiq(recipient, point, false); \\n\\n            // Buy is filled, which means somebody burnt trade, so claimedAmount is in trade\\n            claimedAmount = claimFilledOrder(recipient, point, false);\\n            claimedAmount = claimedAmount.mulWadDown(maxPrice) \\n                            - baseGivenLiquidity(\\n                            pointToPrice(point+1), \\n                            pointToPrice(point), \\n                            liq); \\n            BaseToken.transfer(recipient, claimedAmount);\\n        }\\n    }    \\n\\n    function makerPartiallyClaim(\\n        uint16 point, \\n        bool isLong,\\n        bool open, \\n        address recipient\\n        ) external returns(uint256 baseAmount, uint256 tradeAmount){\\n   \\n        if(open){\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true);\\n        }\\n        else{\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false);\\n        }\\n        \\n        BaseToken.transfer(recipient, baseAmount);\\n        TradeToken.mint(recipient, tradeAmount); \\n    }\\n\\n    /// @notice amount is in base if long, trade if short \\n    function makerReduceOpen(\\n        uint16 point, \\n        uint256 amount, \\n        bool isLong, \\n        address recipient\\n        ) external{\\n    \\n        if(isLong){\\n            uint256 returned_amount =reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenBase(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point),\\n                    amount\\n                    ).toUint128(), \\n                false\\n                ); \\n            // need to send base back \\n            BaseToken.transfer(recipient, returned_amount); \\n        }\\n        else {\\n            uint128 liq = liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amount).toUint128(); \\n            // Reduce asks \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liq, \\n                true\\n                ); \\n\\n            // Need to send escrowed basetoken back, which is shortTrade quantity - baseGivenLiquidity \\n            BaseToken.transfer(recipient, \\n                amount - baseGivenLiquidity(pointToPrice(point+1), pointToPrice(point), liq));\\n        }\\n    }\\n\\n    /// @notice amount is in trade if long, ALSO trade if short \\n    function makerReduceClose(      \\n        uint16 point, \\n        uint256 amount, \\n        bool isLong,\\n        address recipient\\n        ) external{\\n\\n        if(isLong){\\n            uint256 returned_amount = reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                true\\n                ); \\n            // need to send trade back \\n            TradeToken.mint(recipient, returned_amount); \\n        }\\n\\n        else{\\n            // reduce limit bids \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                false\\n            ); \\n             \\n            s_tradeToken.mint(recipient, amount); \\n        }\\n    }\\n\\n    // TODO separate contracts \\n    // function provideLiquidity(\\n    //     uint16 pointLower,\\n    //     uint16 pointUpper,\\n    //     uint128 amount, \\n    //     bytes calldata data \\n    //     ) external {\\n\\n    //     (uint256 amount0, uint256 amount1) = provide(\\n    //         msg.sender, \\n    //         pointLower, \\n    //         pointUpper, \\n    //         amount, \\n    //         data \\n    //     ); \\n    //     BaseToken.transferFrom(msg.sender, address(this), amount0); \\n    //     // TradeToken.transferFrom(msg.sender, address(this), amount1);\\n    //     TradeToken.burn(msg.sender, amount1);\\n    // }\\n\\n    // function withdrawLiquidity(\\n    //     uint16 pointLower,\\n    //     uint16 pointUpper,\\n    //     uint128 amount, \\n    //     bytes calldata data \\n    //     )external{\\n\\n    //     (uint256 amountBase, uint256 amountTrade) = remove(\\n    //         msg.sender, \\n    //         pointLower, \\n    //         pointUpper, \\n    //         amount\\n    //     ); \\n      \\n    //     collect(\\n    //         msg.sender, \\n    //         pointLower,\\n    //         pointUpper,\\n    //         type(uint128).max,\\n    //         type(uint128).max\\n    //     ); \\n\\n    //     BaseToken.transfer(msg.sender,  amountBase); \\n    //     TradeToken.mint(msg.sender, amountTrade); \\n    // }\\n\\n    //TODO fees, skipping uninit for gas, below functions\\n    // possible attacks: manipulation of price with no liquidityregions, add a bid/ask and a naive \\n    // trader fills, and immediately submit a ask much higher/lower\\n    // gas scales with number of loops, so need to set ticks apart large, or provide minimal liquidity in each tick\\n\\n}\\n\\ninterface iTradeCallBack{\\n    function tradeCallBack(\\n        uint256 amount0,\\n bytes calldata data    ) external;\\n} \\n\",\"keccak256\":\"0x898a010d7920b6b1a1b030d793310bd50ff46206a0b43bf05d775b258b155ebb\"},\"contracts/bonds/libraries.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMath {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint256(y)) == y);\\n    // }\\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint160(y)) == y);\\n    // }\\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\\n        require((z = uint128(y)) == y);\\n    }\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\\n\\ncontract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n    function mint(address to, uint256 amount) public {\\n      _mint(to, amount); \\n    }\\n    function burn(address to, uint256 amount) public {\\n      _burn(to, amount); \\n    }\\n}\",\"keccak256\":\"0x6f4b41b0a3a677144ec92ae040f756a7af61ffe54f497f92d7f20a729b3cb091\"},\"contracts/bonds/synthetic.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport { LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {BoundedDerivativesPool} from \\\"./boundedDerivatives.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\ncontract ZCBFactory{\\n    function newBond(\\n        string memory name, \\n        string memory description \\n        ) public returns(address) {\\n        ERC20 bondToken = new ERC20(name,description, 18);\\n        return address(bondToken); \\n    }\\n\\n}\\ncontract SyntheticZCBPoolFactory{\\n    address public immutable controller;\\n    address public immutable zcbFactory; \\n    constructor(address _controller, address _zcbFactory){\\n        controller = _controller; \\n        zcbFactory = _zcbFactory; \\n    }\\n\\n    event PoolCreated(address pool, address longZCB, address shortZCB);\\n\\n    /// @notice param base is the collateral used in pool \\n    function newPool(\\n        address base, \\n        address entry\\n        ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\\n        longZCB = ZCBFactory(zcbFactory).newBond(\\\"longZCB\\\", \\\"long\\\");\\n        shortZCB = ZCBFactory(zcbFactory).newBond(\\\"shortZCB\\\", \\\"short\\\");\\n\\n        pool = new SyntheticZCBPool(\\n            base, longZCB, shortZCB, entry, controller\\n        ); \\n        emit PoolCreated(address(pool), longZCB, shortZCB);\\n    }\\n}\\n\\ncontract SyntheticZCBPool is BoundedDerivativesPool{\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 public a_initial;\\n    uint256 public b_initial; // b without discount cap \\n    uint256 public b;\\n    uint256 public discount_cap; \\n    uint256 public discountedReserves; \\n    uint256 public upperBound; \\n    address public immutable controller; \\n    uint256 public constant precision = 1e18; \\n    constructor(address base, \\n        address trade, \\n        address s_trade, \\n        address _entry, \\n        address _controller\\n        )BoundedDerivativesPool(base,trade,s_trade, false){\\n        entry = _entry; \\n        controller = _controller; \\n        }\\n\\n    /// @notice calculate and store initial curve params that takes into account\\n    /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\\n    /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \\n    /// @param sigma is the proportion of P that is going to be bought at a discount  \\n    function calculateInitCurveParams(\\n        uint256 P, \\n        uint256 I, \\n        uint256 sigma,\\n        uint256 alpha, \\n        uint256 delta) external {\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        b_initial = (2*P).divWadDown(P+I) - precision; \\n        a_initial = (precision-b_initial).divWadDown(P+I); \\n\\n        // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\\n        (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\\n        (, upperBound )= LinearCurve.amountOutGivenIn(P.mulWadDown(alpha+delta), 0, a_initial, b_initial,true); \\n\\n        // Set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a_initial))); \\n        setPriceAndPoint(b);\\n    }\\n\\n    /// @notice calculates initparams for pool based instruments \\n    /// param endPrice is the inception Price of longZCB, or its price when there is no discount\\n    function calculateInitCurveParamsPool(\\n        uint256 saleAmount, \\n        uint256 initPrice, \\n        uint256 endPrice, \\n        uint256 sigma\\n        ) external returns(uint256 managementFee){\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        //TODO these fails at some inputs\\n        uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \\n        uint256 a = (endPrice - initPrice).divWadDown(saleAmountQty); \\n        \\n        //Set discount cap as saleAmount * sigma \\n        (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \\n        b = initPrice; \\n\\n        // How much total discounts are validators and managers getting\\n        // managementFee = discount_cap.mulWadDown(endPrice) \\n        //     - saleAmount.mulWadDown(sigma) + saleAmountQty.mulWadDown(endPrice) - saleAmount ; \\n\\n        // set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a))); \\n        setPriceAndPoint(b); \\n        setDynamicLiquidity(priceToPoint(endPrice), type(int128).max); \\n        setModifyLiqPoint(priceToPoint(endPrice)); \\n    }\\n\\n    /// @notice computes area between the curve and max price for given storage parameters\\n    function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\\n        (uint256 amountDelta, ) = LinearCurve.amountOutGivenIn(amount, 0, a_initial, b_initial, true); \\n        return amountDelta.mulWadDown(maxPrice) - amount; \\n    }\\n\\n    /// @notice mints new zcbs \\n    function trustedDiscountedMint(\\n        address receiver, \\n        uint256 amount \\n        ) external{\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        TradeToken.mint(receiver, amount);\\n        discountedReserves += amount;  \\n    }\\n\\n\\n    function trustedBurn(\\n        address trader, \\n        uint256 amount, \\n        bool long\\n        ) external {\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        if (long) TradeToken.burn(trader, amount); \\n        else s_tradeToken.burn(trader, amount);\\n    }\\n\\n    function flush(address flushTo, uint256 amount) external {\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        if (amount == type(uint256).max) BaseToken.transfer(flushTo, baseBal()); \\n        else BaseToken.transfer(flushTo, amount); \\n    }\\n\\n    /// @notice resets AMM liquidity to 0 and make it ready to be liq provisioned \\n    /// by anyone \\n    function resetLiq() external{\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        setLiquidity(0); \\n        amortizeLiq(); \\n    }\\n\\n}\\n\",\"keccak256\":\"0x6b3cfeeb410dbe6c8b8d54d887530c09fc862969ceda71235617793e88522207\"},\"contracts/chainlink/VRFConsumerBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\",\"keccak256\":\"0xd4697556c95e0f2e5055eea0b07b4d476887052d95dbf838b3cf7c32436c71d1\",\"license\":\"MIT\"},\"contracts/chainlink/VRFCoordinatorV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\",\"keccak256\":\"0xadc1f1babaa7202145a22d82c85176cbe7f1fae993f2c11dabdf6058aebea6b2\",\"license\":\"MIT\"},\"contracts/instruments/IRateCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity >=0.8.16;\\n\\ninterface IRateCalculator {\\n    function name() external pure returns (string memory);\\n\\n    function requireValidInitData(bytes calldata _initData) external pure;\\n\\n    function getConstants() external pure returns (bytes memory _calldata);\\n\\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec);\\n}\\n\",\"keccak256\":\"0xf12adc4ffcf31a867fabcc2cfcebf8edf7bc35def82f9dbfdcb9eccf3e0e14a6\",\"license\":\"ISC\"},\"contracts/instruments/VaultAccount.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.16;\\n\\nstruct VaultAccount {\\n    uint128 amount; // Total amount, analogous to market cap\\n    uint128 shares; // Total shares, analogous to shares outstanding\\n}\\n\\n/// @title VaultAccount Library\\n/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto\\n/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations\\n/// @dev Uses uint128 to save on storage\\nlibrary VaultAccountingLibrary {\\n    /// @notice Calculates the shares value in relationship to `amount` and `total`\\n    /// @dev Given an amount, return the appropriate number of shares\\n    function toShares(\\n        VaultAccount memory total,\\n        uint256 amount,\\n        bool roundUp\\n    ) internal pure returns (uint256 shares) {\\n        if (total.amount == 0) {\\n            shares = amount;\\n        } else {\\n            shares = (amount * total.shares) / total.amount;\\n            if (roundUp && (shares * total.amount) / total.shares < amount) {\\n                shares = shares + 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the amount value in relationship to `shares` and `total`\\n    /// @dev Given a number of shares, returns the appropriate amount\\n    function toAmount(\\n        VaultAccount memory total,\\n        uint256 shares,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount) {\\n        if (total.shares == 0) {\\n            amount = shares;\\n        } else {\\n            amount = (shares * total.amount) / total.shares;\\n            if (roundUp && (amount * total.shares) / total.amount < shares) {\\n                amount = amount + 1;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb751d82f4ebf9b19781e9f69d748eef5ffedd97445492ae7904abc5b2341fdff\",\"license\":\"ISC\"},\"contracts/instruments/poolConstants.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\n// taken from https://github.com/FraxFinance/fraxlend\\nabstract contract PoolConstants {\\n    uint256 internal constant LTV_PRECISION = 1e5; // 5 decimals\\n    uint256 internal constant LIQ_PRECISION = 1e5;\\n    uint256 internal constant UTIL_PREC = 1e5;\\n    uint256 internal constant FEE_PRECISION = 1e5;\\n    uint256 internal constant EXCHANGE_PRECISION = 1e18;\\n    uint64 internal constant DEFAULT_INT = 158049988; // 0.5% annual rate 1e18 precision\\n}\",\"keccak256\":\"0xa6d79d0014ff7e7b0b28ec3e9ded940ba9749a72a5f5509d24738f7d531049e4\"},\"contracts/instruments/poolInstrument.sol\":{\"content\":\"pragma solidity ^0.8.16;\\nimport {Instrument} from \\\"../vaults/instrument.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {ERC721} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {PoolConstants} from \\\"./poolConstants.sol\\\";\\nimport {VaultAccount, VaultAccountingLibrary} from \\\"./VaultAccount.sol\\\";\\nimport {SafeCastLib} from \\\"lib/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {IRateCalculator} from \\\"./IRateCalculator.sol\\\";\\nimport {ReentrancyGuard} from \\\"lib/solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {Pausable} from \\\"lib/openzeppelin-contracts/contracts/security/Pausable.sol\\\";\\nimport {ERC4626} from \\\"lib/solmate/src/mixins/ERC4626.sol\\\";\\nimport {ERC721TokenReceiver} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n// import \\\"@prb/math/SD59x18.sol\\\";\\n\\n// https://github.com/FraxFinance/fraxlend\\n/// ****THIS IS A PROOF OF CONCEPT INSTRUMENT.\\ncontract PoolInstrument is ERC4626, Instrument, PoolConstants, ReentrancyGuard, Pausable, ERC721TokenReceiver {\\n    using SafeTransferLib for ERC20;\\n    using VaultAccountingLibrary for VaultAccount;\\n    using SafeCastLib for uint256;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    /// @param lastBlock last block number\\n    /// @param lastTimestamp last block.timestamp\\n    /// @param ratePerSec rate per second of interest accrual\\n    struct CurrentRateInfo {\\n        uint64 lastBlock;\\n        uint64 lastTimestamp;\\n        uint64 ratePerSec;\\n    }\\n\\n    /// @param tokenAddress collateral token address\\n    /// @param tokenId collateral tokenId, 0 for ERC20.\\n    struct CollateralLabel {\\n        address tokenAddress;\\n        uint256 tokenId;\\n    }\\n\\n    /// @param totalCollateral total amount of collateral for a given ERC20 asset, will be zero for NFTs\\n    /// @param maxAmount max amount in underlying that a user can \\\"owe\\\" per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\\n    /// should always be more than the maxBorrowAmount, acts as buffer for protocol and borrower. this is the value to determine whether\\n    /// a borrower is liquidatable\\n    /// @param maxBorrowAmount max amount in underlying that a user can borrow per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\\n    struct Collateral {\\n        uint256 totalCollateral; \\n        uint256 maxAmount;\\n        uint256 maxBorrowAmount;\\n        bool isERC20;\\n    }\\n\\n    /// @notice dutch auctions for NFTs, GDA for illiquid ERC20s.\\n    /// @param borrower address of borrower\\n    /// @param collateral address of collateral\\n    /// @param tokenId tokenId of collateral, 0 for ERC20\\n    /// @param initialPrice initial price of collateral currently is (account liquidity / collateral amount) + maxAmount.\\n    /// @param decayConstant parameter that controls price decay, stored as a 59x18 fixed precision number\\n    /// @param startTime for dutch auction: start time of auction, for GDA: time of last auction.\\n    /// @param emissionRate for dutch auction: 0, for GDA: amount of collateral to be auctioned off per second.\\n    // struct Auction {\\n    //     address borrower;\\n    //     address collateral;\\n    //     uint256 tokenId;\\n    //     SD59x18 initialPrice;\\n    //     SD59x18 minimumPrice;\\n    //     SD59x18 decayConstant;\\n    //     SD59x18 startTime;\\n    //     // SD59x18 emissionRate;\\n    //     bool alive;\\n    // }\\n\\n    /// @notice amount: asset token borrowed, shares = total shares outstanding\\n    VaultAccount public totalBorrow;\\n    /// @notice amount: total asset supplied + interest earned, shares = total shares outstanding\\n    VaultAccount public totalAsset;\\n\\n    mapping(address=>mapping(uint256 => Collateral)) public collateralData; // collateral address => tokenId (0 for erc20) => collateral data.\\n    mapping(address=>mapping(uint256=>bool)) public approvedCollateral;\\n    mapping(address=>mapping(address=>uint256)) public userCollateralERC20; // per collateral, user balance of collateral.\\n    mapping(address=>mapping(uint256 => address)) public userCollateralNFTs; // nft addr => tokenId => owner.\\n    mapping(address=>uint256) public userBorrowShares;\\n    mapping(address=>uint256) public userAuctionId; // user => current auction id, if 0 then no auction.\\n    \\n    /// @dev auction id => order of creation.\\n    // mapping(uint256=>Auction) public auctions; // auction id => auction data, auction id is in order of creation.\\n\\n    uint256 public numAuctions; // number of auction ids.\\n\\n    IRateCalculator public rateContract;\\n\\n    /// @dev depends on rateCalculator used\\n    bytes public rateInitCallData;\\n    \\n    CurrentRateInfo public currentRateInfo;\\n    CollateralLabel[] collaterals; //approved collaterals.\\n    address controller;\\n    \\n    constructor (\\n        address _vault,\\n        address _controller,\\n        address _utilizer,\\n        address _asset,\\n        string memory _name,\\n        string memory _symbol,\\n        address _rateCalculator,\\n        bytes memory _rateInitCallData,\\n        CollateralLabel[] memory _collaterals,\\n        Collateral[] memory _collateralDatas\\n    ) Instrument(_vault, _utilizer) ERC4626(ERC20(_asset), _name, _symbol) {\\n        controller = _controller;\\n        rateContract = IRateCalculator(_rateCalculator);\\n        rateInitCallData = _rateInitCallData;\\n        rateContract.requireValidInitData(_rateInitCallData);\\n\\n        for (uint i = 0; i < _collaterals.length; i ++) {\\n            collaterals.push(_collaterals[i]);\\n            Collateral memory _collateral = _collateralDatas[i];\\n            _collateral.totalCollateral = 0;\\n            collateralData[_collaterals[i].tokenAddress][_collaterals[i].tokenId] = _collateral;\\n        }\\n    }\\n\\n    // should be gated function\\n    /// tokenId 0 for ERC20.\\n    function initialize(\\n    ) external {\\n\\n    }\\n\\n    function getAcceptedCollaterals() view public returns (CollateralLabel[] memory) {\\n        return collaterals;\\n    }\\n\\n    // legacy for tests, remove later.\\n    function addAcceptedCollateral(\\n        address _collateral,\\n        uint256 _tokenId,\\n        uint256 _maxAmount,\\n        uint256 _maxBorrowAmount,\\n        bool _isERC20\\n    ) external  {\\n        require(msg.sender == controller, \\\"only controller\\\");\\n        if (approvedCollateral[_collateral][_tokenId]) return; \\n        require(_maxAmount > _maxBorrowAmount, \\\"maxAmount must be greater than maxBorrowAmount\\\");\\n        approvedCollateral[_collateral][_tokenId] = true;\\n        collaterals.push(CollateralLabel(_collateral, _tokenId));\\n        collateralData[_collateral][_tokenId] = Collateral(0,_maxAmount, _maxBorrowAmount, _isERC20);\\n    }\\n\\n    // INTERNAL HELPERS\\n\\n    modifier onlyApprovedCollateral(address _collateral, uint256 _tokenId) {\\n        require(approvedCollateral[_collateral][_tokenId], \\\"collateral not approved\\\");\\n        _;\\n    }\\n\\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return _totalAsset.amount - _totalBorrow.amount;\\n    }\\n\\n    // INTEREST RATE LOGIC\\n    event InterestAdded(uint256 indexed timestamp, uint256 interestEarned, uint256 feesAmount, uint256 feesShare, uint64 newRate);\\n\\n    function addInterest()\\n        external\\n        nonReentrant\\n        returns (\\n            uint256 _interestEarned,\\n            uint256 _feesAmount,\\n            uint256 _feesShare,\\n            uint64 _newRate\\n        )\\n    {\\n        return _addInterest();\\n    }\\n\\n    function _addInterest() internal\\n        returns (\\n            uint256 _interestEarned,\\n            uint256 _feesAmount,\\n            uint256 _feesShare,\\n            uint64 _newRate\\n        )\\n    {\\n        // Add interest only once per block\\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\\n            _newRate = _currentRateInfo.ratePerSec;\\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\\n        }\\n\\n        // Pull some data from storage to save gas\\n        VaultAccount memory _totalAsset = totalAsset;\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n        console.log(\\\"total borrower shares: \\\", totalBorrow.shares);\\n\\n        // If there are no borrows or contract is paused, no interest adds and we reset interest rate\\n        if (_totalBorrow.shares == 0 || paused()) {\\n            if (!paused()) {\\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\\n            }\\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\\n            _currentRateInfo.lastBlock = uint64(block.number);\\n\\n            // Effects: write to storage\\n            currentRateInfo = _currentRateInfo;\\n        } else {\\n            // We know totalBorrow.shares > 0\\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\\n\\n            // NOTE: Violates Checks-Effects-Interactions pattern\\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\\n            // Calc new rate\\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\\n            // console.log(\\\"_utilizationRate: \\\", _utilizationRate);\\n            bytes memory _rateData = abi.encode(\\n                    _currentRateInfo.ratePerSec,\\n                    _deltaTime,\\n                    _utilizationRate,\\n                    block.number - _currentRateInfo.lastBlock\\n                );\\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\\n\\n            // Effects: bookkeeping\\n            _currentRateInfo.ratePerSec = _newRate;\\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\\n            _currentRateInfo.lastBlock = uint64(block.number);\\n\\n            // Calculate interest addd\\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\\n\\n            // Accumulate interest and fees, only if no overflow upon casting\\n            if (\\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\\n                _interestEarned + _totalAsset.amount <= type(uint128).max\\n            ) {\\n                _totalBorrow.amount += uint128(_interestEarned);\\n                _totalAsset.amount += uint128(_interestEarned);\\n            }\\n\\n            // Effects: write to storage\\n            totalAsset = _totalAsset;\\n            currentRateInfo = _currentRateInfo;\\n            totalBorrow = _totalBorrow;\\n        }\\n        console.log(\\\"_interestEarned: \\\", _interestEarned);\\n        emit InterestAdded(block.timestamp, _interestEarned, _feesAmount, _feesShare, _newRate);\\n        // console.log(\\\"ratePerSec: \\\", _currentRateInfo.ratePerSec);\\n    }\\n\\n    // SOLVENCY* LOGIC\\n\\n    /// @notice Checks if total amount of asset user borrowed is less than max borrow threshold AFTER executing contract code\\n    modifier canBorrow(address _borrower) {\\n        _;\\n        require(_canBorrow(_borrower), \\\"borrower is insolvent\\\");\\n    }\\n\\n\\n    /// @notice checks if the borrower is can borrow\\n    /// @dev collateral value is in asset, summed across all approved collaterals.\\n    /// @dev will return true if the borrower has no collateral and also has no borrower shares.\\n    /// @dev 0 addr cannot borrow.\\n    function _canBorrow(address _borrower) public view returns (bool) {\\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\\n\\n        if (userBorrowShares[_borrower] == 0) {\\n            return true;\\n        }\\n        if (_maxBorrowableAmount == 0) {\\n            return false;\\n        }\\n        return _maxBorrowableAmount >= totalBorrow.toAmount(userBorrowShares[_borrower], false);\\n    }\\n\\n    function getMaxBorrow(address _borrower) public view returns(uint256 _maxBorrowableAmount){\\n\\n        for (uint256 i; i < collaterals.length; i++) {\\n            CollateralLabel memory _collateral = collaterals[i];\\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxBorrowAmount / (10**_d); // <= precision of collateral.\\n            } else {\\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\\n                    _maxBorrowableAmount += _collateralData.maxBorrowAmount;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice returns how much collateral can be removed, given the borrower's current debt condition\\n    function removeableCollateral(address _borrower, uint256 tokenId, address collateral) public view returns(uint256){\\n        //800 borrowable = 800 * 1, 600borrowed (800-x)*1 - 600 = 0 x=? \\n        //800*1-x*1-600 , x = (800*1 - 600)/1\\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower); \\n        uint256 perUnitMaxBorrowAmount = collateralData[collateral][tokenId].maxBorrowAmount; \\n        //check solvency\\n        return (_maxBorrowableAmount - totalBorrow.toAmount(userBorrowShares[_borrower], true)) \\n            * 1e18/ perUnitMaxBorrowAmount; \\n    }  \\n\\n    // BORROW LOGIC\\n    event Borrow(address indexed _borrower, uint256 _amount, uint256 _shares);\\n\\n    /// @param _borrowAmount amount of asset to borrow\\n    /// @param _collateralAmount amount of collateral to add\\n    /// @param _collateral address of collateral, \\n    /// @param _reciever address of reciever of asset\\n    function borrow(\\n        uint256 _borrowAmount,\\n        address _collateral,\\n        uint256 _tokenId,\\n        uint256 _collateralAmount,\\n        address _reciever\\n    ) canBorrow(msg.sender) nonReentrant whenNotPaused external returns (uint256 _shares) {\\n        _addInterest();\\n\\n        if (_collateral != address(0) && (_collateralAmount > 0 || _tokenId > 0)) {\\n            require(approvedCollateral[_collateral][_tokenId], \\\"unapproved collateral\\\");\\n            _addCollateral(msg.sender, _collateral, _collateralAmount, msg.sender, _tokenId);\\n        }\\n        // borrow asset.\\n        _shares = _borrow(_borrowAmount.safeCastTo128(), _reciever);\\n    }\\n\\n    function _borrow(\\n        uint128 _borrowAmount,\\n        address _receiver\\n    ) internal returns (uint256 _shares) {\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n\\n        // Check available capital\\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\\n        if (_assetsAvailable < _borrowAmount) {\\n            revert(\\\"insufficient contract asset balance\\\");\\n        }\\n\\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\\n        _shares = _totalBorrow.toShares(_borrowAmount, true);\\n        _totalBorrow.amount += _borrowAmount;\\n        _totalBorrow.shares += uint128(_shares);\\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\\n\\n        // Effects: write back to storage\\n        totalBorrow = _totalBorrow;\\n        userBorrowShares[msg.sender] += _shares;\\n\\n        emit Borrow(msg.sender, _borrowAmount, _shares);\\n\\n        // Interactions\\n        if (_receiver != address(this)) {\\n            asset.safeTransfer(_receiver, _borrowAmount);\\n        }\\n    }\\n\\n    // REPAY LOGIC\\n    event Repay(address indexed borrower, uint256 amount, uint256 shares);\\n\\n    function repayWithAmount(\\n        uint256 _amount, \\n        address _borrower\\n        )   external nonReentrant returns (uint256 _sharesToRepay){\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n        _sharesToRepay = _totalBorrow.toShares(_amount, true); \\n        _repay(_totalBorrow, _amount.safeCastTo128(), _sharesToRepay.safeCastTo128(), msg.sender, _borrower);\\n    }\\n\\n    function repay(\\n        uint256 _shares,\\n        address _borrower\\n    ) external nonReentrant returns (uint256 _amountToRepay) {\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\\n        console.log(\\\"amount to repay: \\\", _amountToRepay);\\n        _repay(_totalBorrow, _amountToRepay.safeCastTo128(), _shares.safeCastTo128(), msg.sender, _borrower);\\n    }\\n\\n    function _repay(\\n        VaultAccount memory _totalBorrow,\\n        uint128 _amountToRepay,\\n        uint128 _shares,\\n        address _payer,\\n        address _borrower\\n    ) internal {\\n        console.log(\\\"_shares: \\\", _shares);\\n        console.log(\\\"_amountToRepay: \\\", _amountToRepay);\\n        console.log(\\\"userBorrowShares[_borrower]: \\\", userBorrowShares[_borrower]);\\n        // Effects: Bookkeeping\\n        _totalBorrow.amount -= _amountToRepay;\\n        _totalBorrow.shares -= _shares;\\n\\n        // Effects: write to state\\n        userBorrowShares[_borrower] -= _shares;\\n        totalBorrow = _totalBorrow;\\n\\n        emit Repay(_borrower, _amountToRepay, _shares);\\n\\n        // Interactions\\n        if (_payer != address(this)) {\\n            asset.safeTransferFrom(_payer, address(this), _amountToRepay);\\n        }\\n    }\\n\\n\\n    // ADD/REMOVE COLLATERAL LOGIC\\n    event AddCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\\n    event RemoveCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\\n\\n    \\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation, or ERC721.approve().\\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\\n    /// @param _borrower The account to be credited\\n    function addCollateral(\\n        address _collateral,\\n        uint256 _tokenId,\\n        uint256 _collateralAmount,\\n        address _borrower\\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant {\\n        _addInterest();\\n        _addCollateral(msg.sender, _collateral, _collateralAmount, _borrower, _tokenId);\\n    }\\n\\n    function _addCollateral(\\n        address _sender,\\n        address _collateral,\\n        uint256 _collateralAmount,\\n        address _borrower,\\n        uint256 _tokenId\\n    ) internal {\\n\\n        // Interactions\\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\\n    \\n        if (_sender != address(this)) {\\n            if (_isERC20)  {\\n                userCollateralERC20[_collateral][_borrower] += _collateralAmount;\\n                collateralData[_collateral][0].totalCollateral += _collateralAmount;\\n                ERC20(_collateral).safeTransferFrom(_sender, address(this), _collateralAmount);\\n            } else {\\n                userCollateralNFTs[_collateral][_tokenId] = _borrower;\\n                ERC721(_collateral).safeTransferFrom(_sender, address(this), _tokenId);\\n            }\\n        }\\n        emit AddCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\\n    }\\n\\n    function removeAvailableCollateral(\\n        address _collateral, \\n        uint256 _tokenId,\\n        address _receiver\\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) returns(uint256 removeable){\\n        _addInterest();\\n\\n        removeable = removeableCollateral(msg.sender,  _tokenId,  _collateral); \\n\\n        _removeCollateral(_collateral, \\n            removeable,\\n            _tokenId, msg.sender, _receiver);\\n    }\\n\\n    function removeCollateral(\\n        address _collateral, \\n        uint256 _tokenId,\\n        uint256 _collateralAmount,\\n        address _receiver\\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) {\\n        _addInterest();\\n\\n        // Note: exchange rate is irrelevant when borrower has no debt shares\\n        _removeCollateral(_collateral, _collateralAmount, _tokenId, msg.sender, _receiver);\\n    }\\n\\n    function _removeCollateral(\\n        address _collateral,\\n        uint256 _collateralAmount,\\n        uint256 _tokenId,\\n        address _borrower,\\n        address _receiver\\n    ) internal {\\n\\n        // Interactions\\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\\n        if (_receiver != address(this)) {\\n            if (_isERC20) {\\n                console.log(\\\"removing erc20 collateral\\\");\\n                console.log(\\\"userCollateralerc20: \\\", userCollateralERC20[_collateral][_borrower] );\\n                console.log(\\\"collateralAmount: \\\", _collateralAmount);\\n                console.log(\\\"total: \\\", collateralData[_collateral][0].totalCollateral);\\n                userCollateralERC20[_collateral][_borrower] -= _collateralAmount;\\n                collateralData[_collateral][0].totalCollateral -= _collateralAmount;\\n                ERC20(_collateral).safeTransfer(_receiver, _collateralAmount);\\n            } else {\\n                require(userCollateralNFTs[_collateral][_tokenId] == _borrower, \\\"not owner of nft\\\");\\n                delete userCollateralNFTs[_collateral][_tokenId];\\n                ERC721(_collateral).safeTransferFrom(address(this), _receiver, _tokenId);\\n            }\\n        }\\n        emit RemoveCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\\n    }\\n\\n    // liquidation logic\\n\\n    /// @notice collateral should be auctioned off at a minimum price chosen by the managers\\n    /// underlying balance, collateral balance, what do we know about the user?\\n    /// if the user's borrow shares are equal to an amount of asset that is greater than the maximum amount they can borrow, \\n    /// they are suceptible to liquidation\\n    /// how to determine what collateral should be auctioned off?\\n    /// maxBorrowAmount\\n    function _isLiquidatable(address _borrower) public view returns (bool, int256 accountLiq) {\\n        uint256 _maxBorrowableAmount;\\n\\n        for (uint256 i; i < collaterals.length; i++) {\\n            CollateralLabel memory _collateral = collaterals[i];\\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxAmount / (10**_d); // <= precision of collateral.\\n            } else {\\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\\n                    _maxBorrowableAmount += _collateralData.maxAmount;\\n                }\\n            }\\n        }\\n\\n\\n        return (_maxBorrowableAmount < totalBorrow.toAmount(userBorrowShares[_borrower], false), \\n            int256(_maxBorrowableAmount) - int256(totalBorrow.toAmount(userBorrowShares[_borrower], false))\\n        );\\n    }\\n\\n    /// AUCTION LOGIC\\n\\n    event AuctionCreated(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\\n    event AuctionClosed(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\\n    event CollateralPurchased(uint256 indexed id, address indexed buyer, address indexed collateral, uint256 tokenId, uint256 amount);\\n\\n    function liquidate(\\n        address _borrower\\n    ) external nonReentrant returns (CollateralLabel memory _collateral, uint256 _auctionId){\\n        _addInterest();\\n        \\n        (bool _liquidatable, int256 _accountLiq) = _isLiquidatable(_borrower);\\n        require(_liquidatable, \\\"borrower is not liquidatable\\\");\\n        require(userAuctionId[_borrower] == 0, \\\"auction already exists\\\");\\n        // _accountLiq < 0 if _liquidatable.\\n        //(_collateral, _auctionId) = _createAuction(_borrower, uint256(-_accountLiq));\\n    }\\n\\n    // since we don't know the price of the collateral, will just use largest maxAmount collateral, presumably the most \\\"liquid\\\"\\n    /// @dev _accountLiq in wad.\\n    // function _createAuction(address _borrower, uint256 _accountLiq) internal returns (CollateralLabel memory _collateral, uint256 _auctionId) {\\n    //     CollateralLabel[] memory _collaterals = collaterals;\\n\\n    //     uint256 maxBorrowableAmount;\\n    //     for (uint256 i; i<_collaterals.length; i++) {\\n    //         CollateralLabel memory _collateralLabel = _collaterals[i];\\n    //         Collateral memory _collateralData = collateralData[_collateralLabel.tokenAddress][_collateralLabel.tokenId];\\n    //         if (_collateralData.isERC20) {\\n    //             uint256 _amount = userCollateralERC20[_collateralLabel.tokenAddress][_borrower] * _collateralData.maxAmount / 1e18; // <= precision of collateral.\\n    //             if (_amount > maxBorrowableAmount) {\\n    //                 maxBorrowableAmount = _amount;\\n    //                 _collateral = _collateralLabel;\\n    //             }\\n    //         } else {\\n    //             if (userCollateralNFTs[_collateralLabel.tokenAddress][_collateralLabel.tokenId] == _borrower) {\\n    //                 if (_collateralData.maxAmount > maxBorrowableAmount) {\\n    //                     maxBorrowableAmount = _collateralData.maxAmount;\\n    //                     _collateral = _collateralLabel;\\n    //                 }\\n    //             }\\n    //         }\\n    //     }\\n\\n    //     // creates auction for collateral user collateral.\\n    //     Collateral memory _data = collateralData[_collateral.tokenAddress][_collateral.tokenId];\\n\\n    //     uint256 _id = numAuctions + 1;\\n\\n    //     SD59x18 _balance;\\n    //     if (_data.isERC20) {\\n    //         uint256 _d = ERC20(_collateral.tokenAddress).decimals();\\n    //         _balance = sd(int256(userCollateralERC20[_collateral.tokenAddress][_borrower] * 10**(18-_d)));\\n    //     } else {\\n    //         _balance = toSD59x18(1);\\n    //     }\\n    //     console.log(\\\"accountLiq: \\\", _accountLiq);\\n    //     console.logInt(SD59x18.unwrap(_balance));\\n    //     console.log(\\\"maxAmount: \\\", _data.maxAmount);\\n    //     console.logInt(int256(_data.maxAmount));\\n\\n    //     SD59x18 _initialPrice = sd(int256(_accountLiq)).div(_balance).add(sd(int256(_data.maxAmount))); // per collateral token.\\n    //     // console.logInt(SD59x18.unwrap(_initialPrice));\\n\\n    //     console.log(\\\"shares: \\\", totalBorrow.toShares(uint256(SD59x18.unwrap(_initialPrice)), true));\\n    //     console.log(\\\"total.shares: \\\", totalBorrow.shares);\\n    //     console.log(\\\"total.amount: \\\", totalBorrow.amount);\\n\\n    //     SD59x18 _decayConstant = sd(1e17).div(toSD59x18(86400));// decayConstant * deltaTime * initial price = discount.\\n    //     SD59x18 _minimumPrice = _initialPrice.div(toSD59x18(4)); // minimum price is 1/4 of initial price.\\n        \\n    //     // sd(1219450412706); // 10% a day. 1.219450412706322930873853944899453684098615428047153617638... \\u00d7 10^-6\\n    //     // SD59x18 _emissionRate = _balance.div(toSD59x18(86400).div(toSD59x18(2))); // 1/2 balance in a day, tokens per second.\\n    //     auctions[_id] = Auction({\\n    //         collateral: _collateral.tokenAddress,\\n    //         tokenId: _collateral.tokenId,\\n    //         borrower: _borrower,\\n    //         initialPrice: _initialPrice,\\n    //         minimumPrice: _minimumPrice,\\n    //         decayConstant: _decayConstant,\\n    //         startTime: toSD59x18(int256(block.timestamp)),\\n    //         //emissionRate: _emissionRate,\\n    //         alive: true\\n    //     });\\n    \\n    //     numAuctions = numAuctions + 1;\\n    //     _auctionId = _id;\\n    //     userAuctionId[_borrower] = _auctionId;\\n\\n    //     emit AuctionCreated(_id, _borrower, _collateral.tokenAddress, _collateral.tokenId);\\n    // }\\n\\n    \\n    // function closeAuction(address _borrower) public {\\n    //     uint256 _id = userAuctionId[_borrower];\\n    //     (bool _liquidatable, ) = _isLiquidatable(auctions[_id].borrower);\\n    //     require(_id != 0, \\\"no auction exists\\\");\\n\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //     }\\n    // }\\n\\n    // function _closeAuction(uint256 _id) internal {\\n    //     address _borrower = auctions[_id].borrower;\\n    //     emit AuctionClosed(_id, _borrower, auctions[_id].collateral, auctions[_id].tokenId);\\n    //     delete userAuctionId[_borrower];\\n    //     delete auctions[_id];\\n    // }\\n\\n    // function purchaseERC20Collateral(uint256 _id, uint256 _amount) external returns (uint256 _totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n\\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //         revert(\\\"auction closed\\\");\\n    //     }\\n        \\n    //     _totalCost = purchasePriceERC20(_id, _amount);\\n    //     console.log(\\\"totalCost: \\\", _totalCost);\\n\\n    //     VaultAccount memory _totalBorrow = totalBorrow;\\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\\n       \\n    //    // will revert if not enough collateral in user collateral balance.\\n    //    _removeCollateral(_auction.collateral, _amount, _auction.tokenId, _auction.borrower, msg.sender);\\n\\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //     }\\n    //     if (userCollateralERC20[_auction.collateral][_auction.borrower] == 0) {\\n    //         delete userAuctionId[_auction.borrower];\\n    //         delete auctions[_id];\\n    //     }\\n        \\n    // }\\n\\n    // function purchasePriceERC20(uint256 _id, uint256 _numTokens) public view returns (uint256 totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n    //     require(_auction.alive, \\\"auction is not alive\\\");\\n\\n    //     uint256 _d = ERC20(_auction.collateral).decimals();\\n        \\n    //     SD59x18 _quantity = sd(int256(_numTokens * (10 ** (18 - _d))));\\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime)).mul(_auction.initialPrice);\\n    //     SD59x18 _price = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) // is initial price > minimum price + discount => initial price - discount > minimum price\\n    //         ? _auction.initialPrice.sub(_discount) : _auction.minimumPrice;\\n    //     totalCost = uint256(SD59x18.unwrap(_price.mul(_quantity)));\\n    // }\\n\\n    // /// @param _id is the auction id to purchase the collateral from\\n    // function purchaseERC721Collateral(uint256 _id) external returns (uint256 _totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n\\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _auction.alive = false;\\n    //         auctions[_id] = _auction;\\n    //         delete userAuctionId[_auction.borrower];\\n    //         revert(\\\"auction closed\\\");\\n    //     }\\n        \\n    //     _totalCost = purchasePriceERC721(_id);\\n\\n    //     VaultAccount memory _totalBorrow = totalBorrow;\\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\\n       \\n    //    // will revert if not enough collateral in user collateral balance.\\n    //    _removeCollateral(_auction.collateral, 0, _auction.tokenId, _auction.borrower, msg.sender);\\n\\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //     }\\n    //     if (userCollateralNFTs[_auction.collateral][_auction.tokenId] == address(0)) {\\n    //         delete userAuctionId[_auction.borrower];\\n    //         delete auctions[_id];\\n    //     }\\n    // }\\n\\n    // function purchasePriceERC721(uint256 _id) public view returns (uint256 totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n    //     require(_auction.alive, \\\"auction is not alive\\\");\\n\\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime));\\n\\n    //     totalCost = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) ? \\n    //     uint256(SD59x18.unwrap(_auction.initialPrice.sub(_discount))) : uint256(SD59x18.unwrap(_auction.minimumPrice));\\n        \\n    // }\\n\\n    // instrument functions\\n    function instrumentApprovalCondition() public override virtual view returns (bool) {\\n        return true;\\n    }\\n\\n    function borrowLiquidityAvailable(uint256 _borrowAmount) public view returns (bool){\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n\\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\\n        if (_assetsAvailable < _borrowAmount) {\\n            return false;\\n        }\\n        return true; \\n    }\\n\\n    function totalAssetAvailable() public view returns(uint256){\\n        return _totalAssetAvailable(totalAsset, totalBorrow); \\n    }\\n\\n\\n    // ERC4626 functions.\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override virtual {\\n        // require(msg.sender == address(vault) || msg.sender == controller, \\\"!Vault/Controller\\\"); // only the vault can withdraw\\n        // check if there is enough asset to cover the withdraw.\\n        uint256 totalAvailableAsset = _totalAssetAvailable(totalAsset, totalBorrow);\\n        require(totalAvailableAsset >= assets, \\\"not enough asset\\\");\\n\\n        VaultAccount memory _totalAsset = totalAsset;\\n\\n        _totalAsset.amount -= assets.safeCastTo128();\\n        _totalAsset.shares -= shares.safeCastTo128();\\n\\n        totalAsset = _totalAsset;\\n\\n    }\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal override virtual {\\n        // require(msg.sender == address(vault) || msg.sender == controller, \\\"!Vault/Controller\\\"); // only the vault can deposit\\n        VaultAccount memory _totalAsset = totalAsset;\\n\\n        _totalAsset.amount += assets.safeCastTo128();\\n        _totalAsset.shares += shares.safeCastTo128();\\n\\n        totalAsset = _totalAsset;\\n    }\\n\\n    function getUserSnapshot(address _address)\\n        external\\n        view\\n        returns (\\n            uint256 _userAssetShares,\\n            uint256 _userAssetAmount,\\n            uint256 _userBorrowShares,\\n            uint256 _userBorrowAmount,\\n            int256 _userAccountLiquidity\\n        )\\n    {\\n        _userAssetShares = balanceOf[_address];\\n        _userAssetAmount = totalAsset.toAmount(_userAssetShares, false);\\n        _userBorrowShares = userBorrowShares[_address];\\n        _userBorrowAmount = totalBorrow.toAmount(_userBorrowShares, false);\\n        (, _userAccountLiquidity) = _isLiquidatable(_address);\\n    }\\n    function isWithdrawAble(address holder, uint256 amount) external view returns(bool){\\n        return (previewRedeem(balanceOf[holder])>= amount && totalAssetAvailable() >= amount); \\n    }\\n\\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\\n        return totalBorrow.toShares(_amount, _roundUp);\\n    }\\n\\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\\n        return totalBorrow.toAmount(_shares, _roundUp);\\n    }\\n\\n    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\\n        return totalAsset.toAmount(_shares, _roundUp);\\n    }\\n\\n    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\\n        return totalAsset.toShares(_amount, _roundUp);\\n    }\\n\\n    function totalAssets() public view override virtual returns (uint256) {\\n        return totalAsset.amount;\\n    }\\n\\n    function convertToShares(uint256 assets) public view override virtual returns (uint256) {\\n        return totalAsset.toShares(assets, false);\\n    }\\n\\n    function convertToAssets(uint256 shares) public view override virtual returns (uint256) {\\n        return totalAsset.toAmount(shares, false);\\n    }\\n\\n\\n    function previewMint(uint256 shares) public view override virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view override virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewRedeem(uint256 shares) public view override virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n}\\n\\n/**\\nnonReentrant\\ndeposit asset\\nredeem/withdraw\\nborrow\\nadd collateral,\\nremove collateral,\\nliquidate,\\nrepay,\\nrepay behalf,\\nupdate exchange rate,\\nupdate interest rate,\\nonlyVault\\nupdate oracle,\\nupdate rateCalculator\\n\\nminting, redeeming, depositing\\n\\n add collateral in batches\\n batch liquidation\\n update exchange rate + accue interest when *necessary\\n\\n virtual function, is approved borrower.\\n\\n instrument functions to override: \\n function estimatedTotalAssets() public view virtual returns (uint256){}\\n prepareWithdraw\\n liquidatePosition => protocol liquidation for all outstanding debt.\\n */\",\"keccak256\":\"0x60bb3c3bce3313d0a0565a08dc501938a81de58b562a764ccd47596decf240bc\"},\"contracts/protocol/LeverageModule.sol\":{\"content\":\"pragma solidity ^0.8.4; \\n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\n\\nimport  \\\"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\"; \\nimport {Controller} from \\\"./controller.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {PoolInstrument} from \\\"../instruments/poolInstrument.sol\\\"; \\nimport {SafeCastLib} from \\\"lib/solmate/src/utils/SafeCastLib.sol\\\";\\n\\n\\n\\n/// @notice borrow from leverageVault to leverage mint vaults\\ncontract LeverageModule is ERC721Enumerable{\\n  \\tusing FixedPointMathLib for uint256;\\n    using SafeCastLib for uint256;\\n\\n\\tuint256 constant precision =1e18; \\n\\tController controller; \\n\\t/// param leverageVault is where the capital is for borrowing\\n\\tconstructor(\\n\\t\\taddress controller_ad \\n\\t\\t)ERC721Enumerable() ERC721(\\\"RAMM lv\\\", \\\"RammLV\\\") {\\n\\t\\tcontroller = Controller(controller_ad); \\n\\t}\\n\\n\\tmapping(uint256=> Position) public positions; \\n\\tmapping(uint256=> address)  leveragePools; \\n\\n\\tstruct Position{\\n\\t\\taddress vaultAd; \\n\\t\\tuint256 totalShares; \\n\\n\\t\\tuint256 suppliedCapital; \\n\\t\\tuint256 borrowedCapital; \\n\\n\\t\\tuint256 borrowTimeStamp;\\n\\t\\tuint256 endStateBalance; \\n\\t}\\n\\n\\tfunction getPosition(uint256 tokenId) public view returns (Position memory position){\\n\\t\\treturn positions[tokenId]; \\n\\t}\\n\\n    /// @dev The ID of the next token that will be minted. Skips 0\\n    uint176 private _nextId = 1;\\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\\n    uint80 private _nextPoolId = 1;\\n\\n    function addLeveragePool(uint256 vaultId, address pool) public \\n    //onlyowner\\n    {\\n    \\tleveragePools[vaultId] = pool; \\n    }\\n\\n\\t/// @notice Allow people to borrow from leverageVault and use that to\\n\\t/// create leveraged Vault positions \\n\\t/// @dev steps\\n\\t// 0. transfer to this address\\n\\t// 1. mint vault to this address\\n\\t// 2. borrow to this address,\\n\\t// 3. mint new vault to this address \\n\\t// 4. borrow new vault to this \\n\\tfunction _mintWithLeverage(\\n\\t\\tuint256 vaultId, \\n\\t\\tuint256 availableLiquidity, \\n\\t\\tuint256 borrowAmount, \\n\\t\\tuint256 collateralAmount, \\n\\t\\tMintLocalVars memory vars) \\n\\t\\tinternal{\\n\\n\\t\\t// Check collateral specific borrowable \\n\\t\\tuint256 maxBorrowableAmount = min(borrowAmount, vars.collateralPower.mulWadDown(collateralAmount)); \\n\\n\\t\\t// Check if liquidity available\\n\\t\\tvars.maxBorrowableAmount = min(maxBorrowableAmount, availableLiquidity); \\n\\n\\t\\t// Depleted lendingpool if availableLiquidity < maxBorrowableAmount\\n\\t\\tvars.noMoreLiq = (vars.maxBorrowableAmount < maxBorrowableAmount); \\n\\n\\t\\tvars.vault.approve(address(vars.leveragePool), collateralAmount); \\n\\n\\t\\tvars.leveragePool.borrow(\\n\\t\\t\\tvars.maxBorrowableAmount, address(vars.vault), \\n\\t\\t\\t0, collateralAmount, address(this) \\n\\t\\t\\t); \\n\\n\\t\\tconsole.log('new collateral amount', collateralAmount); \\n\\t\\tconsole.log('maxBorrowableAmount', vars.maxBorrowableAmount); \\n\\n\\t\\tvars.shares = vars.vault.deposit(vars.maxBorrowableAmount, address(this)); \\t\\t\\n\\t}\\n\\n\\tstruct MintLocalVars{\\n\\t\\tVault vault; \\n\\t\\tPoolInstrument leveragePool; \\n\\n\\t\\tuint256 totalBorrowAmount; \\n\\t\\tuint256 maxBorrowAmount; \\n\\t\\tbool noMoreLiq; \\n\\t\\tuint256 shares; \\n\\t\\tuint256 mintedShares; \\n\\t\\tuint256 borrowedAmount; \\n\\n\\t\\tuint256 availableLiquidity; \\n\\t\\tuint256 maxBorrowableAmount; \\n\\t\\tuint256 collateralPower; \\n\\n\\t}\\n\\n\\t/// @notice Implements a leverage loop \\n\\t// TODO implement with flash minting, maybe more gas efficient \\n\\tfunction mintWithLeverage(\\n\\t\\tuint256 vaultId, \\n\\t\\tuint256 suppliedCapital, \\n\\t\\tuint256 leverageFactor) public returns(uint256 tokenId, Position memory newPosition) {\\n\\t\\tMintLocalVars memory vars; \\n\\t\\tvars.vault = controller.vaults(vaultId); \\n\\n\\t\\tERC20 underlying = ERC20(address(vars.vault.UNDERLYING()));\\n\\t\\tunderlying.transferFrom(msg.sender, address(this), suppliedCapital); \\n\\t\\tunderlying.approve(address(vars.vault), suppliedCapital.mulWadDown(precision + leverageFactor)); \\n\\n\\t\\tvars.leveragePool = PoolInstrument(leveragePools[vaultId]); \\n\\t\\tvars.availableLiquidity = vars.leveragePool.totalAssetAvailable(); \\n\\n\\t\\tif(vars.availableLiquidity == 0) revert(\\\"Not Enough Liq\\\"); \\n\\t\\t(,,vars.collateralPower,) = vars.leveragePool.collateralData(address(vars.vault),0); \\n\\n\\t\\t// Initial minting \\n\\t\\tvars.shares = vars.vault.deposit(suppliedCapital, address(this));\\n\\n\\t\\t// borrow until leverage is met, \\n\\t\\tvars.totalBorrowAmount = suppliedCapital.mulWadDown(leverageFactor); \\n\\n\\t\\twhile(true){\\n\\t\\t\\tvars.mintedShares += vars.shares; \\n\\t\\t\\tconsole.log('___NEW___'); \\n\\t\\t\\tconsole.log('totalBorrowAmount', vars.borrowedAmount); \\n\\t\\t\\tconsole.log('borrowedAmount Left', vars.totalBorrowAmount); \\n\\t\\t\\t_mintWithLeverage( \\n\\t\\t\\t\\tvaultId, \\n\\t\\t\\t\\tvars.availableLiquidity, \\n\\t\\t\\t\\tvars.totalBorrowAmount, \\n\\t\\t\\t\\tvars.shares,\\n\\t\\t\\t\\tvars \\n\\t\\t\\t); \\n\\n\\t\\t\\tvars.borrowedAmount += vars.maxBorrowableAmount; \\n\\n\\t\\t\\tif(vars.totalBorrowAmount>= vars.maxBorrowableAmount)\\n\\t\\t\\t\\t(vars.totalBorrowAmount) -= vars.maxBorrowableAmount;\\n\\n\\t\\t\\telse vars.totalBorrowAmount = 0; \\n\\n\\t\\t\\tif(vars.totalBorrowAmount == 0 || vars.noMoreLiq) break; \\n\\t\\t}\\n\\t\\tvars.mintedShares += vars.shares; \\n\\n\\t\\t_mint(msg.sender,  (tokenId = _nextId++)); \\n\\n\\t\\tnewPosition = Position(\\n\\t\\t\\taddress(vars.vault),\\n\\t\\t\\tvars.mintedShares, \\n\\t\\t\\tsuppliedCapital, \\n\\t\\t\\tvars.borrowedAmount, \\n\\t\\t\\tblock.timestamp, \\n\\t\\t\\tvars.shares\\n\\t\\t);\\n\\n\\t\\tpositions[tokenId] = newPosition; \\n\\n\\n\\n\\t}\\n\\n\\tstruct RewindLocalVars{\\n\\t\\tuint256 assetReturned; \\n\\n\\t\\tuint256 withdrawAmount; \\n\\t\\tuint256 removed; \\n\\t\\tuint256 totalAssetReturned;\\n\\t\\tuint256 sharesRedeemed; \\n\\n\\t}\\n\\n\\t/// @notice Allows leverage minters to close their positions, and share profit with the leverageVault\\n\\t/// @dev step goes 1. repay to instrument,  \\n\\tfunction rewindPartialLeverage(\\n\\t\\tuint256 vaultId, \\n\\t\\tuint256 tokenId, \\n\\t\\tuint256 withdrawAmount) public{\\n\\t\\t//0. redeem \\n\\t\\t//1. repay to leverage pool\\n\\t\\t//2. get vault collateral back \\n\\t\\t//3. redeem\\n\\t\\t//4. repay to leverage pool \\n\\t\\tRewindLocalVars memory vars; \\n\\n\\t\\tPosition memory position = positions[tokenId]; \\n\\t\\trequire(position.totalShares >= withdrawAmount, \\\"larger than position\\\"); \\n\\n\\t\\tVault vault = controller.vaults(vaultId); \\n\\n\\t\\tERC20 underlying = ERC20(address(vault.UNDERLYING())); \\n\\t\\tPoolInstrument leveragePool = PoolInstrument(leveragePools[vaultId]); \\n\\t\\tunderlying.approve(address(leveragePool), vault.previewMint(withdrawAmount)); //TODO \\n\\n\\t\\tvars.withdrawAmount = withdrawAmount; \\n\\n\\t\\t// Begin with initial redeem \\n\\n\\n    \\t// vars.redeemedShares = position.endStateBalance; \\n\\n\\t\\twhile(vars.withdrawAmount!=0 ){\\n\\t\\t\\tvars.sharesRedeemed = min(position.endStateBalance, vars.withdrawAmount); \\n\\t\\t\\tvars.assetReturned = vault.redeem(\\n\\t\\t\\t\\tvars.sharesRedeemed, \\n\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\taddress(this)//70, 100=70, 80,30= 30\\n\\t\\t\\t\\t); \\n\\t\\t\\tleveragePool.repayWithAmount(vars.assetReturned, address(this)); //70->80\\n\\t\\t\\t// get 70 collateral in, 30 collateral in, \\n\\t\\t\\tvars.removed = leveragePool.removeAvailableCollateral(address(vault), 0, address(this)); \\n\\t\\t\\t// get 80 collateral out , 34 collateral out\\n       \\t\\tconsole.log('___NEW___'); \\n       \\t\\tconsole.log('withdraw left', vars.withdrawAmount); \\n        \\tconsole.log('redeemed shares',min(position.endStateBalance, vars.withdrawAmount) ); \\n        \\tconsole.log('redeemed/repayed', vars.assetReturned); \\n        \\tconsole.log('removed', vars.removed); \\n\\n        \\t// Revert if err\\n\\t\\t\\tvars.withdrawAmount -= vars.sharesRedeemed; \\n\\n        \\tvars.totalAssetReturned += vars.assetReturned; \\n\\n        \\tposition.endStateBalance = position.endStateBalance >= vars.withdrawAmount\\n        \\t\\t\\t\\t\\t\\t\\t\\t? position.endStateBalance - vars.withdrawAmount + vars.removed \\n        \\t\\t\\t\\t\\t\\t\\t\\t: vars.removed; \\n        \\tconsole.log('totalAssetReturned', vars.totalAssetReturned); \\t\\t\\t\\t\\t\\t\\t\\n        \\tconsole.log('endStateBalance', position.endStateBalance); \\n\\n\\t\\t}// how does this take care of losses? how does interest accrue? \\n\\t\\tposition.totalShares -= withdrawAmount; \\n\\n\\t\\tif(position.borrowedCapital >= vars.totalAssetReturned)\\n\\t\\t\\tposition.borrowedCapital -= vars.totalAssetReturned;\\n\\n\\t\\telse {\\n\\t\\t\\tposition.borrowedCapital = 0; \\n\\t\\t\\t// revert if withdraw amount was too large \\n\\t\\t\\tposition.suppliedCapital -= vars.totalAssetReturned - position.borrowedCapital; \\n\\t\\t}\\n\\n\\t\\tpositions[tokenId] = position; \\n\\n\\t}\\n\\n\\tfunction getTokenIds(address _owner) public view returns (uint[] memory) {\\n        uint[] memory _tokensOfOwner = new uint[](balanceOf(_owner));\\n        uint i;\\n\\n        for (i=0;i<balanceOf(_owner);i++){\\n            _tokensOfOwner[i] =tokenOfOwnerByIndex(_owner, i);\\n        }\\n        return (_tokensOfOwner);\\n    }\\n\\n    function getPositions(address _owner) public view returns(Position[] memory){\\n    \\tuint[] memory ids = getTokenIds(_owner); \\n    \\tPosition[] memory openpositions = new Position[](ids.length); \\n    \\tfor(uint i=0; i<ids.length; i++){\\n    \\t\\topenpositions[i] = positions[ids[i]]; \\n    \\t}\\n    \\treturn openpositions; \\n    }\\n\\n// 60 c repay-> 70 v remove -> 70 v redeem-> 70c repay-> 80v remove -> 80v redeem \\n// 70 + \\n\\t/// @notice when debt is 0, user can claim their endstate balance \\n\\tfunction deletePosition() public {\\n\\n\\t}\\n\\n\\n\\tfunction viewPNL () public {}\\n\\n\\n\\tfunction rewindFull()public{}\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\tfunction tokenURI(uint256 id) public view override returns (string memory){}\\n}\\n\\n\\n\",\"keccak256\":\"0xd0efd7901764626f45ae9cfae61099352759d58c2b799fbf371ba68aeb0d18cc\"},\"contracts/protocol/controller.sol\":{\"content\":\"pragma solidity ^0.8.16;\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\n// import {ReputationNFT} from \\\"./reputationtoken.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {Instrument} from \\\"../vaults/instrument.sol\\\";\\nimport {Strings} from \\\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {VaultFactory} from \\\"./factories.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n// import \\\"@interep/contracts/IInterep.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\n// import \\\"@interep/contracts/IInterep.sol\\\";\\nimport {SyntheticZCBPoolFactory, SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ReputationManager} from \\\"./reputationmanager.sol\\\";\\nimport {PoolInstrument} from \\\"../instruments/poolInstrument.sol\\\";\\nimport {LinearCurve} from \\\"../bonds/GBC.sol\\\"; \\n\\nimport {ValidatorManager} from \\\"./validatorManager.sol\\\";\\n\\ncontract Controller {\\n    using SafeMath for uint256;\\n    using FixedPointMathLib for uint256;\\n    using SafeTransferLib for ERC20;\\n\\n    struct MarketData {\\n        address instrument_address;\\n        address utilizer;\\n    }\\n\\n    struct ApprovalData {\\n        uint256 managers_stake;\\n        uint256 approved_principal;\\n        uint256 approved_yield;\\n    }\\n\\n    ValidatorManager validatorManager;\\n\\n\\n\\n    mapping(uint256 => ApprovalData) approvalDatas;\\n\\n    function getApprovalData(uint256 marketId)\\n        public\\n        view\\n        returns (ApprovalData memory)\\n    {\\n        approvalDatas[marketId];\\n    }\\n\\n    mapping(address => bool) public verified;\\n    mapping(uint256 => MarketData) public market_data; // id => recipient\\n    mapping(address => uint256) public ad_to_id; //utilizer address to marketId\\n    mapping(uint256 => Vault) public vaults; // vault id to Vault contract\\n    mapping(uint256 => uint256) public id_parent; //marketId-> vaultId\\n    mapping(uint256 => uint256[]) public vault_to_marketIds;\\n\\n    address creator_address;\\n\\n    // IInterep interep;\\n    // TrustedMarketFactoryV3 marketFactory;\\n    MarketManager marketManager;\\n    // ReputationNFT repNFT;\\n    VaultFactory vaultFactory;\\n    SyntheticZCBPoolFactory poolFactory;\\n    ReputationManager reputationManager;\\n\\n\\n    /* ========== MODIFIERS ========== */\\n    modifier onlyValidator(uint256 marketId) {\\n        require(\\n            isValidator(marketId, msg.sender) || msg.sender == creator_address,\\n            \\\"!Val\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(\\n            msg.sender == address(marketManager) ||\\n                msg.sender == creator_address,\\n            \\\"!manager\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _creator_address,\\n        address _interep_address //TODO\\n    ) {\\n        creator_address = _creator_address;\\n    }\\n\\n    /*----Setup Functions----*/\\n\\n    function setMarketManager(address _marketManager) public onlyManager {\\n        require(_marketManager != address(0));\\n        marketManager = MarketManager(_marketManager);\\n    }\\n\\n    function setReputationManager(address _reputationManager)\\n        public\\n        onlyManager\\n    {   require(address(marketManager)!= address(0), \\\"0mm\\\"); \\n        reputationManager = ReputationManager(_reputationManager);\\n        marketManager.setReputationManager(_reputationManager); \\n    }\\n\\n    function setVaultFactory(address _vaultFactory) public onlyManager {\\n        vaultFactory = VaultFactory(_vaultFactory);\\n    }\\n\\n    function setPoolFactory(address _poolFactory) public onlyManager {\\n        poolFactory = SyntheticZCBPoolFactory(_poolFactory);\\n    }\\n\\n    function setValidatorManager(address _validatorManager) public onlyManager {\\n        validatorManager = ValidatorManager(_validatorManager);\\n    }\\n\\n    // function verifyAddress(\\n    //     uint256 nullifier_hash,\\n    //     uint256 external_nullifier,\\n    //     uint256[8] calldata proof\\n    // ) external  {\\n    //     require(!verified[msg.sender], \\\"address already verified\\\");\\n    //     interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\\n    //     verified[msg.sender] = true;\\n    // }\\n\\n    function testVerifyAddress() external {\\n        verified[msg.sender] = true;\\n        reputationManager.setTraderScore(msg.sender, 1e18); \\n    }\\n\\n    /// @notice called only when redeeming, transfer funds from vault\\n    function redeem_transfer(\\n        uint256 amount,\\n        address to,\\n        uint256 marketId\\n    ) external onlyManager {\\n        vaults[id_parent[marketId]].trusted_transfer(amount, to);\\n    }\\n\\n    event VaultCreated(address indexed vault, uint256 vaultId, address underlying, bool onlyVerified, uint256 r, uint256 assetLimit, uint256 totalAssetLimit, MarketManager.MarketParameters defaultParams);\\n    /// @notice creates vault\\n    /// @param underlying: underlying asset for vault\\n    /// @param _onlyVerified: only verified users can mint shares\\n    /// @param _r: minimum reputation score to mint shares\\n    /// @param _asset_limit: max number of shares for a single address\\n    /// @param _total_asset_limit: max number of shares for entire vault\\n    /// @param default_params: default params for markets created by vault\\n    function createVault(\\n        address underlying,\\n        bool _onlyVerified,\\n        uint256 _r,\\n        uint256 _asset_limit,\\n        uint256 _total_asset_limit,\\n        MarketManager.MarketParameters memory default_params\\n    ) public {\\n        (Vault newVault, uint256 vaultId) = vaultFactory.newVault(\\n            underlying,\\n            address(this),\\n            _onlyVerified,\\n            _r,\\n            _asset_limit,\\n            _total_asset_limit,\\n            default_params\\n        );\\n\\n        vaults[vaultId] = newVault;\\n\\n        emit VaultCreated(address(newVault), vaultId, underlying, _onlyVerified, _r, _asset_limit, _total_asset_limit, default_params);\\n    }\\n\\n    function getInstrumentSnapShot(uint256 marketId) external returns (uint256 managerStake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) {\\n        MarketManager.CoreMarketData memory data = marketManager.getMarket(marketId); \\n        Controller.ApprovalData memory approvalData = getApprovalData(marketId); \\n        Vault.InstrumentData memory instrumentData = getVault(marketId).fetchInstrumentData(marketId);\\n        managerStake = approvalData.managers_stake;\\n        exposurePercentage = (approvalData.approved_principal- approvalData.managers_stake).divWadDown(getVault(marketId).totalAssets()+1);\\n        seniorAPR = instrumentData.poolData.promisedReturn; \\n        approvalPrice = instrumentData.poolData.inceptionPrice; \\n\\n        if(!instrumentData.isPool){\\n            uint256 amountDelta;\\n            uint256 resultPrice;\\n\\n            if(approvalData.managers_stake>0){\\n                ( amountDelta,  resultPrice) = LinearCurve.amountOutGivenIn(\\n                approvalData.managers_stake,\\n                0, \\n                data.bondPool.a_initial(), \\n                data.bondPool.b(), \\n                true \\n                );\\n            }\\n            \\n            uint256 seniorYield = instrumentData.faceValue -amountDelta\\n                - (instrumentData.principal - approvalData.managers_stake); \\n\\n            seniorAPR = approvalData.approved_principal>0\\n                ? seniorYield.divWadDown(1+instrumentData.principal - approvalData.managers_stake)\\n                : 0; \\n            approvalPrice = resultPrice; \\n        }\\n    }\\n\\n    event MarketInitiated(uint256 indexed marketId, address indexed vault, address indexed recipient, address pool, address longZCB, address shortZCB, Vault.InstrumentData instrumentData);\\n\\n    /// @notice initiates market, called by frontend loan proposal or instrument form submit button.\\n    /// @dev Instrument should already be deployed\\n    /// @param recipient: utilizer for the associated instrument\\n    /// @param instrumentData: instrument arguments\\n    /// @param vaultId: vault identifier\\n    function initiateMarket(\\n        address recipient,\\n        Vault.InstrumentData memory instrumentData,\\n        uint256 vaultId\\n    ) external {\\n        require(recipient != address(0), \\\"address0R\\\");\\n        require(instrumentData.instrument_address != address(0), \\\"address0I\\\");\\n        require(address(vaults[vaultId]) != address(0), \\\"address0V\\\");\\n\\n        Vault vault = vaults[vaultId];\\n        uint256 marketId = marketManager.marketCount();\\n        id_parent[marketId] = vaultId;\\n        vault_to_marketIds[vaultId].push(marketId);\\n        market_data[marketId] = MarketData(\\n            instrumentData.instrument_address,\\n            recipient\\n        );\\n        marketManager.setParameters(\\n            vault.get_vault_params(),\\n            vault.utilizationRate(),\\n            marketId\\n        ); //TODO non-default\\n\\n        // Create new pool and bonds and store initial price and liquidity for the pool\\n        (address longZCB, address shortZCB, SyntheticZCBPool pool) = poolFactory\\n            .newPool(\\n                address(vaults[vaultId].UNDERLYING()),\\n                address(marketManager)\\n            );\\n\\n        if (instrumentData.isPool) {\\n          require(instrumentData.poolData.initPrice<= 1e18 \\n            && instrumentData.poolData.initPrice< instrumentData.poolData.inceptionPrice, \\\"PRICE ERR\\\"); \\n          require(instrumentData.poolData.promisedReturn>0, \\\"RETURN ERR\\\"); \\n          instrumentData.poolData.inceptionTime = block.timestamp;\\n\\n          instrumentData.poolData.managementFee = pool\\n            .calculateInitCurveParamsPool(\\n                instrumentData.poolData.saleAmount,\\n                instrumentData.poolData.initPrice,\\n                instrumentData.poolData.inceptionPrice,\\n                marketManager.getParameters(marketId).sigma\\n            );\\n\\n          marketManager.newMarket(\\n            marketId,\\n            pool,\\n            longZCB,\\n            shortZCB,\\n            instrumentData.description,\\n            true\\n        );\\n\\n          // set validators\\n          validatorManager.validatorSetup(\\n            marketId,\\n            instrumentData.poolData.saleAmount,\\n            instrumentData.isPool\\n        );\\n        } else {\\n            MarketManager.MarketParameters memory params = marketManager.getParameters(marketId); \\n            pool.calculateInitCurveParams(\\n                instrumentData.principal,\\n                instrumentData.expectedYield,\\n                params.sigma, \\n                params.alpha, \\n                params.delta\\n            );\\n\\n            marketManager.newMarket(\\n                marketId,\\n                pool,\\n                longZCB,\\n                shortZCB,\\n                instrumentData.description,\\n                false\\n            );          \\n\\n            // set validators\\n            validatorManager.validatorSetup(\\n                marketId,\\n                instrumentData.principal,\\n                instrumentData.isPool\\n            );\\n        }\\n\\n        // add vault proposal\\n        instrumentData.marketId = marketId;\\n        vault.addProposal(instrumentData);\\n\\n        emit MarketInitiated(marketId, address(vaults[vaultId]), recipient, address(pool), longZCB, shortZCB, instrumentData);\\n\\n        ad_to_id[recipient] = marketId; //only for testing purposes, one utilizer should be able to create multiple markets\\n    }\\n\\n    /// @notice Resolve function 1\\n    /// @dev Prepare market/instrument for closing, called separately before resolveMarket\\n    /// this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest\\n    /// or, in the event of a default, by validators who deem the principal recouperation is finished\\n    /// and need to collect remaining funds by redeeming ZCB\\n    function beforeResolve(uint256 marketId) external //onlyValidator(marketId)\\n    {\\n        (bool duringMarketAssessment, , , bool alive, , ) = marketManager\\n            .restriction_data(marketId);\\n        require(!duringMarketAssessment && alive, \\\"market conditions not met\\\");\\n        require(\\n            resolveCondition(marketId),\\n            \\\"not enough validators have voted to resolve\\\"\\n        );\\n        vaults[id_parent[marketId]].beforeResolve(marketId);\\n    }\\n\\n    // function testBeforeResolve(uint256 marketId) external {\\n    //   (bool duringMarketAssessment, , , bool alive, , ) = marketManager\\n    //         .restriction_data(marketId);\\n    //     require(!duringMarketAssessment && alive, \\\"market conditions not met\\\");\\n    //     vaults[id_parent[marketId]].beforeResolve(marketId);\\n    // }\\n\\n    function testResolveMarket(uint256 marketId) external {\\n      vaults[id_parent[marketId]].beforeResolve(marketId);\\n      (\\n            bool atLoss,\\n            uint256 extra_gain,\\n            uint256 principal_loss,\\n            bool premature\\n        ) = vaults[id_parent[marketId]].resolveInstrument(marketId);\\n\\n        updateRedemptionPrice(\\n            marketId,\\n            atLoss,\\n            extra_gain,\\n            principal_loss,\\n            premature\\n        );\\n        validatorManager.updateValidatorStake(\\n            marketId,\\n            approvalDatas[marketId].approved_principal,\\n            principal_loss\\n        );\\n        cleanUpDust(marketId);\\n        emit MarketResolved(marketId, atLoss, extra_gain, principal_loss, premature);\\n    }\\n\\n    event MarketResolved(uint256 indexed marketId, bool atLoss, uint256 extraGain, uint256 principalLoss, bool premature);\\n\\n    /// Resolve function 2\\n    /// @notice main function called at maturity OR premature resolve of instrument(from early default)\\n    /// @dev validators call this function from market manager\\n    /// any funds left for the instrument, irrespective of whether it is in profit or inloss.\\n    function resolveMarket(uint256 marketId) external onlyValidator(marketId) {\\n        (\\n            bool atLoss,\\n            uint256 extra_gain,\\n            uint256 principal_loss,\\n            bool premature\\n        ) = vaults[id_parent[marketId]].resolveInstrument(marketId);\\n\\n        updateRedemptionPrice(\\n            marketId,\\n            atLoss,\\n            extra_gain,\\n            principal_loss,\\n            premature\\n        );\\n        validatorManager.updateValidatorStake(\\n            marketId,\\n            approvalDatas[marketId].approved_principal,\\n            principal_loss\\n        );\\n        cleanUpDust(marketId);\\n\\n        emit MarketResolved(marketId, atLoss, extra_gain, principal_loss, premature);\\n    }\\n\\n    /// @dev Redemption price, as calculated (only once) at maturity,\\n    /// depends on total_repayed/(principal + predetermined yield)\\n    /// If total_repayed = 0, redemption price is 0\\n    /// @param atLoss: defines circumstances where expected returns are higher than actual\\n    /// @param loss: facevalue - returned amount => non-negative always?\\n    /// @param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\\n    function updateRedemptionPrice(\\n        uint256 marketId,\\n        bool atLoss,\\n        uint256 extra_gain,\\n        uint256 loss,\\n        bool premature\\n    ) internal {\\n        if (atLoss) assert(extra_gain == 0);\\n\\n        uint256 total_supply = marketManager.getZCB(marketId).totalSupply();\\n        uint256 total_shorts = (extra_gain > 0)\\n            ? marketManager.getShortZCB(marketId).totalSupply()\\n            : 0;\\n        uint256 redemption_price;\\n        if (!atLoss)\\n            redemption_price =\\n                config.WAD +\\n                extra_gain.divWadDown(total_supply + total_shorts);\\n        else {\\n            if (config.WAD <= loss.divWadDown(total_supply)) {\\n                redemption_price = 0;\\n            } else {\\n                redemption_price = config.WAD - loss.divWadDown(total_supply);\\n            }\\n        }\\n\\n        marketManager.deactivateMarket(\\n            marketId,\\n            atLoss,\\n            !premature,\\n            redemption_price\\n        );\\n\\n        // TODO edgecase redemption price calculations\\n    }\\n\\n    // uint256 public constant riskTransferPenalty = 1e17;\\n\\n    // /// @notice deduce fees for non vault stakers, should go down as maturity time approach 0\\n    // function deduct_selling_fee(uint256 marketId)\\n    //     public\\n    //     view\\n    //     returns (uint256)\\n    // {\\n    //     // Linearly decreasing fee\\n    //     uint256 normalizedTime = ((getVault(marketId)\\n    //         .fetchInstrumentData(marketId)\\n    //         .maturityDate - block.timestamp) * config.WAD) /\\n    //         getVault(marketId).fetchInstrumentData(marketId).duration;\\n    //     return normalizedTime.mulWadDown(riskTransferPenalty);\\n    // }\\n\\n    /// @notice When market resolves, should collect remaining liquidity and/or dust from\\n    /// the pool and send them back to the vault\\n    /// @dev should be called before redeem_transfer is allowed\\n    function cleanUpDust(uint256 marketId) internal {\\n        marketManager.getPool(marketId).flush(\\n            getVaultAd(marketId),\\n            type(uint256).max\\n        );\\n    }\\n\\n    // /// @notice when market is resolved(maturity/early default), calculates score\\n    // /// and update each assessment phase trader's reputation, called by individual traders when redeeming\\n    // function updateReputation(\\n    //     uint256 marketId,\\n    //     address trader,\\n    //     bool increment\\n    // ) external onlyManager {\\n    //     uint256 implied_probs = marketManager.assessment_probs(\\n    //         marketId,\\n    //         trader\\n    //     );\\n    //     // int256 scoreToUpdate = increment ? int256(implied_probs.mulDivDown(implied_probs, config.WAD)) //experiment\\n    //     //                                  : -int256(implied_probs.mulDivDown(implied_probs, config.WAD));\\n    //     uint256 change = implied_probs.mulDivDown(implied_probs, config.WAD);\\n\\n    //     if (increment) {\\n    //         reputationManager.incrementScore(trader, change);\\n    //     } else {\\n    //         reputationManager.decrementScore(trader, change);\\n    //     }\\n    // }\\n\\n    /// @notice function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast\\n    /// or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc.\\n    /// After, the resolveMarket function should be called in a new block\\n    /// @dev withdraws all balance from the instrument.\\n    /// If assets in instrument is not in underlying, need all balances to be divested to underlying\\n    /// Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\\n    /// @param emergency ascribes cases where the instrument should be forcefully liquidated back to the vault\\n    function forceCloseInstrument(uint256 marketId, bool emergency)\\n        external\\n        returns (bool)\\n    {\\n        Vault vault = vaults[id_parent[marketId]];\\n\\n        // Prepare for close\\n        vault.closeInstrument(marketId);\\n\\n        // Harvests/records all profit & losses\\n        vault.beforeResolve(marketId);\\n        return true;\\n    }\\n\\n    /// @notice returns true if amount bought is greater than the insurance threshold\\n    function marketCondition(uint256 marketId) public view returns (bool) {\\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\\n\\n        // TODO add vault balances as well \\n        if (isPool) {\\n            return (marketManager.loggedCollaterals(marketId) >=\\n                getVault(marketId)\\n                    .fetchInstrumentData(marketId)\\n                    .poolData\\n                    .saleAmount);\\n            console.log('marketcondition', marketManager.loggedCollaterals(marketId), \\n               getVault(marketId)\\n                    .fetchInstrumentData(marketId)\\n                    .poolData\\n                    .saleAmount); \\n        } else {\\n            uint256 principal = getVault(marketId)\\n                .fetchInstrumentData(marketId)\\n                .principal;\\n                console.log('marketcondition', marketManager.loggedCollaterals(marketId), \\n                principal.mulWadDown(\\n                    marketManager.getParameters(marketId).alpha\\n                )); \\n            return (marketManager.loggedCollaterals(marketId) >=\\n                principal.mulWadDown(\\n                    marketManager.getParameters(marketId).alpha\\n                ));\\n        }\\n    }\\n\\n    /// GOD FUNCTION\\n    function testApproveMarket(uint256 marketId) external {\\n        require(msg.sender == creator_address, \\\"!owner\\\");\\n        require(marketCondition(marketId), \\\"market condition not met\\\");\\n        approveMarket(marketId);\\n    }\\n\\n    event MarketApproved(uint256 indexed marketId, ApprovalData data);\\n\\n    /// @notice called by the validator from validatorApprove when market conditions are met\\n    /// need to move the collateral in the wCollateral to\\n    function approveMarket(uint256 marketId) public {\\n        require(msg.sender == address(validatorManager) || msg.sender == creator_address, \\\"!validator\\\");\\n        Vault vault = vaults[id_parent[marketId]];\\n        SyntheticZCBPool pool = marketManager.getPool(marketId);\\n\\n\\n        require(\\n            marketManager.getCurrentMarketPhase(marketId) == 3,\\n            \\\"!marketCondition\\\"\\n        );\\n        require(\\n            vault.instrumentApprovalCondition(marketId),\\n            \\\"!instrumentCondition\\\"\\n        );\\n        marketManager.approveMarket(marketId);\\n\\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\\n        uint256 managerCollateral = marketManager.loggedCollaterals(marketId);\\n\\n\\n        pool.flush(address(this), managerCollateral); \\n        address instrument = address(vault.fetchInstrument(marketId)); \\n        vault.UNDERLYING().approve(instrument, managerCollateral); \\n\\n        if (isPool) {\\n            poolApproval(\\n                marketId,\\n                marketManager.getZCB(marketId).totalSupply(),\\n                vault.fetchInstrumentData(marketId).poolData\\n            );\\n          require(ERC4626(instrument).deposit(managerCollateral, address(vault))>0, \\\"DEPOSIT_FAILED\\\");\\n        } else {\\n            if (vault.getInstrumentType(marketId) == 0)\\n                creditApproval(marketId, pool);\\n            else generalApproval(marketId);\\n            vault.UNDERLYING().transfer(instrument, managerCollateral); \\n        }\\n\\n        approvalDatas[marketId].managers_stake = managerCollateral;\\n\\n        // TODO vault exchange rate should not change\\n        // pull from pool to vault, which will be used to fund the instrument\\n\\n        // Trust and deposit to the instrument contract\\n        vault.trustInstrument(marketId, approvalDatas[marketId], isPool);\\n\\n        // Since funds are transfered from pool to vault, set default liquidity in pool to 0\\n        pool.resetLiq();\\n        \\n        emit MarketApproved(marketId, approvalDatas[marketId]);\\n    }\\n\\n    function poolApproval(\\n        uint256 marketId,\\n        uint256 juniorSupply,\\n        Vault.PoolData memory data\\n    ) internal {\\n        require(data.leverageFactor > 0, \\\"0 LEV_FACTOR\\\");\\n        approvalDatas[marketId] = ApprovalData(\\n            0,\\n            juniorSupply\\n                .mulWadDown(config.WAD + data.leverageFactor)\\n                .mulWadDown(data.inceptionPrice),\\n            0\\n        );\\n\\n    }\\n\\n    /// @notice receives necessary market information. Only applicable for creditlines\\n    /// required for market approval such as max principal, quoted interest rate\\n    function creditApproval(uint256 marketId, SyntheticZCBPool pool) internal {\\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\\n            id_parent[marketId]\\n        ].viewPrincipalAndYield(marketId);\\n\\n        // get max_principal which is (s+1) * total long bought for creditline, or just be\\n        // proposed principal for other instruments\\n        uint256 max_principal = min(\\n            (marketManager.getParameters(marketId).s + config.WAD).mulWadDown(\\n                marketManager.loggedCollaterals(marketId)\\n            ),\\n            proposed_principal\\n        );\\n\\n        // Required notional yield amount denominated in underlying  given credit determined by managers\\n        uint256 quoted_interest = min(\\n            pool.areaBetweenCurveAndMax(max_principal),\\n            proposed_yield\\n        );\\n\\n        approvalDatas[marketId] = ApprovalData(\\n            0,\\n            max_principal,\\n            quoted_interest\\n        );\\n    }\\n\\n    function generalApproval(uint256 marketId) internal {\\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\\n            id_parent[marketId]\\n        ].viewPrincipalAndYield(marketId);\\n        approvalDatas[marketId] = ApprovalData(\\n            0,\\n            proposed_principal,\\n            proposed_yield\\n        );\\n    }\\n\\n    event MarketDenied(uint256 indexed marketId);\\n    /**\\n   @dev called by validator denial of market.\\n   */\\n    function denyMarket(uint256 marketId) external onlyValidator(marketId) {\\n        vaults[id_parent[marketId]].denyInstrument(marketId);\\n        cleanUpDust(marketId);\\n        marketManager.denyMarket(marketId);\\n        emit MarketDenied(marketId);\\n    }\\n\\n    /*----Validator Logic----*/\\n    // struct ValidatorData {\\n    //     mapping(address => uint256) sales; // amount of zcb bought per validator\\n    //     mapping(address => bool) staked; // true if address has staked vt (approved)\\n    //     mapping(address => bool) resolved; // true if address has voted to resolve the market\\n    //     address[] validators;\\n    //     uint256 val_cap; // total zcb validators can buy at a discount\\n    //     uint256 avg_price; //price the validators can buy zcb at a discount\\n    //     bool requested; // true if already requested random numbers from array.\\n    //     uint256 totalSales; // total amount of zcb bought;\\n    //     uint256 totalStaked; // total amount of vault token staked.\\n    //     uint256 numApproved;\\n    //     uint256 initialStake; // amount staked\\n    //     uint256 finalStake; // amount of stake recoverable post resolve\\n    //     uint256 numResolved; // number of validators calling resolve on early resolution.\\n    // }\\n\\n    // mapping(uint256 => uint256) requestToMarketId;\\n    // mapping(uint256 => ValidatorData) public validator_data;\\n\\n    /// @notice sets the validator cap + valdiator amount\\n    /// param prinicipal is saleAmount for pool based instruments\\n    /// @dev called by controller to setup the validator scheme\\n    // function _validatorSetup(\\n    //     uint256 marketId,\\n    //     uint256 principal,\\n    //     bool isPool\\n    // ) internal {\\n    //     require(principal != 0, \\\"0 principal\\\");\\n    //     _getValidators(marketId);\\n    //     _setValidatorCap(marketId, principal, isPool);\\n    //     _setValidatorStake(marketId, principal);\\n    // }\\n\\n    function getValidatorPrice(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getValidatorPrice(marketId);\\n        //return validator_data[marketId].avg_price;\\n    }\\n\\n    function getValidatorCap(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getValidatorCap(marketId);\\n        //return validator_data[marketId].val_cap;\\n    }\\n\\n    function viewValidators(uint256 marketId)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return validatorManager.viewValidators(marketId);\\n        //return validator_data[marketId].validators;\\n    }\\n\\n    function getNumApproved(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getNumApproved(marketId);\\n        //return validator_data[marketId].numApproved;\\n    }\\n\\n    function getNumResolved(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getNumResolved(marketId);\\n        //return validator_data[marketId].numResolved;\\n    }\\n\\n    function getTotalStaked(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getTotalStaked(marketId);\\n        //return validator_data[marketId].totalStaked;\\n    }\\n\\n    function getTotalValidatorSales(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return validatorManager.getTotalValidatorSales(marketId);\\n        //return validator_data[marketId].totalSales;\\n    }\\n\\n    function getInitialStake(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getInitialStake(marketId);\\n        //return validator_data[marketId].initialStake;\\n    }\\n\\n    function getFinalStake(uint256 marketId) public view returns (uint256) {\\n        return validatorManager.getFinalStake(marketId);\\n        //return validator_data[marketId].finalStake;\\n    }\\n\\n    /**\\n   @notice randomly choose validators for market approval, async operation => fulfillRandomness is the callback function.\\n   @dev for now called on market initialization\\n   */\\n    // function _getValidators(uint256 marketId) public {\\n    //     // retrieve traders that meet requirement.\\n    //     // address instrument = market_data[marketId].instrument_address;\\n    //     address utilizer = market_data[marketId].utilizer;\\n    //     (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\\n    //     address[] memory selected = reputationManager.filterTraders(\\n    //         r,\\n    //         utilizer\\n    //     );\\n\\n    //     // if there are not enough traders, set validators to all selected traders.\\n    //     if (selected.length <= N) {\\n    //         validator_data[marketId].validators = selected;\\n\\n    //         if (selected.length < N) {\\n    //             revert(\\\"not enough rated traders\\\");\\n    //         }\\n\\n    //         return;\\n    //     }\\n\\n    //     validator_data[marketId].requested = true;\\n\\n    //     uint256 _requestId = 1;\\n    //     // uint256 _requestId = COORDINATOR.requestRandomWords(\\n    //     //   keyHash,\\n    //     //   subscriptionId,\\n    //     //   requestConfirmations,\\n    //     //   callbackGasLimit,\\n    //     //   uint32(parameters[marketId].N)\\n    //     // );\\n\\n    //     requestToMarketId[_requestId] = marketId;\\n    // }\\n\\n    /**\\n   @notice chainlink callback function, sets validators.\\n   @dev TODO => can be called by anyone?\\n   */\\n    function fulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords //internal\\n    ) public //override\\n    {\\n        validatorManager.fulfillRandomWords(requestId, randomWords);\\n        // uint256 marketId = requestToMarketId[requestId];\\n        // (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\\n\\n        // assert(randomWords.length == N);\\n\\n        // // address instrument = market_data[marketId].instrument_address;\\n        // address utilizer = market_data[marketId].utilizer;\\n\\n        // address[] memory temp = reputationManager.filterTraders(r, utilizer);\\n        // uint256 length = temp.length;\\n\\n        // // get validators\\n        // for (uint8 i = 0; i < N; i++) {\\n        //     uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\\n        //     validator_data[marketId].validators.push(temp[j]);\\n        //     temp[j] = temp[length - 1];\\n        //     length--;\\n        // }\\n    }\\n\\n    // function _weightedRetrieve(\\n    //     address[] memory group,\\n    //     uint256 length,\\n    //     uint256 randomWord\\n    // ) internal view returns (uint256) {\\n    //     uint256 sum_weights;\\n\\n    //     for (uint8 i = 0; i < length; i++) {\\n    //         sum_weights += getTraderScore(group[i]); //repToken.getReputationScore(group[i]);\\n    //     }\\n\\n    //     uint256 tmp = randomWord % sum_weights;\\n\\n    //     for (uint8 i = 0; i < length; i++) {\\n    //         uint256 wt = getTraderScore(group[i]);\\n    //         if (tmp < wt) {\\n    //             return i;\\n    //         }\\n    //         unchecked {\\n    //             tmp -= wt;\\n    //         }\\n    //     }\\n    // }\\n\\n    /// @notice allows validators to buy at a discount + automatically stake a percentage of the principal\\n    /// They can only buy a fixed amount of ZCB, usually a at lot larger amount\\n    /// @dev get val_cap, the total amount of zcb for sale and each validators should buy\\n    /// val_cap/num validators zcb\\n    /// They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly\\n    /// correlated instruments triggers controller.approveMarket\\n    function validatorApprove(uint256 marketId) external returns (uint256) {\\n        \\n        (uint256 collateral_required, uint256 zcb_for_sale) = validatorManager.validatorApprove(marketId, msg.sender);\\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\\n        marketManager.validatorApprove(\\n            marketId,\\n            collateral_required,\\n            zcb_for_sale,\\n            msg.sender\\n        );\\n\\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\\n        if (approvalCondition(marketId)) {\\n            approveMarket(marketId);\\n            marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\\n        }\\n\\n        return collateral_required;\\n    }\\n\\n    /**\\n   @notice conditions for approval => validator zcb stake fulfilled + validators have all approved\\n   */\\n    function approvalCondition(uint256 marketId) public view returns (bool) {\\n        return validatorManager.approvalCondition(marketId);\\n        // return (validator_data[marketId].totalSales >=\\n        //     validator_data[marketId].val_cap &&\\n        //     validator_data[marketId].validators.length ==\\n        //     validator_data[marketId].numApproved);\\n    }\\n\\n    /**\\n   @notice returns true if user is validator for corresponding market\\n   */\\n    function isValidator(uint256 marketId, address user)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return validatorManager.isValidator(marketId, user);\\n    }\\n\\n    /**\\n   @notice condition for resolving market, met when all the validators chosen for the market\\n   have voted to resolve.\\n   */\\n    function resolveCondition(uint256 marketId) public view returns (bool) {\\n        return validatorManager.resolveCondition(marketId);\\n        // return (validator_data[marketId].numResolved ==\\n        //     validator_data[marketId].validators.length);\\n    }\\n\\n    /**\\n   @notice updates the validator stake, burned in proportion to loss.\\n   principal and principal loss are in the underlying asset of the vault => must be converted to vault shares.\\n   @dev called by resolveMarket\\n   */\\n    // function _updateValidatorStake(\\n    //     uint256 marketId,\\n    //     uint256 principal,\\n    //     uint256 principal_loss\\n    // ) internal {\\n    //     if (principal_loss == 0) {\\n    //         validator_data[marketId].finalStake = validator_data[marketId]\\n    //             .initialStake;\\n    //         return;\\n    //     }\\n\\n    //     ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n    //     uint256 p_shares = vault.convertToShares(principal);\\n    //     uint256 p_loss_shares = vault.convertToShares(principal_loss);\\n\\n    //     uint256 totalStaked = validator_data[marketId].totalStaked;\\n    //     uint256 newTotal = totalStaked /\\n    //         2 +\\n    //         (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(\\n    //             totalStaked / 2\\n    //         );\\n\\n    //     ERC4626(getVaultAd(marketId)).burn(totalStaked - newTotal);\\n    //     validator_data[marketId].totalStaked = newTotal;\\n\\n    //     validator_data[marketId].finalStake =\\n    //         newTotal /\\n    //         validator_data[marketId].validators.length;\\n    // }\\n\\n    /**\\n   @notice called by validators to approve resolving the market, after approval.\\n   */\\n    function validatorResolve(uint256 marketId) external {\\n        validatorManager.validatorResolve(marketId, msg.sender);\\n        // require(isValidator(marketId, msg.sender), \\\"!val\\\");\\n        // require(!validator_data[marketId].resolved[msg.sender], \\\"voted\\\");\\n\\n        // validator_data[marketId].resolved[msg.sender] = true;\\n        // validator_data[marketId].numResolved++;\\n    }\\n\\n    /**\\n   @notice called by validators when the market is resolved or denied to retrieve their stake.\\n   */\\n    function unlockValidatorStake(uint256 marketId) external {\\n        validatorManager.unlockValidatorStake(marketId, msg.sender);\\n        // require(isValidator(marketId, msg.sender), \\\"!validator\\\");\\n        // require(validator_data[marketId].staked[msg.sender], \\\"!stake\\\");\\n        // (bool duringMarketAssessment, , , , , ) = marketManager\\n        //     .restriction_data(marketId);\\n\\n        // // market early denial, no loss.\\n        // ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n        // if (duringMarketAssessment) {\\n        //     ERC20(getVaultAd(marketId)).safeTransfer(\\n        //         msg.sender,\\n        //         validator_data[marketId].initialStake\\n        //     );\\n        //     validator_data[marketId].totalStaked -= validator_data[marketId]\\n        //         .initialStake;\\n        // } else {\\n        //     // market resolved.\\n        //     ERC20(getVaultAd(marketId)).safeTransfer(\\n        //         msg.sender,\\n        //         validator_data[marketId].finalStake\\n        //     );\\n        //     validator_data[marketId].totalStaked -= validator_data[marketId]\\n        //         .finalStake;\\n        // }\\n\\n        // validator_data[marketId].staked[msg.sender] = false;\\n    }\\n\\n    /// @notice called when market initialized, calculates the average price and quantities of zcb\\n    /// validators will buy at a discount when approving\\n    /// valcap = sigma * princpal.\\n    // function _setValidatorCap(\\n    //     uint256 marketId,\\n    //     uint256 principal,\\n    //     bool isPool //??\\n    // ) internal {\\n    //     SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\\n    //     (, uint256 sigma, , , , , , ) = marketManager.parameters(marketId);\\n    //     require(config.isInWad(sigma) && config.isInWad(principal), \\\"paramERR\\\");\\n    //     ValidatorData storage valdata = validator_data[marketId];\\n\\n    //     uint256 valColCap = (sigma.mulWadDown(principal));\\n\\n    //     // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved\\n    //     uint256 discount_cap = bondingPool.discount_cap();\\n    //     uint256 avgPrice = valColCap.divWadDown(discount_cap);\\n\\n    //     valdata.val_cap = discount_cap;\\n    //     valdata.avg_price = avgPrice;\\n    // }\\n\\n    /**\\n   @notice sets the amount of vt staked by a single validator for a specific market\\n   @dev steak should be between 1-0 wad.\\n   */\\n    // function _setValidatorStake(uint256 marketId, uint256 principal) internal {\\n    //     //get vault\\n    //     ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n    //     uint256 shares = vault.convertToShares(principal);\\n    //     (, , , , , , , uint256 steak) = marketManager.parameters(marketId);\\n    //     validator_data[marketId].initialStake = steak.mulWadDown(shares);\\n    // }\\n\\n    function hasApproved(uint256 marketId, address validator)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return validatorManager.hasApproved(marketId, validator);\\n        // return validator_data[marketId].staked[validator];\\n    }\\n\\n    /**\\n   @notice called by marketManager.redeemDeniedMarket, redeems the discounted ZCB\\n   */\\n    function deniedValidator(uint256 marketId, address validator)\\n        external\\n        onlyManager\\n        returns (uint256 collateral_amount)\\n    {\\n        collateral_amount = validatorManager.deniedValidator(\\n            marketId,\\n            validator\\n        );\\n        //??? is this correct\\n        // collateral_amount = validator_data[marketId]\\n        //     .sales[validator]\\n        //     .mulWadDown(validator_data[marketId].avg_price);\\n        // delete validator_data[marketId].sales[validator];\\n    }\\n\\n    function redeemValidator(uint256 marketId, address validator)\\n        external\\n        onlyManager\\n    {\\n        validatorManager.redeemValidator(\\n            marketId,\\n            validator\\n        );\\n        //delete validator_data[marketId].sales[validator];\\n    }\\n\\n    function getValidatorRequiredCollateral(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return validatorManager.getValidatorRequiredCollateral(marketId);\\n        // uint256 val_cap = validator_data[marketId].val_cap;\\n        // (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\\n        // uint256 zcb_for_sale = val_cap / N;\\n        // return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\\n    }\\n\\n    function getTraderScore(address trader) public view returns (uint256) {\\n        return reputationManager.trader_scores(trader);\\n    }\\n\\n    function isReputable(address trader, uint256 r) public view returns (bool) {\\n      return reputationManager.isReputable(trader, r);\\n    }\\n\\n\\n    /// @notice pool instrument\\n    /// @notice called by utilizer during assessment\\n    // function addAcceptedCollateral(\\n    //     uint256 _marketId,\\n    //     address _tokenAddress,\\n    //     uint256 _tokenId,\\n    //     uint256 _maxAmount,\\n    //     uint256 _borrowAmount,\\n    //     bool _isERC20\\n    // ) external {\\n    //     require(\\n    //         msg.sender == address(market_data[_marketId].utilizer),\\n    //         \\\"only utilizer can call this function\\\"\\n    //     );\\n    //     require(marketManager.getCurrentMarketPhase(_marketId) == 1, \\\"is during assessment\\\");\\n        \\n    //     Vault.InstrumentData memory _data = getVault(_marketId).fetchInstrumentData(_marketId);\\n    //     require(_data.isPool, \\\"instrument is not pool\\\");\\n        \\n    //     PoolInstrument(address(getVault(_marketId).fetchInstrument(_marketId))).addAcceptedCollateral(\\n    //         _tokenAddress,\\n    //         _tokenId,\\n    //         _maxAmount,\\n    //         _borrowAmount,\\n    //         _isERC20\\n    //     );\\n\\n\\n    //     // Instrument instrument = fetchInstrument(_marketId);\\n    //     // instrument.addAcceptedCollateral(\\n    //     //     _tokenAddress,\\n    //     //     _tokenId,\\n    //     //     _maxAmount,\\n    //     //     _borrowAmount\\n    //     // );\\n    // }\\n\\n    function pullLeverage(uint256 marketId, uint256 amount)\\n        external\\n        onlyManager\\n    {\\n        getVault(marketId).trusted_transfer(amount, address(marketManager));\\n    }\\n\\n    function getTotalSupply(uint256 marketId) external view returns (uint256) {\\n        return marketManager.getZCB(marketId).totalSupply();\\n    }\\n\\n    function getMarketId(address recipient) public view returns (uint256) {\\n        return ad_to_id[recipient];\\n    }\\n\\n    function getVault(uint256 marketId) public view returns (Vault) {\\n        return vaults[id_parent[marketId]];\\n    }\\n\\n    function getVaultAd(uint256 marketId) public view returns (address) {\\n        return address(vaults[id_parent[marketId]]);\\n    }\\n\\n    function isVerified(address addr) public view returns (bool) {\\n        return verified[addr];\\n    }\\n\\n    function getVaultfromId(uint256 vaultId) public view returns (address) {\\n        return address(vaults[vaultId]);\\n    }\\n\\n    function marketId_to_vaultId(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return id_parent[marketId];\\n    }\\n\\n    function marketIdToVaultId(uint256 marketId) public view returns (uint256) {\\n        return id_parent[marketId];\\n    }\\n\\n    function getMarketIds(uint256 vaultId)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return vault_to_marketIds[vaultId];\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0xbc22d0bdd9a48e319a2ec3148244ea297c831b4f7138adc4123cc7cc0e6dc6b3\"},\"contracts/protocol/factories.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\n\\n\\n/// @notice Anyone can create a vault. These can be users who  \\n/// a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans)\\n/// b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers)\\n/// c) a vault for any long-tailed assets \\n/// d) managers who wants leverage for yield opportunities on a specific asset \\n/// e) uncollateralized lending platforms that wants to delegate the risk underwriting \\n/// etc\\n/// They need to specify \\n/// 1. Vault mint conditions-> such as verified LPs(managers) only, \\n/// 2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers)\\n/// 3. Vault underlying \\n/// @dev only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\\n\\ncontract VaultFactory{\\n\\n  address owner; \\n  mapping(address=>bool) private _isVault; \\n\\n  uint256 public numVaults; \\n  Controller controller; \\n\\n  constructor(address _controller){\\n    owner = msg.sender; \\n    controller = Controller(_controller);\\n  }\\n\\n  function isVault(address v) external view returns(bool){\\n    return _isVault[v]; \\n  }\\n\\n  modifier onlyController(){\\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"is not controller\\\"); \\n      _;\\n  }\\n\\n  /**\\n   @notice creates vault\\n   @param underlying: underlying asset for vault\\n   @param _controller: protocol controller\\n   @param _onlyVerified: only verified users can mint shares\\n   @param _r: minimum reputation score to mint shares\\n   @param _asset_limit: max number of shares for a single address\\n   @param _total_asset_limit: max number of shares for entire vault\\n   @param default_params: default params for markets created by vault\\n   */\\n  function newVault(\\n    address underlying, \\n    address _controller,\\n    bool _onlyVerified, \\n    uint256 _r, \\n    uint256 _asset_limit,\\n    uint256 _total_asset_limit,\\n    MarketManager.MarketParameters memory default_params\\n  ) external onlyController returns(Vault, uint256) {\\n    require(default_params.alpha >= 1e16, \\\"Alpha too small\\\"); \\n    \\n    Vault vault = new Vault(\\n      underlying,\\n       _controller, \\n       owner, \\n       //Params \\n       _onlyVerified,  _r, _asset_limit, _total_asset_limit,\\n       default_params\\n       ); \\n    _isVault[address(vault)] = true; \\n    numVaults++;\\n\\n    return (vault, numVaults); \\n    // vaultId is numVaults after new creation of the vault.\\n\\n  }\\n}\",\"keccak256\":\"0x4803cb04fbe52fb215c0a434ac6420dcb639e74cf4a2cb917fa9c17014e24855\"},\"contracts/protocol/marketmanager.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\nimport \\\"./reputationtoken.sol\\\"; \\nimport {Controller} from \\\"./controller.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {VRFConsumerBaseV2} from \\\"../chainlink/VRFConsumerBaseV2.sol\\\";\\nimport {VRFCoordinatorV2Interface} from \\\"../chainlink/VRFCoordinatorV2Interface.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\";\\nimport {SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\"; \\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\"; \\nimport {ReputationManager} from \\\"./reputationmanager.sol\\\"; \\n\\ncontract MarketManager \\n // VRFConsumerBaseV2 \\n {\\n  using FixedPointMathLib for uint256;\\n  using SafeTransferLib for ERC20;\\n\\n  // Chainlink state variables\\n  // VRFCoordinatorV2Interface COORDINATOR;\\n  // uint64 private immutable subscriptionId;\\n  // bytes32 private keyHash;\\n  // uint32 private callbackGasLimit = 100000;\\n  // uint16 private requestConfirmations = 3;\\n  // uint256 total_validator_bought; // should be a mapping no?\\n  bool private _mutex;\\n\\n  // ReputationNFT repToken;\\n  Controller controller;\\n  ReputationManager reputationManager; \\n  CoreMarketData[] public markets;\\n  address public owner; \\n\\n  // mapping(uint256 => uint256) requestToMarketId; // chainlink request id to marketId\\n  // mapping(uint256 => ValidatorData) validator_data;\\n  mapping(uint256=>uint256) public redemption_prices; //redemption price for each market, set when market resolves \\n  // mapping(uint256=>mapping(address=>uint256)) private assessment_prices; \\n  // mapping(uint256=>mapping(address=>bool)) private assessment_trader;\\n  // mapping(uint256=>mapping(address=>uint256) ) public assessment_probs; \\n  mapping(uint256=> MarketPhaseData) public restriction_data; // market ID => restriction data\\n  mapping(uint256=> MarketParameters) public parameters; //marketId-> params\\n  mapping(uint256=> mapping(address=>bool)) private redeemed; \\n  mapping(uint256=> mapping(address=>uint256)) public longTrades; \\n  mapping(uint256=> mapping(address=>uint256)) public shortTrades;\\n  mapping(uint256=> uint256) public loggedCollaterals;\\n\\n  struct CoreMarketData {\\n    SyntheticZCBPool bondPool; \\n    ERC20 longZCB;\\n    ERC20 shortZCB; \\n    string description; // instrument description\\n    uint256 creationTimestamp;\\n    uint256 resolutionTimestamp;\\n    bool isPool; \\n  }\\n\\n  struct MarketPhaseData {\\n    bool duringAssessment;\\n    bool onlyReputable;\\n    bool resolved;\\n    bool alive;\\n    bool atLoss;\\n    // uint256 min_rep_score;\\n    uint256 base_budget;\\n  }\\n\\n  /// @param N: upper bound on number of validators chosen.\\n  /// @param sigma: validators' stake\\n  /// @param alpha: minimum managers' stake\\n  /// @param omega: high reputation's stake \\n  /// @param delta: Upper and lower bound for price which is added/subtracted from alpha \\n  /// @param r: reputation percentile for reputation constraint phase\\n  /// @param s: senior coefficient; how much senior capital the managers can attract at approval \\n  /// @param steak: steak*approved_principal is the staking amount.\\n  /// param beta: how much volatility managers are absorbing \\n  /// param leverage: how much leverage managers can apply \\n  /// param base_budget: higher base_budget means lower decentralization, \\n  /// @dev omega always <= alpha\\n  struct MarketParameters{\\n      uint256 N;\\n      uint256 sigma; \\n      uint256 alpha; \\n      uint256 omega;\\n      uint256 delta; \\n      uint256 r;\\n      uint256 s;\\n      uint256 steak;\\n  }\\n\\n  modifier onlyController(){\\n    require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"!controller\\\"); \\n    _;\\n  }\\n\\n\\n  modifier _lock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  constructor(\\n    address _creator_address,\\n    address _controllerAddress,\\n    address _vrfCoordinator, // 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\\n    bytes32 _keyHash, // 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\\n    uint64 _subscriptionId // 1713, \\n  ) \\n    //VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) \\n  {\\n    controller = Controller(_controllerAddress);\\n    // keyHash = bytes32(0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f);\\n    // subscriptionId = 1713;\\n    // COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);\\n    \\n    // push empty market\\n    markets.push(\\n      makeEmptyMarketData()\\n    );\\n\\n    owner = msg.sender; \\n  }\\n//TODO setcontroller\\n  function makeEmptyMarketData() public pure returns (CoreMarketData memory) {\\n    return CoreMarketData(\\n        SyntheticZCBPool(address(0)),\\n        ERC20(address(0)),\\n        ERC20(address(0)),\\n        \\\"\\\",\\n        0,\\n        0, \\n        false\\n      );\\n  }    \\n\\n  function marketCount() public view returns (uint256) {\\n    return markets.length;\\n  }\\n\\n  function getMarket(uint256 _id) public view returns (CoreMarketData memory) {\\n    if (_id >= markets.length) {\\n        return makeEmptyMarketData();\\n    } else {\\n        return markets[_id];\\n    }\\n  }\\n\\n  /// @notice parameters have to be set prior \\n  // event MarketCreated(uint256 indexed marketId, address bondPool, address longZCB, address shortZCB, string description, bool isPool);\\n\\n  function newMarket(\\n    uint256 marketId,\\n    SyntheticZCBPool bondPool,  \\n    address _longZCB, \\n    address _shortZCB, \\n    string calldata _description, \\n    // uint256 _duration, \\n    bool isPool\\n    ) external onlyController {\\n    uint256 creationTimestamp = block.timestamp;\\n    \\n    //emit MarketCreated(marketId, address(bondPool), _longZCB, _shortZCB, _description, isPool);\\n\\n    markets.push(CoreMarketData(\\n      bondPool, \\n      ERC20(_longZCB),\\n      ERC20(_shortZCB),  \\n      _description,\\n      creationTimestamp,\\n      0, //TODO resolution timestamp, \\n      isPool \\n    ));\\n\\n    uint256 base_budget = 1000 * config.WAD; //TODO \\n    setMarketPhase(marketId, true, true, base_budget);\\n\\n   // _validatorSetup(marketId, principal, creationTimestamp, _duration, isPool);\\n  }\\n\\n\\n  /*----Phase Functions----*/\\n\\n  event MarketParametersSet(uint256 indexed marketId, MarketParameters params);\\n  /// @notice list of parameters in this system for each market, should vary for each instrument \\n  /// @dev calculates market driven s from utilization rate. If u-r high,  then s should be low, as 1) it disincentivizes \\n  /// managers to approving as more proportion of the profit goes to the LP, and 2) disincentivizes the borrower \\n  /// to borrow as it lowers approved principal and increases interest rate \\n  function setParameters(\\n    MarketParameters memory param,\\n    uint256 utilizationRate,\\n    uint256 marketId \\n    ) public onlyController{\\n\\n    require(param.N <= reputationManager.getTraders().length, \\\"not enough rated traders\\\");\\n    parameters[marketId] = param; \\n    parameters[marketId].s = param.s.mulWadDown(config.WAD - utilizationRate); // experiment\\n    emit MarketParametersSet(marketId, param);\\n  }\\n\\n  function setReputationManager(address _reputationManager) external onlyController{\\n      reputationManager = ReputationManager(_reputationManager);\\n  }\\n\\n  /**\\n   @dev in the event that the number of traders in X percentile is less than the specified number of validators\\n   parameter N is changed to reflect this\\n   */\\n  // function setN(uint256 marketId, uint256 _N) external onlyController {\\n  //   parameters[marketId].N = _N;\\n  // }\\n\\nevent MarketPhaseSet(uint256 indexed marketId, MarketPhaseData data);\\n\\n  /// @notice sets market phase data\\n  /// @dev called on market initialization by controller\\n  /// @param base_budget: base budget (amount of vault tokens to spend) as a market manager during the assessment stage\\n  function setMarketPhase(\\n    uint256 marketId, \\n    bool duringAssessment,\\n    bool _onlyReputable,\\n    uint256 base_budget\\n    ) internal {\\n    MarketPhaseData storage data = restriction_data[marketId]; \\n    data.onlyReputable = _onlyReputable; \\n    data.duringAssessment = duringAssessment;\\n    // data.min_rep_score = calcMinRepScore(marketId);\\n    data.base_budget = base_budget;\\n    data.alive = true;\\n    emit MarketPhaseSet(marketId, restriction_data[marketId]);\\n  }\\n\\n  event MarketReputationSet(uint256 indexed marketId, bool onlyReputable);\\n\\n  /// @notice used to transition from reputationphases \\n  // function setReputationPhase(\\n  //   uint256 marketId,\\n  //   bool _onlyReputable\\n  // ) public onlyController {\\n  //   restriction_data[marketId].onlyReputable = _onlyReputable;\\n  //   emit MarketReputationSet(marketId, _onlyReputable);\\n  // }\\n\\n\\nevent DeactivatedMarket(uint256 indexed marketId, bool atLoss, bool resolve, uint256 rp);\\n  /// @notice Called when market resolves \\n  /// @param resolve is true when instrument does not resolve prematurely\\n  function deactivateMarket(\\n    uint256 marketId, \\n    bool atLoss, \\n    bool resolve, \\n    uint256 rp) public onlyController{\\n    restriction_data[marketId].resolved = resolve; \\n    restriction_data[marketId].atLoss = atLoss; \\n    restriction_data[marketId].alive = false;\\n    redemption_prices[marketId] = rp; \\n    emit DeactivatedMarket(marketId, atLoss, resolve, rp);\\n  } \\n\\nevent MarketDenied(uint256 indexed marketId); \\n\\n  /// @notice called by validator only\\n  function denyMarket(\\n    uint256 marketId\\n  ) external onlyController {\\n    //TODO should validators be able to deny even though they've approved.\\n    require(restriction_data[marketId].duringAssessment, \\\"!assessment\\\");\\n    MarketPhaseData storage data = restriction_data[marketId]; \\n    data.alive = false;\\n    data.resolved = true;\\n    emit MarketDenied(marketId);\\n  }\\n\\n  event MarketApproved(uint256 indexed marketId);\\n  /// @notice main approval function called by controller\\n  /// @dev if market is alive and market is not during assessment, it is approved. \\n  function approveMarket(uint256 marketId) onlyController external {\\n    restriction_data[marketId].duringAssessment = false;    \\n    emit MarketApproved(marketId);\\n  }\\n\\n  function getPhaseData(\\n    uint256 marketId\\n  ) public view returns (MarketPhaseData memory)  {\\n    return restriction_data[marketId];\\n  }\\n\\n  \\n\\n  function isMarketApproved(uint256 marketId) public view returns(bool){\\n    return(!restriction_data[marketId].duringAssessment && restriction_data[marketId].alive);  \\n  }\\n\\n\\n\\n  /// @notice returns whether current market is in phase \\n  /// 1: onlyReputable, which also means market is in assessment\\n  /// 2: not onlyReputable but in asseessment \\n  /// 3: in assessment but canbeapproved \\n  /// 4: post assessment(accepted or denied), amortized liquidity \\n  function getCurrentMarketPhase(uint256 marketId) public view returns(uint256){\\n    if (restriction_data[marketId].onlyReputable){\\n      // assert(!controller.marketCondition(marketId) && !isMarketApproved(marketId) && restriction_data[marketId].duringAssessment ); \\n      return 1; \\n    }\\n\\n    else if (restriction_data[marketId].duringAssessment && !restriction_data[marketId].onlyReputable){\\n      // assert(!isMarketApproved(marketId)); \\n      if (controller.marketCondition(marketId)) return 3; \\n      return 2; \\n    }\\n\\n    else if (isMarketApproved( marketId)){\\n      // assert (!restriction_data[marketId].duringAssessment && controller.marketCondition(marketId)); \\n      return 4; \\n    }\\n  }\\n\\n  /// @notice get trade budget = f(reputation), returns in collateral_dec\\n  /// sqrt for now\\n  function getTraderBudget(uint256 marketId, address trader) public view returns(uint256){\\n    uint256 repscore = reputationManager.trader_scores(trader);\\n    if (repscore==0) return 0;\\n    return restriction_data[marketId].base_budget + (repscore*config.WAD).sqrt();\\n  }\\n\\n  function getParameters(uint256 marketId) public view returns(MarketParameters memory){\\n    return parameters[marketId]; \\n  }\\n\\n  function getPool(uint256 marketId) public view returns(SyntheticZCBPool){\\n    return markets[marketId].bondPool; \\n  }\\n\\n  function getZCB(uint256 marketId) public view returns (ERC20) {\\n    return markets[marketId].longZCB;\\n  }\\n\\n  function getShortZCB(uint256 marketId) public view returns (ERC20) {\\n    return markets[marketId].shortZCB;\\n  }\\n  \\n\\n  /// @notice whether new longZCB can be issued \\n  function _canIssue(\\n    address trader,\\n    int256 amount,\\n    uint256 marketId\\n    ) internal view {\\n    //TODO per market queue \\n    //if(queuedRepUpdates[trader] > queuedRepThreshold)\\n    //  revert(\\\"rep queue\\\"); \\n\\n    // if (!controller.isVerified(trader)) \\n    //   revert(\\\"!verified\\\");\\n\\n    if (getTraderBudget(marketId, trader) <= uint256(amount))\\n      revert(\\\"budget\\\");\\n\\n    if (controller.getTraderScore(trader) == 0)\\n      revert(\\\"!rep\\\"); \\n  }\\n\\n  /// @notice performs checks for buy function\\n  /// @param amount: collateral used to buy ZCB.\\n  function _canBuy(\\n    address trader,\\n    int256 amount,\\n    uint256 marketId\\n  ) internal view {\\n    //If after assessment there is a set buy threshold, people can't buy above this threshold\\n    require(restriction_data[marketId].alive, \\\"!Active\\\");\\n    // TODO: upper bound \\n    // TODO: check if this is correct\\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \\\"market maturity reached\\\");\\n    // TODO: check if enough liquidity \\n    bool _duringMarketAssessment = restriction_data[marketId].duringAssessment;\\n    bool _onlyReputable =  restriction_data[marketId].onlyReputable;\\n\\n    if(amount>0){\\n      if (_duringMarketAssessment){\\n        _canIssue(trader, amount, marketId); \\n      }\\n    }\\n\\n    //During the early risk assessment phase only reputable can buy \\n    if (_onlyReputable){\\n      if (!controller.isReputable(trader, parameters[marketId].r)){\\n        revert(\\\"insufficient rep\\\");\\n      }\\n    }\\n  }\\n\\n  /// @notice amount is in zcb_amount_in TODO \\n  function _canSell(\\n    address trader,\\n    uint256 amount, \\n    uint256 marketId\\n  ) internal view returns(bool) {\\n    require(restriction_data[marketId].alive, \\\"!Active\\\");\\n\\n    //TODO: check if this is correct\\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \\\"market maturity reached\\\");\\n\\n    // if(restriction_data[marketId].duringAssessment) {\\n    //   // restrict attacking via disapproving the utilizer by just shorting a bunch\\n    //  // if(amount>= hedgeAmount) return false; \\n\\n    //   //else return true;\\n    // }\\n    // else{\\n    //   // restrict naked CDS amount\\n      \\n    //   // \\n    // } \\n\\n    return true; \\n  }\\n\\n  // VALIDATOR FUNCTIONS\\n\\n  /**\\n   @notice called when the validator votes to approve the market => stakes vt + recieves discounted ZCB\\n   the staked amount goes to the controller while the discounted ZCB goes to the market manager.\\n   */\\n  function validatorApprove(\\n    uint256 marketId, \\n    uint256 collateral_required,\\n    uint256 zcb_for_sale,\\n    address validator\\n  ) external onlyController {\\n    loggedCollaterals[marketId] += collateral_required;\\n    SyntheticZCBPool bondPool = getPool(marketId); \\n    bondPool.BaseToken().transferFrom(validator, address(bondPool), collateral_required); \\n    bondPool.trustedDiscountedMint(validator, zcb_for_sale);\\n  }\\n\\n\\n  event MarketCollateralUpdate(uint256 marketId, uint256 totalCollateral);\\n  event TraderCollateralUpdate(uint256 marketId, address manager, uint256 totalCollateral, bool isLong);\\n  /// @notice log how much collateral trader has at stake, \\n  /// to be used for redeeming, restricting trades\\n  function _logTrades(\\n    uint256 marketId,\\n    address trader, \\n    uint256 collateral,\\n    uint256 shortCollateral,  \\n    bool isBuy, \\n    bool isLong\\n    ) internal {\\n\\n    if (isLong){\\n      // TODO queuerep needs to be per market \\n      // If buying bond during assessment, trader is manager, so should update \\n      if (isBuy) {\\n        longTrades[marketId][trader] += collateral; \\n        loggedCollaterals[marketId] += collateral; \\n        queuedRepUpdates[trader] += 1; \\n        } else {\\n        longTrades[marketId][trader] -= collateral;\\n        loggedCollaterals[marketId] -= collateral; \\n        }\\n        emit TraderCollateralUpdate(marketId, trader, longTrades[marketId][trader], true);\\n      } else {\\n      if (isBuy) {\\n        // shortCollateral is amount trader pays to buy shortZCB\\n        shortTrades[marketId][trader] += shortCollateral;\\n\\n        // collateral is the area under the curve that is subtracted due to the (short)selling\\n        loggedCollaterals[marketId] -= collateral; \\n        } else {\\n        // revert if underflow, which means trader sold short at a profit, which is not allowed during assessment \\n        shortTrades[marketId][trader] -= shortCollateral; \\n        loggedCollaterals[marketId] += collateral;\\n      } \\n      emit TraderCollateralUpdate(marketId, trader, shortTrades[marketId][trader], false);\\n    }\\n    emit MarketCollateralUpdate(marketId, loggedCollaterals[marketId]);\\n  }\\n\\n  /// @notice general limitorder claim + liquidity provision funnels used post-assessment, \\n  /// which will be recorded if necessary \\n  /// param type: 1 if open long, 2 if close long, 3 if open short, 4 if close short\\n  /// type 5: partially claim , TODO do all possible trading functions \\n  function claimFunnel(\\n    uint256 marketId, \\n    uint16 point, \\n    uint256 funnel\\n    ) external returns(uint256 claimedAmount){\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    // if (funnel == 1) claimedAmount = bondPool.makerClaimOpen(point,true, msg.sender); \\n    // else if (funnel == 2) claimedAmount = bondPool.makerClaimClose(point,true, msg.sender);\\n    // else if (funnel == 3) claimedAmount = bondPool.makerClaimOpen(point,false, msg.sender); \\n    // else if (funnel == 4) claimedAmount = bondPool.makerClaimClose(point,false, msg.sender); \\n  }\\n\\n  /// @notice called by pool when buying, transfers funds from trader to pool \\n  function tradeCallBack(uint256 amount, bytes calldata data) external{\\n    SyntheticZCBPool(msg.sender).BaseToken().transferFrom(abi.decode(data, (address)), msg.sender, amount); \\n  }\\n\\n\\n\\n  /// @notice after assessment, let managers buy newly issued longZCB if the instrument is pool based \\n  /// funds + funds * levFactor will be directed to the instrument \\n  function issuePoolBond(\\n    uint256 _marketId, \\n    uint256 _amountIn\\n    ) external _lock_ returns(uint256 issueQTY){\\n    require(!restriction_data[_marketId].duringAssessment, \\\"Pre Approval\\\"); \\n    // TODO doesn't work for first approved, and 1 \\n    _canIssue(msg.sender, int256(_amountIn), _marketId);  \\n    Vault vault = controller.getVault(_marketId); \\n    ERC20 underlying = ERC20(address(markets[_marketId].bondPool.BaseToken())); \\n    address instrument = address(vault.Instruments(_marketId)); \\n\\n    // Get price and sell longZCB with this price\\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(_marketId);\\n\\n    underlying.transferFrom(msg.sender, address(this), _amountIn);\\n    underlying.approve(instrument, _amountIn); \\n    ERC4626(instrument).deposit(_amountIn, address(vault)); \\n\\n    issueQTY = _amountIn.divWadUp(pju); //TODO rounding errs\\n    markets[_marketId].bondPool.trustedDiscountedMint(msg.sender, issueQTY); \\n\\n    // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu  \\n    vault.depositIntoInstrument(_marketId, issueQTY.mulWadDown(config.WAD + levFactor).mulWadDown(psu), true); \\n    //TODO Need totalAssets and exchange rate to remain same assertion \\n    //TODO vault always has to have more shares, all shares minted goes to vault \\n    reputationManager.recordPull(msg.sender, _marketId, issueQTY,\\n       _amountIn, getTraderBudget( _marketId, msg.sender), true); \\n      \\n  }\\n\\n  /// @notice when a manager redeems a poollongzcb, redeemAmount*levFactor are automatically \\n  /// withdrawn from the instrument\\n  function redeemPoolLongZCB(\\n    uint256 marketId, \\n    uint256 redeemAmount\\n    ) external _lock_ returns(uint256 collateral_redeem_amount, uint256 seniorAmount){\\n    // TODO conditions/restrictions-> need some time to pass to call this + need some liquidity in pool \\n    Vault vault = controller.getVault(marketId); \\n    CoreMarketData memory market = markets[marketId]; \\n\\n    require(market.isPool, \\\"!pool\\\"); \\n\\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(marketId);\\n    collateral_redeem_amount = pju.mulWadDown(redeemAmount); \\n    seniorAmount = redeemAmount.mulWadDown(levFactor).mulWadDown(psu); \\n\\n    // Need to check if redeemAmount*levFactor can be withdrawn from the pool and do so\\n    vault.withdrawFromPoolInstrument(marketId, collateral_redeem_amount, msg.sender, seniorAmount); \\n\\n    // Update reputation \\n    reputationManager.recordPush(msg.sender, marketId, pju, false, redeemAmount); \\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }\\n    market.bondPool.trustedBurn(msg.sender, redeemAmount, true); \\n\\n    // TODO assert pju stays same \\n    // TODO assert need totalAssets and exchange rate to remain same \\n  }\\n\\n  mapping(address => uint8) public queuedRepUpdates; \\n  uint8 public constant queuedRepThreshold = 3; // at most 3 simultaneous assessment per manager\\n\\n  event BondBuy(uint256 indexed marketId, address indexed trader, uint256 amountIn, uint256 amountOut);\\n  /// @notice main entry point for longZCB buys \\n  /// @param _amountIn is negative if specified in zcb quantity\\n  function buyBond(\\n    uint256 _marketId, \\n    int256 _amountIn, \\n    uint256 _priceLimit, \\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    _canBuy(msg.sender, _amountIn, _marketId);\\n    //TODO return readable error on why it reverts\\n    CoreMarketData memory marketData = markets[_marketId]; \\n    SyntheticZCBPool bondPool = marketData.bondPool; \\n    \\n\\n    // During assessment, real bonds are issued from utilizer, they are the sole LP \\n    if (restriction_data[_marketId].duringAssessment){\\n      // TODO fix pricelimit  \\n\\n      (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender)); \\n\\n      // uint256 upperBound = bondPool.upperBound(); \\n      if( bondPool.upperBound() !=0 &&  bondPool.upperBound() < bondPool.getCurPrice()) revert(\\\"bound\\\"); \\n\\n      //Need to log assessment trades for updating reputation scores or returning collateral when market denied \\n      _logTrades(_marketId, msg.sender, amountIn, 0, true, true);\\n\\n      // Get implied probability estimates by summing up all this manager bought for this market \\n      reputationManager.recordPull(msg.sender, _marketId, amountOut,\\n        amountIn, getTraderBudget(_marketId, msg.sender), marketData.isPool); \\n\\n      // assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\\n      //     getZCB(_marketId).balanceOf(msg.sender) + leveragePosition[_marketId][msg.sender].amount, \\n      //     longTrades[_marketId][msg.sender], \\n      //     getTraderBudget(_marketId, msg.sender) \\n      // ); \\n\\n      // Phase Transitions when conditions met\\n      if(restriction_data[_marketId].onlyReputable){\\n        uint256 total_bought = loggedCollaterals[_marketId];\\n\\n        if (total_bought >= parameters[_marketId].omega.mulWadDown(\\n              controller\\n              .getVault(_marketId)\\n              .fetchInstrumentData(_marketId)\\n              .principal)\\n        ) {\\n          restriction_data[_marketId].onlyReputable = false;\\n          emit MarketPhaseSet(_marketId, restriction_data[_marketId]);\\n        }\\n      }\\n    }\\n\\n    // Synthetic bonds are issued (liquidity provision are amortized as counterparties)\\n    else{\\n      (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender));\\n\\n      // TODO check if valid slippage \\n      // TODO check liquidity, revert if not\\n      // TODO reputation while trading post assessment? \\n      // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      // if(isTaker)\\n\\n      //   (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender));\\n      // else{\\n      //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), true, msg.sender); \\n      // }\\n    }\\n\\n    if(_amountIn> 0)require(uint256(_amountIn) == amountIn, \\\" !liq\\\") ; \\n    else require(uint256(-_amountIn)==amountOut, \\\"!liq\\\"); \\n\\n    emit BondBuy(_marketId, msg.sender, amountIn, amountOut); // get current price as well.\\n  }\\n\\n  \\n  /// @notice longZCB sells  \\n  /// @param _amountIn quantity in longZCB \\n  function sellBond(\\n      uint256 _marketId,\\n      uint256 _amountIn, \\n      uint256 _priceLimit, \\n      bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    // if (duringMarketAssessment(_marketId)) revert(\\\"can't close during assessment\\\"); \\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    require(_canSell(msg.sender, _amountIn, _marketId),\\\"Restricted\\\");\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      (amountIn, amountOut) = bondPool.takerClose(\\n                                    true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountIn, 0, false, true );                                          \\n\\n    }\\n    else{\\n      // controller.deduct_selling_fee( _marketId ); //TODO, if validator or manager, deduct reputation \\n\\n      // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      // if(isTaker) \\n      (amountIn, amountOut) = bondPool.takerClose(\\n              true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      // else {\\n      //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, uint256(_amountIn), true, msg.sender);        \\n      // }\\n    }\\n\\n    reputationManager.recordPush(msg.sender, _marketId, bondPool.getCurPrice(), true, amountIn); \\n\\n  } \\n\\n  /// @param _amountIn: amount of short trader is willing to buy\\n  /// @param _priceLimit: slippage tolerance on trade\\n  function shortBond(\\n    uint256 _marketId,\\n    uint256 _amountIn, \\n    uint256 _priceLimit,\\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    require(_canSell(msg.sender, _amountIn, _marketId),\\\"Restricted\\\");\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      // amountOut is base collateral down the curve, amountIn is collateral used to buy shortZCB \\n      (amountOut, amountIn) = bondPool.takerOpen(false, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false);\\n\\n    }\\n    else{\\n      //deduct_selling_fee(); //if naked CDS( staked vault)\\n\\n      // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      // if (isTaker)\\n        (amountOut, amountIn) = bondPool.takerOpen(false, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      \\n      // else{\\n      //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), false, msg.sender);\\n      // }\\n    }\\n  }\\n\\n  /// @param _amountIn is amount of short trader is willing to cover \\n  function coverBondShort(\\n    uint256 _marketId, \\n    uint256 _amountIn, \\n    uint256 _priceLimit,\\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      // amountOut is collateral up the curve, amountIn is collateral returned from closing  \\n      (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false); \\n     // deduct_selling_fee(); \\n    }\\n    else{\\n      // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      // if (isTaker)\\n        (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      \\n      // else{\\n      //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, _amountIn, false, msg.sender);\\n      // }\\n    }\\n  }\\n\\n  event RedeemDenied(uint256 marketId, address trader, bool isLong);\\n\\n  /// @notice called by traders when market is denied before approval TODO\\n  /// ??? if the market is denied, this function is called and everything is redeemed \\n  /// validator will need to call this on denial + isLong = true to redeem their collateral.\\n  function redeemDeniedMarket(\\n    uint256 marketId, \\n    bool isLong\\n  ) external _lock_ {\\n    require(!restriction_data[marketId].alive, \\\"Market Still During Assessment\\\"); // TODO\\n    require(restriction_data[marketId].duringAssessment, \\\"Market has been approved\\\");\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    uint256 collateral_amount;\\n    uint256 balance; \\n    // Get collateral at stake in shorts, which will be directly given back to traders\\n    if(!isLong){\\n      balance = markets[marketId].shortZCB.balanceOf(msg.sender); \\n      require(balance >= 0, \\\"Empty\\\");\\n\\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n      collateral_amount = shortTrades[marketId][msg.sender]; \\n      delete shortTrades[marketId][msg.sender]; \\n      emit RedeemDenied(marketId, msg.sender, false);\\n\\n      //Burn all their balance\\n      bondPool.trustedBurn(msg.sender, balance, false);\\n    } \\n\\n    // Get collateral at stake in longs, which will be directly given back to traders\\n    else {\\n      balance = markets[marketId].longZCB.balanceOf(msg.sender); \\n      require(balance >= 0, \\\"Empty\\\");\\n\\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n      if (controller.isValidator(marketId, msg.sender) && controller.hasApproved(marketId, msg.sender)) {\\n        collateral_amount = controller.deniedValidator(marketId, msg.sender);\\n      }\\n      else{\\n        collateral_amount = longTrades[marketId][msg.sender]; \\n        delete longTrades[marketId][msg.sender]; \\n        emit RedeemDenied(marketId, msg.sender, true);\\n      }\\n\\n      // Burn all their balance \\n      bondPool.trustedBurn(msg.sender, balance, true); \\n      \\n      // This means that the sender is a manager\\n      if (queuedRepUpdates[msg.sender] > 0){\\n        unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n      }    \\n    }\\n\\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\\n    controller.redeem_transfer(collateral_amount, msg.sender, marketId);\\n    //TODO need to check if last redeemer, so can kill market.\\n  }\\n\\n  /// @notice trader will redeem entire balance of ZCB\\n  /// Needs to be called at maturity, market needs to be resolved first(from controller)\\n  function redeem(\\n    uint256 marketId\\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\\n    require(!restriction_data[marketId].alive, \\\"!Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender);\\n\\n    uint256 zcb_redeem_amount = markets[marketId].longZCB.balanceOf(msg.sender); \\n    uint256 redemption_price = redemption_prices[marketId]; \\n    collateral_redeem_amount = redemption_price.mulWadDown(zcb_redeem_amount); \\n\\n    if (!controller.isValidator(marketId, msg.sender)) { // TODO should validators get reputation if they do ok.\\n      reputationManager.recordPush(msg.sender, marketId, redemption_price, false, zcb_redeem_amount); \\n    }\\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n   }\\n\\n    bondPool.trustedBurn(msg.sender, zcb_redeem_amount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n\\n\\n  }\\n\\n  /// @notice called by short buyers when market is resolved  \\n  function redeemShortZCB(\\n    uint256 marketId \\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\\n    require(!restriction_data[marketId].alive, \\\"Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    uint256 shortZCB_redeem_amount = markets[marketId].shortZCB.balanceOf(msg.sender); \\n    uint256 long_redemption_price = redemption_prices[marketId];\\n    uint256 redemption_price = long_redemption_price >= config.WAD \\n                               ? 0 \\n                               : config.WAD - long_redemption_price; \\n    collateral_redeem_amount = redemption_price.mulWadDown(shortZCB_redeem_amount);\\n\\n    bondPool.trustedBurn(msg.sender, shortZCB_redeem_amount, false); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  /// @notice returns the manager's maximum leverage \\n  function getMaxLeverage(address manager) public view returns(uint256){\\n    //return (repToken.getReputationScore(manager) * config.WAD).sqrt(); //TODO experiment \\n    return (controller.getTraderScore(manager) * config.WAD).sqrt();\\n  }\\n\\n  mapping(uint256=>mapping(address=> LeveredBond)) public leveragePosition; \\n  struct LeveredBond{\\n    uint128 debt; //how much collateral borrowed from vault \\n    uint128 amount; // how much bonds were bought with the given leverage\\n  }\\n\\n  /// @notice for managers that are a) meet certain reputation threshold and b) choose to be more\\n  /// capital efficient with their zcb purchase. \\n  /// @param _amountIn (in collateral) already accounts for the leverage, so the actual amount manager is transferring\\n  /// is _amountIn/_leverage \\n  /// @dev the marketmanager should take custody of the quantity bought with leverage\\n  /// and instead return notes of the levered position \\n  /// TODO do + instead of creating new positions and implied prob cumulative \\n  function buyBondLevered(\\n    uint256 _marketId, \\n    uint256 _amountIn, \\n    uint256 _priceLimit, \\n    uint256 _leverage //in 18 dec \\n    ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\\n    require(restriction_data[_marketId].duringAssessment, \\\"PhaseERR\\\"); \\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= config.WAD, \\\"!leverage\\\");\\n    _canBuy(msg.sender, int256(_amountIn), _marketId);\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    // stack collateral from trader and borrowing from vault \\n    uint256 amountPulled = _amountIn.divWadDown(_leverage); \\n    bondPool.BaseToken().transferFrom(msg.sender, address(this), amountPulled); \\n    controller.pullLeverage(_marketId, _amountIn - amountPulled); \\n\\n    // Buy with leverage, zcb transferred here\\n    bondPool.BaseToken().approve(address(this), _amountIn); \\n    (amountIn, amountOut) = bondPool.takerOpen(true, int256(_amountIn), _priceLimit, abi.encode(address(this))); \\n\\n    //Need to log assessment trades for updating reputation scores or returning collateral when market denied \\n    _logTrades(_marketId, msg.sender, _amountIn, 0, true, true);\\n\\n    // Get implied probability estimates by summing up all this managers bought for this market \\n    // assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\\n    //     amountOut, \\n    //     amountIn, \\n    //     getTraderBudget(_marketId, msg.sender) \\n    // ); \\n\\n    // Phase Transitions when conditions met\\n    if(restriction_data[_marketId].onlyReputable){\\n      uint256 total_bought = loggedCollaterals[_marketId];\\n\\n      if (total_bought >= parameters[_marketId].omega.mulWadDown(\\n            controller\\n            .getVault(_marketId)\\n            .fetchInstrumentData(_marketId)\\n            .principal)\\n      ) {\\n        restriction_data[_marketId].onlyReputable = false;\\n      }\\n    }\\n    // create note to trader \\n    leveragePosition[_marketId][msg.sender] = LeveredBond(uint128(_amountIn - amountPulled ),uint128(amountOut)) ; \\n  }\\n\\n  function redeemLeveredBond(uint256 marketId) public{\\n    require(!restriction_data[marketId].alive, \\\"!Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender); \\n\\n    LeveredBond memory position = leveragePosition[marketId][msg.sender]; \\n    require(position.amount>0, \\\"ERR\\\"); \\n\\n    uint256 redemption_price = redemption_prices[marketId]; \\n    uint256 collateral_back = redemption_price.mulWadDown(position.amount) ; \\n    uint256 collateral_redeem_amount = collateral_back >= uint256(position.debt)  \\n        ? collateral_back - uint256(position.debt) : 0; \\n\\n    if (!controller.isValidator(marketId, msg.sender)) {\\n      // bool increment = redemption_price >= config.WAD? true: false;\\n      // controller.updateReputation(marketId, msg.sender, increment);\\n      // reputationManager.recordPush(msg.sender, marketId, redemption_price, false, zcb_redeem_amount); \\n\\n    }\\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }\\n\\n    leveragePosition[marketId][msg.sender].amount = 0; \\n    markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  function redeemDeniedLeveredBond(uint256 marketId) public returns(uint collateral_amount){\\n    LeveredBond memory position = leveragePosition[marketId][msg.sender]; \\n    require(position.amount>0, \\\"ERR\\\"); \\n    leveragePosition[marketId][msg.sender].amount = 0; \\n\\n    // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n    if (controller.isValidator(marketId, msg.sender)) {\\n      collateral_amount = controller.deniedValidator(marketId, msg.sender);\\n    }\\n    else{\\n      collateral_amount = longTrades[marketId][msg.sender]; \\n      delete longTrades[marketId][msg.sender]; \\n    }\\n\\n    // Burn all their position, \\n    markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n      unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }    \\n\\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\\n    controller.redeem_transfer(collateral_amount - uint256(position.debt), msg.sender, marketId);\\n  }\\n\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n}\\n\\n\",\"keccak256\":\"0xd66e31efe48cd02c3055240a326f570f479501a072dc3b6adec7ece80f7ec468\"},\"contracts/protocol/reputationmanager.sol\":{\"content\":\"pragma solidity ^0.8.16;\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\nimport {config} from \\\"../utils/helpers.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\"; \\n\\ncontract ReputationManager {\\n    using FixedPointMathLib for uint256;\\n\\n    mapping(address=>uint256) public trader_scores; // trader address => score\\n    mapping(address=>bool) public isRated;\\n    address[] public traders;\\n\\n    address controller;\\n    address marketManager;\\n\\n    address deployer;\\n\\n    modifier onlyProtocol() {\\n        require(msg.sender == controller || msg.sender == marketManager || msg.sender == deployer, \\\"ReputationManager: !protocol\\\");\\n        _;\\n    }\\n    // event pullLogged(uint256 marketId, address recipient, );\\n    event reputationUpdated(uint256 marketId, address recipient);\\n\\n    constructor(\\n        address _controller,\\n        address _marketManager\\n    ) {\\n       controller = _controller;\\n       marketManager = _marketManager;\\n       deployer = msg.sender;\\n    }\\n\\n    struct RepLog{\\n        uint256 collateralAmount; \\n        uint256 bondAmount; \\n        uint256 budget; \\n        bool perpetual; \\n        //TODO place this info elsewhere or do packing\\n    }\\n\\n    mapping(address=> mapping(uint256=> RepLog)) public repLogs; //trader=> marketid=>replog \\n\\n    function getRepLog(address trader, uint256 marketId) external view returns(RepLog memory){\\n        return repLogs[trader][marketId]; \\n    }\\n\\n    /// @notice record for reputation updates whenever trader buys longZCB\\n    function recordPull(\\n        address trader, \\n        uint256 marketId, \\n        uint256 bondAmount, \\n        uint256 collateral_amount, \\n        uint256 budget,\\n        bool perpetual\\n        ) external onlyProtocol{\\n        RepLog memory newLog = repLogs[trader][marketId]; \\n        newLog.collateralAmount += collateral_amount; \\n        newLog.bondAmount += bondAmount; \\n        newLog.perpetual = perpetual; \\n        newLog.budget = budget; \\n\\n        repLogs[trader][marketId] = newLog;   \\n    }\\n\\n    /// @notice updates reputation whenever trader redeems \\n    /// param premature is true if trader redeems/sells before maturity \\n    /// param redeemAmount is 0 if !perpetual, since for those traders will redeem all at once \\n    function recordPush(\\n        address trader, \\n        uint256 marketId, \\n        uint256 bondPrice, \\n        bool premature, \\n        uint256 redeemAmount//in bonds \\n        ) external onlyProtocol {\\n        RepLog memory newLog = repLogs[trader][marketId]; \\n\\n        uint256 avgPrice = newLog.collateralAmount.divWadDown(newLog.bondAmount); \\n\\n        // Penalize premature sells \\n        if(premature){\\n            _updateReputation(marketId, trader, false, 1e18, newLog); \\n            delete repLogs[trader][marketId]; \\n        }\\n        // What about when trader buys during assessment at discount?  \\n        // if instrument is perpetual, increment if exit price > avgPrice by \\n        // proportional to the diff in price  \\n        if(newLog.perpetual){\\n            if (bondPrice >= avgPrice) \\n                _updateReputation(marketId, trader, true,  bondPrice-avgPrice, newLog); \\n            else \\n                _updateReputation(marketId, trader, false,  avgPrice - bondPrice, newLog); \\n\\n            require(newLog.collateralAmount >= redeemAmount.mulWadDown(avgPrice), \\\"logERR1\\\");\\n            require(newLog.bondAmount>= redeemAmount, \\\"logERR2\\\"); \\n            unchecked{\\n                newLog.collateralAmount -= redeemAmount.mulWadDown(avgPrice);\\n                newLog.bondAmount -= redeemAmount; \\n                repLogs[trader][marketId] = newLog; \\n            }\\n        }\\n\\n        // if instrument is fixed term, increment if redemptionprice >= 1, \\n        // no change if 1>= redemption price >= avgPrice and decrement otherwise \\n        else{\\n            //bondPrice is redemptionprice for fixed term instruments\\n            if(bondPrice>= 1e18)\\n                _updateReputation(marketId, trader, true, bondPrice-avgPrice, newLog); \\n            \\n            else if(bondPrice <= avgPrice && bondPrice < 1e18)\\n                _updateReputation(marketId, trader, false, avgPrice-bondPrice, newLog);  \\n            // Redeeming everything at maturity \\n            delete repLogs[trader][marketId];             \\n        }\\n\\n\\n    }\\n\\n    /// @notice given a hypoethetical bond price, calculate how much reputation one will gain\\n    function expectedRepGain(\\n        address trader, \\n        uint256 marketId, \\n        uint256 bondPrice, \\n        uint256 incremntalAmount, \\n        uint256 incrementalBondAmount) external view returns(int256 expectedGain){\\n        RepLog memory log = repLogs[trader][marketId]; \\n\\n        uint256 avgPrice = (log.collateralAmount+incremntalAmount)\\n            .divWadDown(log.bondAmount + incrementalBondAmount); \\n        uint256 priceChange = bondPrice- avgPrice; \\n        uint256 implied_probs; \\n\\n        if(log.perpetual){\\n            implied_probs = log.collateralAmount.divWadDown(log.budget); \\n            expectedGain = (bondPrice >= avgPrice)\\n                ? int256(priceChange.mulWadDown(implied_probs))\\n                : -int256(priceChange.mulWadDown(implied_probs)); \\n        } else {\\n            implied_probs = calcImpliedProbability(\\n                log.bondAmount, \\n                log.collateralAmount, \\n                log.budget\\n                ); \\n            if(bondPrice>= 1e18)\\n                expectedGain = int256(priceChange.mulWadDown(implied_probs)); \\n            else if(bondPrice <= avgPrice && bondPrice < 1e18)\\n                expectedGain = -int256(priceChange.mulWadDown(implied_probs)); \\n        }\\n    }\\n\\n    /// @notice when market is resolved(maturity/early default), calculates score\\n    /// and update each assessment phase trader's reputation, called by individual traders when redeeming\\n    function _updateReputation(\\n        uint256 marketId,\\n        address trader,\\n        bool increment, \\n        uint256 priceChange, \\n        RepLog memory log\\n    ) internal {\\n\\n        uint256 implied_probs = log.perpetual\\n            ? log.collateralAmount.divWadDown(log.budget)\\n            : calcImpliedProbability(\\n                log.bondAmount, \\n                log.collateralAmount, \\n                log.budget\\n                ); \\n\\n        uint256 change = priceChange.mulWadDown(implied_probs); \\n                        // log.perpetual\\n                        // ? priceChange.mulWadDown(implied_probs) * \\n                        // : implied_probs.mulDivDown(implied_probs, config.WAD);\\n\\n        if (increment) {\\n            incrementScore(trader, change);\\n        } else {\\n            decrementScore(trader, change);\\n        }\\n    }\\n\\n    //function expectedRepGain()\\n\\n\\n    /// @notice calculates implied probability of the trader, used to\\n    /// update the reputation score by brier scoring mechanism\\n    /// @param budget of trader in collateral decimals\\n    function calcImpliedProbability(\\n        uint256 bondAmount,\\n        uint256 collateral_amount,\\n        uint256 budget\\n    ) public pure returns (uint256) {\\n        require(bondAmount > 0 && collateral_amount > 0, \\\"0div\\\"); \\n      // TODO underflows when avgprice bigger than wad\\n        uint256 avg_price = collateral_amount.divWadDown(bondAmount);\\n        uint256 b = avg_price.mulWadDown(config.WAD - avg_price);\\n        uint256 ratio = bondAmount.divWadDown(budget);\\n\\n        return ratio.mulWadDown(b) + avg_price;\\n    }\\n\\n    function calculateMinScore(uint256 percentile) view external returns (uint256) {\\n        uint256 l = traders.length * config.WAD;\\n        if (percentile / 1e2 == 0) {\\n        return 0;\\n        }\\n        uint256 x = l.mulWadDown(percentile / 1e2);\\n        x /= config.WAD;\\n        return trader_scores[traders[x - 1]];\\n    }\\n\\n    // change visiblity, external only for testing.\\n    function setTraderScore(address trader, uint256 score) external {\\n        uint256 prev_score = trader_scores[trader];\\n        if (score > prev_score) {\\n        incrementScore(trader, score - prev_score);\\n        } else if (score < prev_score) {\\n        decrementScore(trader, prev_score - score);\\n        }\\n    }\\n    \\n    function isReputable(address trader, uint256 percentile) view external returns (bool) {\\n        uint256 k = findTrader(trader);\\n        uint256 n = (traders.length - (k+1))*config.WAD;\\n        uint256 N = traders.length*config.WAD;\\n        uint256 p = uint256(n).divWadDown(N)*10**2;\\n\\n        if (p >= percentile) {\\n        return true;\\n        } else {\\n        return false;\\n        }\\n    }\\n\\n    // TODO \\n    function expectedIncrement(address manager) public view returns(uint256){\\n\\n    }\\n\\n    /**\\n    @dev percentile is is wad 0-100\\n    @notice returns a list of top X percentile traders excluding the utilizer. \\n    */\\n    function filterTraders(uint256 percentile, address utilizer) view public returns (address[] memory) {\\n        uint256 l = traders.length * config.WAD;\\n        \\n        // if below minimum percentile, return all traders excluding the utilizer\\n        if (percentile / 1e2 == 0) {\\n        if (isRated[utilizer]) {\\n            address[] memory result = new address[](traders.length - 1);\\n\\n            uint256 j = 0;\\n            for (uint256 i=0; i<traders.length; i++) {\\n            if (utilizer == traders[i]) {\\n                j = 1;\\n                continue;\\n            }\\n            result[i - j] = traders[i];\\n            }\\n            return result;\\n        } else {\\n            return traders;\\n        }\\n        }\\n\\n        uint256 x = l.mulWadDown((config.WAD*100 - percentile) / 1e2);\\n        x /= config.WAD;\\n\\n        address[] memory selected; \\n        if (utilizer == address(0) || !isRated[utilizer]) {\\n        selected = new address[](x);\\n        for (uint256 i=0; i<x; i++) {\\n            selected[i] = traders[i];\\n        }\\n        } else {\\n        selected = new address[](x - 1);\\n        uint256 j=0;\\n        for (uint256 i = 0; i<x; i++) {\\n            if (traders[i] == utilizer) {\\n            j = 1;\\n            continue;\\n            }\\n            selected[i - j] = traders[i];\\n        }\\n        }\\n\\n        return selected;\\n    }\\n\\n    function getTraders() view public returns (address[] memory) {\\n        return traders;\\n    }\\n\\n    event ScoreUpdated(address trader, uint256 score);\\n    /**\\n    @notice increments trader's score\\n    @dev score >= 0, update > 0\\n    */\\n    function incrementScore(address trader, uint256 update) onlyProtocol public {\\n        trader_scores[trader] += update;\\n        _updateRanking(trader, true);\\n        emit ScoreUpdated(trader, trader_scores[trader]);\\n    }\\n\\n    function testIncrementScore(uint256 update) public {\\n        trader_scores[msg.sender] += update;\\n        _updateRanking(msg.sender, true);\\n        emit ScoreUpdated(msg.sender, trader_scores[msg.sender]);\\n    }\\n\\n    /**\\n    @notice decrements trader's score\\n    @dev score >= 0, update > 0\\n    */\\n    function decrementScore(address trader, uint256 update) onlyProtocol public {\\n        if (update >= trader_scores[trader]) {\\n        trader_scores[trader] = 0;\\n        } else {\\n        trader_scores[trader] -= update;\\n        }\\n        _updateRanking(trader, false);\\n        emit ScoreUpdated(trader, trader_scores[trader]);\\n    }\\n\\n    /**\\n    @notice updates top trader array\\n    @dev holy moly is this ugly\\n    */\\n    function _updateRanking(address trader, bool increase) internal {\\n        uint256 score = trader_scores[trader];\\n\\n        if (!isRated[trader]) {\\n        isRated[trader] = true;\\n        if (traders.length == 0) {\\n            traders.push(trader);\\n            return;\\n        }\\n        for (uint256 i=0; i<traders.length; i++) {\\n            if (score > trader_scores[traders[i]]) {\\n            traders.push(address(0));\\n            _shiftRight(i, traders.length-1);\\n            traders[i] = trader;\\n            return;\\n            }\\n            if (i == traders.length - 1) {\\n            traders.push(trader);\\n            return;\\n            }\\n        }\\n        } else {\\n        uint256 k = findTrader(trader);\\n        //swap places with someone.\\n        if ((k == 0 && increase)\\n        || (k == traders.length - 1 && !increase)) {\\n            return;\\n        }\\n\\n        if (increase) {\\n            for (uint256 i=0; i<k; i++) {\\n            if (score > trader_scores[traders[i]]) {\\n                _shiftRight(i,k);\\n                traders[i] = trader;\\n                return;\\n            }\\n            }\\n        } else {\\n            for (uint256 i=traders.length - 1; i>k; i--) {\\n            if (score < trader_scores[traders[i]]) {\\n                _shiftLeft(k, i);\\n                traders[i] = trader;\\n                return;\\n            }\\n            }\\n        }\\n        }\\n    }\\n\\n    function findTrader(address trader) public view returns (uint256) {\\n    for (uint256 i=0; i<traders.length; i++) {\\n        if (trader == traders[i]) {\\n            return i;\\n        }\\n        }\\n    }\\n\\n    /**\\n    @notice helpers\\n    */\\n    function _shiftRight(uint256 pos, uint256 end) internal {\\n        for (uint256 i=end; i>pos; i--) {\\n        traders[i] = traders[i-1];\\n        }\\n    }\\n\\n    function _shiftLeft(uint256 pos, uint256 end) internal {\\n        for (uint256 i=pos; i<end; i++) {\\n        traders[i] = traders[i+1];\\n        }\\n    }\\n    \\n}\",\"keccak256\":\"0xaa173296471c8500d78eea8adb6640c8645f56e9bae86ef791b2e37181acb4b1\"},\"contracts/protocol/reputationtoken.sol\":{\"content\":\"pragma solidity ^0.8.16; \\n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\\nimport {ERC721} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\n\\ncontract ReputationNFT is ERC721 {\\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\\n  mapping(address => uint256) internal _ownerToId;\\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\\n\\n  uint256 private nonce = 1;\\n  Controller controller;\\n  uint256 SCALE = 1e18;\\n\\n\\n  struct ReputationData {\\n    uint256 n; // number of markets participated in => regular uint256\\n    uint256 score; \\n  }\\n\\n  struct TraderData { // for each market\\n    address trader;\\n    uint256 tokensBought;\\n  }\\n\\n  struct TopReputation{\\n    address trader; \\n    uint256 score; \\n  }\\n\\n  uint256 private constant topRep = 100; \\n  TopReputation[topRep] topReputations; \\n\\n  mapping(uint256=>mapping(address=>bool)) canTrade; //marketID-> address-> cantrade\\n  mapping(uint256=>bool) allowAll; \\n  mapping(address=>bool) isUnique; \\n  address[] unique_traders; \\n  mapping(uint256=>mapping(address=>uint256)) public balances; // marketId => market manager address => how much collateral already bought.\\n\\n  modifier onlyController() {\\n    require(msg.sender == address(controller));\\n    _;\\n  }\\n\\n  constructor (\\n    address _controller\\n  ) ERC721(\\\"Debita Reputation Token\\\", \\\"DRT\\\") {\\n    controller = Controller(_controller);\\n  }\\n\\n  /**\\n   @notice incrementBalance\\n   */\\n  function incrementBalance(uint256 marketId, address trader, uint256 amount) external onlyController {\\n    balances[marketId][trader] += amount;\\n  }\\n\\n  /**\\n   @notice called post reputation update\\n   */\\n  function removeBalance(uint256 marketId, address trader) external onlyController {\\n    delete balances[marketId][trader];\\n  }\\n\\n  function _baseURI() internal pure returns (string memory baseURI) {\\n    baseURI = \\\"\\\";\\n  }\\n\\n  function tokenURI(uint256 id) public view override returns (string memory) {\\n    require(_ownerOf[id] != address(0), \\\"Invalid Identifier\\\");\\n\\n    string memory baseURI = _baseURI();\\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \\\"\\\";\\n  }\\n\\n  function mint(address to) external {\\n    require(_ownerToId[to] == uint256(0), \\\"can only mint one reputation token\\\");\\n    super._mint(to, nonce);\\n    _ownerToId[to] = nonce;\\n\\n    // Set default score, if this goes to 0 cannot trade\\n    _reputation[_ownerToId[to]].score = 1e18; \\n\\n    nonce++;\\n  }\\n\\n  function getReputationScore(address owner) view external returns (uint256){\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score;\\n  }\\n\\n  function setReputationScore(address owner, uint256 score) external returns (uint256) \\n  //onlyOwner\\n  {\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score = score;\\n  }\\n\\n\\n  function updateScore(address to, int256 score) external onlyController{\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    if (score > 0) data.score = data.score + uint256(score);\\n    else{\\n        if (data.score <= uint256(-score)) data.score = 0; \\n        else data.score = data.score - uint256(-score);\\n      } \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n\\n  function addScore(address to, uint256 score) external onlyController\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    data.score = data.score + score; \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n  function decrementScore(address to, uint256 score) external onlyController\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    if (data.score <= score) data.score = 0; \\n    else data.score = data.score - score; \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n  function addAverageScore(address to, uint256 score) external onlyController\\n\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    \\n    if (data.n == 0) {\\n      data.score = score;\\n    } else {\\n      data.score = (data.score / data.n + score) / (data.n + 1);\\n    }\\n\\n    data.n++;\\n  }\\n\\n  /**\\n   @notice reset scores\\n   */\\n  function resetScore(address to) external {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n    delete _reputation[_ownerToId[to]];\\n  }\\n\\n  /// @notice called by controller when initiating market,\\n  function storeTopReputation(uint256 topX, uint256 marketId) external onlyController{\\n    if (getAvailableTopX() < topX) {\\n      allowAll[marketId] =true; \\n      return; \\n    }\\n\\n    for (uint256 i; i<topX; i++){\\n      canTrade[marketId][topReputations[i].trader] = true;\\n    }\\n\\n  }\\n\\n  /// @notice gets the x's ranked score from all reputation scores \\n  /// @dev returns 0 if topX is greater then avaiable nonzero rep scores-> everyone is allowed\\n  /// during reputation constraint periods \\n  function getMinRepScore(uint256 topX) public view returns(uint256) {\\n    if (getAvailableTopX() < topX) {\\n      return 0; \\n    }\\n    return topReputations[topX].score;\\n  }\\n\\n  function getAvailableTopX() public view returns(uint256){\\n    return unique_traders.length; \\n  }\\n\\n  function getAvailableTraderNum() public view returns(uint256){\\n    return nonce -1; \\n  }\\n\\n  /// @notice whether trader is above reputation threshold \\n  function traderCanTrade(uint256 marketId, address trader) external returns(bool){\\n    return allowAll[marketId]? true : canTrade[marketId][trader]; \\n  }\\n\\n  /// @notice called whenever a score is incremented   \\n  function storeTopX(uint256 score, address trader) internal {\\n    uint256 i = 0;\\n\\n    for(i; i < topReputations.length; i++) {\\n      if(topReputations[i].score < score) {\\n        break;\\n      }\\n    }\\n    // shifting the array of position (getting rid of the last element) \\n    for(uint j = topReputations.length - 1; j > i; j--) {\\n        topReputations[j].score = topReputations[j - 1].score;\\n        topReputations[j].trader = topReputations[j - 1].trader;\\n    }\\n    // update the new max element \\n    topReputations[i].score = score;\\n    topReputations[i].trader = trader;\\n\\n    if (isUnique[trader]) return; \\n    isUnique[trader] = true; \\n    unique_traders.push(trader);\\n\\n  }\\n\\n  function testStore() public view {\\n    for (uint i=0; i<10; i++){\\n      console.log('score', topReputations[i].score); \\n    }\\n  }  \\n}\",\"keccak256\":\"0xecaf77b1bd3c0c68f9e4181314fb094cfce1d1f9445f432a9bf68c9138e860b1\"},\"contracts/protocol/validatorManager.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\nimport {Controller} from \\\"./controller.sol\\\";\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\nimport {ReputationManager} from \\\"./reputationmanager.sol\\\";\\nimport {SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\";\\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\ncontract ValidatorManager {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n    Controller private controller;\\n    ReputationManager private reputationManager;\\n    MarketManager private marketManager;\\n\\n    modifier onlyController () {\\n        require(msg.sender == address(controller), \\\"not controller\\\");\\n        _;\\n    }\\n\\n     /*----Validator Logic----*/\\n    struct ValidatorData {\\n        mapping(address => uint256) sales; // amount of zcb bought per validator\\n        mapping(address => bool) staked; // true if address has staked vt (approved)\\n        mapping(address => bool) resolved; // true if address has voted to resolve the market\\n        address[] validators;\\n        uint256 val_cap; // total zcb validators can buy at a discount\\n        uint256 avg_price; //price the validators can buy zcb at a discount\\n        bool requested; // true if already requested random numbers from array.\\n        uint256 totalSales; // total amount of zcb bought;\\n        uint256 totalStaked; // total amount of vault token staked.\\n        uint256 numApproved;\\n        uint256 initialStake; // amount staked\\n        uint256 finalStake; // amount of stake recoverable post resolve\\n        uint256 numResolved; // number of validators calling resolve on early resolution.\\n    }\\n\\n    mapping(uint256 => uint256) requestToMarketId;\\n    mapping(uint256 => ValidatorData) public validator_data;\\n    \\n    constructor (\\n        address _controller,\\n        address _marketManager,\\n        address _reputationManager\\n        ) {\\n        controller = Controller(_controller);\\n        reputationManager = ReputationManager(_reputationManager);\\n        marketManager = MarketManager(_marketManager);\\n    }\\n\\n    function validatorSetup(\\n        uint256 marketId,\\n        uint256 principal,\\n        bool isPool\\n    ) external onlyController {\\n        require(principal != 0, \\\"0 principal\\\");\\n        _getValidators(marketId);\\n        _setValidatorCap(marketId, principal, isPool);\\n        _setValidatorStake(marketId, principal);\\n    }\\n\\n    function _getValidators(uint256 marketId) public {\\n        // retrieve traders that meet requirement.\\n        // address instrument = market_data[marketId].instrument_address;\\n        (,address utilizer) = controller.market_data(marketId);\\n\\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\\n        address[] memory selected = reputationManager.filterTraders(\\n            r,\\n            utilizer\\n        );\\n\\n        // if there are not enough traders, set validators to all selected traders.\\n        if (selected.length <= N) {\\n            validator_data[marketId].validators = selected;\\n\\n            if (selected.length < N) {\\n                revert(\\\"not enough rated traders\\\");\\n            }\\n\\n            return;\\n        }\\n\\n        validator_data[marketId].requested = true;\\n\\n        uint256 _requestId = 1;\\n        // uint256 _requestId = COORDINATOR.requestRandomWords(\\n        //   keyHash,\\n        //   subscriptionId,\\n        //   requestConfirmations,\\n        //   callbackGasLimit,\\n        //   uint32(parameters[marketId].N)\\n        // );\\n\\n        requestToMarketId[_requestId] = marketId;\\n    }\\n\\n    function _setValidatorCap(\\n        uint256 marketId,\\n        uint256 principal,\\n        bool isPool //??\\n    ) internal {\\n        SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\\n        (, uint256 sigma, , , , , , ) = marketManager.parameters(marketId);\\n        require(config.isInWad(sigma) && config.isInWad(principal), \\\"paramERR\\\");\\n        ValidatorData storage valdata = validator_data[marketId];\\n\\n        uint256 valColCap = (sigma.mulWadDown(principal));\\n\\n        // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved\\n        uint256 discount_cap = bondingPool.discount_cap();\\n        uint256 avgPrice = valColCap.divWadDown(discount_cap);\\n\\n        valdata.val_cap = discount_cap;\\n        valdata.avg_price = avgPrice;\\n    }\\n\\n     /**\\n   @notice sets the amount of vt staked by a single validator for a specific market\\n   @dev steak should be between 1-0 wad.\\n   */\\n    function _setValidatorStake(uint256 marketId, uint256 principal) internal {\\n        //get vault\\n        uint256 vaultId = controller.id_parent(marketId);\\n        ERC4626 vault = controller.vaults(vaultId);\\n        // ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n        uint256 shares = vault.convertToShares(principal);\\n        (, , , , , , , uint256 steak) = marketManager.parameters(marketId);\\n        validator_data[marketId].initialStake = steak.mulWadDown(shares);\\n    }\\n\\n    function deniedValidator(uint256 marketId, address validator)\\n        external\\n        onlyController\\n        returns (uint256 collateral_amount)\\n    {\\n        //??? is this correct\\n        collateral_amount = validator_data[marketId]\\n            .sales[validator]\\n            .mulWadDown(validator_data[marketId].avg_price);\\n        delete validator_data[marketId].sales[validator];\\n    }\\n\\n    function redeemValidator(uint256 marketId, address validator)\\n        external\\n        onlyController\\n    {\\n        delete validator_data[marketId].sales[validator];\\n    }\\n\\n    function getValidatorRequiredCollateral(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 val_cap = validator_data[marketId].val_cap;\\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\\n        uint256 zcb_for_sale = val_cap / N;\\n        return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\\n    }\\n\\n    function unlockValidatorStake(uint256 marketId, address validator) onlyController external {\\n        require(isValidator(marketId, validator), \\\"!validator\\\");\\n        require(validator_data[marketId].staked[validator], \\\"!stake\\\");\\n        (bool duringMarketAssessment, , , , , ) = marketManager\\n            .restriction_data(marketId);\\n\\n        // market early denial, no loss.\\n        uint256 vaultId = controller.id_parent(marketId);\\n        ERC4626 vault = ERC4626(controller.vaults(vaultId));\\n        if (duringMarketAssessment) {\\n            ERC20(controller.getVaultAd(marketId)).safeTransfer(\\n                validator,\\n                validator_data[marketId].initialStake\\n            );\\n            validator_data[marketId].totalStaked -= validator_data[marketId]\\n                .initialStake;\\n        } else {\\n            // market resolved.\\n            ERC20(controller.getVaultAd(marketId)).safeTransfer(\\n                validator,\\n                validator_data[marketId].finalStake\\n            );\\n            validator_data[marketId].totalStaked -= validator_data[marketId]\\n                .finalStake;\\n        }\\n\\n        validator_data[marketId].staked[validator] = false;\\n    }\\n\\n     function updateValidatorStake(\\n        uint256 marketId,\\n        uint256 principal,\\n        uint256 principal_loss\\n    ) public onlyController {\\n        if (principal_loss == 0) {\\n            validator_data[marketId].finalStake = validator_data[marketId]\\n                .initialStake;\\n            return;\\n        }\\n\\n        uint256 vaultId = controller.id_parent(marketId);\\n        ERC4626 vault = ERC4626(controller.vaults(vaultId));\\n        uint256 p_shares = vault.convertToShares(principal);\\n        uint256 p_loss_shares = vault.convertToShares(principal_loss);\\n\\n        uint256 totalStaked = validator_data[marketId].totalStaked;\\n        uint256 newTotal = totalStaked /\\n            2 +\\n            (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(\\n                totalStaked / 2\\n            );\\n\\n        ERC4626(controller.getVaultAd(marketId)).burn(totalStaked - newTotal);\\n        validator_data[marketId].totalStaked = newTotal;\\n\\n        validator_data[marketId].finalStake =\\n            newTotal /\\n            validator_data[marketId].validators.length;\\n    }\\n\\n    function validatorResolve(uint256 marketId, address validator) onlyController external {\\n        require(isValidator(marketId, validator), \\\"!val\\\");\\n        require(!validator_data[marketId].resolved[validator], \\\"voted\\\");\\n\\n        validator_data[marketId].resolved[validator] = true;\\n        validator_data[marketId].numResolved++;\\n    }\\n\\n    function isValidator(uint256 marketId, address user)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        address[] storage _validators = validator_data[marketId].validators;\\n        for (uint256 i = 0; i < _validators.length; i++) {\\n            if (_validators[i] == user) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function validatorApprove(uint256 marketId, address validator) external returns (uint256 collateral_required, uint256 zcb_for_sale) {\\n        require(isValidator(marketId, validator), \\\"!Val\\\");\\n        require(controller.marketCondition(marketId), \\\"!condition\\\");\\n\\n        ValidatorData storage valdata = validator_data[marketId];\\n        require(!valdata.staked[validator], \\\"!staked\\\");\\n\\n        // staking logic, TODO optional since will throw error on transfer.\\n        // require(ERC20(getVaultAd(marketId)).balanceOf(validator) >= valdata.initialStake, \\\"not enough tokens to stake\\\");\\n\\n        // staked vault tokens go to controller\\n        ERC20(controller.getVaultAd(marketId)).safeTransferFrom(\\n            validator,\\n            address(this),\\n            valdata.initialStake\\n        );\\n\\n        valdata.totalStaked += valdata.initialStake;\\n        valdata.staked[validator] = true;\\n\\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\\n        zcb_for_sale = valdata.val_cap / N;\\n        collateral_required = zcb_for_sale.mulWadDown(\\n            valdata.avg_price\\n        );\\n\\n        require(valdata.sales[validator] <= zcb_for_sale, \\\"approved\\\");\\n\\n        valdata.sales[validator] += zcb_for_sale;\\n        valdata.totalSales += (zcb_for_sale + 1); //since division rounds down ??\\n        valdata.numApproved += 1;\\n\\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\\n        // marketManager.validatorApprove(\\n        //     marketId,\\n        //     collateral_required,\\n        //     zcb_for_sale,\\n        //     validator\\n        // );\\n\\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\\n        if (controller.approvalCondition(marketId)) {\\n            controller.approveMarket(marketId);\\n            // marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\\n        }\\n    }\\n\\n    function approvalCondition(uint256 marketId) public view returns (bool) {\\n        return (validator_data[marketId].totalSales >=\\n            validator_data[marketId].val_cap &&\\n            validator_data[marketId].validators.length ==\\n            validator_data[marketId].numApproved);\\n    }\\n\\n\\n    function getValidatorPrice(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].avg_price;\\n    }\\n\\n    function getValidatorCap(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].val_cap;\\n    }\\n\\n    function viewValidators(uint256 marketId)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return validator_data[marketId].validators;\\n    }\\n\\n    function fulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords //internal\\n    ) external onlyController\\n    {\\n        uint256 marketId = requestToMarketId[requestId];\\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\\n\\n        assert(randomWords.length == N);\\n\\n        // address instrument = market_data[marketId].instrument_address;\\n        (,address utilizer) = controller.market_data(marketId);\\n\\n        address[] memory temp = reputationManager.filterTraders(r, utilizer);\\n        uint256 length = temp.length;\\n\\n        // get validators\\n        for (uint8 i = 0; i < N; i++) {\\n            uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\\n            validator_data[marketId].validators.push(temp[j]);\\n            temp[j] = temp[length - 1];\\n            length--;\\n        }\\n    }\\n\\n    function _weightedRetrieve(\\n        address[] memory group,\\n        uint256 length,\\n        uint256 randomWord\\n    ) internal view returns (uint256) {\\n        uint256 sum_weights;\\n\\n        for (uint8 i = 0; i < length; i++) {\\n            sum_weights += controller.getTraderScore(group[i]); //repToken.getReputationScore(group[i]);\\n        }\\n\\n        uint256 tmp = randomWord % sum_weights;\\n\\n        for (uint8 i = 0; i < length; i++) {\\n            uint256 wt = controller.getTraderScore(group[i]);\\n            if (tmp < wt) {\\n                return i;\\n            }\\n            unchecked {\\n                tmp -= wt;\\n            }\\n        }\\n    }\\n\\n    function resolveCondition(uint256 marketId) public view returns (bool) {\\n        return (validator_data[marketId].numResolved ==\\n            validator_data[marketId].validators.length);\\n    }\\n\\n    function hasApproved(uint256 marketId, address validator)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return validator_data[marketId].staked[validator];\\n    }\\n\\n    function getNumApproved(uint256 marketId) public view returns (uint256) {\\n        //return validatorManager.getNumApproved(marketId);\\n        return validator_data[marketId].numApproved;\\n    }\\n\\n    function getNumResolved(uint256 marketId) public view returns (uint256) {\\n        //return validatorManager.getNumResolved(marketId);\\n        return validator_data[marketId].numResolved;\\n    }\\n\\n    function getTotalStaked(uint256 marketId) public view returns (uint256) {\\n        // return validatorManager.getTotalStaked(marketId);\\n        return validator_data[marketId].totalStaked;\\n    }\\n\\n    function getTotalValidatorSales(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        // return validatorManager.getTotalValidatorSales(marketId);\\n        return validator_data[marketId].totalSales;\\n    }\\n\\n    function getInitialStake(uint256 marketId) public view returns (uint256) {\\n        //return validatorManager.getInitialStake(marketId);\\n        return validator_data[marketId].initialStake;\\n    }\\n\\n    function getFinalStake(uint256 marketId) public view returns (uint256) {\\n        //return validatorManager.getFinalStake(marketId);\\n        return validator_data[marketId].finalStake;\\n    }\\n}\",\"keccak256\":\"0x5fe30a0b1279ede8fd4236ab83d726ffec1183790928dd74d1dcde69416dcb09\"},\"contracts/utils/helpers.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nlibrary config{\\n\\n  uint256 public constant WAD_PRECISION = 18; \\n  uint256 public constant WAD = 1e18; \\n  uint256 public constant USDC_dec = 1e6; \\n  uint256 public constant roundLimit = 1e14; //0.0001 \\n\\n  //Max amount in one transaction \\n  uint256 private constant max_amount = 1e8 * WAD; \\n\\n  //Min amount in one transaction \\n  uint256 private constant min_amount = WAD/1e4; \\n\\n  function convertToWad(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\\n    //number should not be 18 dec, but in collateral_dec\\n    new_number = number * (10 ** (WAD_PRECISION - dec));\\n    assert(new_number <= max_amount); \\n  }\\n\\n  function wadToDec(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\\n    // number should be 18 dec \\n    assert(isInWad(number)); \\n    new_number = number/(10 ** (WAD_PRECISION - dec)); \\n\\n  }\\n\\n  function isInWad(uint256 number) internal pure returns(bool){\\n    return (number >= min_amount); \\n  }\\n\\n\\n\\n\\n}\",\"keccak256\":\"0xd30e0b9fdc4387086c91449032c63c8190e50bd580306e1e2a0b0dccbf735779\"},\"contracts/vaults/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n    mapping(address=>bool) Authorized; \\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return(user == owner || Authorized[user]);\\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setNewAuthority(address newAuthority) public {\\n        require(msg.sender == owner );\\n        Authorized[newAuthority] = true; \\n\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x46c0e8d518396b50d7dc7f0050d716a5643afad9320b0cd27490fd8e00689dc7\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/instrument.sol\":{\"content\":\"\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.16;\\n\\nimport \\\"./vault.sol\\\";\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\nabstract contract Instrument {\\n\\n    modifier onlyUtilizer() {\\n        require(msg.sender == Utilizer, \\\"!Utilizer\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(msg.sender == vault.owner() || isValidator[msg.sender], \\\"!authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == address(vault), \\\"caller must be vault\\\");\\n        _;\\n    }\\n\\n    modifier notLocked() {\\n        require(!locked); \\n        _; \\n    }\\n\\n    constructor (\\n        address _vault,\\n        address _Utilizer\\n    ) {\\n        vault = Vault(_vault);\\n        underlying = ERC20(vault.UNDERLYING());\\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \\n        Utilizer = _Utilizer;\\n    }\\n\\n\\n    ERC20 public underlying;\\n    Vault public vault; \\n    bool locked; \\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private maturity_balance; \\n    uint256 rawFunds; \\n\\n    /// @notice address of user who submits the liquidity proposal \\n    address public Utilizer; \\n    address[] public validators; //set when deployed, but can't be ch\\n    mapping(address=>bool) isValidator;\\n\\n    /**\\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\\n     */\\n    function onMarketApproval(uint256 principal, uint256 yield) virtual external {}\\n\\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\\n        require(_Utilizer != address(0));\\n        Utilizer = _Utilizer;\\n    }\\n\\n    // function setValidator(address _validator) external {\\n    //     require(msg.sender == vault.owner(), \\\"Not owner\\\"); \\n    //     validators.push(_validator); \\n    //     isValidator[_validator] = true;     \\n    // }\\n    function setVault(address newVault) external onlyAuthorized {\\n        vault = Vault(newVault); \\n    }\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\\n        //TODO if this is pool redeemig to vault, need to redeem pool shares \\n        return underlying.transfer(address(vault), amount); \\n    }\\n\\n    /// @notice Returns a user's Instrument balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Instrument balance in underlying tokens.\\n    /// @dev May mutate the state of the Instrument by accruing interest.\\n    /// TODO need to incorporate the capital supplied by pool bond issuers\\n    function balanceOfUnderlying(address user) public view virtual returns (uint256){\\n        if(user == address(this)) return underlying.balanceOf(user) - rawFunds;\\n        return underlying.balanceOf(user); \\n    }\\n\\n    /// @notice raw funds should not be harvested by the vault\\n    function pullRawFunds(uint256 amount) public {\\n        underlying.transferFrom(msg.sender,address(this), amount); \\n        rawFunds += amount; \\n    }\\n\\n\\n\\n    function estimatedTotalAssets() public view virtual returns (uint256){}\\n\\n\\n    /// @notice Free up returns for vault to pull,  checks if the instrument is ready to be withdrawed, i.e all \\n    /// loans have been paid, all non-underlying have been liquidated, etc\\n    function readyForWithdrawal() public view virtual returns(bool){\\n        return true; \\n    }\\n\\n    /// @notice checks whether the vault can withdraw and record profit from this instrument \\n    /// for this instrument to resolve \\n    /// For creditlines, all debts should be repaid\\n    /// for strategies, all assets should be divested + converted to Underlying\\n    /// this function is important in preventing manipulations, \\n    /// @dev prepareWithdraw->vault.beforeResolve->vault.resolveInstrument in separate txs\\n    function prepareWithdraw()\\n        external \\n        onlyVault \\n        virtual\\n        returns (\\n            uint256 _profit,\\n            uint256 _loss,\\n            uint256 _debtPayment\\n        ){\\n            require(readyForWithdrawal(), \\\"not ready to withdraw\\\"); \\n\\n            // Lock additional drawdowns or usage of instrument balance \\n            lockLiquidityFlow();    \\n\\n        }\\n\\n\\n    function liquidatePosition(uint256 _amountNeeded) public  virtual returns (uint256 _liquidatedAmount, uint256 _loss){}\\n\\n\\n    function liquidateAllPositions() public  virtual returns (uint256 _amountFreed){}\\n\\n    function lockLiquidityFlow() internal{\\n        locked = true; \\n    }\\n\\n    function isLocked() public view returns(bool){\\n        return locked; \\n    }\\n\\n    event LiquidityTransfer(address indexed to, uint256 amount);\\n    function transfer_liq(address to, uint256 amount) internal notLocked {\\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \\n        underlying.transfer(to, amount);\\n        emit LiquidityTransfer(to, amount);\\n    }\\n\\n    event LiquidityTransferFrom(address indexed to, uint256 amount);\\n    function transfer_liq_from(address from, address to, uint256 amount) internal notLocked {\\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \\n        underlying.transferFrom(from, to, amount);\\n    }\\n\\n    /// @notice called before resolve, to avoid calculating redemption price based on manipulations \\n    function store_internal_balance() external onlyVault{\\n\\n        maturity_balance = balanceOfUnderlying(address(this)); \\n        if (vault.decimal_mismatch()) maturity_balance = vault.decAssetsToShares(maturity_balance); \\n\\n    }\\n\\n    function getMaturityBalance() public view returns(uint256){\\n        return maturity_balance; \\n    }\\n\\n    function isLiquid(uint256 amount) public virtual view returns(bool){\\n        //TODO \\n        console.log('isliquid', balanceOfUnderlying(address(this)), amount); \\n        return balanceOfUnderlying(address(this)) >= amount; \\n    }\\n\\n    // function beforeApprove(Vault.InstrumentData memory _instrumentData) onlyVault virtual external  {}\\n\\n\\n    /// @notice Before supplying liquidity from the vault to this instrument,\\n    /// which is done automatically when instrument is trusted, \\n    /// need to check if certain conditions that are required to this specific \\n    /// instrument is met. For example, for a creditline with a collateral \\n    /// requirement need to check if this address has the specific amount of collateral\\n    /// @dev called to be checked at the approve phase from controller  \\n    function instrumentApprovalCondition() public virtual view returns(bool); \\n}\\n\\n\\n\\n \\n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\\n/// approved borrowers will interact with this contract to borrow, repay. \\n/// and vault will supply principal and harvest principal/interest \\ncontract CreditLine is Instrument {\\n    using FixedPointMathLib for uint256;\\n    address public immutable borrower; \\n\\n    //  variables initiated at creation\\n    uint256 principal;\\n    uint256 notionalInterest; \\n    uint256 faceValue; //total amount due, i.e principal+interest\\n    uint256 duration; // normalized to a year 1 means 1 year, 0.5 means 6 month \\n    uint256 interestAPR; \\n\\n    // Modify-able Global Variables during repayments, borrow\\n    uint256 totalOwed; \\n    uint256 principalOwed; \\n    uint256 interestOwed;\\n    uint256 accumulated_interest; \\n    uint256 principalRepayed;\\n    uint256 interestRepayed; \\n\\n    // Collateral Info \\n    enum CollateralType{\\n        liquidateAble, \\n        nonLiquid, \\n        ownership ,        \\n        none\\n\\n\\n    }\\n    address public collateral; \\n    address public oracle; \\n    uint256 public collateral_balance; \\n    CollateralType public collateral_type; \\n\\n    uint256 drawdown_block; \\n    bool didDrawdown; \\n\\n    uint256 gracePeriod; \\n    uint256 resolveBlock; \\n    uint256 constant DUST = 1e18; //1usd\\n\\n    enum LoanStatus{\\n        notApproved,\\n        approvedNotDrawdowned,\\n        drawdowned, \\n        partially_repayed,\\n        prepayment_fulfilled, \\n        matured, \\n        grace_period, \\n        isDefault\\n    }\\n\\n    LoanStatus public loanStatus; \\n\\n    uint256 lastRepaymentTime; \\n    uint256 gracePeriodStart; \\n    Proxy proxy; \\n\\n    /// @notice both _collateral and _oracle could be 0\\n    /// address if fully uncollateralized or does not have a price oracle \\n    /// param _notionalInterest and _principal is initialized as desired variables\\n    constructor(\\n        address vault,\\n        address _borrower, \\n        uint256 _principal,\\n        uint256 _notionalInterest, \\n        uint256 _duration,\\n        uint256 _faceValue,\\n        address _collateral, //collateral for the dao, could be their own native token or some tokenized revenue \\n        address _oracle, // oracle for price of collateral \\n        uint256 _collateral_balance, //promised collateral balance\\n        uint256 _collateral_type\\n    )  Instrument(vault, _borrower) {\\n        borrower = _borrower; \\n        principal = DUST* _principal; \\n        notionalInterest =DUST* _notionalInterest; \\n        duration = _duration;   \\n        faceValue = DUST*_faceValue;\\n\\n        collateral = _collateral; \\n        oracle = _oracle; \\n        collateral_balance = DUST*_collateral_balance; \\n        collateral_type = CollateralType(_collateral_type); \\n\\n        loanStatus = LoanStatus.notApproved; \\n\\n        proxy = new Proxy(address(this), _borrower); \\n    }\\n\\n    function getCurrentTime() internal view returns(uint256){\\n        return block.timestamp + 31536000/2; \\n    }\\n    function getProxy() public view returns(address){\\n        return address(proxy); \\n    }\\n\\n    /// @notice checks if the creditline is ready to be withdrawed, i.e all \\n    /// loans have been paid, all non-underlying have been liquidated, etc\\n    function readyForWithdrawal() public view override returns(bool){\\n        if (loanStatus == LoanStatus.matured || loanStatus == LoanStatus.isDefault\\n            || loanStatus == LoanStatus.prepayment_fulfilled) return true; \\n        return true; \\n        //return false  \\n    }\\n\\n    function getApprovedBorrowConditions() public view returns(uint256, uint256){\\n        if (vault.isTrusted(this)) return(principal, notionalInterest) ;\\n\\n        return (0,0); \\n    }\\n\\n    /// @notice if possible, and borrower defaults, liquidates given collateral to underlying\\n    /// and push back to vault. If not possible, push the collateral back to\\n    function liquidateAndPushToVault() internal  {}\\n    function auctionAndPushToVault() internal {} \\n    function isLiquidatable(address collateral) public view returns(bool){}\\n\\n    /// @notice if collateral is liquidateable and has oracle, fetch value of collateral \\n    /// and return ratio to principal \\n    function getCollateralRatio() public view returns(uint256){\\n\\n    }\\n    /// @notice After grace period auction off ownership to some other party and transfer the funds back to vault \\n    /// @dev assumes collateral has already been transferred to vault, needs to be checked by the caller \\n    function liquidateOwnership(address buyer) public virtual onlyAuthorized{\\n        // TODO implement auction \\n        proxy.changeOwnership(buyer);\\n    }\\n\\n    /// @notice transfers collateral back to vault when default \\n    function pushCollateralToVault(uint256 amount, address to) public virtual onlyAuthorized{\\n        require(loanStatus == LoanStatus.isDefault); \\n        ERC20(collateral).transfer(to, amount); \\n    }\\n\\n\\n\\n    /// @notice validators have to check these conditions at a human level too before approving \\n    function instrumentApprovalCondition() public override view returns(bool){\\n        // check if borrower has correct identity \\n\\n        // check if enough collateral has been added as agreed   \\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid){\\n            require(ERC20(collateral).balanceOf(address(this)) >= collateral_balance, \\\"Insufficient collateral\\\"); \\n        }\\n\\n        // // check if validator(s) are set \\n        // if (validators.length == 0) {revert(\\\"No validators\\\"); }\\n\\n        // Check if proxy has been given ownership\\n        if (collateral_type == CollateralType.ownership && proxy.numContracts() == 0) revert(\\\"Ownership \\\"); \\n\\n        return true; \\n    } \\n\\n    event DepositCollateral(uint256 amount);\\n    /// @notice borrower deposit promised collateral  \\n    function depositCollateral(uint256 amount) external onlyUtilizer {\\n        require(collateral!= address(0)); \\n        ERC20(collateral).transferFrom(msg.sender, address(this), amount); \\n        emit DepositCollateral(amount);\\n    }\\n\\n    /// @notice can only redeem collateral when debt is fully paid \\n    function releaseAllCollateral() internal {\\n        require(loanStatus == LoanStatus.matured || loanStatus == LoanStatus.prepayment_fulfilled, \\\"Loan status err\\\"); \\n\\n        ERC20(collateral).transfer(msg.sender,collateral_balance); \\n    }\\n\\n\\n\\n    /// @notice should only be called when (portion of) principal is repayed\\n    function adjustInterestOwed() internal {\\n\\n        uint256 remainingDuration = (drawdown_block + toSeconds(duration)) - getCurrentTime();\\n\\n        interestOwed = interestAPR.mulWadDown(toYear(remainingDuration).mulWadDown(principalOwed)); \\n    }\\n\\n    /// @param quoted_yield is in notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \\n    /// where area under curve is max_principal \\n    function onMarketApproval(uint256 max_principal, uint256 quoted_yield)  external override onlyVault {\\n        principal = max_principal; \\n        notionalInterest = quoted_yield; //this accounts for duration as well\\n        interestAPR = quoted_yield.divWadDown(duration.mulWadDown(principal)); \\n\\n        loanStatus = LoanStatus.approvedNotDrawdowned;\\n    }\\n\\n    function onMaturity() external onlyUtilizer {\\n        require(loanStatus == LoanStatus.prepayment_fulfilled || loanStatus == LoanStatus.matured,\\\"Not matured\\\"); \\n        require(block.number > resolveBlock, \\\"Block equal\\\"); \\n\\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid ){\\n            releaseAllCollateral(); \\n        }\\n\\n        else proxy.changeOwnership(borrower);\\n        \\n        bool isPrepaid = loanStatus == LoanStatus.prepayment_fulfilled? true:false;\\n        // Write to storage resolve details (principal+interest repaid, is prepaid, etc) \\n        vault.pingMaturity(address(this), isPrepaid); \\n\\n    }\\n\\n    /// @notice borrower can see how much to repay now starting from last repayment time, also used to calculated\\n    /// how much interest to repay for the current principalOwed, which can be changed \\n    function interestToRepay() public view returns(uint256){\\n\\n        // Normalized to year\\n        uint256 elapsedTime = toYear(getCurrentTime() - lastRepaymentTime);\\n        // Owed interest from last timestamp till now  + any unpaid interest that has accumulated\\n        return elapsedTime.mulWadDown(interestAPR.mulWadDown(principalOwed)) + accumulated_interest ; \\n    }\\n\\n    event Drawdown(uint256 amount);\\n    /// @notice Allows a borrower to borrow on their creditline.\\n    /// This creditline allows only lump sum drawdowns, all approved principal needs to be borrowed\\n    /// which would start the interest timer \\n    function drawdown() external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        require(loanStatus == LoanStatus.approvedNotDrawdowned, \\\"Already borrowed\\\"); \\n        loanStatus = LoanStatus.drawdowned; \\n\\n        drawdown_block = block.timestamp; \\n        lastRepaymentTime = block.timestamp;//-31536000/2; \\n\\n        totalOwed = principal + notionalInterest; \\n        principalOwed = principal; \\n        interestOwed = notionalInterest;\\n\\n        transfer_liq(msg.sender, principal); \\n\\n        emit Drawdown(principal);\\n    }\\n\\n    event Repay(uint256 amount);\\n    /// @notice allows a borrower to repay their loan\\n    /// Standard repayment structure is repaying interest for the owed principal periodically and\\n    /// whenever principal is repayed interest owed is decreased proportionally \\n    function repay( uint256 _repay_amount) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n\\n        uint256 owedInterest = interestToRepay(); \\n        uint256 repay_principal; \\n        uint256 repay_interest = _repay_amount; \\n\\n        // Push remaineder to repaying principal \\n        if (_repay_amount >= owedInterest){\\n            repay_principal += (_repay_amount - owedInterest);  \\n            repay_interest = owedInterest; \\n            accumulated_interest = 0; \\n        }\\n\\n        //else repay_amount is less than owed interest, accumulate the debt \\n        else accumulated_interest = owedInterest - repay_interest;\\n\\n        if(handleRepay(repay_principal, repay_interest)){\\n\\n            // Save resolve block, so that onMaturity can be called later\\n            resolveBlock = block.number; \\n\\n            // Prepayment //TODO cases where repayed a significant portion at the start but paid rest at maturity date\\n            if (isPaymentPremature()) loanStatus = LoanStatus.prepayment_fulfilled; \\n\\n            // Repayed at full maturity \\n            else loanStatus = LoanStatus.matured; \\n\\n        }\\n\\n        lastRepaymentTime = getCurrentTime();  \\n\\n        transfer_liq_from(msg.sender, address(this), _repay_amount);\\n\\n        emit Repay(_repay_amount);\\n\\n    }   \\n\\n    /// @notice updates balances after repayment\\n    /// need to remove min.\\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal returns(bool){\\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \\n        principalOwed -= Math.min(repay_principal, principalOwed);\\n        interestOwed -= Math.min(repay_interest, interestOwed);\\n\\n        principalRepayed += repay_principal;\\n        interestRepayed += repay_interest; \\n        if (repay_principal > 0) adjustInterestOwed(); \\n\\n        bool fullyRepayed = (principalOwed == 0 && interestOwed == 0)? true : false; \\n        return fullyRepayed; \\n    }\\n\\n    function setGracePeriod() external {}\\n\\n    /// @notice callable by anyone \\n    function beginGracePeriod() external {\\n       // require(block.timestamp >= drawdown_block + toSeconds(duration), \\\"time err\\\"); \\n        require(principalOwed > 0 && interestOwed > 0, \\\"repaid\\\"); \\n        gracePeriodStart = block.timestamp; \\n        loanStatus = LoanStatus.grace_period; \\n    }\\n\\n    function declareDefault() external onlyAuthorized {\\n       // require(gracePeriodStart + gracePeriod >= block.timestamp);\\n        require(loanStatus == LoanStatus.grace_period); \\n\\n        loanStatus = LoanStatus.isDefault; \\n    }\\n\\n    /// @notice should be called  at default by validators\\n    /// calling this function will go thorugh the necessary process\\n    /// to recoup bad debt, and will push the remaining funds to vault\\n    function onDefault() external onlyAuthorized{\\n        require(loanStatus == LoanStatus.isDefault); \\n\\n        // If collateral is liquidateable, liquidate at dex and push to vault\\n        if (isLiquidatable(collateral)) {\\n            liquidateAndPushToVault(); //TODO get pool \\n        }\\n\\n        // Else for non liquid governance tokens or ownership, should auction off \\n        else {\\n            auctionAndPushToVault(); \\n        }\\n\\n        //Testing purposes only \\n        underlying.transferFrom(msg.sender, address(this), principal/2); \\n\\n    }\\n\\n    /// @notice when principal/interest owed becomes 0, need to find out if this is prepaid\\n    function isPaymentPremature() internal returns(bool){\\n        // bool timeCondition = getCurrentTime() <= drawdown_block + toSeconds(duration); \\n        bool amountCondition = (principal+notionalInterest) > (principalRepayed + interestRepayed) + DUST; \\n\\n        // timeCondition implies amountCondition, but not the other way around \\n        return amountCondition; \\n    }\\n\\n\\n    function toYear(uint256 sec) internal pure returns(uint256){\\n        return (sec*1e18)/uint256(31536000); \\n    }\\n\\n    function toSeconds(uint256 y) internal pure returns(uint256){\\n        return uint256(31536000).mulWadDown(y); \\n    }\\n\\n    function getRemainingOwed() public view returns(uint256, uint256){\\n        return(principalOwed, interestOwed); \\n    }\\n\\n    function getCurrentLoanStatus() public view returns(uint256){}\\n\\n\\n\\n\\n\\n}\\n\\n\\ncontract Proxy{\\n    address owner; \\n    address delegator; \\n\\n    address[] public ownedContracts;\\n    mapping(address=>bytes4) public ownerTransferFunctions; \\n    mapping(address=>bool) public isValidContract; \\n\\n    /// @notice owner is first set to be the instrument contract\\n    /// and is meant to be changed back to the borrower or whoever is\\n    /// buying the ownership \\n    constructor(address _owner, address _delegator){\\n        owner = _owner; \\n        delegator = _delegator; \\n\\n    }\\n\\n    function changeOwnership(address newOwner) external {\\n        require(msg.sender == owner, \\\"Not owner\\\"); \\n        owner = newOwner; \\n    }\\n\\n    function numContracts() public view returns(uint256){\\n        return ownedContracts.length; \\n    }\\n\\n    /// @notice temporarily delegate ownership of relevant contract \\n    /// to this address, and stores the ownership transfering function\\n    /// called when initialized\\n    /// @param ownershipFunction is selector of the functions that transfers\\n    /// ownership \\n    /// @dev called by the borrower during assessment, after they had given ownership \\n    /// of the contract to this address first, \\n    /// but ownerTransferfunction/contract needs to be checked before approval by the validators\\n    /// Validators are responsible for checking if there isn't any other ownership transferring functions \\n    /// and check that the contract is legit, and think ways that the borrower can game the system. \\n    function delegateOwnership(\\n        address _contract, \\n        bytes4 ownershipFunction) external \\n    {\\n        ownedContracts.push(_contract); \\n        isValidContract[_contract] = true; \\n        ownerTransferFunctions[_contract] = ownershipFunction; \\n\\n    }\\n\\n    /// @notice transfers ownership to borrower or any other party if necessary\\n    function grantOwnership(\\n        address _contract, \\n        address newOwner,\\n        bytes calldata data, \\n        bool isSingleArgument) external{   \\n        require(msg.sender == owner);\\n        require(isValidContract[_contract]);\\n        if(newOwner != address(this)) isValidContract[_contract] = false; \\n\\n        if(isSingleArgument){\\n            (bool success, ) = _contract.call(\\n                abi.encodeWithSelector(\\n                    ownerTransferFunctions[_contract], \\n                    newOwner\\n                )\\n            );  \\n            require(success, \\\"!success\\\"); \\n        }\\n\\n        else{\\n            require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \\\"func not allowed\\\"); \\n            (bool success, ) = _contract.call(data);\\n            require(success, \\\"!success\\\"); \\n\\n        }\\n    }\\n\\n    /// @notice function that ownership delegators use to call functions \\n    /// in their contract other than the transferFunction contract \\n    function proxyFunc(address _contract, bytes calldata data) external{\\n        require(msg.sender == delegator); \\n        require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \\\"func not allowed\\\"); \\n\\n        (bool success, ) = _contract.call(data); \\n        require(success, \\\"!success\\\"); \\n\\n    }\\n\\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\\n        if (inBytes.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            outBytes4 := mload(add(inBytes, 4))\\n        }\\n    }\\n\\n    function getOwner() public view returns(address){\\n        return owner; \\n    }\\n}\\n\\n\\ncontract MockBorrowerContract{\\n\\n    address public owner; \\n    constructor(){\\n        owner = msg.sender;  \\n    }\\n\\n    function changeOwner(address newOwner) public {\\n        require(msg.sender == owner, \\\"notowner\\\"); \\n        owner = newOwner; \\n    } \\n\\n    function onlyOwnerFunction(uint256 a) public {\\n        console.log('msgsender', msg.sender, owner); \\n        require(msg.sender == owner, \\\"notowner\\\"); \\n        console.log('hello', a); \\n    }\\n\\n    function autoDelegate(address proxyad) public {\\n        Proxy(proxyad).delegateOwnership(address(this), this.changeOwner.selector); \\n    }\\n    fallback () external {\\n        console.log('hi?'); \\n    }\\n}\\n\",\"keccak256\":\"0xf34715ea1110296203b24a590ae46a392eac6ac091927598552994a49b6e7824\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n// import {ERC20} from \\\"../../ERC20/ERC20.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    uint immutable underlying_decimals; \\n    uint8 constant default_decimals = 18; \\n    bool public decimal_mismatch; \\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, default_decimals) {\\n        asset = _asset;\\n\\n        underlying_decimals = _asset.decimals(); \\n        decimal_mismatch = (_asset.decimals() != default_decimals);\\n        if(decimal_mismatch) assert(_asset.decimals() < default_decimals);  \\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function burn(uint256 shares) public virtual {\\n        _burn(msg.sender, shares);\\n    }\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \\n                : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if(decimal_mismatch) shares = decSharesToAssets(shares); \\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \\n                : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \\n                : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \\n\\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \\n                : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function decAssetsToShares(uint256 assets) public view virtual returns(uint256) {\\n        return assets * (10 ** (default_decimals - underlying_decimals)); \\n    }\\n\\n    function decSharesToAssets(uint256 shares) public view virtual returns(uint256){\\n        return shares / (10**(default_decimals - underlying_decimals)); \\n    }\\n}\\n\",\"keccak256\":\"0xe3819a59ee062bb8a99e9ddddbdf15e3cef2e6eb3068072309d9d189243af5ff\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9faabac0803e077fb8d8950f5e2fec1984d3e6cd6ad5fc144609b5c9de83d169\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0x636e0f18c1b287c9342e14660a914b37a927d9f64d6c29e27016784979ce8d59\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/vault.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"./auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"./mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"./utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"./utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"./instrument.sol\\\";\\nimport {PoolInstrument} from \\\"../instruments/poolInstrument.sol\\\";\\nimport {Controller} from \\\"../protocol/controller.sol\\\";\\nimport {MarketManager} from \\\"../protocol/marketmanager.sol\\\"; \\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\ncontract Vault is ERC4626{\\n    using SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal BASE_UNIT;\\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\\n    ERC20 public immutable UNDERLYING;\\n    Controller private controller;\\n    MarketManager.MarketParameters default_params; \\n\\n    ///// For Factory\\n    bool public onlyVerified; \\n    uint256 public r; //reputation ranking  \\n    uint256 public asset_limit; \\n    uint256 public total_asset_limit; \\n\\n    mapping(Instrument => InstrumentData) public instrument_data;\\n    // mapping(address => uint256) public  num_proposals;\\n    mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\\n    mapping(uint256 => bool) resolveBeforeMaturity;\\n    mapping(uint256=>ResolveVar) prepareResolveBlock;\\n\\n    enum InstrumentType {\\n        CreditLine,\\n        CoveredCallShort,\\n        LendingPool, \\n        StraddleBuy, \\n        LiquidityProvision, \\n        Other\\n    }\\n\\n\\n    /// @param trusted Whether the Instrument is trusted.\\n    /// @param balance The amount of underlying tokens held in the Instrument.\\n    struct InstrumentData {\\n      bytes32 name;\\n      bool isPool; \\n      // Used to determine if the Vault will operate on a Instrument.\\n      bool trusted;\\n      // Balance of the contract denominated in Underlying, \\n      // used to determine profit and loss during harvests of the Instrument.  \\n      // represents the amount of debt the Instrument has incurred from this vault   \\n      uint256 balance; // in underlying, IMPORTANT to get this number right as it modifies key states \\n      uint256 faceValue; // in underlying\\n      uint256 marketId;\\n      uint256 principal; //this is total available allowance in underlying\\n      uint256 expectedYield; // total interest paid over duration in underlying\\n      uint256 duration;\\n      string description;\\n      address instrument_address;\\n      InstrumentType instrument_type;\\n      uint256 maturityDate;\\n      PoolData poolData; \\n    }\\n\\n    /// @notice probably should have default parameters for each vault\\n    struct PoolData{\\n      uint256 saleAmount; \\n      uint256 initPrice; // init price of longZCB in the amm \\n      uint256 promisedReturn; //per unit time \\n      uint256 inceptionTime;\\n      uint256 inceptionPrice; // init price of longZCB after assessment \\n      uint256 leverageFactor; //leverageFactor * manager collateral = capital from vault to instrument\\n      uint256 managementFee; // sum of discounts for high reputation managers/validators\\n    }\\n\\n    struct ResolveVar{\\n        uint256 endBlock; \\n        bool isPrepared; \\n    }\\n    address public owner; \\n    constructor(\\n        address _UNDERLYING,\\n        address _controller, \\n        address _owner, \\n\\n        bool _onlyVerified, //\\n        uint256 _r, //reputation ranking\\n        uint256 _asset_limit, \\n        uint256 _total_asset_limit,\\n\\n        MarketManager.MarketParameters memory _default_params\\n    )\\n        ERC4626(\\n            ERC20(_UNDERLYING),\\n            string(abi.encodePacked(\\\"Ramm \\\", ERC20(_UNDERLYING).name(), \\\" Vault\\\")),\\n            string(abi.encodePacked(\\\"RAMM\\\", ERC20(_UNDERLYING).symbol()))\\n        )  \\n\\n    {   \\n        owner = _owner; \\n        UNDERLYING = ERC20(_UNDERLYING);\\n        require(UNDERLYING.decimals() == 18, \\\"decimals\\\"); \\n        BASE_UNIT = 1e18; \\n        controller = Controller(_controller);\\n        //set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \\n        onlyVerified = _onlyVerified; \\n        r = _r; \\n        asset_limit = _asset_limit; \\n        total_asset_limit = _total_asset_limit; \\n        default_params = _default_params; \\n    }\\n\\n    function getInstrumentType(uint256 marketId) public view returns(uint256){\\n        // return 0 if credit line //TODO \\n        return 0; \\n    }\\n\\n    function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\\n        return instrument_data[_instrument];\\n    }\\n    \\n    function _onlyController() view internal {\\n        require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \\\"is not controller\\\"); \\n    }\\n\\n    modifier onlyController(){\\n        _onlyController();\\n        _;\\n    }\\n\\n    /// @notice called by controller at maturity \\n    // function controller_burn(uint256 amount, address bc_address) external onlyController {\\n    //     _burn(bc_address,amount); \\n    // }\\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\\n    // function controller_mint(uint256 amount, address to) external onlyController {\\n    //     _mint(to , amount); \\n    // }\\n    /// @notice amount is always in WAD, so need to convert if decimals mismatch\\n    function trusted_transfer(uint256 amount, address to) external onlyController{\\n        if (decimal_mismatch) amount = decSharesToAssets(amount); \\n        UNDERLYING.transfer(to, amount); \\n    }\\n\\n    function balanceInUnderlying(address ad) external view returns(uint256){\\n        return previewRedeem(balanceOf[ad]); \\n    }\\n\\n    /// @notice burns all balance of address \\n    // function burnAll(address to) private{\\n    //   _burn(to, balanceOf[to]); \\n    // }\\n\\n  struct localVars{\\n    uint256 promised_return; \\n    uint256 inceptionTime; \\n    uint256 inceptionPrice; \\n    uint256 leverageFactor; \\n    uint256 managementFee; \\n\\n    uint256 srpPlusOne; \\n    uint256 totalAssetsHeldScaled; \\n    uint256 juniorSupply;\\n    uint256 seniorSupply; \\n\\n    bool belowThreshold; \\n  }\\n  /// @notice get programmatic pricing of a pool based longZCB \\n  /// returns psu: price of senior(VT's share of investment) vs underlying \\n  /// returns pju: price of junior(longZCB) vs underlying\\n  function poolZCBValue(uint256 marketId) \\n    public \\n    view\\n    returns(uint256 psu, uint256 pju, uint256 levFactor){\\n      //TODO should not tick during assessment \\n    localVars memory vars; \\n\\n    (vars.promised_return, vars.inceptionTime, vars.inceptionPrice, vars.leverageFactor, \\n      vars.managementFee) = fetchPoolTrancheData(marketId); \\n    levFactor = vars.leverageFactor; \\n\\n    require(vars.inceptionPrice > 0, \\\"0\\\"); \\n\\n    // Get senior redemption price that increments per unit time \\n    vars.srpPlusOne = vars.inceptionPrice.mulWadDown((BASE_UNIT+ vars.promised_return)\\n      .rpow(block.timestamp - vars.inceptionTime, BASE_UNIT));\\n\\n    // Get total assets held by the instrument \\n    vars.juniorSupply = controller.getTotalSupply(marketId); \\n    vars.seniorSupply = vars.juniorSupply.mulWadDown(vars.leverageFactor); \\n    vars.totalAssetsHeldScaled = instrumentAssetOracle(marketId, vars.juniorSupply, vars.seniorSupply)\\n      .mulWadDown(vars.inceptionPrice); \\n\\n    if (vars.seniorSupply == 0) return(vars.srpPlusOne,vars.srpPlusOne,levFactor); \\n    \\n    // Check if all seniors can redeem\\n    if (vars.totalAssetsHeldScaled >= vars.srpPlusOne.mulWadDown(vars.seniorSupply))\\n      psu = vars.srpPlusOne; \\n    else{\\n      psu = vars.totalAssetsHeldScaled.divWadDown(vars.seniorSupply);\\n      vars.belowThreshold = true;  \\n    }\\n    // should be 0 otherwise \\n    if(!vars.belowThreshold) pju = (vars.totalAssetsHeldScaled \\n      - vars.srpPlusOne.mulWadDown(vars.seniorSupply)).divWadDown(vars.juniorSupply); \\n    uint pju_ = (BASE_UNIT+ vars.leverageFactor).mulWadDown(previewMint(BASE_UNIT.mulWadDown(vars.inceptionPrice))) \\n      -  vars.srpPlusOne.mulWadDown(vars.leverageFactor);\\n\\n    // assert(pju_ >= pju-10 || pju_ <= pju+10); \\n        // console.log('ok????'); \\n\\n    }\\n\\n    event InstrumentHarvest(address indexed instrument, uint256 totalInstrumentHoldings, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\\n\\n    /// @notice Harvest a trusted Instrument, records profit/loss \\n    function harvest(address instrument) public {\\n      require(instrument_data[Instrument(instrument)].trusted, \\\"UNTRUSTED_Instrument\\\");\\n      InstrumentData storage data = instrument_data[Instrument(instrument)]; \\n\\n      uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \\n      uint256 balanceLastHarvest = data.balance;\\n      uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\\n      \\n      if (balanceLastHarvest == balanceThisHarvest) {\\n          return;\\n      }\\n\\n      data.balance = balanceThisHarvest;\\n\\n      uint256 delta;\\n      bool net_positive = balanceThisHarvest >= balanceLastHarvest;\\n      delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\\n      totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\\n\\n      emit InstrumentHarvest(instrument, totalInstrumentHoldings, balanceThisHarvest, delta, net_positive);\\n    }\\n\\n    event InstrumentDeposit(uint256 indexed marketId, address indexed instrument, uint256 amount, bool isPool);\\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\\n    /// Called when market is approved. \\n    /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \\n    function depositIntoInstrument(\\n      uint256 marketId, \\n      uint256 underlyingAmount,\\n      bool isPool) onlyTrustedInstrument(fetchInstrument(marketId)) public virtual\\n  //onlyManager\\n    {\\n      Instrument instrument = fetchInstrument(marketId); \\n      // require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n\\n      // if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \\n\\n      uint256 curBalance = UNDERLYING.balanceOf(address(this)); \\n      if (underlyingAmount > curBalance) {\\n\\n        // check if can be pulled from lending pool, if yes do it\\n        uint256 required = underlyingAmount - curBalance; \\n        if(PoolInstrument(address(Instruments[0])).isWithdrawAble( address(this), required))  \\n          pullFromLM( required); \\n        else revert(\\\"!vaultbal\\\"); \\n      }\\n\\n      totalInstrumentHoldings += underlyingAmount; \\n      instrument_data[instrument].balance += underlyingAmount;\\n\\n      if(!isPool)\\n        require(UNDERLYING.transfer(address(instrument), underlyingAmount), \\\"DEPOSIT_FAILED\\\");\\n      else{\\n        // TODO keep track of all this \\n        UNDERLYING.approve(address(instrument), underlyingAmount); \\n        require(ERC4626(address(instrument)).deposit(underlyingAmount, address(this))>0, \\\"DEPOSIT_FAILED\\\");\\n\\n      }\\n\\n      emit InstrumentDeposit(marketId, address(instrument), underlyingAmount, isPool);\\n    }\\n\\n    modifier onlyTrustedInstrument(Instrument instrument) {\\n      _onlyTrustedInstrument(instrument);\\n      _;\\n    }\\n\\n    function _onlyTrustedInstrument(Instrument instrument) internal view {\\n      require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n    }\\n\\n    event InstrumentWithdrawal(uint256 indexed marketId, address indexed instrument, uint256 amount);\\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\\n    function withdrawFromInstrument(\\n      Instrument instrument, \\n      uint256 underlyingAmount, \\n      bool redeem) onlyTrustedInstrument(instrument) internal virtual {\\n      // require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n      \\n      // if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \\n\\n      instrument_data[instrument].balance -= underlyingAmount;\\n      \\n      totalInstrumentHoldings -= underlyingAmount;\\n      \\n      if (redeem) require(instrument.redeemUnderlying(underlyingAmount), \\\"REDEEM_FAILED\\\");\\n\\n      emit InstrumentWithdrawal(instrument_data[instrument].marketId, address(instrument), underlyingAmount);\\n    }\\n\\n    function withdrawFromPoolInstrument(\\n      uint256 marketId, \\n      uint256 instrumentPullAmount, \\n      address pushTo, \\n      uint256 underlyingAmount\\n      ) public virtual \\n    //onlyManager\\n    { \\n      // Send to withdrawer \\n      Instrument instrument = fetchInstrument( marketId); \\n      require(instrument.isLiquid(underlyingAmount + instrumentPullAmount), \\\"!liq\\\");\\n\\n      ERC4626(address(instrument)).withdraw(underlyingAmount + instrumentPullAmount, address(this), address(this)); \\n      UNDERLYING.transfer(pushTo, instrumentPullAmount); \\n\\n      //TODO instrument balance should decrease to 0 and stay solvent  \\n      //TODO can everyone redeem? does vault's instument share balance change when\\n      // mint-> redeem at different pjus? \\n      withdrawFromInstrument(fetchInstrument(marketId), underlyingAmount, false);\\n    }\\n\\n    event InstrumentTrusted(uint256 indexed marketId, address indexed instrument, uint256 principal, uint256 expectedYield, uint256 maturityDate);\\n    /// @notice Stores a Instrument as trusted when its approved\\n    function trustInstrument(\\n      uint256 marketId,\\n      Controller.ApprovalData memory data, \\n      bool isPool\\n      ) external virtual onlyController{\\n      instrument_data[fetchInstrument(marketId)].trusted = true;\\n\\n      //Write to storage \\n      if(!isPool){\\n        InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \\n        instrumentData.principal = data.approved_principal; \\n        instrumentData.expectedYield = data.approved_yield;\\n        instrumentData.faceValue = data.approved_principal + data.approved_yield; \\n\\n        depositIntoInstrument(marketId, data.approved_principal - data.managers_stake, false);\\n        \\n        // setMaturityDate(marketId);\\n        instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\\n\\n        fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \\n\\n      } else{\\n        instrument_data[Instruments[marketId]].poolData.inceptionTime = block.timestamp; \\n        depositIntoInstrument(marketId, data.approved_principal - data.managers_stake, true);\\n      }\\n      emit InstrumentTrusted(marketId, address(Instruments[marketId]), data.approved_principal, data.approved_yield, instrument_data[fetchInstrument(marketId)].maturityDate);\\n    }\\n\\n    /// @notice fetches how much asset the instrument has in underlying. \\n    function instrumentAssetOracle(\\n      uint256 marketId, \\n      uint256 juniorSupply, \\n      uint256 seniorSupply) public view returns(uint256){\\n      // Default balance oracle \\n      ERC4626 instrument = ERC4626(address(Instruments[marketId])); \\n      return (juniorSupply + seniorSupply).mulWadDown(instrument.previewMint(BASE_UNIT)); \\n      //TODO custom oracle \\n    }\\n\\n    /// @notice Stores a Instrument as untrusted\\n    // not needed?\\n    function distrustInstrument(Instrument instrument) external onlyController {\\n      instrument_data[instrument].trusted = false; \\n    }\\n\\n    function addLendingModule(address lv) external\\n    //onlyOwner\\n    { \\n      // The 0th instrument is always the lending module \\n      Instruments[0] = Instrument(lv);\\n      instrument_data[Instruments[0]].trusted = true; \\n      UNDERLYING.approve(lv, type(uint256).max); \\n    }\\n\\n    /// @notice push unutilized capital to leverage vault \\n    function pushToLM(uint256 amount) external \\n    //onlyOwner \\n    { \\n      // if amount=0, push everything this vault have \\n      uint256 bal = UNDERLYING.balanceOf(address(this)); \\n      require(amount<= bal, \\\"push exceeds liq\\\"); \\n      uint256 depositAmount = amount==0 ? bal : amount; \\n\\n      depositIntoInstrument(0, depositAmount, true); \\n    }\\n\\n    function pullFromLM(uint256 amount) public\\n    //onlyowner or internal \\n    {\\n\\n\\n      // check if amount is available liquidity, and is appropriate for the given\\n      // shares this vault has of it. \\n      Instrument instrument = fetchInstrument(0); \\n      uint256 shares = ERC4626(address(instrument)).balanceOf(address(this)); \\n      require(amount <= ERC4626(address(instrument)).previewMint(shares), \\\"!!liq1\\\" ); \\n      require(instrument.isLiquid(amount), \\\"!liq2\\\");\\n\\n      ERC4626(address(instrument)).withdraw(amount, address(this), address(this)); \\n\\n      withdrawFromInstrument(instrument, amount, false);\\n    }\\n\\n    /// @notice returns true if Instrument is approved\\n    function isTrusted(Instrument instrument) public view returns(bool){\\n      return instrument_data[instrument].trusted; \\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \\n    function totalAssets() public view override returns(uint256){\\n      return totalInstrumentHoldings + totalFloat();\\n    }\\n\\n    function utilizationRate() public view returns(uint256){\\n\\n        if (totalInstrumentHoldings==0) return 0;  \\n        return totalInstrumentHoldings.divWadDown(totalAssets()); \\n\\n    }\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    function fetchInstrument(uint256 marketId) public view returns(Instrument){\\n      return Instruments[marketId]; \\n    }\\n\\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\\n      return instrument_data[Instruments[marketId]];\\n    }\\n\\n    function fetchPoolTrancheData(uint256 marketId) public view returns(uint256, uint256, uint256, uint256, uint256){\\n      // InstrumentData memory data = instrument_data[Instruments[marketId]]; \\n      return (instrument_data[Instruments[marketId]].poolData.promisedReturn, instrument_data[Instruments[marketId]].poolData.inceptionTime, \\n            instrument_data[Instruments[marketId]].poolData.inceptionPrice, instrument_data[Instruments[marketId]].poolData.leverageFactor, instrument_data[Instruments[marketId]].poolData.managementFee); \\n    }\\n  \\n    event InstrumentRemoved(uint256 indexed marketId, address indexed instrumentAddress);\\n    /**\\n     called on market denial + removal, maybe no chekcs?\\n     */\\n    function removeInstrument(uint256 marketId) internal {\\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\\n        require(data.marketId > 0, \\\"instrument doesn't exist\\\");\\n        delete instrument_data[Instruments[marketId]];\\n        delete Instruments[marketId];\\n        // emit event here;\\n        emit InstrumentRemoved(marketId, address(Instruments[marketId]));\\n    }\\n\\n    // event PoolAdded(\\n    //   uint256 indexed marketId,\\n    //   address indexed instrumentAddress,\\n    //   bytes32 indexed name,\\n    //   uint256 saleAmount, \\n    //   uint256 initPrice, // init price of longZCB in the amm \\n    //   uint256 promisedReturn, //per unit time \\n    //   uint256 inceptionTime,\\n    //   uint256 inceptionPrice, // init price of longZCB after assessment \\n    //   uint256 leverageFactor, //leverageFactor * manager collateral = capital from vault to instrument\\n    //   uint256 managementFee\\n    // );\\n\\n    // event InstrumentAdded(\\n    //   uint256 indexed marketId,\\n    //   address indexed instrumentAddress,\\n    //   bytes32 indexed name,\\n    //   uint256 faceValue,\\n    //   uint256 principal,\\n    //   uint256 expectedYield,\\n    //   uint256 duration,\\n    //   uint256 maturityDate,\\n    //   InstrumentType instrumentType,\\n    //   bool isPool\\n    // );\\n\\n    // event ProposalAdded(InstrumentData data);\\n    /// @notice add instrument proposal created by the Utilizer \\n    /// @dev Instrument instance should be created before this is called\\n    /// need to add authorization\\n    function addProposal(\\n        InstrumentData memory data\\n    ) external onlyController {\\n      if(!data.isPool){\\n        require(data.principal > 0, \\\"principal must be greater than 0\\\");\\n        require(data.duration > 0, \\\"duration must be greater than 0\\\");\\n        require(data.faceValue > 0, \\\"faceValue must be greater than 0\\\");\\n        require(data.principal >= BASE_UNIT, \\\"Needs to be in decimal format\\\"); \\n        require(data.marketId > 0, \\\"must be valid instrument\\\");\\n      }\\n        // num_proposals[msg.sender] ++; \\n        // TODO indexed by id\\n        instrument_data[Instrument(data.instrument_address)] = data;  \\n\\n        Instruments[data.marketId] = Instrument(data.instrument_address);\\n        // emit ProposalAdded(data);\\n    }\\n\\n    //event MaturityDateSet(uint256 indexed marketId, address indexed instrument, uint256 maturityDate);\\n  \\n    // function setMaturityDate(uint256 marketId) internal {\\n\\n    //     instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\\n    //     emit MaturityDateSet(marketId, address(fetchInstrument(marketId)), instrument_data[fetchInstrument(marketId)].maturityDate);\\n    // }\\n\\n    /// @notice function called when instrument resolves from within\\n    function pingMaturity(address instrument, bool premature) external {\\n        require(msg.sender == instrument || isTrusted(Instrument(instrument))); \\n        uint256 marketId = instrument_data[Instrument(instrument)].marketId; \\n        beforeResolve(marketId); \\n        resolveBeforeMaturity[marketId] = premature; \\n    }\\n\\n    /// @notice RESOLVE FUNCTION #1\\n    /// Checks if instrument is ready to be resolved and locks capital.\\n    /// records blocknumber such that resolveInstrument is called after this function \\n    /// records balances+PnL of instrument\\n    /// @dev need to store internal balance that is used to calculate the redemption price \\n    function beforeResolve(uint256 marketId) public {\\n        Instrument _instrument = Instruments[marketId]; \\n\\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \\\"Not allowed\\\"); \\n        require(isTrusted( _instrument), \\\"Not trusted\\\"); \\n\\n        // Should revert if can't be resolved \\n        _instrument.prepareWithdraw();\\n\\n        // Record profit/loss used for calculation of redemption price \\n        harvest(address(_instrument));\\n\\n        _instrument.store_internal_balance(); \\n        prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \\n      }\\n\\n\\n    //event InstrumentResolve(uint256 indexed marketId, uint256 instrumentBalance, bool atLoss, uint256 extraGain, uint256 totalLoss, bool prematureResolve);\\n    /// @notice RESOLVE FUNCTION #2\\n    /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \\n    /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\\n    function resolveInstrument(\\n        uint256 marketId\\n    ) external onlyController\\n    returns(bool, uint256, uint256, bool) {\\n        Instrument _instrument = Instruments[marketId];\\n        ResolveVar memory rvar = prepareResolveBlock[marketId]; \\n        require(_instrument.isLocked(), \\\"Not Locked\\\");\\n        // require(rvar.isPrepared && rvar.endBlock < block.number, \\\"can't resolve\\\"); \\n\\n        // uint256 bal = UNDERLYING.balanceOf(address(this)); \\n        uint256 instrument_balance = _instrument.getMaturityBalance(); \\n\\n        // InstrumentData memory data = instrument_data[_instrument];\\n\\n        bool prematureResolve = resolveBeforeMaturity[marketId]; \\n        bool atLoss; \\n        uint256 total_loss; \\n        uint256 extra_gain; \\n\\n        // If resolved at predetermined maturity date, loss is defined by\\n        // the event the instrument has paid out all its yield + principal \\n        if (!prematureResolve){\\n            atLoss = instrument_balance < instrument_data[_instrument].faceValue;\\n            total_loss = atLoss ? instrument_data[_instrument].faceValue - instrument_balance : 0;\\n            extra_gain = !atLoss ? instrument_balance - instrument_data[_instrument].faceValue : 0;\\n        }\\n\\n        // If resolved before predetermined maturity date, loss is defined by \\n        // the event the instrument has balance less then principal \\n        else {\\n            atLoss = instrument_balance < instrument_data[_instrument].principal; \\n            total_loss = atLoss? instrument_data[_instrument].principal - instrument_balance :0; \\n        }\\n\\n        withdrawFromInstrument(_instrument, instrument_balance, true);\\n        removeInstrument(instrument_data[_instrument].marketId);\\n\\n        //emit InstrumentResolve(marketId, instrument_balance, atLoss, extra_gain, total_loss, prematureResolve);\\n\\n        return(atLoss, extra_gain, total_loss, prematureResolve); \\n    }\\n\\n    /// @notice when market resolves, send back pulled collateral from managers \\n    function repayDebt(address to, uint256 amount) external onlyController{\\n        UNDERLYING.transfer(to, amount); \\n    }\\n\\n    event InstrumentDeny(uint256 indexed marketId);\\n    /**\\n     called on market denial by controller => denied before approval\\n     */\\n    function denyInstrument(uint256 marketId) external onlyController {\\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\\n\\n        require(marketId > 0 && data.instrument_address != address(0), \\\"invalid instrument\\\");\\n\\n        require(!data.trusted, \\\"can't deny approved instrument\\\");\\n        emit InstrumentDeny(marketId);\\n        removeInstrument(marketId);\\n    }\\n\\n\\n    function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\\n      return Instruments[marketId].instrumentApprovalCondition(); \\n    }\\n\\n    /// TODO \\n    function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\\n      return amount; \\n    }\\n\\n\\n    /// @notice types of restrictions are: \\n    /// a) verified address b) reputation scores \\n    function receiver_conditions(address receiver) public view returns(bool){\\n        return true; \\n    }\\n\\n    /// @notice called when constructed, params set by the creater of the vault \\n    // function set_minting_conditions(\\n    //   bool _onlyVerified, \\n    //   uint256 _r, \\n    //   uint256 _asset_limit,\\n    //   uint256 _total_asset_limit) internal{\\n    //     onlyVerified = _onlyVerified; \\n    //     r = _r; \\n    //     asset_limit = _asset_limit; \\n    //     total_asset_limit = _total_asset_limit; \\n    // } \\n\\n\\n    function get_vault_params() public view returns(MarketManager.MarketParameters memory){\\n      return default_params; \\n    }\\n\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\\n      require(enoughLiqudity(assets), \\\"Not enough liqudity in vault\\\"); \\n\\n    }\\n\\n    /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\\n    /// (excluding those supplied to existing instruments)\\n    /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\\n    /// should be (soft)maxed and tunable by a parameter \\n    function enoughLiqudity(uint256 amounts) public view returns(bool){\\n        return (UNDERLYING.balanceOf(address(this)) >= amounts); \\n    }\\n\\n\\n    /// @notice function that closes instrument prematurely \\n    function closeInstrument(uint256 marketId) external onlyController{\\n      Instrument instrument = fetchInstrument( marketId); \\n\\n      // If instrument has non-underlying tokens, liquidate them first. \\n      instrument.liquidateAllPositions(); \\n\\n    }\\n\\n    function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\\n        // InstrumentData memory data = instrument_data[Instruments[marketId]];\\n        return (instrument_data[Instruments[marketId]].principal, instrument_data[Instruments[marketId]].expectedYield); \\n    }\\n\\n    /// @notice a minting restrictor is set for different vaults \\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\\n        if (!receiver_conditions(receiver)) revert(\\\"Minting Restricted\\\"); \\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n\\n    /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \\n     function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        assets = deduct_withdrawal_fees(assets); \\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n}\",\"keccak256\":\"0x3af51acfd7e905ec07e393351f376ce49f754d2dfb0988bb5b746b89b7cd7d30\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 /* firstTokenId */,\\n        uint256 batchSize\\n    ) internal virtual {\\n        if (batchSize > 1) {\\n            if (from != address(0)) {\\n                _balances[from] -= batchSize;\\n            }\\n            if (to != address(0)) {\\n                _balances[to] += batchSize;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n}\\n\",\"keccak256\":\"0x5b58c0def48629fb952407199c42b974af2c49cf554a5027312df3fbf05eec28\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xec73066434a92377fb5d8e0f4d9b12abaa91efdd67220e74856422ea1d64c817\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\n\\n        if (batchSize > 1) {\\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\\n            revert(\\\"ERC721Enumerable: consecutive transfers not supported\\\");\\n        }\\n\\n        uint256 tokenId = firstTokenId;\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\",\"keccak256\":\"0xa8796bd16014cefb8c26449413981a49c510f92a98d6828494f5fd046223ced3\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd1556954440b31c97a142c6ba07d5cade45f96fafd52091d33a14ebe365aecbf\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe74d3d16da6172c8ea8493c14a3b02d75ee42120a4381f5b409bb83587395973\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5d9242699672087b2f423dfab23a3b8326448f58da4e38cd9e4ba6a3e7e153a2\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa80cb30fccbba7c8ff72ac82cc898576a78d4c3031e85676840048f3fe195f5d\",\"license\":\"MIT\"},\"lib/solmate/src/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa404f6f45bd53f24a90cc5ffe95e16b52e3f2dfd88f0d7a1edcb35f815919a7b\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x04af19f16f00ba65ae168d6d10da5210dc18da6bcec6974dccf984ba388aa22d\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\",\"keccak256\":\"0xb282dd78aa7375d6b200b9a5d8dd214b2e5df1004f8217a4b4c2b07f0c5bfd01\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\\n        require(x < 1 << 16);\\n\\n        y = uint16(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0xb784a14411858036491124e677aecde6d500e695b7a70c74aa8f1001bda2ccab\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xbadf3d708cf532b12f75f78a1d423135954b63774a6d4ba15914a551d348db8a\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6080604052760100000000000000000000000000000000000000000001600d553480156200002c57600080fd5b5060405162002fd138038062002fd18339810160408190526200004f91620000d8565b604051806040016040528060078152602001662920a6a690363b60c91b815250604051806040016040528060068152602001652930b6b6a62b60d11b81525081600090816200009f9190620001af565b506001620000ae8282620001af565b5050600a80546001600160a01b0319166001600160a01b039390931692909217909155506200027b565b600060208284031215620000eb57600080fd5b81516001600160a01b03811681146200010357600080fd5b9392505050565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806200013557607f821691505b6020821081036200015657634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620001aa57600081815260208120601f850160051c81016020861015620001855750805b601f850160051c820191505b81811015620001a65782815560010162000191565b5050505b505050565b81516001600160401b03811115620001cb57620001cb6200010a565b620001e381620001dc845462000120565b846200015c565b602080601f8311600181146200021b5760008415620002025750858301515b600019600386901b1c1916600185901b178555620001a6565b600085815260208120601f198616915b828110156200024c578886015182559484019460019091019084016200022b565b50858210156200026b5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b612d46806200028b6000396000f3fe608060405234801561001057600080fd5b506004361061018e5760003560e01c80636352211e116100de578063b88d4fde11610097578063db61598511610071578063db6159851461020e578063e985e9c51461040a578063eb02c30114610446578063f0a856441461020e57600080fd5b8063b88d4fde146103c3578063c87b56dd146103d6578063d004b036146103ea57600080fd5b80636352211e146102dd57806370a08231146102f0578063794799c01461030357806395d89b411461032457806399fbab881461032c578063a22cb465146103b057600080fd5b80632f745c591161014b57806342842e0e1161012557806342842e0e1461027b5780634f6ccce71461028e57806352e59b231461020e5780635da6f921146102a157600080fd5b80632f745c591461023557806334a8ee14146102485780633eeb530e1461025b57600080fd5b806301ffc9a71461019357806306fdde03146101bb578063081812fc146101d0578063095ea7b3146101fb57806318160ddd1461021057806323b872dd14610222575b600080fd5b6101a66101a1366004612661565b610466565b60405190151581526020015b60405180910390f35b6101c3610491565b6040516101b291906126c4565b6101e36101de3660046126d7565b610523565b6040516001600160a01b0390911681526020016101b2565b61020e610209366004612705565b61054a565b005b6008545b6040519081526020016101b2565b61020e610230366004612731565b610664565b610214610243366004612705565b610695565b61020e610256366004612772565b61072b565b61026e61026936600461279e565b610e26565b6040516101b291906127fb565b61020e610289366004612731565b610f50565b61021461029c3660046126d7565b610f6b565b61020e6102af366004612849565b6000918252600c602052604090912080546001600160a01b0319166001600160a01b03909216919091179055565b6101e36102eb3660046126d7565b610ffe565b6102146102fe36600461279e565b61105e565b610316610311366004612772565b6110e4565b6040516101b2929190612879565b6101c3611764565b61037961033a3660046126d7565b600b602052600090815260409020805460018201546002830154600384015460048501546005909501546001600160a01b039094169492939192909186565b604080516001600160a01b0390971687526020870195909552938501929092526060840152608083015260a082015260c0016101b2565b61020e6103be36600461289b565b611773565b61020e6103d13660046128df565b611782565b6101c36103e43660046126d7565b50606090565b6103fd6103f836600461279e565b6117ba565b6040516101b291906129bf565b6101a66104183660046129f7565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b6104596104543660046126d7565b61185e565b6040516101b29190612a25565b60006001600160e01b0319821663780e9d6360e01b148061048b575061048b826118c8565b92915050565b6060600080546104a090612a33565b80601f01602080910402602001604051908101604052809291908181526020018280546104cc90612a33565b80156105195780601f106104ee57610100808354040283529160200191610519565b820191906000526020600020905b8154815290600101906020018083116104fc57829003601f168201915b5050505050905090565b600061052e82611918565b506000908152600460205260409020546001600160a01b031690565b600061055582610ffe565b9050806001600160a01b0316836001600160a01b0316036105c75760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b60648201526084015b60405180910390fd5b336001600160a01b03821614806105e357506105e38133610418565b6106555760405162461bcd60e51b815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c00000060648201526084016105be565b61065f838361197a565b505050565b61066e33826119e8565b61068a5760405162461bcd60e51b81526004016105be90612a6d565b61065f838383611a67565b60006106a08361105e565b82106107025760405162461bcd60e51b815260206004820152602b60248201527f455243373231456e756d657261626c653a206f776e657220696e646578206f7560448201526a74206f6620626f756e647360a81b60648201526084016105be565b506001600160a01b03919091166000908152600660209081526040808320938352929052205490565b61075d6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b6000838152600b6020908152604091829020825160c08101845281546001600160a01b03168152600182015492810183905260028201549381019390935260038101546060840152600481015460808401526005015460a08301528311156107fe5760405162461bcd60e51b81526020600482015260146024820152733630b933b2b9103a3430b7103837b9b4ba34b7b760611b60448201526064016105be565b600a54604051634632752560e11b8152600481018790526000916001600160a01b031690638c64ea4a90602401602060405180830381865afa158015610848573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086c9190612aba565b90506000816001600160a01b031663c5d664c66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d29190612aba565b6000888152600c60205260409081902054905163b3d7f6b960e01b8152600481018890529192506001600160a01b03908116918184169163095ea7b391849187169063b3d7f6b990602401602060405180830381865afa15801561093a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095e9190612ad7565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af11580156109a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109cd9190612af0565b50602085018690525b602085015115610d4f576109f28460a001518660200151611bd8565b60808601819052604051635d043b2960e11b81526004810191909152306024820181905260448201526001600160a01b0384169063ba087652906064016020604051808303816000875af1158015610a4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a729190612ad7565b808652604051631fd0956760e01b815260048101919091523060248201526001600160a01b03821690631fd09567906044016020604051808303816000875af1158015610ac3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ae79190612ad7565b50604051636e9c33bd60e11b81526001600160a01b0384811660048301526000602483015230604483015282169063dd38677a906064016020604051808303816000875af1158015610b3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b619190612ad7565b856040018181525050610b94604051806040016040528060098152602001685f5f5f4e45575f5f5f60b81b815250611bf1565b610bc76040518060400160405280600d81526020016c1dda5d1a191c985dc81b19599d609a1b8152508660200151611c34565b610c096040518060400160405280600f81526020016e72656465656d65642073686172657360881b815250610c048660a001518860200151611bd8565b611c34565b610c3f6040518060400160405280601081526020016f1c995919595b59590bdc995c185e595960821b8152508660000151611c34565b610c6c604051806040016040528060078152602001661c995b5bdd995960ca1b8152508660400151611c34565b846080015185602001818151610c829190612b23565b9052508451606086018051610c98908390612b36565b905250602085015160a08501511015610cb5578460400151610cd8565b846040015185602001518560a00151610cce9190612b23565b610cd89190612b36565b60a08501526040805180820190915260128152711d1bdd185b105cdcd95d14995d1d5c9b995960721b60208201526060860151610d159190611c34565b610d4a6040518060400160405280600f81526020016e656e64537461746542616c616e636560881b8152508560a00151611c34565b6109d6565b8584602001818151610d619190612b23565b9052506060808601519085015110610d9157846060015184606001818151610d899190612b23565b905250610dbd565b60006060808601829052860151610da89190612b23565b84604001818151610db99190612b23565b9052505b5050506000938452600b6020908152604094859020825181546001600160a01b0319166001600160a01b03909116178155908201516001820155938101516002850155606081015160038501556080810151600485015560a00151600590930192909255505050565b60606000610e33836117ba565b90506000815167ffffffffffffffff811115610e5157610e516128c9565b604051908082528060200260200182016040528015610e8a57816020015b610e7761260c565b815260200190600190039081610e6f5790505b50905060005b8251811015610f4857600b6000848381518110610eaf57610eaf612b49565b6020908102919091018101518252818101929092526040908101600020815160c08101835281546001600160a01b0316815260018201549381019390935260028101549183019190915260038101546060830152600481015460808301526005015460a08201528251839083908110610f2a57610f2a612b49565b60200260200101819052508080610f4090612b5f565b915050610e90565b509392505050565b61065f83838360405180602001604052806000815250611782565b6000610f7660085490565b8210610fd95760405162461bcd60e51b815260206004820152602c60248201527f455243373231456e756d657261626c653a20676c6f62616c20696e646578206f60448201526b7574206f6620626f756e647360a01b60648201526084016105be565b60088281548110610fec57610fec612b49565b90600052602060002001549050919050565b6000818152600260205260408120546001600160a01b03168061048b5760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016105be565b60006001600160a01b0382166110c85760405162461bcd60e51b815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f7420612076616044820152683634b21037bbb732b960b91b60648201526084016105be565b506001600160a01b031660009081526003602052604090205490565b60006110ee61260c565b61115f60405180610160016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160008152602001600081526020016000151581526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600a54604051634632752560e11b8152600481018890526001600160a01b0390911690638c64ea4a90602401602060405180830381865afa1580156111a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111cc9190612aba565b6001600160a01b0316808252604080516362eb326360e11b815290516000929163c5d664c69160048083019260209291908290030181865afa158015611216573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061123a9190612aba565b6040516323b872dd60e01b8152336004820152306024820152604481018890529091506001600160a01b038216906323b872dd906064016020604051808303816000875af1158015611290573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b49190612af0565b5081516001600160a01b0382169063095ea7b3906112e46112dd89670de0b6b3a7640000612b36565b8a90611c79565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af115801561132f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113539190612af0565b506000878152600c6020908152604091829020546001600160a01b03168482018190528251631d09b9e960e21b815292519092637426e7a49260048083019391928290030181865afa1580156113ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d19190612ad7565b61010083018190526000036114195760405162461bcd60e51b815260206004820152600e60248201526d4e6f7420456e6f756768204c697160901b60448201526064016105be565b602082015182516040516324627b4760e21b81526001600160a01b03918216600482015260006024820152911690639189ed1c90604401608060405180830381865afa15801561146d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114919190612b78565b5061014085015250508151604051636e553f6560e01b8152600481018890523060248201526001600160a01b0390911690636e553f65906044016020604051808303816000875af11580156114ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061150e9190612ad7565b60a083015261151d8686611c79565b60408301525b8160a001518260c0018181516115399190612b36565b9052506040805180820190915260098152685f5f5f4e45575f5f5f60b81b602082015261156590611bf1565b61159c604051806040016040528060118152602001701d1bdd185b109bdc9c9bddd05b5bdd5b9d607a1b8152508360e00151611c34565b6115d560405180604001604052806013815260200172189bdc9c9bddd959105b5bdd5b9d081319599d606a1b8152508360400151611c34565b6115ef8783610100015184604001518560a0015186611c8e565b8161012001518260e0018181516116069190612b36565b90525061012082015160408301511061163857816101200151826040018181516116309190612b23565b905250611640565b600060408301525b60408201511580611652575081608001515b15611523578160a001518260c00181815161166d9190612b36565b905250600d80546116c49133916001600160b01b031690600061168f83612bb9565b91906101000a8154816001600160b01b0302191690836001600160b01b031602179055506001600160b01b0316955085611eda565b506040805160c0808201835283516001600160a01b039081168352908401516020808401918252838501998a5260e086015160608501908152426080860190815260a09788015197860197885260008a8152600b90935295909120845181546001600160a01b0319169416939093178355905160018301559751600282015596516003880155905160048701559051600590950194909455509391925050565b6060600180546104a090612a33565b61177e338383612073565b5050565b61178c33836119e8565b6117a85760405162461bcd60e51b81526004016105be90612a6d565b6117b484848484612141565b50505050565b606060006117c78361105e565b67ffffffffffffffff8111156117df576117df6128c9565b604051908082528060200260200182016040528015611808578160200160208202803683370190505b50905060005b6118178461105e565b811015611857576118288482610695565b82828151811061183a5761183a612b49565b60209081029190910101528061184f81612b5f565b91505061180e565b5092915050565b61186661260c565b506000908152600b6020908152604091829020825160c08101845281546001600160a01b03168152600182015492810192909252600281015492820192909252600382015460608201526004820154608082015260059091015460a082015290565b60006001600160e01b031982166380ac58cd60e01b14806118f957506001600160e01b03198216635b5e139f60e01b145b8061048b57506301ffc9a760e01b6001600160e01b031983161461048b565b6000818152600260205260409020546001600160a01b03166119775760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016105be565b50565b600081815260046020526040902080546001600160a01b0319166001600160a01b03841690811790915581906119af82610ffe565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b6000806119f483610ffe565b9050806001600160a01b0316846001600160a01b03161480611a3b57506001600160a01b0380821660009081526005602090815260408083209388168352929052205460ff165b80611a5f5750836001600160a01b0316611a5484610523565b6001600160a01b0316145b949350505050565b826001600160a01b0316611a7a82610ffe565b6001600160a01b031614611aa05760405162461bcd60e51b81526004016105be90612be7565b6001600160a01b038216611b025760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b60648201526084016105be565b611b0f8383836001612174565b826001600160a01b0316611b2282610ffe565b6001600160a01b031614611b485760405162461bcd60e51b81526004016105be90612be7565b600081815260046020908152604080832080546001600160a01b03199081169091556001600160a01b0387811680865260038552838620805460001901905590871680865283862080546001019055868652600290945282852080549092168417909155905184937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b600081831115611be85781611bea565b825b9392505050565b61197781604051602401611c0591906126c4565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526122b4565b61177e8282604051602401611c4a929190612c2c565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b1790526122b4565b6000611bea8383670de0b6b3a76400006122d5565b6000611cb184611cac85856101400151611c7990919063ffffffff16565b611bd8565b9050611cbd8186611bd8565b6101208301819052811160808301528151602083015160405163095ea7b360e01b81526001600160a01b0391821660048201526024810186905291169063095ea7b3906044016020604051808303816000875af1158015611d22573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d469190612af0565b5060208201516101208301518351604051631c5ef1ab60e01b815260048101929092526001600160a01b039081166024830152600060448301526064820186905230608483015290911690631c5ef1ab9060a4016020604051808303816000875af1158015611db9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ddd9190612ad7565b50611e15604051806040016040528060158152602001741b995dc818dbdb1b185d195c985b08185b5bdd5b9d605a1b81525084611c34565b611e4f604051806040016040528060138152602001721b585e109bdc9c9bddd8589b19505b5bdd5b9d606a1b815250836101200151611c34565b8151610120830151604051636e553f6560e01b815260048101919091523060248201526001600160a01b0390911690636e553f65906044016020604051808303816000875af1158015611ea6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611eca9190612ad7565b60a0909201919091525050505050565b6001600160a01b038216611f305760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f206164647265737360448201526064016105be565b6000818152600260205260409020546001600160a01b031615611f955760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e7465640000000060448201526064016105be565b611fa3600083836001612174565b6000818152600260205260409020546001600160a01b0316156120085760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e7465640000000060448201526064016105be565b6001600160a01b038216600081815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b816001600160a01b0316836001600160a01b0316036120d45760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c65720000000000000060448201526064016105be565b6001600160a01b03838116600081815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b61214c848484611a67565b612158848484846122f3565b6117b45760405162461bcd60e51b81526004016105be90612c4e565b612180848484846123f4565b60018111156121ef5760405162461bcd60e51b815260206004820152603560248201527f455243373231456e756d657261626c653a20636f6e7365637574697665207472604482015274185b9cd9995c9cc81b9bdd081cdd5c1c1bdc9d1959605a1b60648201526084016105be565b816001600160a01b03851661224b5761224681600880546000838152600960205260408120829055600182018355919091527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30155565b61226e565b836001600160a01b0316856001600160a01b03161461226e5761226e858261247c565b6001600160a01b03841661228a5761228581612519565b6122ad565b846001600160a01b0316846001600160a01b0316146122ad576122ad84826125c8565b5050505050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b60008260001904841183021582026122ec57600080fd5b5091020490565b60006001600160a01b0384163b156123e957604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290612337903390899088908890600401612ca0565b6020604051808303816000875af1925050508015612372575060408051601f3d908101601f1916820190925261236f91810190612cdd565b60015b6123cf573d8080156123a0576040519150601f19603f3d011682016040523d82523d6000602084013e6123a5565b606091505b5080516000036123c75760405162461bcd60e51b81526004016105be90612c4e565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050611a5f565b506001949350505050565b60018111156117b4576001600160a01b0384161561243a576001600160a01b03841660009081526003602052604081208054839290612434908490612b23565b90915550505b6001600160a01b038316156117b4576001600160a01b03831660009081526003602052604081208054839290612471908490612b36565b909155505050505050565b600060016124898461105e565b6124939190612b23565b6000838152600760205260409020549091508082146124e6576001600160a01b03841660009081526006602090815260408083208584528252808320548484528184208190558352600790915290208190555b5060009182526007602090815260408084208490556001600160a01b039094168352600681528383209183525290812055565b60085460009061252b90600190612b23565b6000838152600960205260408120546008805493945090928490811061255357612553612b49565b90600052602060002001549050806008838154811061257457612574612b49565b60009182526020808320909101929092558281526009909152604080822084905585825281205560088054806125ac576125ac612cfa565b6001900381819060005260206000200160009055905550505050565b60006125d38361105e565b6001600160a01b039093166000908152600660209081526040808320868452825280832085905593825260079052919091209190915550565b6040518060c0016040528060006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160e01b03198116811461197757600080fd5b60006020828403121561267357600080fd5b8135611bea8161264b565b6000815180845260005b818110156126a457602081850181015186830182015201612688565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000611bea602083018461267e565b6000602082840312156126e957600080fd5b5035919050565b6001600160a01b038116811461197757600080fd5b6000806040838503121561271857600080fd5b8235612723816126f0565b946020939093013593505050565b60008060006060848603121561274657600080fd5b8335612751816126f0565b92506020840135612761816126f0565b929592945050506040919091013590565b60008060006060848603121561278757600080fd5b505081359360208301359350604090920135919050565b6000602082840312156127b057600080fd5b8135611bea816126f0565b80516001600160a01b031682526020808201519083015260408082015190830152606080820151908301526080808201519083015260a090810151910152565b6020808252825182820181905260009190848201906040850190845b8181101561283d5761282a8385516127bb565b9284019260c09290920191600101612817565b50909695505050505050565b6000806040838503121561285c57600080fd5b82359150602083013561286e816126f0565b809150509250929050565b82815260e08101611bea60208301846127bb565b801515811461197757600080fd5b600080604083850312156128ae57600080fd5b82356128b9816126f0565b9150602083013561286e8161288d565b634e487b7160e01b600052604160045260246000fd5b600080600080608085870312156128f557600080fd5b8435612900816126f0565b93506020850135612910816126f0565b925060408501359150606085013567ffffffffffffffff8082111561293457600080fd5b818701915087601f83011261294857600080fd5b81358181111561295a5761295a6128c9565b604051601f8201601f19908116603f01168101908382118183101715612982576129826128c9565b816040528281528a602084870101111561299b57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b6020808252825182820181905260009190848201906040850190845b8181101561283d578351835292840192918401916001016129db565b60008060408385031215612a0a57600080fd5b8235612a15816126f0565b9150602083013561286e816126f0565b60c0810161048b82846127bb565b600181811c90821680612a4757607f821691505b602082108103612a6757634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252602d908201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560408201526c1c881bdc88185c1c1c9bdd9959609a1b606082015260800190565b600060208284031215612acc57600080fd5b8151611bea816126f0565b600060208284031215612ae957600080fd5b5051919050565b600060208284031215612b0257600080fd5b8151611bea8161288d565b634e487b7160e01b600052601160045260246000fd5b8181038181111561048b5761048b612b0d565b8082018082111561048b5761048b612b0d565b634e487b7160e01b600052603260045260246000fd5b600060018201612b7157612b71612b0d565b5060010190565b60008060008060808587031215612b8e57600080fd5b8451935060208501519250604085015191506060850151612bae8161288d565b939692955090935050565b60006001600160b01b038281166002600160b01b03198101612bdd57612bdd612b0d565b6001019392505050565b60208082526025908201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060408201526437bbb732b960d91b606082015260800190565b604081526000612c3f604083018561267e565b90508260208301529392505050565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b6001600160a01b0385811682528416602082015260408101839052608060608201819052600090612cd39083018461267e565b9695505050505050565b600060208284031215612cef57600080fd5b8151611bea8161264b565b634e487b7160e01b600052603160045260246000fdfea2646970667358221220e7592daabdb0b1c5660f95eee874dd0c3c7de2ba09f694ac26b6553c2a0e955964736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061018e5760003560e01c80636352211e116100de578063b88d4fde11610097578063db61598511610071578063db6159851461020e578063e985e9c51461040a578063eb02c30114610446578063f0a856441461020e57600080fd5b8063b88d4fde146103c3578063c87b56dd146103d6578063d004b036146103ea57600080fd5b80636352211e146102dd57806370a08231146102f0578063794799c01461030357806395d89b411461032457806399fbab881461032c578063a22cb465146103b057600080fd5b80632f745c591161014b57806342842e0e1161012557806342842e0e1461027b5780634f6ccce71461028e57806352e59b231461020e5780635da6f921146102a157600080fd5b80632f745c591461023557806334a8ee14146102485780633eeb530e1461025b57600080fd5b806301ffc9a71461019357806306fdde03146101bb578063081812fc146101d0578063095ea7b3146101fb57806318160ddd1461021057806323b872dd14610222575b600080fd5b6101a66101a1366004612661565b610466565b60405190151581526020015b60405180910390f35b6101c3610491565b6040516101b291906126c4565b6101e36101de3660046126d7565b610523565b6040516001600160a01b0390911681526020016101b2565b61020e610209366004612705565b61054a565b005b6008545b6040519081526020016101b2565b61020e610230366004612731565b610664565b610214610243366004612705565b610695565b61020e610256366004612772565b61072b565b61026e61026936600461279e565b610e26565b6040516101b291906127fb565b61020e610289366004612731565b610f50565b61021461029c3660046126d7565b610f6b565b61020e6102af366004612849565b6000918252600c602052604090912080546001600160a01b0319166001600160a01b03909216919091179055565b6101e36102eb3660046126d7565b610ffe565b6102146102fe36600461279e565b61105e565b610316610311366004612772565b6110e4565b6040516101b2929190612879565b6101c3611764565b61037961033a3660046126d7565b600b602052600090815260409020805460018201546002830154600384015460048501546005909501546001600160a01b039094169492939192909186565b604080516001600160a01b0390971687526020870195909552938501929092526060840152608083015260a082015260c0016101b2565b61020e6103be36600461289b565b611773565b61020e6103d13660046128df565b611782565b6101c36103e43660046126d7565b50606090565b6103fd6103f836600461279e565b6117ba565b6040516101b291906129bf565b6101a66104183660046129f7565b6001600160a01b03918216600090815260056020908152604080832093909416825291909152205460ff1690565b6104596104543660046126d7565b61185e565b6040516101b29190612a25565b60006001600160e01b0319821663780e9d6360e01b148061048b575061048b826118c8565b92915050565b6060600080546104a090612a33565b80601f01602080910402602001604051908101604052809291908181526020018280546104cc90612a33565b80156105195780601f106104ee57610100808354040283529160200191610519565b820191906000526020600020905b8154815290600101906020018083116104fc57829003601f168201915b5050505050905090565b600061052e82611918565b506000908152600460205260409020546001600160a01b031690565b600061055582610ffe565b9050806001600160a01b0316836001600160a01b0316036105c75760405162461bcd60e51b815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e656044820152603960f91b60648201526084015b60405180910390fd5b336001600160a01b03821614806105e357506105e38133610418565b6106555760405162461bcd60e51b815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c00000060648201526084016105be565b61065f838361197a565b505050565b61066e33826119e8565b61068a5760405162461bcd60e51b81526004016105be90612a6d565b61065f838383611a67565b60006106a08361105e565b82106107025760405162461bcd60e51b815260206004820152602b60248201527f455243373231456e756d657261626c653a206f776e657220696e646578206f7560448201526a74206f6620626f756e647360a81b60648201526084016105be565b506001600160a01b03919091166000908152600660209081526040808320938352929052205490565b61075d6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b6000838152600b6020908152604091829020825160c08101845281546001600160a01b03168152600182015492810183905260028201549381019390935260038101546060840152600481015460808401526005015460a08301528311156107fe5760405162461bcd60e51b81526020600482015260146024820152733630b933b2b9103a3430b7103837b9b4ba34b7b760611b60448201526064016105be565b600a54604051634632752560e11b8152600481018790526000916001600160a01b031690638c64ea4a90602401602060405180830381865afa158015610848573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086c9190612aba565b90506000816001600160a01b031663c5d664c66040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d29190612aba565b6000888152600c60205260409081902054905163b3d7f6b960e01b8152600481018890529192506001600160a01b03908116918184169163095ea7b391849187169063b3d7f6b990602401602060405180830381865afa15801561093a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095e9190612ad7565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af11580156109a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109cd9190612af0565b50602085018690525b602085015115610d4f576109f28460a001518660200151611bd8565b60808601819052604051635d043b2960e11b81526004810191909152306024820181905260448201526001600160a01b0384169063ba087652906064016020604051808303816000875af1158015610a4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a729190612ad7565b808652604051631fd0956760e01b815260048101919091523060248201526001600160a01b03821690631fd09567906044016020604051808303816000875af1158015610ac3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ae79190612ad7565b50604051636e9c33bd60e11b81526001600160a01b0384811660048301526000602483015230604483015282169063dd38677a906064016020604051808303816000875af1158015610b3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b619190612ad7565b856040018181525050610b94604051806040016040528060098152602001685f5f5f4e45575f5f5f60b81b815250611bf1565b610bc76040518060400160405280600d81526020016c1dda5d1a191c985dc81b19599d609a1b8152508660200151611c34565b610c096040518060400160405280600f81526020016e72656465656d65642073686172657360881b815250610c048660a001518860200151611bd8565b611c34565b610c3f6040518060400160405280601081526020016f1c995919595b59590bdc995c185e595960821b8152508660000151611c34565b610c6c604051806040016040528060078152602001661c995b5bdd995960ca1b8152508660400151611c34565b846080015185602001818151610c829190612b23565b9052508451606086018051610c98908390612b36565b905250602085015160a08501511015610cb5578460400151610cd8565b846040015185602001518560a00151610cce9190612b23565b610cd89190612b36565b60a08501526040805180820190915260128152711d1bdd185b105cdcd95d14995d1d5c9b995960721b60208201526060860151610d159190611c34565b610d4a6040518060400160405280600f81526020016e656e64537461746542616c616e636560881b8152508560a00151611c34565b6109d6565b8584602001818151610d619190612b23565b9052506060808601519085015110610d9157846060015184606001818151610d899190612b23565b905250610dbd565b60006060808601829052860151610da89190612b23565b84604001818151610db99190612b23565b9052505b5050506000938452600b6020908152604094859020825181546001600160a01b0319166001600160a01b03909116178155908201516001820155938101516002850155606081015160038501556080810151600485015560a00151600590930192909255505050565b60606000610e33836117ba565b90506000815167ffffffffffffffff811115610e5157610e516128c9565b604051908082528060200260200182016040528015610e8a57816020015b610e7761260c565b815260200190600190039081610e6f5790505b50905060005b8251811015610f4857600b6000848381518110610eaf57610eaf612b49565b6020908102919091018101518252818101929092526040908101600020815160c08101835281546001600160a01b0316815260018201549381019390935260028101549183019190915260038101546060830152600481015460808301526005015460a08201528251839083908110610f2a57610f2a612b49565b60200260200101819052508080610f4090612b5f565b915050610e90565b509392505050565b61065f83838360405180602001604052806000815250611782565b6000610f7660085490565b8210610fd95760405162461bcd60e51b815260206004820152602c60248201527f455243373231456e756d657261626c653a20676c6f62616c20696e646578206f60448201526b7574206f6620626f756e647360a01b60648201526084016105be565b60088281548110610fec57610fec612b49565b90600052602060002001549050919050565b6000818152600260205260408120546001600160a01b03168061048b5760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016105be565b60006001600160a01b0382166110c85760405162461bcd60e51b815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f7420612076616044820152683634b21037bbb732b960b91b60648201526084016105be565b506001600160a01b031660009081526003602052604090205490565b60006110ee61260c565b61115f60405180610160016040528060006001600160a01b0316815260200160006001600160a01b0316815260200160008152602001600081526020016000151581526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b600a54604051634632752560e11b8152600481018890526001600160a01b0390911690638c64ea4a90602401602060405180830381865afa1580156111a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111cc9190612aba565b6001600160a01b0316808252604080516362eb326360e11b815290516000929163c5d664c69160048083019260209291908290030181865afa158015611216573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061123a9190612aba565b6040516323b872dd60e01b8152336004820152306024820152604481018890529091506001600160a01b038216906323b872dd906064016020604051808303816000875af1158015611290573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b49190612af0565b5081516001600160a01b0382169063095ea7b3906112e46112dd89670de0b6b3a7640000612b36565b8a90611c79565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af115801561132f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113539190612af0565b506000878152600c6020908152604091829020546001600160a01b03168482018190528251631d09b9e960e21b815292519092637426e7a49260048083019391928290030181865afa1580156113ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d19190612ad7565b61010083018190526000036114195760405162461bcd60e51b815260206004820152600e60248201526d4e6f7420456e6f756768204c697160901b60448201526064016105be565b602082015182516040516324627b4760e21b81526001600160a01b03918216600482015260006024820152911690639189ed1c90604401608060405180830381865afa15801561146d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114919190612b78565b5061014085015250508151604051636e553f6560e01b8152600481018890523060248201526001600160a01b0390911690636e553f65906044016020604051808303816000875af11580156114ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061150e9190612ad7565b60a083015261151d8686611c79565b60408301525b8160a001518260c0018181516115399190612b36565b9052506040805180820190915260098152685f5f5f4e45575f5f5f60b81b602082015261156590611bf1565b61159c604051806040016040528060118152602001701d1bdd185b109bdc9c9bddd05b5bdd5b9d607a1b8152508360e00151611c34565b6115d560405180604001604052806013815260200172189bdc9c9bddd959105b5bdd5b9d081319599d606a1b8152508360400151611c34565b6115ef8783610100015184604001518560a0015186611c8e565b8161012001518260e0018181516116069190612b36565b90525061012082015160408301511061163857816101200151826040018181516116309190612b23565b905250611640565b600060408301525b60408201511580611652575081608001515b15611523578160a001518260c00181815161166d9190612b36565b905250600d80546116c49133916001600160b01b031690600061168f83612bb9565b91906101000a8154816001600160b01b0302191690836001600160b01b031602179055506001600160b01b0316955085611eda565b506040805160c0808201835283516001600160a01b039081168352908401516020808401918252838501998a5260e086015160608501908152426080860190815260a09788015197860197885260008a8152600b90935295909120845181546001600160a01b0319169416939093178355905160018301559751600282015596516003880155905160048701559051600590950194909455509391925050565b6060600180546104a090612a33565b61177e338383612073565b5050565b61178c33836119e8565b6117a85760405162461bcd60e51b81526004016105be90612a6d565b6117b484848484612141565b50505050565b606060006117c78361105e565b67ffffffffffffffff8111156117df576117df6128c9565b604051908082528060200260200182016040528015611808578160200160208202803683370190505b50905060005b6118178461105e565b811015611857576118288482610695565b82828151811061183a5761183a612b49565b60209081029190910101528061184f81612b5f565b91505061180e565b5092915050565b61186661260c565b506000908152600b6020908152604091829020825160c08101845281546001600160a01b03168152600182015492810192909252600281015492820192909252600382015460608201526004820154608082015260059091015460a082015290565b60006001600160e01b031982166380ac58cd60e01b14806118f957506001600160e01b03198216635b5e139f60e01b145b8061048b57506301ffc9a760e01b6001600160e01b031983161461048b565b6000818152600260205260409020546001600160a01b03166119775760405162461bcd60e51b8152602060048201526018602482015277115490cdcc8c4e881a5b9d985b1a59081d1bdad95b88125160421b60448201526064016105be565b50565b600081815260046020526040902080546001600160a01b0319166001600160a01b03841690811790915581906119af82610ffe565b6001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b6000806119f483610ffe565b9050806001600160a01b0316846001600160a01b03161480611a3b57506001600160a01b0380821660009081526005602090815260408083209388168352929052205460ff165b80611a5f5750836001600160a01b0316611a5484610523565b6001600160a01b0316145b949350505050565b826001600160a01b0316611a7a82610ffe565b6001600160a01b031614611aa05760405162461bcd60e51b81526004016105be90612be7565b6001600160a01b038216611b025760405162461bcd60e51b8152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f206164646044820152637265737360e01b60648201526084016105be565b611b0f8383836001612174565b826001600160a01b0316611b2282610ffe565b6001600160a01b031614611b485760405162461bcd60e51b81526004016105be90612be7565b600081815260046020908152604080832080546001600160a01b03199081169091556001600160a01b0387811680865260038552838620805460001901905590871680865283862080546001019055868652600290945282852080549092168417909155905184937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b600081831115611be85781611bea565b825b9392505050565b61197781604051602401611c0591906126c4565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526122b4565b61177e8282604051602401611c4a929190612c2c565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b1790526122b4565b6000611bea8383670de0b6b3a76400006122d5565b6000611cb184611cac85856101400151611c7990919063ffffffff16565b611bd8565b9050611cbd8186611bd8565b6101208301819052811160808301528151602083015160405163095ea7b360e01b81526001600160a01b0391821660048201526024810186905291169063095ea7b3906044016020604051808303816000875af1158015611d22573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d469190612af0565b5060208201516101208301518351604051631c5ef1ab60e01b815260048101929092526001600160a01b039081166024830152600060448301526064820186905230608483015290911690631c5ef1ab9060a4016020604051808303816000875af1158015611db9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ddd9190612ad7565b50611e15604051806040016040528060158152602001741b995dc818dbdb1b185d195c985b08185b5bdd5b9d605a1b81525084611c34565b611e4f604051806040016040528060138152602001721b585e109bdc9c9bddd8589b19505b5bdd5b9d606a1b815250836101200151611c34565b8151610120830151604051636e553f6560e01b815260048101919091523060248201526001600160a01b0390911690636e553f65906044016020604051808303816000875af1158015611ea6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611eca9190612ad7565b60a0909201919091525050505050565b6001600160a01b038216611f305760405162461bcd60e51b815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f206164647265737360448201526064016105be565b6000818152600260205260409020546001600160a01b031615611f955760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e7465640000000060448201526064016105be565b611fa3600083836001612174565b6000818152600260205260409020546001600160a01b0316156120085760405162461bcd60e51b815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e7465640000000060448201526064016105be565b6001600160a01b038216600081815260036020908152604080832080546001019055848352600290915280822080546001600160a01b0319168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a45050565b816001600160a01b0316836001600160a01b0316036120d45760405162461bcd60e51b815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c65720000000000000060448201526064016105be565b6001600160a01b03838116600081815260056020908152604080832094871680845294825291829020805460ff191686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b61214c848484611a67565b612158848484846122f3565b6117b45760405162461bcd60e51b81526004016105be90612c4e565b612180848484846123f4565b60018111156121ef5760405162461bcd60e51b815260206004820152603560248201527f455243373231456e756d657261626c653a20636f6e7365637574697665207472604482015274185b9cd9995c9cc81b9bdd081cdd5c1c1bdc9d1959605a1b60648201526084016105be565b816001600160a01b03851661224b5761224681600880546000838152600960205260408120829055600182018355919091527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee30155565b61226e565b836001600160a01b0316856001600160a01b03161461226e5761226e858261247c565b6001600160a01b03841661228a5761228581612519565b6122ad565b846001600160a01b0316846001600160a01b0316146122ad576122ad84826125c8565b5050505050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b60008260001904841183021582026122ec57600080fd5b5091020490565b60006001600160a01b0384163b156123e957604051630a85bd0160e11b81526001600160a01b0385169063150b7a0290612337903390899088908890600401612ca0565b6020604051808303816000875af1925050508015612372575060408051601f3d908101601f1916820190925261236f91810190612cdd565b60015b6123cf573d8080156123a0576040519150601f19603f3d011682016040523d82523d6000602084013e6123a5565b606091505b5080516000036123c75760405162461bcd60e51b81526004016105be90612c4e565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050611a5f565b506001949350505050565b60018111156117b4576001600160a01b0384161561243a576001600160a01b03841660009081526003602052604081208054839290612434908490612b23565b90915550505b6001600160a01b038316156117b4576001600160a01b03831660009081526003602052604081208054839290612471908490612b36565b909155505050505050565b600060016124898461105e565b6124939190612b23565b6000838152600760205260409020549091508082146124e6576001600160a01b03841660009081526006602090815260408083208584528252808320548484528184208190558352600790915290208190555b5060009182526007602090815260408084208490556001600160a01b039094168352600681528383209183525290812055565b60085460009061252b90600190612b23565b6000838152600960205260408120546008805493945090928490811061255357612553612b49565b90600052602060002001549050806008838154811061257457612574612b49565b60009182526020808320909101929092558281526009909152604080822084905585825281205560088054806125ac576125ac612cfa565b6001900381819060005260206000200160009055905550505050565b60006125d38361105e565b6001600160a01b039093166000908152600660209081526040808320868452825280832085905593825260079052919091209190915550565b6040518060c0016040528060006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160e01b03198116811461197757600080fd5b60006020828403121561267357600080fd5b8135611bea8161264b565b6000815180845260005b818110156126a457602081850181015186830182015201612688565b506000602082860101526020601f19601f83011685010191505092915050565b602081526000611bea602083018461267e565b6000602082840312156126e957600080fd5b5035919050565b6001600160a01b038116811461197757600080fd5b6000806040838503121561271857600080fd5b8235612723816126f0565b946020939093013593505050565b60008060006060848603121561274657600080fd5b8335612751816126f0565b92506020840135612761816126f0565b929592945050506040919091013590565b60008060006060848603121561278757600080fd5b505081359360208301359350604090920135919050565b6000602082840312156127b057600080fd5b8135611bea816126f0565b80516001600160a01b031682526020808201519083015260408082015190830152606080820151908301526080808201519083015260a090810151910152565b6020808252825182820181905260009190848201906040850190845b8181101561283d5761282a8385516127bb565b9284019260c09290920191600101612817565b50909695505050505050565b6000806040838503121561285c57600080fd5b82359150602083013561286e816126f0565b809150509250929050565b82815260e08101611bea60208301846127bb565b801515811461197757600080fd5b600080604083850312156128ae57600080fd5b82356128b9816126f0565b9150602083013561286e8161288d565b634e487b7160e01b600052604160045260246000fd5b600080600080608085870312156128f557600080fd5b8435612900816126f0565b93506020850135612910816126f0565b925060408501359150606085013567ffffffffffffffff8082111561293457600080fd5b818701915087601f83011261294857600080fd5b81358181111561295a5761295a6128c9565b604051601f8201601f19908116603f01168101908382118183101715612982576129826128c9565b816040528281528a602084870101111561299b57600080fd5b82602086016020830137600060208483010152809550505050505092959194509250565b6020808252825182820181905260009190848201906040850190845b8181101561283d578351835292840192918401916001016129db565b60008060408385031215612a0a57600080fd5b8235612a15816126f0565b9150602083013561286e816126f0565b60c0810161048b82846127bb565b600181811c90821680612a4757607f821691505b602082108103612a6757634e487b7160e01b600052602260045260246000fd5b50919050565b6020808252602d908201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560408201526c1c881bdc88185c1c1c9bdd9959609a1b606082015260800190565b600060208284031215612acc57600080fd5b8151611bea816126f0565b600060208284031215612ae957600080fd5b5051919050565b600060208284031215612b0257600080fd5b8151611bea8161288d565b634e487b7160e01b600052601160045260246000fd5b8181038181111561048b5761048b612b0d565b8082018082111561048b5761048b612b0d565b634e487b7160e01b600052603260045260246000fd5b600060018201612b7157612b71612b0d565b5060010190565b60008060008060808587031215612b8e57600080fd5b8451935060208501519250604085015191506060850151612bae8161288d565b939692955090935050565b60006001600160b01b038281166002600160b01b03198101612bdd57612bdd612b0d565b6001019392505050565b60208082526025908201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060408201526437bbb732b960d91b606082015260800190565b604081526000612c3f604083018561267e565b90508260208301529392505050565b60208082526032908201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560408201527131b2b4bb32b91034b6b83632b6b2b73a32b960711b606082015260800190565b6001600160a01b0385811682528416602082015260408101839052608060608201819052600090612cd39083018461267e565b9695505050505050565b600060208284031215612cef57600080fd5b8151611bea8161264b565b634e487b7160e01b600052603160045260246000fdfea2646970667358221220e7592daabdb0b1c5660f95eee874dd0c3c7de2ba09f694ac26b6553c2a0e955964736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "details": "See {IERC721-approve}."
      },
      "balanceOf(address)": {
        "details": "See {IERC721-balanceOf}."
      },
      "getApproved(uint256)": {
        "details": "See {IERC721-getApproved}."
      },
      "isApprovedForAll(address,address)": {
        "details": "See {IERC721-isApprovedForAll}."
      },
      "name()": {
        "details": "See {IERC721Metadata-name}."
      },
      "ownerOf(uint256)": {
        "details": "See {IERC721-ownerOf}."
      },
      "rewindPartialLeverage(uint256,uint256,uint256)": {
        "details": "step goes 1. repay to instrument,  "
      },
      "safeTransferFrom(address,address,uint256)": {
        "details": "See {IERC721-safeTransferFrom}."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "details": "See {IERC721-safeTransferFrom}."
      },
      "setApprovalForAll(address,bool)": {
        "details": "See {IERC721-setApprovalForAll}."
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "symbol()": {
        "details": "See {IERC721Metadata-symbol}."
      },
      "tokenByIndex(uint256)": {
        "details": "See {IERC721Enumerable-tokenByIndex}."
      },
      "tokenOfOwnerByIndex(address,uint256)": {
        "details": "See {IERC721Enumerable-tokenOfOwnerByIndex}."
      },
      "totalSupply()": {
        "details": "See {IERC721Enumerable-totalSupply}."
      },
      "transferFrom(address,address,uint256)": {
        "details": "See {IERC721-transferFrom}."
      }
    },
    "stateVariables": {
      "_nextId": {
        "details": "The ID of the next token that will be minted. Skips 0"
      },
      "_nextPoolId": {
        "details": "The ID of the next pool that is used for the first time. Skips 0"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "param leverageVault is where the capital is for borrowing"
      },
      "deletePosition()": {
        "notice": "when debt is 0, user can claim their endstate balance "
      },
      "mintWithLeverage(uint256,uint256,uint256)": {
        "notice": "Implements a leverage loop "
      },
      "rewindPartialLeverage(uint256,uint256,uint256)": {
        "notice": "Allows leverage minters to close their positions, and share profit with the leverageVault"
      }
    },
    "notice": "borrow from leverageVault to leverage mint vaults",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 38829,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_name",
        "offset": 0,
        "slot": "0",
        "type": "t_string_storage"
      },
      {
        "astId": 38831,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_symbol",
        "offset": 0,
        "slot": "1",
        "type": "t_string_storage"
      },
      {
        "astId": 38835,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_owners",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 38839,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_balances",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 38843,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_tokenApprovals",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 38849,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_operatorApprovals",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 39897,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_ownedTokens",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      {
        "astId": 39901,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_ownedTokensIndex",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 39904,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_allTokens",
        "offset": 0,
        "slot": "8",
        "type": "t_array(t_uint256)dyn_storage"
      },
      {
        "astId": 39908,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_allTokensIndex",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 9230,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "controller",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(Controller)12342"
      },
      {
        "astId": 9254,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "positions",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_uint256,t_struct(Position)9271_storage)"
      },
      {
        "astId": 9258,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "leveragePools",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 9288,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_nextId",
        "offset": 0,
        "slot": "13",
        "type": "t_uint176"
      },
      {
        "astId": 9292,
        "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
        "label": "_nextPoolId",
        "offset": 22,
        "slot": "13",
        "type": "t_uint80"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Controller)12342": {
        "encoding": "inplace",
        "label": "contract Controller",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_struct(Position)9271_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct LeverageModule.Position)",
        "numberOfBytes": "32",
        "value": "t_struct(Position)9271_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Position)9271_storage": {
        "encoding": "inplace",
        "label": "struct LeverageModule.Position",
        "members": [
          {
            "astId": 9260,
            "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
            "label": "vaultAd",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 9262,
            "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
            "label": "totalShares",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 9264,
            "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
            "label": "suppliedCapital",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 9266,
            "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
            "label": "borrowedCapital",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 9268,
            "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
            "label": "borrowTimeStamp",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 9270,
            "contract": "contracts/protocol/LeverageModule.sol:LeverageModule",
            "label": "endStateBalance",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_uint176": {
        "encoding": "inplace",
        "label": "uint176",
        "numberOfBytes": "22"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint80": {
        "encoding": "inplace",
        "label": "uint80",
        "numberOfBytes": "10"
      }
    }
  }
}