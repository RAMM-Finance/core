{
  "language": "Solidity",
  "sources": {
    "contracts/bonds/bondPool.sol": {
      "content": "pragma solidity ^0.8.9;\nimport { LinearPiecewiseCurve, SwapParams} from \"./linearCurve.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {oERC20} from \"../utils/ownedERC20.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\ncontract SyntheticZCBPool{\n    using FixedPointMathLib for uint256;\n    using LinearPiecewiseCurve for uint256; \n\n    constructor(address base, \n        address trade, \n        address s_trade, \n        address _entry, \n        address _controller\n        ){\n        baseToken =  ERC20(base);\n        tradeToken = oERC20(trade);\n        s_tradeToken = oERC20(s_trade);\n\n        entry = _entry; \n        controller = _controller; \n    }\n\n    /// @notice Long up the curve, or short down the curve \n    /// @param amountIn is base if long, trade if short\n    /// @param priceLimit is slippage tolerance\n    function takerOpen(\n        bool isLong, \n        int256 amountIn,\n        uint256 priceLimit, \n        bytes calldata data\n        ) external  returns(uint256 poolamountIn, uint256 poolamountOut )\n    {\n        uint256 bal = baseBal(); \n        bool exactInput = amountIn>=0; \n        if(isLong){\n            // amountIn is base, out is trade\n            poolamountIn = exactInput? uint256(amountIn) : uint256(-amountIn);\n\n            (poolamountOut, curPrice) = !exactInput\n            \t? (poolamountIn.areaUnderCurve(netSupply, a_initial, b), \n            \t\t(netSupply + poolamountIn).mulWadDown(a_initial) + b)\n            \t: poolamountIn.amountOutGivenIn(\n                SwapParams(netSupply, a_initial, b, true, pieceWisePrice )); \n\n            if(exactInput) netSupply += poolamountOut; \n            else netSupply += poolamountIn; \n\n            if(exactInput){ \n            \tiTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \n            \trequire(baseBal() >= poolamountIn + bal, \"balERR\"); \n            \ttradeToken.mint(abi.decode(data, (address)), poolamountOut); \n        \t}else{\n            \tiTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \n            \trequire(baseBal() >= poolamountOut + bal, \"balERR\"); \n            \ttradeToken.mint(abi.decode(data, (address)), poolamountIn); \n       \t\t\t// for return values \n        \t\tuint256 cachedOut = poolamountOut; \n        \t\tpoolamountOut = poolamountIn; \n        \t\tpoolamountIn = cachedOut; \n        \t}\n        } else{\n        \t// TODO do exact input \n        \trequire(netSupply>=uint256(amountIn), \"not enough liquidity\"); \n            //amount in is trade out is base \n            (poolamountOut,curPrice) = uint256(amountIn).amountOutGivenIn(\n                SwapParams(netSupply, a_initial, b, false, pieceWisePrice)); \n            netSupply -= uint256(amountIn); \n\n            require(poolamountOut <= bal, \"not enough liquidity\"); \n            uint256 cached_poolamountOut = poolamountOut; \n            // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\n            poolamountOut = uint256(amountIn).mulWadDown(maxPrice) - poolamountOut;\n\n            iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \n            require(baseBal() >= poolamountOut + bal, \"balERR\"); \n            s_tradeToken.mint(abi.decode(data,(address)), uint256(amountIn)); \n            poolamountIn = cached_poolamountOut; \n\n\n            // need to send cached poolamountOut(the area under the curve) data for accounting purposes\n        }\n\n    }\n\n    /// @notice calculate and store initial curve params that takes into account\n    /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\n    /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \n    /// @param sigma is the proportion of P that is going to be bought at a discount  \n    function calculateInitCurveParams(\n        uint256 P, \n        uint256 I, \n        uint256 sigma,\n        uint256 alpha, \n        uint256 delta) external {\n        require(msg.sender == controller, \"unauthorized\"); \n        b_initial = (2*P).divWadDown(P+I) >= precision\n            ? (2*P).divWadDown(P+I) - precision\n            : MIN_INIT_PRICE;         \n        a_initial = (precision-b_initial).divWadDown(P+I); \n\n        discount_cap_collateral = P.mulWadDown(0); //sigma =0 TODO\n\n        // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\n       (discount_cap, b) = discount_cap_collateral.amountOutGivenIn(SwapParams(0, a_initial, b_initial, true, 0));\n        (, upperBound) = P.mulWadDown(alpha+delta).amountOutGivenIn(SwapParams(0, a_initial, b_initial,true, 0)); \n        curPrice = b;\n        // (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\n        // (, upperBound )= LinearCurve.amountOutGivenIn(P.mulWadDown(alpha+delta), 0, a_initial, b_initial,true); \n    }\n// 10000000000000000000, 649999999496683521, 649999999999999985, 50000000000000000\n    /// @notice calculates initparams for pool based instruments \n    /// param endPrice is the inception Price of longZCB, or its price when there is no discount\n    function calculateInitCurveParamsPool(\n        uint256 saleAmount, \n        uint256 initPrice, \n        uint256 endPrice, \n        uint256 sigma\n        ) external returns(uint256 managementFee){\n        require(msg.sender == controller, \"unauthorized\"); \n        //TODO these fails at some inputs\n        uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \n        uint256 a =a_initial= (endPrice - initPrice).divWadDown(saleAmountQty); \n        console.log('where', a); \n        //Set discount cap as saleAmount * sigma \n        (discount_cap, ) = saleAmount.mulWadDown(sigma).amountOutGivenIn(SwapParams(0, a, initPrice,true, 0)); \n        // (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \n        curPrice = b = initPrice; \n        console.log('where', b); \n\n        console.log('where',  discount_cap.mulWadDown(endPrice) + saleAmountQty.mulWadDown(endPrice) ,\n            saleAmount.mulWadDown(sigma)  +saleAmount ); \n\n        // How much total discounts are validators and managers getting\n        uint256 x = discount_cap.mulWadDown(endPrice) + saleAmountQty.mulWadDown(endPrice) ; \n        uint256 y = saleAmount.mulWadDown(sigma)  +saleAmount ; \n\n        // For rounding errors cases\n        managementFee = x>=y? x-y : 0; \n\n\n        pieceWisePrice = endPrice; \n\n    }\n\n    /// @notice computes area between the curve and max price for given storage parameters\n    function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\n        (uint256 amountDelta, ) = amount.amountOutGivenIn(SwapParams(0, a_initial, b_initial, true, 0)); \n        return amountDelta.mulWadDown(maxPrice) - amount; \n    }\n\n    /// @notice mints new zcbs \n    function trustedDiscountedMint(\n        address receiver, \n        uint256 amount \n        ) external{\n        require(msg.sender == entry, \"entryERR\"); \n\n        tradeToken.mint(receiver, amount);\n        discountedReserves += amount;\n    }\n\n    function trustedMint(address receiver, uint256 amount, bool long) external{\n        if(long) tradeToken.mint(receiver, amount); \n        else s_tradeToken.mint(receiver, amount); \n    }\n\n    function trustedBurn(\n        address trader, \n        uint256 amount, \n        bool long\n        ) external {\n        require(msg.sender == entry, \"entryERR\"); \n        if (long) tradeToken.burn(trader, amount); \n        else s_tradeToken.burn(trader, amount);\n        console.log('??balacnce', long, s_tradeToken.balanceOf(trader)); \n    }\n\n    function flush(address flushTo, uint256 amount) external {\n        require(msg.sender == controller, \"entryERR\"); \n        if (amount == type(uint256).max) baseToken.transfer(flushTo, baseBal()); \n        else baseToken.transfer(flushTo, amount); \n    }\n\n    function baseBal() public view returns(uint256){\n        return baseToken.balanceOf(address(this)); \n    }\n\n    function getCurPrice() external view returns(uint256){\n    \treturn curPrice; \n    }\n\n\n    uint256 curPrice; \n\n    uint256 public pieceWisePrice; \n    uint256 public netSupply; \n    uint256 public a_initial;\n    uint256 public b_initial; // b without discount cap \n    uint256 public b;\n    uint256 public discount_cap; \n    uint256 public discount_cap_collateral; \n    uint256 public discountedReserves; \n    uint256 public upperBound; \n    ERC20 public  baseToken; \n    oERC20 public  tradeToken; \n    oERC20 public  s_tradeToken; \n\n    address public immutable entry; \n    address public immutable controller; \n    uint256 public constant precision = 1e18; \n    uint256 public constant maxPrice = 1e18; \n    uint256 public constant MIN_INIT_PRICE = 5e17; \n}\n\n\n\n\n\n\n\n\n\n\n\ninterface iTradeCallBack{\n    function tradeCallBack(\n        uint256 amount0,\n bytes calldata data    ) external;\n} "
    },
    "contracts/bonds/boundedDerivatives.sol": {
      "content": "// pragma solidity ^0.8.9;\n// import \"./GBC.sol\"; \n// // import {BoundedDerivativesPool, LinearCurve} from \"./GBC.sol\"; \n// import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n// import {ERC20} from \"./libraries.sol\"; \n// import \"forge-std/console.sol\";\n\n// /// @notice Uses AMM as a derivatives market,where the price is bounded between two price\n// /// and mints/burns tradeTokens. \n// /// stores all baseTokens for trading, and also stores tradetokens when providing liquidity, \n// /// @dev Short loss is bounded as the price is bounded, no need to program liquidations logic \n// contract BoundedDerivativesPool is GranularBondingCurve{\n//     using FixedPointMath for uint256;\n//     using SafeCast for uint256; \n//     // using Position for Position.Info;\n//     // uint256 constant PRECISION = 1e18; \n//     ERC20 public  BaseToken; \n//     ERC20 public  TradeToken; \n//     ERC20 public  s_tradeToken; \n//     uint256 public constant maxPrice = 1e18; \n\n//     bool immutable noCallBack; \n//     constructor(\n//         address base, \n//         address trade, \n//         address s_trade, \n//         bool _noCallBack\n//         // address _pool \n//         ) GranularBondingCurve(base, trade){\n//         BaseToken =  ERC20(base);\n//         TradeToken = ERC20(trade);\n//         s_tradeToken = ERC20(s_trade);\n//         noCallBack = _noCallBack; \n//     }\n\n//     /// @notice recipient recieves amountOut in exchange for giving this contract amountIn (base)\n//     function mintAndPull(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\n        \n//         // Mint and Pull \n//         if(isLong) TradeToken.mint(recipient, amountOut); \n//         else s_tradeToken.mint(recipient, amountOut); \n//         BaseToken.transferFrom(recipient,address(this), amountIn); \n//     }\n\n//     function burnAndPush(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\n//         // Burn and Push \n//         if(isLong) TradeToken.burn(recipient, amountIn); \n//         else s_tradeToken.burn(recipient, amountIn); \n   \n//         BaseToken.transfer(recipient, amountOut); \n//     }\n\n//     function baseBal() public view returns(uint256){\n//         return BaseToken.balanceOf(address(this)); \n//     }\n\n//     /// @notice Long up the curve, or short down the curve \n//     /// @param amountIn is base if long, trade if short\n//     /// @param priceLimit is slippage tolerance\n//     function takerOpen(\n//         bool isLong, \n//         int256 amountIn,\n//         uint256 priceLimit, \n//         bytes calldata data\n//         ) external  returns(uint256 poolamountIn, uint256 poolamountOut ){\n//         if(isLong){\n//             // Buy up \n//             (poolamountIn, poolamountOut) = trade(\n//                 msg.sender, \n//                 true, \n//                 amountIn, \n//                 priceLimit, \n//                 data\n//             ); \n//             if (noCallBack) mintAndPull(msg.sender, poolamountOut, poolamountIn, true);\n\n//             else {\n//                 uint256 bal = baseBal(); \n//                 iTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \n//                 require(baseBal() >= poolamountIn + bal, \"balERR\"); \n//                 TradeToken.mint(abi.decode(data, (address)), poolamountOut); \n//             }\n//         }\n\n//         else{\n//             // just shift pool state\n//             (poolamountIn, poolamountOut) = trade(\n//                 address(this), \n//                 false, \n//                 amountIn, \n//                 priceLimit, \n//                 data\n//             ); \n//             uint b = baseBal(); \n//             console.log('basebal',b , poolamountOut); \n//             require(poolamountOut <= baseBal(), \"!ammLiq\"); \n//             uint256 cached_poolamountOut = poolamountOut; \n//             // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\n//             poolamountOut = poolamountIn.mulWadDown(maxPrice) - poolamountOut;\n\n//             // One s_tradeToken is a representation of debt+sell of one tradetoken\n//             // Escrow collateral required for shorting, where price for long + short = maxPrice, \n//             // so (maxPrice-price of trade) * quantity\n//             if (noCallBack) mintAndPull(msg.sender, poolamountIn, poolamountOut, false);\n\n//             else{\n//                 uint256 bal = baseBal(); \n//                 iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \n//                 require(baseBal() >= poolamountOut + bal, \"balERR\"); \n//                 s_tradeToken.mint(abi.decode(data,(address)), poolamountIn); \n\n//                 // need to send cached poolamountOut(the area under the curve) data for accounting purposes\n//                 poolamountIn = cached_poolamountOut; \n//             }\n\n//             // BaseToken.transferFrom(msg.sender, address(this), poolamountIn.mulWadDown(maxPrice) - poolamountOut); \n//             // s_tradeToken.mint(msg.sender, uint256(amountIn)); \n//         }\n\n//     }\n\n//     /// @param amountIn is trade if long, ALSO trade if short, since getting rid of s_trade \n//     function takerClose(\n//         bool isLong, \n//         int256 amountIn,\n//         uint256 priceLimit, \n//         bytes calldata data\n//         ) external returns(uint256 poolamountIn, uint256 poolamountOut){\n\n//         // Sell down\n//         if(isLong){\n//             (poolamountIn, poolamountOut) = trade(\n//                 msg.sender,\n//                 false, \n//                 amountIn, //this should be trade tokens\n//                 priceLimit, \n//                 data\n//             ); \n\n//             if (noCallBack) burnAndPush(msg.sender, poolamountOut, poolamountIn, true);\n\n//             else burnAndPush(abi.decode(data, (address)), poolamountOut, poolamountIn, true );                             \n//         }\n\n//         else{            \n//             // buy up with the baseToken that was transferred to this contract when opened, in is base out is trade\n//             (poolamountIn, poolamountOut) = trade(\n//                 msg.sender, \n//                 true, \n//                 amountIn, \n//                 priceLimit, \n//                 data\n//             ); \n//             uint256 cached_poolamountIn = poolamountIn; \n\n//             // collateral used to buy short \n//             poolamountIn = poolamountOut.mulWadDown(maxPrice) - poolamountIn; \n\n//             if (noCallBack) burnAndPush(msg.sender, poolamountIn,poolamountOut, false);\n//             else {\n//                 burnAndPush(abi.decode(data, (address)), poolamountIn, poolamountOut,false ); \n//                 poolamountOut = cached_poolamountIn; \n//             }\n\n//             // s_tradeToken.burn(msg.sender, poolamountOut); \n//             // BaseToken.transfer(msg.sender, poolamountOut.mulWadDown(maxPrice) - poolamountIn);\n//         }\n//     }\n\n//     /// @notice provides oneTimeliquidity in the range (point,point+1)\n//     /// @param amount is in base if long, trade if in short  \n//     function makerOpen(\n//         uint16 point, \n//         uint256 amount,\n//         bool isLong,\n//         address recipient\n//         )external  returns(uint256 toEscrowAmount, uint128 crossId){\n\n//         if(isLong){\n//             // escrowAmount is base \n//             (toEscrowAmount, crossId) = placeLimitOrder(\n//                 recipient,\n//                 point, \n//                 uint128(liquidityGivenBase(pointToPrice(point+1), pointToPrice(point), amount)), \n//                 false\n//                 ); \n//             BaseToken.transferFrom(recipient, address(this), toEscrowAmount); \n//         }\n\n//         // need to set limit for sells, but claiming process is different then regular sells \n//         else{\n//             // escrowAmount is trade \n//             (toEscrowAmount, crossId) = placeLimitOrder(\n//                 recipient, \n//                 point,\n//                 uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)) , \n//                 true\n//                 ); \n\n//             // escrow amount is (maxPrice - avgPrice) * quantity \n//             uint256 escrowCollateral = toEscrowAmount - baseGivenLiquidity(\n//                     pointToPrice(point+1), \n//                     pointToPrice(point), \n//                     uint256(amount) //positive since adding asks, not subtracting \n//                     ); \n//             BaseToken.transferFrom(recipient, address(this), escrowCollateral); \n//             toEscrowAmount = escrowCollateral; \n//         }\n\n//     }\n\n//     function makerClaimOpen(\n//         uint16 point, \n//         bool isLong, \n//         address recipient\n//         )external returns(uint256 claimedAmount){\n\n//         if(isLong){\n//             uint256 claimedAmount = claimFilledOrder(recipient, point, false ); \n\n//             // user already escrowed funds, so need to send him tradeTokens \n//             TradeToken.mint(recipient, claimedAmount);          \n//         }\n\n//         else{           \n//             s_tradeToken.mint(recipient, \n//                 tradeGivenLiquidity(\n//                     pointToPrice(point+1), \n//                     pointToPrice(point), \n//                     getLiq(msg.sender, point, true)\n//                     )\n//                 ); \n\n//             // open short is filled sells, check if sells are filled. If it is,\n//             // claimedAmount of basetokens should already be in this contract \n//             claimedAmount = claimFilledOrder(recipient, point, true ); \n//         }\n\n//     }\n//     /// @notice amount is trade if long, but ALSO trade if short(since trade quantity also coincides\n//     /// with shortTrade quantity )\n//     function makerClose(\n//         uint16 point, \n//         uint256 amount,\n//         bool isLong, \n//         address recipient\n//         )external returns(uint256 toEscrowAmount, uint128 crossId){\n\n//         if(isLong){\n//             // close long is putting up trades for sells, \n//             (toEscrowAmount, crossId) = placeLimitOrder(\n//                 recipient, \n//                 point, \n//                 uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \n//                 true\n//                 ); \n//             //maybe burn it when claiming, and just escrow? \n//             TradeToken.burn(recipient, toEscrowAmount); \n//         }\n\n//         else{\n//             // Place limit orders for buys \n//             (toEscrowAmount, crossId) = placeLimitOrder(\n//                 recipient, \n//                 point,\n//                 uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \n//                 false\n//                 ); \n\n//             // burn s_tradeTokens, \n//             s_tradeToken.burn(recipient, amount); \n\n//         }\n//     }\n\n//     function makerClaimClose(\n//         uint16 point, \n//         bool isLong, \n//         address recipient\n//         ) external returns(uint256 claimedAmount){\n\n//         if(isLong){\n//             // Sell is filled, so need to transfer back base \n//             claimedAmount = claimFilledOrder(recipient, point, true ); \n//             BaseToken.transfer(recipient, claimedAmount); \n//         }\n//         else{\n//             uint128 liq = getLiq(recipient, point, false); \n\n//             // Buy is filled, which means somebody burnt trade, so claimedAmount is in trade\n//             claimedAmount = claimFilledOrder(recipient, point, false);\n//             claimedAmount = claimedAmount.mulWadDown(maxPrice) \n//                             - baseGivenLiquidity(\n//                             pointToPrice(point+1), \n//                             pointToPrice(point), \n//                             liq); \n//             BaseToken.transfer(recipient, claimedAmount);\n//         }\n//     }    \n\n//     function makerPartiallyClaim(\n//         uint16 point, \n//         bool isLong,\n//         bool open, \n//         address recipient\n//         ) external returns(uint256 baseAmount, uint256 tradeAmount){\n   \n//         if(open){\n//             if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false); \n//             else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true);\n//         }\n//         else{\n//             if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true); \n//             else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false);\n//         }\n        \n//         BaseToken.transfer(recipient, baseAmount);\n//         TradeToken.mint(recipient, tradeAmount); \n//     }\n\n//     /// @notice amount is in base if long, trade if short \n//     function makerReduceOpen(\n//         uint16 point, \n//         uint256 amount, \n//         bool isLong, \n//         address recipient\n//         ) external{\n    \n//         if(isLong){\n//             uint256 returned_amount =reduceLimitOrder(\n//                 recipient, \n//                 point, \n//                 liquidityGivenBase(\n//                     pointToPrice(point+1), \n//                     pointToPrice(point),\n//                     amount\n//                     ).toUint128(), \n//                 false\n//                 ); \n//             // need to send base back \n//             BaseToken.transfer(recipient, returned_amount); \n//         }\n//         else {\n//             uint128 liq = liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amount).toUint128(); \n//             // Reduce asks \n//             reduceLimitOrder(\n//                 recipient, \n//                 point, \n//                 liq, \n//                 true\n//                 ); \n\n//             // Need to send escrowed basetoken back, which is shortTrade quantity - baseGivenLiquidity \n//             BaseToken.transfer(recipient, \n//                 amount - baseGivenLiquidity(pointToPrice(point+1), pointToPrice(point), liq));\n//         }\n//     }\n\n//     /// @notice amount is in trade if long, ALSO trade if short \n//     function makerReduceClose(      \n//         uint16 point, \n//         uint256 amount, \n//         bool isLong,\n//         address recipient\n//         ) external{\n\n//         if(isLong){\n//             uint256 returned_amount = reduceLimitOrder(\n//                 recipient, \n//                 point, \n//                 liquidityGivenTrade(\n//                     uint256(pointToPrice(point+1)), \n//                     uint256(pointToPrice(point)), amount).toUint128(), \n//                 true\n//                 ); \n//             // need to send trade back \n//             TradeToken.mint(recipient, returned_amount); \n//         }\n\n//         else{\n//             // reduce limit bids \n//             reduceLimitOrder(\n//                 recipient, \n//                 point, \n//                 liquidityGivenTrade(\n//                     uint256(pointToPrice(point+1)), \n//                     uint256(pointToPrice(point)), amount).toUint128(), \n//                 false\n//             ); \n             \n//             s_tradeToken.mint(recipient, amount); \n//         }\n//     }\n\n//     // TODO separate contracts \n//     // function provideLiquidity(\n//     //     uint16 pointLower,\n//     //     uint16 pointUpper,\n//     //     uint128 amount, \n//     //     bytes calldata data \n//     //     ) external {\n\n//     //     (uint256 amount0, uint256 amount1) = provide(\n//     //         msg.sender, \n//     //         pointLower, \n//     //         pointUpper, \n//     //         amount, \n//     //         data \n//     //     ); \n//     //     BaseToken.transferFrom(msg.sender, address(this), amount0); \n//     //     // TradeToken.transferFrom(msg.sender, address(this), amount1);\n//     //     TradeToken.burn(msg.sender, amount1);\n//     // }\n\n//     // function withdrawLiquidity(\n//     //     uint16 pointLower,\n//     //     uint16 pointUpper,\n//     //     uint128 amount, \n//     //     bytes calldata data \n//     //     )external{\n\n//     //     (uint256 amountBase, uint256 amountTrade) = remove(\n//     //         msg.sender, \n//     //         pointLower, \n//     //         pointUpper, \n//     //         amount\n//     //     ); \n      \n//     //     collect(\n//     //         msg.sender, \n//     //         pointLower,\n//     //         pointUpper,\n//     //         type(uint128).max,\n//     //         type(uint128).max\n//     //     ); \n\n//     //     BaseToken.transfer(msg.sender,  amountBase); \n//     //     TradeToken.mint(msg.sender, amountTrade); \n//     // }\n\n//     //TODO fees, skipping uninit for gas, below functions\n//     // possible attacks: manipulation of price with no liquidityregions, add a bid/ask and a naive \n//     // trader fills, and immediately submit a ask much higher/lower\n//     // gas scales with number of loops, so need to set ticks apart large, or provide minimal liquidity in each tick\n\n// }\n\n// interface iTradeCallBack{\n//     function tradeCallBack(\n//         uint256 amount0,\n//  bytes calldata data    ) external;\n// } \n"
    },
    "contracts/bonds/GBC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n// import {ERC20} from \"./aave/Libraries.sol\"; \nimport {SafeCast, FixedPointMath, ERC20} from \"./libraries.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \n/// @dev all funds will be handled in the child contract \ncontract GranularBondingCurve{\n    using FixedPointMath for uint256;\n    using Tick for mapping(uint16 => Tick.Info);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n    using SafeCast for uint256; \n\n\n    modifier onlyEntry(){\n        require(entry == msg.sender  ,\"Not Entry\"); \n        _;\n    }\n    \n    bool private _mutex;\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    constructor(\n        address _baseToken,\n        address _tradeToken\n        //uint256 _priceDelta\n        ) {\n        tradeToken = _tradeToken; \n        baseToken = _baseToken; \n        //priceDelta = _priceDelta; \n        fee =0; \n        factory = address(0); \n        tickSpacing = 0; \n\n        //Start liquidity \n        liquidity = 100 * uint128(PRECISION); \n\n        owner = msg.sender; \n    }\n\n    address public immutable owner; \n    uint24 public immutable  fee;\n    Slot0 public slot0; // global state?\n    address public immutable  factory;\n    address public immutable  tradeToken;\n    address public immutable  baseToken;\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\n\n    uint128 public liquidity;\n    uint128 public cachedLiquidity; \n\n    mapping(uint16 => Tick.Info) public ticks;\n\n    mapping(bytes32 => Position.Info) public  positions;\n\n    // mapping(uint16=> PricePoint) Points; \n\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\n    uint256 public constant ROUNDLIMIT = 1e4; \n    uint256 public constant PRECISION = 1e18; \n    address public entry; \n\n    /// @notice previliged function called by the market maker \n    /// if he is the one providing all the liquidity \n    function setLiquidity(uint128 liq) internal  \n    //onlyEntry\n    {\n        liquidity = liq; \n    }\n\n    function setEntry(address _entry) external onlyEntry{\n        entry = _entry; \n    }\n    function lock() external onlyEntry{\n        slot0.unlocked = !slot0.unlocked; \n    }\n\n    function positionIsFilled(\n        address recipient, \n        uint16 point, \n        bool isAsk\n    ) \n        public view returns(bool){\n        Position.Info storage position = positions.get(recipient, point, point+1);\n\n        uint128 numCross = ticks.getNumCross(point, isAsk); \n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\n\n        return (liq>0 && numCross > crossId); \n    }\n\n    function setPriceAndPoint(uint256 price) internal  \n    //onlyOwner\n    {\n        slot0.point = priceToPoint(price);         \n        slot0.curPrice = price.toUint160(); \n    }\n\n    function getCurPrice() external view returns(uint256){\n        return slot0.curPrice; \n    }\n\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\n        return uint256(ticks.oneTimeLiquidity(point)); \n    }    \n\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\n        return ticks.getNumCross(point, moveUp); \n    }\n\n\n    struct Slot0 {\n        // the current price\n        uint160 curPrice;\n        // the current tick\n        uint16 point;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n\n        // Whether liquidity provision is amortized \n        bool amortized; \n\n        // Where to modify liquidity \n        uint16 modifyLiqPoint; \n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        uint256 amountCalculated;\n        // current sqrt(price)\n        uint256 curPrice;\n        // the tick associated with the current price\n        uint16 point;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobal;\n        // amount of input token paid as protocol fee\n        uint128 protocolFee;\n        // the current liquidity in range\n        uint128 liquidity;\n        uint128 liquidityStart; \n\n\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint256 priceStart;\n        // the next tick to swap to from the current tick in the swap direction\n        uint16 pointNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // price for the next tick (1/0)\n        uint256 priceNextLimit;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n\n        uint128 liqDir; \n    }\n\n    struct swapVars{\n        uint256 a;\n        uint256 s; \n        uint256 b; \n    }\n\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\n    /// -amountSpecified is in trade if moveUp, else is in base \n    /// returns amountIn if moveUp, cash, else token\n    /// returns amountOut if moveUp, token, else cash \n    function trade(\n        address recipient, \n        bool moveUp, \n        int256 amountSpecified, \n        uint256 priceLimit, \n        bytes calldata data\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\n        console.logString('---New Trade---'); \n\n        Slot0 memory slot0Start = slot0; \n        uint256 pDelta = priceDelta; \n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amountSpecified, \n            amountCalculated: 0, \n            curPrice: uint256(slot0Start.curPrice),\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\n            protocolFee: 0, \n            liquidity: liquidity, \n            liquidityStart: liquidity,\n            point: slot0.point\n            }); \n        swapVars memory vars = swapVars({\n            a:0,\n            b:0,\n            s:0\n            });\n\n        bool exactInput = amountSpecified > 0;\n\n        // increment price by 1/1e18 if at boundary, and go back up a point,\n        // should be negligible compared to fees TODO \n        if (mod0(state.curPrice, pDelta) && !moveUp) {\n            state.curPrice += 1; \n            state.point = priceToPoint(state.curPrice);\n            slot0.point = state.point; \n            slot0Start.point = state.point; \n        }\n        \n        require(moveUp? priceLimit>= state.curPrice : priceLimit<= state.curPrice, \"plimitERR\" ); \n        priceLimit = pointToPrice(priceToPoint(priceLimit)); \n\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\n            StepComputations memory step; \n            step.priceStart = state.curPrice; \n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \n            step.pointNext = moveUp? state.point + 1 : state.point-1; \n\n            // Only when during non-amortization period, make liquidity finite again when cross \n            // modifyLiqPoint thresdhold. \n            if (!slot0Start.amortized && state.point == slot0Start.modifyLiqPoint\n                && !moveUp&& tradeWhileModified == 0){\n\n                // move down, so amountIn is in trade \n                // Can't be 0 since crossed mofifyLiqPoint already and cached\n                assert(cachedLiquidity !=0); \n                state.liquidity = cachedLiquidity; \n            }\n\n            // Need liquidity for both move up and move down for path independence within a \n            // given point range. Either one of them should be 0 \n            step.liqDir = ticks.oneTimeLiquidity(state.point);\n            vars.a = exactInput \n                ? inv(state.liquidity + step.liqDir)\n                : invRoundUp(state.liquidity + step.liqDir); \n            vars.b = yInt(state.curPrice, moveUp); \n            vars.s = xMax(state.curPrice, vars.b, vars.a); \n \n            //If moveup, amountIn is in cash, amountOut is token and vice versa \n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\n                state.curPrice, \n                step.priceNextLimit,    \n                state.amountSpecifiedRemaining, \n                fee, \n                vars               \n                ); \n\n\n            {console.log('________'); \n            console.log('CURPRICE', state.curPrice); \n            console.log('trading; liquidity, amountleft', state.liquidity); \n            console.log(uint256(state.amountSpecifiedRemaining));\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \n            console.log('a', vars.a); }\n            console.log('amountinandout', step.amountIn, step.amountOut); \n            console.log('s,b', vars.s, vars.b); \n\n            // Track tokens, amountOut is in tokens \n            if(liqModified && moveUp) tradeWhileModified += step.amountOut;\n\n            // Only when during non-amortization period, add liquidity when crossing up \n            if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint){\n                if(moveUp){\n                    cachedLiquidity = state.liquidity; \n                    state.liquidity = addDelta(state.liquidity, dynamicLiq[step.pointNext] ); \n\n                    // initiate tracker \n                    liqModified = true; \n                    }\n                } \n            if(!slot0Start.amortized && !moveUp && state.point == slot0Start.modifyLiqPoint && tradeWhileModified != 0){\n                // move down and first cross. Consume tradeWhileModified liquidity first \n                if (tradeWhileModified > uint256(state.amountSpecifiedRemaining)){\n                    step.amountIn = uint256(state.amountSpecifiedRemaining); \n                    tradeWhileModified -= uint256(state.amountSpecifiedRemaining); \n                } else{\n                    step.amountIn = tradeWhileModified; \n                    tradeWhileModified = 0;                       \n                }\n                step.amountOut = step.amountIn.divWadDown(state.curPrice); \n                state.curPrice += 1; \n            console.log('amountin', step.amountIn, step.amountOut); \n\n            }\n\n            if (exactInput){\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \n            }\n            else{\n                state.amountSpecifiedRemaining += int256(step.amountIn); \n            }\n            state.amountCalculated += step.amountOut; \n\n            if (state.liquidity>0)\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \n\n            // If next limit reached, cross price range and change slope(liquidity)\n            if (state.curPrice == step.priceNextLimit){\n\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\n                // Else if crossing DOWN, bids are all filled \n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \n\n                int128 liquidityNet = ticks.cross(\n                    step.pointNext, \n                    feeGrowthGlobalBase,\n                    feeGrowthGlobalTrade\n                    ); \n\n                if (!moveUp) liquidityNet = -liquidityNet; \n\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\n                state.point = step.pointNext;  \n            }\n        }\n\n        slot0.curPrice = state.curPrice.toUint160(); \n        if(state.point != slot0Start.point) slot0.point = state.point; \n            \n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\n\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \n            \n        // (amountIn, amountOut) = exactInput\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \n\n        (amountIn, amountOut) = exactInput\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \n\n    }\n    bool liqModified; \n    uint256 tradeWhileModified; \n\n    function placeLimitOrder(\n        address recipient, \n        uint16 point, \n        uint128 amount,\n        bool isAsk  \n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \n        //TODO mint NFT \n        // Should only accept asks for price above the current point range\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\"ask below prie\"); \n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\"bids above prie\"); \n\n        Position.Info storage position = positions.get(recipient, point, point+1);\n\n        numCross = ticks.getNumCross(point, isAsk); \n        position.updateLimit(int128(amount), isAsk, numCross); \n\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \n\n        // If placing bids, need to escrow baseAsset, vice versa \n        address tokenToEscrow = isAsk? tradeToken : baseToken;\n\n        amountToEscrow = isAsk\n                ? tradeGivenLiquidity(\n                    pointToPrice(point+1), \n                    pointToPrice(point), \n                    uint256(amount) \n                    )\n            \n                : baseGivenLiquidity(\n                    pointToPrice(point+1), \n                    pointToPrice(point), \n                    uint256(amount) \n                    ); \n\n        console.log('amountbid', amountToEscrow); \n\n    }\n\n    function reduceLimitOrder(\n        address recipient, \n        uint16 point, \n        uint128 amount,\n        bool isAsk \n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \"Can't reduce order for current tick\"); \n\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\n\n        position.updateLimit(-int128(amount), isAsk, 0); \n\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \n\n        address tokenToReturn = isAsk? tradeToken : baseToken;\n        \n        amountToReturn = isAsk\n            ? tradeGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(amount) \n                )\n         \n            : baseGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(amount) \n                );\n    }\n\n    /// @notice called when maker wants to claim when the the price is at the \n    /// point he submitted the order\n    function claimPartiallyFilledOrder(\n        address recipient, \n        uint16 point,\n        bool isAsk\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\n        Slot0 memory _slot0 = slot0; \n\n        Position.Info storage position = positions.get(recipient, point, point+1);\n        require(priceToPoint(uint256(_slot0.curPrice)) == point, \"Not cur price\"); \n\n        // Assume trying to withdraw all liquidity provided \n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \n       \n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \n\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \n\n        // Get total trade filled OR remaining\n        tradeAmount = tradeGivenLiquidity(\n            pointToPrice(point+1),\n            _slot0.curPrice, \n            liqToWithdraw\n        ); \n           \n        // Get total base filled OR remaining \n        baseAmount = baseGivenLiquidity(\n            _slot0.curPrice, \n            pointToPrice(point), \n            liqToWithdraw\n            ); \n\n    }\n\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \n    /// or crossDown \n    function claimFilledOrder(\n        address recipient, \n        uint16 point, \n        bool isAsk \n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\n        Position.Info storage position = positions.get(recipient, point, point+1);\n\n        uint128 numCross = ticks.getNumCross(point, isAsk); \n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \n        require(numCross > crossId, \"Position not filled\");\n\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\n\n        // Sold to base when asks are filled\n        if(isAsk) claimedAmount = baseGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(liq) \n                ); \n\n        // Bought when bids are filled so want tradeTokens\n        else claimedAmount = tradeGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(liq) \n                ); \n\n        position.updateLimit(-int128(liq), isAsk, 0); \n        \n        // Need to burn AND \n\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        uint16 pointLower;\n        uint16 pointUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n    }\n\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\n    function provide(\n        address recipient, \n        uint16 pointLower, \n        uint16 pointUpper, \n        uint128 amount, \n        bytes calldata data \n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\n        require(amount > 0, \"0 amount\"); \n\n        (,  amount0,  amount1) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient, \n                pointLower : pointLower, \n                pointUpper: pointUpper, \n                liquidityDelta: int128(amount)//.toInt128()\n                })\n            ); \n\n        //mintCallback\n\n    }\n\n    function remove(\n        address recipient, \n        uint16 pointLower, \n        uint16 pointUpper, \n        uint128 amount\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\n\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient, \n                pointLower : pointLower, \n                pointUpper: pointUpper, \n                liquidityDelta: -int128(amount)//.toInt128()\n                })\n            ); \n\n        if(amount0>0 || amount1> 0){\n            (position.tokensOwed0, position.tokensOwed1) = (\n                position.tokensOwed0 + amount0,\n                position.tokensOwed1 + amount1\n            );\n        }\n        return (amount0, amount1); \n    }\n\n    function collect(\n        address recipient,\n        uint16 tickLower,\n        uint16 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\n\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\n\n        if (amount0 > 0) {\n            position.tokensOwed0 -= amount0;\n        }\n        if (amount1 > 0) {\n            position.tokensOwed1 -= amount1;\n        }\n    }\n\n\n    function _modifyPosition(ModifyPositionParams memory params)\n    private \n    returns(\n        Position.Info storage position, \n        uint256 baseAmount, \n        uint256 tradeAmount\n        )\n    {\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\n\n        position = _updatePosition(\n            params.owner,\n            params.pointLower,\n            params.pointUpper,\n            params.liquidityDelta,\n            _slot0.point\n        );\n\n        if (params.liquidityDelta != 0){\n            if (_slot0.point < params.pointLower){\n                // in case where liquidity is just asks waiting to be sold into, \n                // so need to only provide tradeAsset \n                tradeAmount = tradeGivenLiquidity(\n                    pointToPrice(params.pointUpper), \n                    pointToPrice(params.pointLower), \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                    ); \n            } else if( _slot0.point < params.pointUpper){\n                uint128 liquidityBefore = liquidity; \n\n                // Get total asks to be submitted above current price\n                tradeAmount = tradeGivenLiquidity(\n                    pointToPrice(params.pointUpper),\n                    _slot0.curPrice, \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                    ); \n\n                // Get total bids to be submitted below current price \n                baseAmount = baseGivenLiquidity(\n                    _slot0.curPrice, \n                    pointToPrice(params.pointLower), \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                    ); \n\n                // Slope changes since current price is in this range \n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\n\n            } else{\n                // liquidity is just bids waiting to be bought into \n                baseAmount = baseGivenLiquidity(\n                    pointToPrice(params.pointUpper), \n                    pointToPrice(params.pointLower), \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                ); \n            }\n        }\n    }\n\n    uint256 public feeGrowthGlobalBase;\n    uint256 public feeGrowthGlobalTrade;\n\n    function _updatePosition(\n        address owner, \n        uint16 pointLower, \n        uint16 pointUpper, \n        int128 liquidityDelta, \n        uint16 point \n        ) private returns(Position.Info storage position){\n\n        position = positions.get(owner, pointLower, pointUpper); \n\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \n\n        if(liquidityDelta != 0){\n\n            ticks.update(\n                pointLower, \n                point, \n                liquidityDelta, \n                feeGrowthGlobalBase,\n                feeGrowthGlobalTrade,\n                false\n                ); \n\n            ticks.update(\n                pointUpper, \n                point, \n                liquidityDelta, \n                feeGrowthGlobalBase,\n                feeGrowthGlobalTrade,\n                true\n                ); \n        } \n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \n    }\n\n\n    mapping(uint16=> int128) dynamicLiq; \n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\n        dynamicLiq[point] = liq; \n    }\n    function setModifyLiqPoint(uint16 point) internal{\n        slot0.modifyLiqPoint = point;  \n    }\n    function amortizeLiq() internal{\n        slot0.amortized = true; \n    }\n\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\n        require(p2>=p1, \"price ERR\"); \n        return (p2-p1).mulWadDown(L); \n    }\n\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\n        require(p2>=p1, \"price ERR\"); \n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \n    }\n\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\n        require(p2>=p1, \"price ERR\"); \n        return T.divWadDown(p2-p1); \n    }\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\n        require(p2>=p1, \"price ERR\"); \n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \n    }\n\n    function pointToPrice(uint16 point) public pure returns(uint160){\n        return(uint256(point) * priceDelta).toUint160(); \n    }\n\n    /// @notice will round down to nearest integer \n    function priceToPoint(uint256 price) public pure returns(uint16){\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \n    }\n\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        if(a==0) return type(uint256).max; \n        return (curPrice-b).divWadDown(a); \n    }\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        return (curPrice-b).divWadUp(a); \n    }\n\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\n    /// the current point\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\n        uint16 point = priceToPoint(curPrice); \n\n        // If at boundary when moving down, decrement point by one\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \n    }\n\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\n        if (moveUp) return uint256(point+1) * pDelta; \n        else return uint256(point) * pDelta; \n    }\n\n    function inv(uint256 l) internal pure returns(uint256){\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \n    }\n    function invRoundUp(uint256 l) internal pure returns(uint256){\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\n        return (a%b ==0); \n    }\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\n        return  isAsk\n                ? positions.get(to, point, point+1).askLiq\n                : positions.get(to, point, point+1).bidLiq; \n    }\n\n}\n\nlibrary LinearCurve{\n    uint256 public constant PRECISION = 1e18; \n    using FixedPointMath for uint256; \n\n\n    /// @notice Compute results of swap given amount in and params\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// b is 0 and s is curPrice/a during variable liquidity phase\n    function swapStep(\n        uint256 curPrice, \n        uint256 targetPrice, \n        int256 amountRemaining, \n        uint24 feePips,    \n        GranularBondingCurve.swapVars memory vars       \n        ) \n        public \n        pure \n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\n\n        bool moveUp = targetPrice >= curPrice; \n        bool exactInput = amountRemaining >= 0; \n\n        // If move up and exactInput, amountIn is base, amountOut is trade \n        if (exactInput){\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\n\n            if (moveUp){\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \n\n                // If overshoot go to next point\n                if (nextPrice >= targetPrice){\n                    nextPrice = targetPrice; \n\n                    // max amount out for a given price range is Pdelta / a \n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \n                }            \n                else {\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \n                }   \n            }\n\n            // amountIn is trade, amountOut is base \n            else {\n                // If amount is greater than s, then need to cap it \n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \n                // If undershoot go to previous point \n                if(nextPrice <= targetPrice && vars.a > 0){//TODO might introduce bugs \n                    nextPrice = targetPrice; \n\n                    // max amount out is area under curve \n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \n\n                }\n                else{\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \n                }\n            }\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \n        }\n\n        else {\n            if(moveUp){\n                uint256 remaining = uint256(-amountRemaining); \n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \n\n                // if overshoot\n                if(nextPrice>=targetPrice){\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \n                    nextPrice = targetPrice; \n\n                    // Prevent stuck cases where point is almost filled but not quite \n                    if(remaining - amountIn<=1e4){\n                        amountIn = remaining; \n                    } \n                }\n                else amountIn = remaining; \n\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\n\n            }\n            else{\n                //TODO \n            }\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\n            amountOut = amountOut + feeAmount;\n        }\n    }\n\n\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\n    /// @param amount: amount of base in\n    /// returns amountDelta wanted token returned \n    function amountOutGivenIn( \n        uint256 amount,\n        uint256 s, \n        uint256 a, \n        uint256 b, \n        bool up\n        ) \n        public \n        pure \n        returns(uint256 amountDelta, uint256 resultPrice) {\n        \n        // If liquidity is not infinite \n        if(a > 0){\n            if (up){\n                //TODO overflow on small amount \n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \n                uint256 y = 2*( a.mulWadDown(amount)); \n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\n                uint256 z = (a.mulWadDown(s) + b); \n                amountDelta = (x_y_sqrt-z).divWadDown(a);\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \n            } else{\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \n                amountDelta = amount.mulWadDown(z); \n                resultPrice = a.mulWadDown(s-amount) + b; \n            }\n        }\n\n        // When a = 0, infinite liquidity and constant price\n        else{     \n            if(up){\n                amountDelta = amount.divWadDown(b); \n            } else{\n                amountDelta = amount.mulWadDown(b); \n            }\n            resultPrice = b;             \n        }\n    }\n\n    /// @notice calculates area under the curve from s to s+amount\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\n     /// returned in collateral decimals\n    function areaUnderCurve(\n        uint256 amount, \n        uint256 s, \n        uint256 a, \n        uint256 b) \n        public\n        pure \n        returns(uint256 area){\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \n    }\n    function areaUnderCurveRoundUp(\n        uint256 amount, \n        uint256 s, \n        uint256 a, \n        uint256 b) \n        public\n        pure \n        returns(uint256 area){\n        // you want area to be big for a given amount \n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        if(a==0) return type(uint256).max; \n        return (curPrice-b).divWadDown(a); \n    }\n\n}\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    using FixedPointMath for uint256;\n\n    // info stored for each user's position\n    struct Info {\n        uint128 bidCrossId; \n        uint128 askCrossId; \n        uint128 askLiq; \n        uint128 bidLiq; \n\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        // the fees owed to the position owner in token0/token1\n        uint256 tokensOwed0;\n        uint256 tokensOwed1;\n\n        \n    }\n\n    function updateLimit(\n        Info storage self,\n        int128 limitLiqudityDelta, \n        bool isAsk, \n        uint128 crossId\n        ) internal {\n\n        if (isAsk) {\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \n        } \n\n        else {\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \n        }\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(\n        mapping(bytes32 => Info) storage self,\n        address owner,\n        uint16 tickLower,\n        uint16 tickUpper\n    ) internal view returns (Position.Info storage position) {\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function update(\n        Info storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal {\n        Info memory _self = self;\n\n        uint128 liquidityNext;\n        if (liquidityDelta == 0) {\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\n            liquidityNext = _self.liquidity;\n        } else {\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\n        }\n\n        // calculate accumulated fees\n        uint128 tokensOwed0 = uint128(\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\n                .mulDivDown(uint256(_self.liquidity), 1e18)\n            );\n        uint128 tokensOwed1 =uint128(\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\n                .mulDivDown(uint256(_self.liquidity), 1e18)\n            );\n            \n        // update the position\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\n            self.tokensOwed0 += tokensOwed0;\n            self.tokensOwed1 += tokensOwed1;\n        }\n    }\n\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n\n/// @title Tick\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary Tick {\n    using FixedPointMath for uint256;\n\n    using SafeCast for int256;\n\n    // info stored for each initialized individual tick\n    struct Info {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute  the value depends on when the tick is initialized\n        uint256 feeGrowthOutsideBase;\n        uint256 feeGrowthOutsideTrade;\n        // the cumulative tick value on the other side of the tick\n        int56 tickCumulativeOutside;\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute  the value depends on when the tick is initialized\n        uint160 secondsPerLiquidityOutsideX128;\n        // the seconds spent on the other side of the tick (relative to the current tick)\n        // only has relative meaning, not absolute  the value depends on when the tick is initialized\n        uint32 secondsOutside;\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n        bool initialized;\n\n        uint128 askLiquidityGross; \n        uint128 bidLiquidityGross;\n        uint128 askNumCross; \n        uint128 bidNumCross; \n    }\n\n    function getNumCross(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick, \n        bool isAsk\n        ) internal view returns(uint128){\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \n    }\n\n    function oneTimeLiquidity(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick \n        ) internal view returns(uint128){\n        Tick.Info memory info = self[tick]; \n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \n        return info.askLiquidityGross + info.bidLiquidityGross; \n    }\n\n    function deleteOneTimeLiquidity(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick, \n        bool isAsk\n        ) internal {\n        Tick.Info storage info = self[tick]; \n        if(isAsk) {\n            info.askLiquidityGross = 0;\n            info.askNumCross++; \n            console.log('tick??', tick); \n        }\n        else {\n            info.bidLiquidityGross = 0; \n            info.bidNumCross++; \n        }\n    }\n\n    function updateOneTimeLiquidity(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick, \n        int128 oneTimeLiquidityDelta,\n        bool isAsk\n        ) internal {\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\n    }\n\n    function update(\n        mapping(uint16 => Tick.Info) storage self,\n        uint16 tick,\n        uint16 tickCurrent,\n        int128 liquidityDelta,\n        uint256 feeGrowthGlobalBase, \n        uint256 feeGrowthGlobalTrade, \n        bool upper\n    ) internal returns (bool flipped) {\n        Tick.Info storage info = self[tick];\n\n        uint128 liquidityGrossBefore = info.liquidityGross; \n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if(liquidityGrossBefore == 0) {\n            if(tick<=tickCurrent){\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \n            }\n            info.initialized = true; \n        }\n        info.liquidityGross = liquidityGrossAfter;\n\n        info.liquidityNet = upper \n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \n    }\n\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\n        delete self[tick];\n    }\n\n    function cross(\n        mapping(uint16 => Tick.Info) storage self,\n        uint16 tick, \n        uint256 feeGrowthGlobalBase,\n        uint256 feeGrowthGlobalTrade\n    ) internal returns (int128 liquidityNet) {\n        Tick.Info storage info = self[tick]; \n\n        liquidityNet = info.liquidityNet; \n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\n    }\n\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n\n    function getFeeGrowthInside(\n        mapping(uint16 => Tick.Info) storage self,\n        uint16 tickLower,\n        uint16 tickUpper,\n        uint16 tickCurrent,\n        uint256 feeGrowthGlobalBase,\n        uint256 feeGrowthGlobalTrade\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\n        Info storage lower = self[tickLower];\n        Info storage upper = self[tickUpper];\n\n        // calculate fee growth below\n        uint256 feeGrowthBelowBase;\n        uint256 feeGrowthBelowTrade;\n        if (tickCurrent >= tickLower) {\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\n        } else {\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\n        }\n\n        // calculate fee growth above\n        uint256 feeGrowthAboveBase;\n        uint256 feeGrowthAboveTrade;\n        if (tickCurrent < tickUpper) {\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\n        } else {\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\n        }\n\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\n    }\n}\n\n\ncontract SpotPool is GranularBondingCurve{\n\n    ERC20 BaseToken; //junior\n    ERC20 TradeToken; //senior \n    // GranularBondingCurve public pool; \n\n    constructor(\n        address _baseToken, \n        address _tradeToken\n        )GranularBondingCurve(_baseToken,_tradeToken){\n        BaseToken = ERC20(_baseToken); \n        TradeToken = ERC20(_tradeToken); \n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \n    }\n\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\n\n        if(up){\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\n            console.log('togive', amountOut, amountIn); \n            TradeToken.transfer(recipient, amountOut); \n            console.log('balofre', BaseToken.balanceOf(recipient));\n            BaseToken.transferFrom(recipient, address(this), amountIn);\n        }\n\n        else{\n            BaseToken.transfer(recipient, amountOut); \n            TradeToken.transferFrom(recipient, address(this), amountIn);\n        }\n    }\n\n    // function getCurPrice() external view returns(uint256){\n    //     return uint256(pool.getCurPrice());\n    // }\n\n    /// @notice if buyTradeForBase, move up, and vice versa \n    function takerTrade(\n        address recipient, \n        bool buyTradeForBase, \n        int256 amountIn,\n        uint256 priceLimit, \n        bytes calldata data        \n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\n\n        (poolamountIn, poolamountOut) = this.trade(\n            recipient, \n            buyTradeForBase, \n            amountIn,  \n            priceLimit, \n            data\n        ); \n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \n    }\n\n    /// @notice specify how much trade trader intends to sell/buy \n    function makerTrade(\n        bool buyTradeForBase,\n        uint256 amountIn,\n        uint16 point\n        ) external {\n        (uint256 toEscrowAmount, uint128 crossId) \n                = this.placeLimitOrder(msg.sender, \n                    point, \n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \n                    !buyTradeForBase); \n\n        // Collateral for bids\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \n\n        // or asks\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \n    }\n\n    function makerClaim(\n        uint16 point, \n        bool buyTradeForBase\n        ) external {\n        uint256 claimedAmount = this.claimFilledOrder(\n            msg.sender, \n            point, \n            !buyTradeForBase\n        ); \n\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\n        else BaseToken.transfer(msg.sender, claimedAmount); \n\n    }\n}\n\n\n\n\n\n"
    },
    "contracts/bonds/libraries.sol": {
      "content": "pragma solidity ^0.8.9;\n\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMath {\n\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\n    //     require((z = uint256(y)) == y);\n    // }\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\n    //     require((z = uint160(y)) == y);\n    // }\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\n        require((z = uint128(y)) == y);\n    }\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n\n\ncontract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n    \n    function mint(address to, uint256 amount) public {\n        _mint(to, amount); \n    }\n    function burn(address to, uint256 amount) public {\n        _burn(to, amount); \n    }\n}"
    },
    "contracts/bonds/linearCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\nstruct SwapParams{\n  uint256 s; \n  uint256 a; \n  uint256 b; \n  bool up;\n\n  uint256 pieceWisePrice;   \n}\n\n/*\n@notice linear curves followed by flat curve \n      - - - - \n    /\n  /\n/\n@dev all computations are done in WAD space, any conversion if needed should be made in the parent contract\n*/\nlibrary LinearPiecewiseCurve{\n    uint256 public constant PRECISION = 1e18; \n    using FixedPointMathLib for uint256; \n\n    function outGivenArea(\n        uint256 amount, \n        SwapParams memory vars\n        ) internal view returns(uint256 amountDelta, uint256 resultPrice){\n        console.log('varsb', vars.b, amount, vars.a); \n        if(vars.a==0) return (amount.divWadDown(vars.b), vars.b);  \n\n        uint256 curPrice = vars.a.mulWadDown(vars.s) + vars.b; \n\n        amountDelta = amount > 0 ? (\n            (\n                (curPrice.mulWadDown(curPrice) + 2*(vars.a.mulWadDown(amount))) * PRECISION\n               \n            ).sqrt() - curPrice\n        ).divWadDown(vars.a) : 0; \n\n        resultPrice = vars.a.mulWadDown(amountDelta + vars.s) + vars.b; \n    }\n\n    function outGivenSupply(\n        uint256 amount,\n        uint256 s, \n        uint256 a, \n        uint256 b\n        ) internal pure returns(uint256 amountDelta, uint256 resultPrice){\n        uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \n        amountDelta = amount.mulWadDown(z); \n        resultPrice = a.mulWadDown(s-amount) + b; \n    }\n\n    /// @param amount: amount of base in if up, trade in if down \n    /// returns amountDelta wanted token returned \n    function amountOutGivenIn( \n        uint256 amount,\n        SwapParams memory vars\n        ) \n        public \n        view \n        returns(uint256 amountDelta, uint256 resultPrice) {\n        \n        if(vars.pieceWisePrice ==0){\n            if (vars.up) (amountDelta, resultPrice) = outGivenArea(amount, vars); \n            else (amountDelta, resultPrice) = outGivenSupply(amount, vars.s, vars.a, vars.b); \n        } else{     \n\n            uint256 pieceWisePoint; \n\n            if(vars.up){\n                console.log('wtf', amount, vars.b); \n                    console.log('where', amount.divWadDown(vars.b)); \n\n                if(vars.a==0) return (amount.divWadDown(vars.b), vars.b);  \n                console.log('here', (vars.pieceWisePrice-vars.b), vars.a); \n\n                pieceWisePoint = (vars.pieceWisePrice-vars.b).divWadDown(vars.a); \n                // get maximum area till piecewiseprice\n                // if amount is larger, then cap it to maximum area \n                // amount-maximum area will be used as remainder \n\n                // Haven't cross to second curve yet \n                if(pieceWisePoint> vars.s){\n                    uint256 maximumArea = areaUnderCurve(pieceWisePoint-vars.s, vars.s,vars.a,vars.b  ); \n                    (amountDelta, resultPrice) = maximumArea >= amount\n                        ? outGivenArea(amount, vars)\n                        : (pieceWisePoint - vars.s + (amount - maximumArea).divWadDown(vars.pieceWisePrice), vars.pieceWisePrice);\n                } else{\n\n                    pieceWisePoint = (vars.pieceWisePrice-vars.b).divWadDown(vars.a); \n                    amountDelta = amount.divWadDown(vars.pieceWisePrice); \n                    resultPrice = vars.pieceWisePrice; \n                }\n            } else{\n                if(pieceWisePoint> vars.s){\n                    (amountDelta, resultPrice) = outGivenSupply(amount, vars.s, vars.a, vars.b); \n                } else{ \n\n                    uint256 maximumArea = (vars.s - pieceWisePoint).divWadDown(vars.pieceWisePrice); \n\n                    (amountDelta, resultPrice) = maximumArea >= amount\n                        ? (amount.mulWadDown(vars.pieceWisePrice), vars.pieceWisePrice)\n                        : ((maximumArea).mulWadDown(vars.pieceWisePrice) \n                        + areaUnderCurveDown(amount-maximumArea, pieceWisePoint, vars.a, vars.b)\n                        , vars.a.mulWadDown(vars.s-amount) + vars.b); \n                }\n            }\n        }\n    }\n\n    // @notice amount is in supply \n    function areaUnderCurveDown(\n        uint256 amount,\n        uint256 s, \n        uint256 a, \n        uint256 b\n        ) public pure returns(uint256 area){\n        uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \n        area = amount.mulWadDown(z); \n    }\n\n    /// @notice calculates area under the curve from s to s+amount\n    /// result = a * amount / 2  * (2* supply + amount) + b * amount\n    /// returned in collateral decimals\n    function areaUnderCurve(\n        uint256 amount, \n        uint256 s, \n        uint256 a, \n        uint256 b) \n        public\n        pure \n        returns(uint256 area){\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        if(a==0) return type(uint256).max; \n        return (curPrice-b).divWadDown(a); \n    }\n\n}\n\n\n\n\n\n\n\n\n"
    },
    "contracts/bonds/synthetic.sol": {
      "content": "// pragma solidity ^0.8.9;\n// import { LinearCurve} from \"./GBC.sol\"; \n// import {BoundedDerivativesPool} from \"./boundedDerivatives.sol\"; \n// import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n// import {ERC20} from \"./libraries.sol\"; \n// import \"forge-std/console.sol\";\n\n// contract ZCBFactory{\n//     function newBond(\n//         string memory name, \n//         string memory description \n//         ) public returns(address) {\n//         ERC20 bondToken = new ERC20(name,description, 18);\n//         return address(bondToken); \n//     }\n\n// }\n// contract SyntheticZCBPoolFactory{\n//     address public immutable controller;\n//     address public immutable zcbFactory; \n//     constructor(address _controller, address _zcbFactory){\n//         controller = _controller; \n//         zcbFactory = _zcbFactory; \n//     }\n\n//     event PoolCreated(address pool, address longZCB, address shortZCB);\n\n//     /// @notice param base is the collateral used in pool \n//     function newPool(\n//         address base, \n//         address entry\n//         ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\n//         longZCB = ZCBFactory(zcbFactory).newBond(\"longZCB\", \"long\");\n//         shortZCB = ZCBFactory(zcbFactory).newBond(\"shortZCB\", \"short\");\n\n//         pool = new SyntheticZCBPool(\n//             base, longZCB, shortZCB, entry, controller\n//         ); \n//         emit PoolCreated(address(pool), longZCB, shortZCB);\n//     }\n// }\n\n// contract SyntheticZCBPool is BoundedDerivativesPool{\n//     using FixedPointMathLib for uint256;\n\n//     uint256 public a_initial;\n//     uint256 public b_initial; // b without discount cap \n//     uint256 public b;\n//     uint256 public discount_cap; \n//     uint256 public discountedReserves; \n//     uint256 public upperBound; \n//     address public immutable controller; \n//     uint256 public constant precision = 1e18; \n//     constructor(address base, \n//         address trade, \n//         address s_trade, \n//         address _entry, \n//         address _controller\n//         )BoundedDerivativesPool(base,trade,s_trade, false){\n//         entry = _entry; \n//         controller = _controller; \n//         }\n\n//     /// @notice calculate and store initial curve params that takes into account\n//     /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\n//     /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \n//     /// @param sigma is the proportion of P that is going to be bought at a discount  \n//     function calculateInitCurveParams(\n//         uint256 P, \n//         uint256 I, \n//         uint256 sigma,\n//         uint256 alpha, \n//         uint256 delta) external {\n//         require(msg.sender == controller, \"unauthorized\"); \n//         b_initial = (2*P).divWadDown(P+I) - precision; \n//         a_initial = (precision-b_initial).divWadDown(P+I); \n\n//         // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\n//         (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\n//         (, upperBound )= LinearCurve.amountOutGivenIn(P.mulWadDown(alpha+delta), 0, a_initial, b_initial,true); \n\n//         // Set initial liquidity and price \n//         setLiquidity(uint128(precision.divWadDown(a_initial))); \n//         setPriceAndPoint(b);\n//     }\n\n//     /// @notice calculates initparams for pool based instruments \n//     /// param endPrice is the inception Price of longZCB, or its price when there is no discount\n//     function calculateInitCurveParamsPool(\n//         uint256 saleAmount, \n//         uint256 initPrice, \n//         uint256 endPrice, \n//         uint256 sigma\n//         ) external returns(uint256 managementFee){\n//         require(msg.sender == controller, \"unauthorized\"); \n//         //TODO these fails at some inputs\n//         uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \n//         uint256 a = (endPrice - initPrice).divWadDown(saleAmountQty); \n        \n//         //Set discount cap as saleAmount * sigma \n//         (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \n//         b = initPrice; \n\n//         // How much total discounts are validators and managers getting\n//         managementFee = discount_cap.mulWadDown(endPrice) \n//             - saleAmount.mulWadDown(sigma) + saleAmountQty.mulWadDown(endPrice) - saleAmount ; \n\n//         // set initial liquidity and price \n//         setLiquidity(uint128(precision.divWadDown(a))); \n//         setPriceAndPoint(b); \n//         setDynamicLiquidity(priceToPoint(endPrice), type(int128).max); \n//         setModifyLiqPoint(priceToPoint(endPrice)); \n//     }\n\n//     /// @notice computes area between the curve and max price for given storage parameters\n//     function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\n//         (uint256 amountDelta, ) = LinearCurve.amountOutGivenIn(amount, 0, a_initial, b_initial, true); \n//         return amountDelta.mulWadDown(maxPrice) - amount; \n//     }\n\n//     /// @notice mints new zcbs \n//     function trustedDiscountedMint(\n//         address receiver, \n//         uint256 amount \n//         ) external{\n//         require(msg.sender == entry, \"entryERR\"); \n\n//         TradeToken.mint(receiver, amount);\n//         discountedReserves += amount;\n//     }\n\n//     function trustedMint(address receiver, uint256 amount, bool long) external{\n//         if(long) TradeToken.mint(receiver, amount); \n//         else s_tradeToken.mint(receiver, amount); \n//     }\n\n\n//     function trustedBurn(\n//         address trader, \n//         uint256 amount, \n//         bool long\n//         ) external {\n//         require(msg.sender == entry, \"entryERR\"); \n//         if (long) TradeToken.burn(trader, amount); \n//         else s_tradeToken.burn(trader, amount);\n//     }\n\n//     function flush(address flushTo, uint256 amount) external {\n//         require(msg.sender == controller, \"entryERR\"); \n//         if (amount == type(uint256).max) BaseToken.transfer(flushTo, baseBal()); \n//         else BaseToken.transfer(flushTo, amount); \n//     }\n\n//     /// @notice resets AMM liquidity to 0 and make it ready to be liq provisioned \n//     /// by anyone \n//     function resetLiq() external{\n//         require(msg.sender == controller, \"entryERR\"); \n//         setLiquidity(0); \n//         amortizeLiq(); \n//     }\n\n// }\n"
    },
    "contracts/chainlink/VRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {VRFConsumerBaseV2} from \"../chainlink/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"../chainlink/VRFCoordinatorV2Interface.sol\";\n\ncontract ChainlinkClient is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface COORDINATOR;\n\n    // Your subscription ID.\n    uint64 private immutable s_subscriptionId;\n\n    // Goerli coordinator. For other networks,\n    // see https://docs.chain.link/docs/vrf-contracts/#configurations\n\n\n    // The gas lane to use, which specifies the maximum gas price to bump to.\n    // For a list of available gas lanes on each network,\n    // see https://docs.chain.link/docs/vrf-contracts/#configurations\n    bytes32 private keyHash;\n\n    // Depends on the number of requested values that you want sent to the\n    // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\n    // so 100,000 is a safe default for this example contract. Test and adjust\n    // this limit based on the network that you select, the size of the request,\n    // and the processing of the callback request in the fulfillRandomWords()\n    // function.\n    uint32 private callbackGasLimit = 100000;\n\n    // The default is 3, but you can set this higher.\n    uint16 private requestConfirmations = 3;\n\n    uint256[] public s_randomWords;\n    uint256 public s_requestId;\n    address s_owner;\n\n    mapping(uint256 => bool) used; // marketId => whether vrf has been called for a specific market\n    mapping(uint256 => address[]) candidates; // marketId => possible validators.\n\n    constructor(\n        bytes32 _keyHash,\n        address _vrfCoordinator,\n        uint64 subscriptionId\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\n        s_owner = msg.sender;\n        s_subscriptionId = subscriptionId;\n        keyHash = _keyHash;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == s_owner);\n        _;\n    }\n\n    /**\n     @notice called by oracle on completion\n     */\n    function fulfillRandomWords(\n        uint256, /* requestId */\n        uint256[] memory randomWords\n    ) internal override {\n        s_randomWords = randomWords;\n    }\n\n    function requestRandomWords(\n        uint32 numWords,\n        uint256 marketId,\n        address[] memory _candidates\n    ) external onlyOwner {\n        require(!used[marketId], \"random words already requested for this marketId\");\n        used[marketId] = true;\n        candidates[marketId] = _candidates;\n\n        // Will revert if subscription is not set and funded.\n        s_requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n    }\n\n    /**\n     @dev should only be called by marketManager.\n     */\n    function deleteWords() external {\n        delete s_randomWords;\n    }\n\n    function wordLength() external returns (uint256) {\n        return s_randomWords.length;\n    }\n\n    function getNums() external returns (uint256[] memory) {\n        return s_randomWords;\n    }\n}\n"
    },
    "contracts/chainlink/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}"
    },
    "contracts/chainlink/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}"
    },
    "contracts/global/GlobalStorage.sol": {
      "content": "pragma solidity ^0.8.16;\nimport \"./types.sol\"; \nimport {PerpTranchePricer} from \"../libraries/pricerLib.sol\"; \nimport {CollateralPricer} from \"../libraries/lendingOracleLib.sol\"; \n\nimport {Instrument} from \"../vaults/instrument.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\n\ncontract StorageHandler{\n\tusing PerpTranchePricer for PricingInfo;\n\tusing CollateralPricer for PoolPricingParam; \n    using FixedPointMathLib for uint256;\n\n\tuint256 constant BASE_UNIT = 1e18; \n\n    modifier onlyProtocol() {\n        \n        _;\n    }\n\n  \tconstructor() \n  \t\t{\n    // controller = Controller(_controllerAddress);\n    // push empty market\n    \tmarkets.push(makeEmptyMarketData());\n\n    // owner = msg.sender; \n  \t}\n\n\n\t/// @notice called at market creation \n\tfunction setNewInstrument(\n\t\tuint256 marketId, \n\t\tuint256 initialPrice, \n\t\tuint256 multiplier, \n\t\tbool constantRF, \n\t\tInstrumentData memory idata, \n\t\tCoreMarketData memory mdata) external onlyProtocol {\n\t\tPricingInfos[marketId].setNewPrices(initialPrice, multiplier, marketId, constantRF); \n\n\t\tstoreNewProposal(marketId, idata); \n\t}\n\n\n    //--- Perp Pricing ---// \n\tmapping(uint256=> PricingInfo) public PricingInfos; \n\n\tfunction getPricingInfo(uint256 marketId) public view returns(PricingInfo memory){\n\t\treturn PricingInfos[marketId]; \n\t}\n\n\tfunction updatePricingInfo(uint256 marketId, PricingInfo memory newInfo) external onlyProtocol{\n\t\tPricingInfos[marketId] = newInfo; \n\t}\n\n\tfunction setRF(uint256 marketId, bool isConstant) external onlyProtocol {\n\t\tPricingInfos[marketId].setRF(isConstant); \n\t}\n\n\t/// @notice updates whenever uRate changes \n\tfunction refreshPricing(uint256 marketId, uint256 uRate) public onlyProtocol{\n\t\tPricingInfos[marketId].storeNewPSU(uRate); \n\t}\n\n\tfunction viewCurrentPricing(uint256 marketId) public view returns(uint256, uint256, uint256) {\n\t\tInstrumentData memory data = InstrumentDatas[marketId]; \n\t\treturn (PricingInfos[marketId].viewCurrentPricing(\n\t\t\tdata.instrument_address, \n\t\t\tdata.poolData, \n\t\t\tmarkets[marketId].longZCB.totalSupply()\n\t\t));  \n\t}\n\n\tfunction checkIsSolventConstantRF(uint256 marketId) public view returns(bool){\n\t\tInstrumentData memory data = InstrumentDatas[marketId]; \n\t\tuint256 psu = PerpTranchePricer.constantRF_PSU(\n\t\t\tdata.poolData.inceptionPrice, \n\t\t\tdata.poolData.promisedReturn, \n\t\t\tdata.poolData.inceptionTime); \n\t\treturn PerpTranchePricer.isSolvent(data.instrument_address, psu, markets[marketId].longZCB.totalSupply(), \n\t\t\tdata.poolData); \n\t}\n\n\n\t//--- Instrument ---//\n\tuint256 public lastTradedRate; \n\tuint256 public lastTradedTime; \n\tuint256 public constant TIME_WINDOW = 10e18; // for rate oracle \n\tmapping(uint256=> PoolPricingParam) PoolPricingParams; \n\n\tmapping(uint256=> ExchangeRateData) storedRates; //marketId-> last exchange rate\n\n\tmapping(uint256=> InstrumentData) public InstrumentDatas; \n\n\tfunction getInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n\t\treturn InstrumentDatas[marketId]; \n\t}\n\n\tfunction getInstrumentAddress(uint256 marketId) public view returns(address){\n\t\treturn InstrumentDatas[marketId].instrument_address; \n\t}\n\n\tfunction storeNewProposal(uint256 marketId, InstrumentData memory data) public onlyProtocol{\n\t\tInstrumentDatas[marketId] = data; \n\t}\n\n\t/// @notice store instrument exchange rate to get delayed rates \n\t/// called whenever instrument exchange rate changes\n\tfunction storeExchangeRateOracle(uint256 marketId, uint256 newRate) public onlyProtocol returns(uint256){\n\t\tExchangeRateData storage rateData = storedRates[marketId];\n\n\t\trateData.lastOracleRate = rateData.initialized? queryExchangeRateOracle(marketId) : newRate; \n\t\trateData.lastRate = newRate; \n\t\trateData.lastTime = block.timestamp; \n\t\trateData.initialized = true; \n\n\t\treturn rateData.lastOracleRate; \n\t}\n\n\tfunction queryExchangeRateOracle(uint256 marketId) public view returns(uint256){\n\t\tExchangeRateData memory rateData = storedRates[marketId];\n\t\tuint256 timeDiff = (block.timestamp -rateData.lastTime) * BASE_UNIT; \n\t\tuint256 timeDivWindow = timeDiff.divWadDown(TIME_WINDOW); \n\n\t\t// Liear interpolation of last rate and last oracle rate\n\t\trateData.lastOracleRate = TIME_WINDOW >= timeDiff\n\t\t\t? rateData.lastRate.mulWadDown(min(timeDivWindow, BASE_UNIT)) \n\t\t\t\t+ rateData.lastOracleRate.mulWadDown((TIME_WINDOW - timeDiff).divWadDown(TIME_WINDOW))\n\t\t\t: rateData.lastRate;\n\n\t\treturn rateData.lastOracleRate; \n\t}\n\n\tfunction setPoolPricingParams(uint256 marketId, PoolPricingParam memory params) public onlyProtocol{\n\t\tPoolPricingParams[marketId] = params; \n\t}\n\n\t/// @notice applicable to lending pool instruments only. Needs to be called\n\t/// whenever utilization rate is about to get updates. i.e while borrowing/\n\tfunction refreshAndGetNewLTV(uint256 marketId, uint256 newURate) public onlyProtocol returns(uint256){\n\t\treturn PoolPricingParams[marketId].storeNewLTV(newURate); \n\t}\n\n\n\n\n\n\n\t//--- Market ---//\n  \tCoreMarketData[] public markets;\n\n\tfunction storeNewMarket(CoreMarketData memory data) public onlyProtocol  returns(uint256 marketId){\n\t\t// MarketDatas[marketId] = data; \n\t\tmarketId = markets.length; \n\t\tmarkets.push(data); \n\t\t// uint256 base_budget = 1000 * BASE_UNIT; //TODO \n\t\t// setMarketPhase(marketId, true, true, base_budget);\n\t}\n\n\tfunction getMarket(uint256 marketId) public view returns(CoreMarketData memory data){\n\t\treturn markets[marketId]; \n\t}\n\n\tfunction getMarketLength() public view returns(uint256){\n\t\treturn markets.length; \n\t}\n\n\tfunction makeEmptyMarketData() internal pure returns (CoreMarketData memory) {\n\t\treturn CoreMarketData(\n\t\t    SyntheticZCBPool(address(0)),\n\t\t    ERC20(address(0)),\n\t\t    ERC20(address(0)),\n\t\t    \"\",\n\t\t    0,\n\t\t    0, \n\t\t    false\n\t\t);\n\t}    \n\n\tfunction zcbMaxPrice(uint256 marketId) public view returns(uint256){\n\t\treturn 1e18; \n\t} \n\n\n\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n\n\n}\n\n\n"
    },
    "contracts/global/types.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {SyntheticZCBPool} from \"../bonds/bondPool.sol\"; \nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\n\nlibrary Constants{\n\tuint256 public constant THRESHOLD_PJU = 5e17; // can't buy if below 0.5 \n\tuint256 public constant MAX_VAULT_URATE = 10e17; \n\n}\n\n\n\nstruct MarketData {\n    address instrument_address;\n    address utilizer;\n}\n\nstruct ApprovalData {\n    uint256 managers_stake;\n    uint256 approved_principal;\n    uint256 approved_yield;\n}\n\nstruct InstrumentData {\n\tbytes32 name;\n\tbool isPool; \n\t// Used to determine if the Vault will operate on a Instrument.\n\tbool trusted;\n\t// Balance of the contract denominated in Underlying, \n\t// used to determine profit and loss during harvests of the Instrument.  \n\t// represents the amount of debt the Instrument has incurred from this vault   \n\tuint256 balance; // in underlying, IMPORTANT to get this number right as it modifies key states \n\tuint256 faceValue; // in underlying\n\tuint256 marketId;\n\t\n\tuint256 principal; //this is total available allowance in underlying\n\tuint256 expectedYield; // total interest paid over duration in underlying\n\tuint256 duration;\n\tstring description;\n\taddress instrument_address;\n\tInstrumentType instrument_type;\n\tuint256 maturityDate;\n\tPoolData poolData; \n}\n\n/// @notice probably should have default parameters for each vault\nstruct PoolData{\n\tuint256 saleAmount; \n\tuint256 initPrice; // init price of longZCB in the amm \n\tuint256 promisedReturn; //per unit time \n\tuint256 inceptionTime;\n\tuint256 inceptionPrice; // init price of longZCB after assessment \n\tuint256 leverageFactor; // leverageFactor * manager collateral = capital from vault to instrument\n\tuint256 managementFee; // sum of discounts for high reputation managers/validators\n}\n\nstruct PoolPricingParam{\n\tuint256 incrementRate; \n\tuint256 urateUpper; \n\tuint256 urateLower;\n\tuint256 prevAccrueTime; \n\tuint256 prevURate; \n\n\tuint256 maxBorrowable; \n}\t\n\nstruct ExchangeRateData{\n\tuint256 lastRate; \n\tuint256 lastTime; \n\tuint256 lastOracleRate;\n\tbool initialized;  \n}\n\nstruct PricingInfo{\n\tuint256 psu; \n\n\tuint256 prevAccrueTime; \n\tuint256 prevIntervalRp; //per second compounding promised return, function of urate \n\n\t// Constants for a given market \n\tuint256 URATE_MULTIPLIER; \n\tuint256 ID; \n\n\tbool constantRF; \n}\n\n\nstruct CoreMarketData {\n\tSyntheticZCBPool bondPool; \n\tERC20 longZCB;\n\tERC20 shortZCB; \n\tstring description; // instrument description\n\tuint256 creationTimestamp;\n\tuint256 resolutionTimestamp;\n\tbool isPool; \n}\n\nstruct MarketPhaseData {\n\tbool duringAssessment;\n\tbool onlyReputable;\n\tbool resolved;\n\tbool alive;\n\tbool atLoss;\n\t// uint256 min_rep_score;\n\tuint256 base_budget;\n}\n\n  /// @param N: upper bound on number of validators chosen.\n  /// @param sigma: validators' stake\n  /// @param alpha: minimum managers' stake\n  /// @param omega: high reputation's stake \n  /// @param delta: Upper and lower bound for price which is added/subtracted from alpha \n  /// @param r: reputation percentile for reputation constraint phase\n  /// @param s: senior coefficient; how much senior capital the managers can attract at approval \n  /// @param steak: steak*approved_principal is the staking amount.\n  /// param beta: how much volatility managers are absorbing \n  /// param leverage: how much leverage managers can apply \n  /// param base_budget: higher base_budget means lower decentralization, \n  /// @dev omega always <= alpha\n struct MarketParameters{\n\tuint256 N;\n\tuint256 sigma; \n\tuint256 alpha; \n\tuint256 omega;\n\tuint256 delta; \n\tuint256 r;\n\tuint256 s;\n\tuint256 steak;\n  }\n\n\n\nstruct ResolveVar{\n\tuint256 endBlock; \n\tbool isPrepared; \n}\n\nstruct Order{\n\tbool isLong; \n\tuint256 price; \n\tuint256 amount; \n\tuint256 orderId; \n\taddress owner; \n}\n\n\n\n\nenum InstrumentType {\n    CreditLine,\n    CoveredCallShort,\n    LendingPool, \n    StraddleBuy,\n    LiquidityProvision, \n    Other\n}\n"
    },
    "contracts/instruments/auctioneer.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {PoolInstrument} from \"./poolInstrument.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\ncontract Auctioneer {\n    using FixedPointMathLib for uint256;\n        /// @notice dutch auction\n    struct Auction { // linearDecrease for beta only.\n        address borrower;\n        address collateral;\n        uint256 tokenId;\n        uint256 creationTimestamp; // auction start\n        bool alive; // delete auction.\n    }\n\n    mapping(bytes32=>Auction) public auctions; // auction id => auction data, auction id is in order of creation.\n    mapping(address=>bytes32[]) public userAuctionIds; // user => auction ids, if 0 then no auction, corresponds to active auctions.\n    \n    bytes32[] public activeAuctionIds;\n\n    event AuctionCreated(bytes32 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event AuctionClosed(bytes32 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event CollateralPurchased(bytes32 indexed id, address indexed buyer, address indexed collateral, uint256 tokenId, uint256 amount);\n    \n    PoolInstrument pool;\n\n    modifier onlyPool() {\n        require(msg.sender == address(pool), \"!pool\");\n        _;\n    }\n\n    constructor (address _pool) {\n        pool = PoolInstrument(_pool);\n    }\n\n    function computeAuctionId(address _borrower, address _collateral, uint256 _tokenId) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_borrower, _collateral, _tokenId));\n    }\n\n    function createAuction(address _borrower, address _collateral, uint256 _tokenId) external onlyPool returns (bytes32 auctionId) {\n        auctionId = computeAuctionId(_borrower, _collateral, _tokenId);\n        bytes32 collateralId = pool.computeId(_collateral, _tokenId);\n\n        require(!auctions[auctionId].alive, \"!auction\");\n        require(pool.enabledCollateral(_borrower, collateralId), \"!enabled\");\n        \n        // must have balance for auction.\n        if (pool.getCollateralConfig(collateralId).isERC20) {\n            require(pool.userERC20s(collateralId,_borrower) > 0, \"!balance\");\n        } else {\n            require(pool.userERC721s(collateralId) == _borrower, \"!balance\");\n        }\n\n        auctions[auctionId] = Auction({\n            borrower: _borrower,\n            collateral: _collateral,\n            tokenId: _tokenId,\n            creationTimestamp: block.timestamp,\n            alive: true\n        });\n\n        activeAuctionIds.push(auctionId);\n        userAuctionIds[_borrower].push(auctionId);\n\n        emit AuctionCreated(auctionId, _borrower, _collateral, _tokenId);\n    }\n\n    function resetAuction(address _borrower, address _collateral, uint256 _tokenId) external onlyPool {\n        require(auctions[computeAuctionId(_borrower, _collateral, _tokenId)].alive, \"!auction\");\n        auctions[computeAuctionId(_borrower, _collateral, _tokenId)].creationTimestamp = block.timestamp;\n    }\n\n    function closeAuction(address _borrower, address _collateral, uint256 _tokenId) external onlyPool {\n        _closeAuction(computeAuctionId(_borrower, _collateral, _tokenId), _borrower);\n    }\n\n    function _closeAuction(bytes32 _auctionId, address _borrower) internal {\n        auctions[_auctionId].alive = false;\n\n        bytes32[] memory _activeAuctionIds = activeAuctionIds;\n        bytes32[] memory _userAuctionIds = userAuctionIds[_borrower];\n\n\n\n        for (uint256 i = 0; i < _activeAuctionIds.length; i++) {\n            if (_activeAuctionIds[i] == _auctionId) {\n                activeAuctionIds[i] = _activeAuctionIds[_activeAuctionIds.length - 1];\n                activeAuctionIds.pop();\n                break;\n            }\n        }\n\n        for (uint256 i = 0; i < _userAuctionIds.length; i++) {\n            if (_userAuctionIds[i] == _auctionId) {\n                userAuctionIds[_borrower][i] = _userAuctionIds[_userAuctionIds.length - 1];\n                userAuctionIds[_borrower].pop();\n                break;\n            }\n        }\n\n        console.log(\"closing auction\");\n    }\n\n    function getActiveUserAuctions(address _user) external view returns (bytes32[] memory) {\n        return userAuctionIds[_user];\n    }\n\n    function closeAllAuctions(address _borrower) external onlyPool {\n        bytes32[] memory _userAuctionIds = userAuctionIds[_borrower];\n        for (uint256 i = 0; i < _userAuctionIds.length; i++) {\n            _closeAuction(_userAuctionIds[i], _borrower);\n        }\n    }\n\n    /**\n     doesn't check whether tau has passed.\n     */\n    function purchasePrice(address _borrower, address _collateral, uint256 _tokenId) public view returns (uint256 currentPrice) {\n        \n        bytes32 auctionId = computeAuctionId(_borrower, _collateral, _tokenId);\n        bytes32 collateralId = pool.computeId(_collateral, _tokenId);\n\n        Auction memory auction = auctions[auctionId];\n        PoolInstrument.Config memory config = pool.getCollateralConfig(collateralId);\n        require(auction.alive, \"auction is not alive\");\n\n        /**\n         slope is (top - 0) / (0 - tau), pf = pi + slope * (t - ti)\n         */\n        uint256 top = config.buf.mulWadDown(config.maxAmount);\n        uint256 t = block.timestamp - auction.creationTimestamp;\n\n        if (t > config.tau) {\n            currentPrice = 0;\n        } else {\n            currentPrice = top  - (top / config.tau) * t;\n        }\n    }\n\n    function getAuction(address _borrower, address _collateral, uint256 _tokenId) external view returns (Auction memory) {\n        return auctions[computeAuctionId(_borrower, _collateral, _tokenId)];\n    }\n\n    function getAuctionWithId(bytes32 _auctionId) external view returns (Auction memory) {\n        return auctions[_auctionId];\n    }\n\n}\n"
    },
    "contracts/instruments/IPoolInstrument.sol": {
      "content": ""
    },
    "contracts/instruments/IRateCalculator.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity >=0.8.16;\n\ninterface IRateCalculator {\n    function name() external pure returns (string memory);\n\n    function requireValidInitData(bytes calldata _initData) external pure;\n\n    function getConstants() external pure returns (bytes memory _calldata);\n\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec);\n}\n"
    },
    "contracts/instruments/LinearInterestRate.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.16;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ======================= LinearInterestRate =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"./IRateCalculator.sol\";\n\n/// @title A formula for calculating interest rates linearly as a function of utilization\n/// @author Drake Evans github.com/drakeevans\ncontract LinearInterestRate is IRateCalculator {\n    uint256 private constant MIN_INT = 0; // 0.00% annual rate\n    uint256 private constant MAX_INT = 146248508681; // 10,000% annual rate\n    uint256 private constant MAX_VERTEX_UTIL = 1e5; // 100%\n    uint256 private constant UTIL_PREC = 1e5;\n\n    /// @notice The ```name``` function returns the name of the rate contract\n    /// @return memory name of contract\n    function name() external pure returns (string memory) {\n        return \"Linear Interest Rate\";\n    }\n\n    /// @notice The ```getConstants``` function returns abi encoded constants\n    /// @return _calldata abi.encode(uint256 MIN_INT, uint256 MAX_INT, uint256 MAX_VERTEX_UTIL, uint256 UTIL_PREC)\n    function getConstants() external pure returns (bytes memory _calldata) {\n        return abi.encode(MIN_INT, MAX_INT, MAX_VERTEX_UTIL, UTIL_PREC);\n    }\n\n    /// @notice The ```requireValidInitData``` function reverts if initialization data fails to be validated\n    /// @param _initData abi.encode(uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization)\n    function requireValidInitData(bytes calldata _initData) public pure {\n        (uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization) = abi.decode(\n            _initData,\n            (uint256, uint256, uint256, uint256)\n        );\n        require(\n            _minInterest < MAX_INT && _minInterest <= _vertexInterest && _minInterest >= MIN_INT,\n            \"LinearInterestRate: _minInterest < MAX_INT && _minInterest <= _vertexInterest && _minInterest >= MIN_INT\"\n        );\n        require(\n            _maxInterest <= MAX_INT && _vertexInterest <= _maxInterest && _maxInterest > MIN_INT,\n            \"LinearInterestRate: _maxInterest <= MAX_INT && _vertexInterest <= _maxInterest && _maxInterest > MIN_INT\"\n        );\n        require(\n            _vertexUtilization < MAX_VERTEX_UTIL && _vertexUtilization > 0,\n            \"LinearInterestRate: _vertexUtilization < MAX_VERTEX_UTIL && _vertexUtilization > 0\"\n        );\n    }\n\n    /// @notice Calculates interest rates using two linear functions f(utilization)\n    /// @dev We use calldata to remain un-opinionated about future implementations\n    /// @param _data abi.encode(uint64 _currentRatePerSec, uint256 _deltaTime, uint256 _utilization, uint256 _deltaBlocks)\n    /// @param _initData abi.encode(uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization)\n    /// @return _newRatePerSec The new interest rate per second, 1e18 precision\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec) {\n        requireValidInitData(_initData);\n        (, , uint256 _utilization, ) = abi.decode(_data, (uint64, uint256, uint256, uint256));\n        (uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization) = abi.decode(\n            _initData,\n            (uint256, uint256, uint256, uint256)\n        );\n        if (_utilization < _vertexUtilization) {\n            uint256 _slope = ((_vertexInterest - _minInterest) * UTIL_PREC) / _vertexUtilization;\n            _newRatePerSec = uint64(_minInterest + ((_utilization * _slope) / UTIL_PREC));\n        } else if (_utilization > _vertexUtilization) {\n            uint256 _slope = (((_maxInterest - _vertexInterest) * UTIL_PREC) / (UTIL_PREC - _vertexUtilization));\n            _newRatePerSec = uint64(_vertexInterest + (((_utilization - _vertexUtilization) * _slope) / UTIL_PREC));\n        } else {\n            _newRatePerSec = uint64(_vertexInterest);\n        }\n    }\n}\n"
    },
    "contracts/instruments/oldpoolInstrument.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {PoolConstants} from \"./poolConstants.sol\";\nimport {VaultAccount, VaultAccountingLibrary} from \"./VaultAccount.sol\";\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {IRateCalculator} from \"./IRateCalculator.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Pausable} from \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {ERC4626} from \"lib/solmate/src/mixins/ERC4626.sol\";\nimport {ERC721TokenReceiver} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport \"lib/forge-std/src/console.sol\";\n// import \"@prb/math/SD59x18.sol\";\n\n// https://github.com/FraxFinance/fraxlend\n/// ****THIS IS A PROOF OF CONCEPT INSTRUMENT.\ncontract PoolInstrument is ERC4626, Instrument, PoolConstants, ReentrancyGuard, Pausable, ERC721TokenReceiver {\n    using SafeTransferLib for ERC20;\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n\n    /// @param lastBlock last block number\n    /// @param lastTimestamp last block.timestamp\n    /// @param ratePerSec rate per second of interest accrual\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @param tokenAddress collateral token address\n    /// @param tokenId collateral tokenId, 0 for ERC20.\n    struct CollateralLabel {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    /// @param totalCollateral total amount of collateral for a given ERC20 asset, will be zero for NFTs\n    /// @param maxAmount max amount in underlying that a user can \"owe\" per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    /// should always be more than the maxBorrowAmount, acts as buffer for protocol and borrower. this is the value to determine whether\n    /// a borrower is liquidatable\n    /// @param maxBorrowAmount max amount in underlying that a user can borrow per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    struct Collateral {\n        uint256 totalCollateral; \n        uint256 maxAmount;\n        uint256 maxBorrowAmount;\n        bool isERC20;\n    }\n\n    /// @notice dutch auctions for NFTs, GDA for illiquid ERC20s.\n    /// @param borrower address of borrower\n    /// @param collateral address of collateral\n    /// @param tokenId tokenId of collateral, 0 for ERC20\n    /// @param initialPrice initial price of collateral currently is (account liquidity / collateral amount) + maxAmount.\n    /// @param decayConstant parameter that controls price decay, stored as a 59x18 fixed precision number\n    /// @param startTime for dutch auction: start time of auction, for GDA: time of last auction.\n    /// @param emissionRate for dutch auction: 0, for GDA: amount of collateral to be auctioned off per second.\n    // struct Auction {\n    //     address borrower;\n    //     address collateral;\n    //     uint256 tokenId;\n    //     SD59x18 initialPrice;\n    //     SD59x18 minimumPrice;\n    //     SD59x18 decayConstant;\n    //     SD59x18 startTime;\n    //     // SD59x18 emissionRate;\n    //     bool alive;\n    // }\n\n    /// @notice amount: asset token borrowed, shares = total shares outstanding\n    VaultAccount public totalBorrow;\n    /// @notice amount: total asset supplied + interest earned, shares = total shares outstanding\n    VaultAccount public totalAsset;\n\n    mapping(address=>mapping(uint256 => Collateral)) public collateralData; // collateral address => tokenId (0 for erc20) => collateral data.\n    mapping(address=>mapping(uint256=>bool)) public approvedCollateral;\n    mapping(address=>mapping(address=>uint256)) public userCollateralERC20; // per collateral, user balance of collateral.\n    mapping(address=>mapping(uint256 => address)) public userCollateralNFTs; // nft addr => tokenId => owner.\n    mapping(address=>uint256) public userBorrowShares;\n    mapping(address=>uint256) public userAuctionId; // user => current auction id, if 0 then no auction.\n    \n    /// @dev auction id => order of creation.\n    // mapping(uint256=>Auction) public auctions; // auction id => auction data, auction id is in order of creation.\n\n    uint256 public numAuctions; // number of auction ids.\n\n    IRateCalculator public rateContract;\n\n    /// @dev depends on rateCalculator used\n    bytes public rateInitCallData;\n    \n    CurrentRateInfo public currentRateInfo;\n    CollateralLabel[] collaterals; //approved collaterals.\n    address controller;\n    \n    constructor (\n        address _vault,\n        address _controller,\n        address _utilizer,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _rateCalculator,\n        bytes memory _rateInitCallData,\n        CollateralLabel[] memory _collaterals,\n        Collateral[] memory _collateralDatas\n    ) Instrument(_vault, _utilizer) ERC4626(ERC20(_asset), _name, _symbol) {\n        controller = _controller;\n        rateContract = IRateCalculator(_rateCalculator);\n        rateInitCallData = _rateInitCallData;\n        rateContract.requireValidInitData(_rateInitCallData);\n\n        for (uint i = 0; i < _collaterals.length; i ++) {\n            collaterals.push(_collaterals[i]);\n            Collateral memory _collateral = _collateralDatas[i];\n            _collateral.totalCollateral = 0;\n            collateralData[_collaterals[i].tokenAddress][_collaterals[i].tokenId] = _collateral;\n        }\n    }\n\n    // should be gated function\n    /// tokenId 0 for ERC20.\n    // function initialize(\n    // ) external {\n\n    // }\n\n    function getAcceptedCollaterals() view public returns (CollateralLabel[] memory) {\n        return collaterals;\n    }\n\n    event NewCollateralAdded(address collateral, uint256 tokenId, uint256 maxAmount, uint256 maxBorrowAmount, bool isERC20);\n    // legacy for tests, remove later.\n    function addAcceptedCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _maxAmount,\n        uint256 _maxBorrowAmount,\n        bool _isERC20\n    ) external  {\n        require(msg.sender == controller || msg.sender == address(vault), \"!authorized\");\n        if (approvedCollateral[_collateral][_tokenId]) return; \n        require(_maxAmount > _maxBorrowAmount, \"maxAmount must be greater than maxBorrowAmount\");\n        approvedCollateral[_collateral][_tokenId] = true;\n        collaterals.push(CollateralLabel(_collateral, _tokenId));\n        collateralData[_collateral][_tokenId] = Collateral(0,_maxAmount, _maxBorrowAmount, _isERC20);\n        emit NewCollateralAdded(_collateral, _tokenId, _maxAmount, _maxBorrowAmount, _isERC20);\n    }\n\n    // INTERNAL HELPERS\n\n    modifier onlyApprovedCollateral(address _collateral, uint256 _tokenId) {\n        require(approvedCollateral[_collateral][_tokenId], \"collateral not approved\");\n        _;\n    }\n\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    // INTEREST RATE LOGIC\n    event InterestAdded(uint256 indexed timestamp, uint256 interestEarned, uint256 feesAmount, uint256 feesShare, uint64 newRate);\n\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    function _addInterest() internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n        console.log(\"total borrower shares: \", totalBorrow.shares);\n\n        // If there are no borrows or contract is paused, no interest adds and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            // console.log(\"_utilizationRate: \", _utilizationRate);\n            bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest addd\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n        console.log(\"_interestEarned: \", _interestEarned);\n        emit InterestAdded(block.timestamp, _interestEarned, _feesAmount, _feesShare, _newRate);\n        // console.log(\"ratePerSec: \", _currentRateInfo.ratePerSec);\n    }\n\n    // SOLVENCY* LOGIC\n\n    /// @notice Checks if total amount of asset user borrowed is less than max borrow threshold AFTER executing contract code\n    modifier canBorrow(address _borrower) {\n        _;\n        require(_canBorrow(_borrower), \"borrower is insolvent\");\n    }\n\n\n    /// @notice checks if the borrower is can borrow\n    /// @dev collateral value is in asset, summed across all approved collaterals.\n    /// @dev will return true if the borrower has no collateral and also has no borrower shares.\n    /// @dev 0 addr cannot borrow.\n    function _canBorrow(address _borrower) public view returns (bool) {\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\n\n        if (userBorrowShares[_borrower] == 0) {\n            return true;\n        }\n        if (_maxBorrowableAmount == 0) {\n            return false;\n        }\n        return _maxBorrowableAmount >= totalBorrow.toAmount(userBorrowShares[_borrower], false);\n    }\n\n    function getMaxBorrow(address _borrower) public view returns(uint256 _maxBorrowableAmount){\n\n        for (uint256 i; i < collaterals.length; i++) {\n            CollateralLabel memory _collateral = collaterals[i];\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxBorrowAmount / (10**_d); // <= precision of collateral.\n            } else {\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\n                    _maxBorrowableAmount += _collateralData.maxBorrowAmount;\n                }\n            }\n        }\n    }\n\n    /// @notice returns how much collateral can be removed, given the borrower's current debt condition\n    function removeableCollateral(address _borrower, uint256 tokenId, address collateral) public view returns(uint256){\n        //800 borrowable = 800 * 1, 600borrowed (800-x)*1 - 600 = 0 x=? \n        //800*1-x*1-600 , x = (800*1 - 600)/1\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower); \n        uint256 perUnitMaxBorrowAmount = collateralData[collateral][tokenId].maxBorrowAmount; \n        //check solvency\n        return (_maxBorrowableAmount - totalBorrow.toAmount(userBorrowShares[_borrower], true)) \n            * 1e18/ perUnitMaxBorrowAmount; \n    }  \n\n    // BORROW LOGIC\n    event Borrow(address indexed _borrower, uint256 _amount, uint256 _shares);\n\n    /// @param _borrowAmount amount of asset to borrow\n    /// @param _collateralAmount amount of collateral to add\n    /// @param _collateral address of collateral, \n    /// @param _reciever address of reciever of asset\n    function borrow(\n        uint256 _borrowAmount,\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _reciever\n    ) canBorrow(msg.sender) nonReentrant whenNotPaused external returns (uint256 _shares) {\n        _addInterest();\n\n        if (_collateral != address(0) && (_collateralAmount > 0 || _tokenId > 0)) {\n            require(approvedCollateral[_collateral][_tokenId], \"unapproved collateral\");\n            _addCollateral(msg.sender, _collateral, _collateralAmount, msg.sender, _tokenId);\n        }\n        // borrow asset.\n        _shares = _borrow(_borrowAmount.safeCastTo128(), _reciever);\n    }\n\n    function _borrow(\n        uint128 _borrowAmount,\n        address _receiver\n    ) internal returns (uint256 _shares) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert(\"insufficient contract asset balance\");\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _shares = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_shares);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _shares;\n\n        emit Borrow(msg.sender, _borrowAmount, _shares);\n\n        // Interactions\n        if (_receiver != address(this)) {\n            asset.safeTransfer(_receiver, _borrowAmount);\n        }\n    }\n\n    // REPAY LOGIC\n    event Repay(address indexed borrower, uint256 amount, uint256 shares);\n\n    function repayWithAmount(\n        uint256 _amount, \n        address _borrower\n        )   external nonReentrant returns (uint256 _sharesToRepay){\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _sharesToRepay = _totalBorrow.toShares(_amount, true); \n        _repay(_totalBorrow, _amount.safeCastTo128(), _sharesToRepay.safeCastTo128(), msg.sender, _borrower);\n    }\n\n    function repay(\n        uint256 _shares,\n        address _borrower\n    ) external nonReentrant returns (uint256 _amountToRepay) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        console.log(\"amount to repay: \", _amountToRepay);\n        _repay(_totalBorrow, _amountToRepay.safeCastTo128(), _shares.safeCastTo128(), msg.sender, _borrower);\n    }\n\n    function _repay(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        console.log(\"_shares: \", _shares);\n        console.log(\"_amountToRepay: \", _amountToRepay);\n        console.log(\"userBorrowShares[_borrower]: \", userBorrowShares[_borrower]);\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        emit Repay(_borrower, _amountToRepay, _shares);\n\n        // Interactions\n        if (_payer != address(this)) {\n            asset.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n    }\n\n\n    // ADD/REMOVE COLLATERAL LOGIC\n    event AddCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\n    event RemoveCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\n\n    \n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation, or ERC721.approve().\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _borrower\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant {\n        _addInterest();\n        _addCollateral(msg.sender, _collateral, _collateralAmount, _borrower, _tokenId);\n    }\n\n    function _addCollateral(\n        address _sender,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _borrower,\n        uint256 _tokenId\n    ) internal {\n\n        // Interactions\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\n    \n        if (_sender != address(this)) {\n            if (_isERC20)  {\n                userCollateralERC20[_collateral][_borrower] += _collateralAmount;\n                collateralData[_collateral][0].totalCollateral += _collateralAmount;\n                ERC20(_collateral).safeTransferFrom(_sender, address(this), _collateralAmount);\n            } else {\n                userCollateralNFTs[_collateral][_tokenId] = _borrower;\n                ERC721(_collateral).safeTransferFrom(_sender, address(this), _tokenId);\n            }\n        }\n        emit AddCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    function removeAvailableCollateral(\n        address _collateral, \n        uint256 _tokenId,\n        address _receiver\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) returns(uint256 removeable){\n        _addInterest();\n\n        removeable = removeableCollateral(msg.sender,  _tokenId,  _collateral); \n\n        _removeCollateral(_collateral, \n            removeable,\n            _tokenId, msg.sender, _receiver);\n    }\n\n    function removeCollateral(\n        address _collateral, \n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _receiver\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) {\n        _addInterest();\n\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        _removeCollateral(_collateral, _collateralAmount, _tokenId, msg.sender, _receiver);\n    }\n\n    function _removeCollateral(\n        address _collateral,\n        uint256 _collateralAmount,\n        uint256 _tokenId,\n        address _borrower,\n        address _receiver\n    ) internal {\n\n        // Interactions\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\n        if (_receiver != address(this)) {\n            if (_isERC20) {\n                console.log(\"removing erc20 collateral\");\n                console.log(\"userCollateralerc20: \", userCollateralERC20[_collateral][_borrower] );\n                console.log(\"collateralAmount: \", _collateralAmount);\n                console.log(\"total: \", collateralData[_collateral][0].totalCollateral);\n                userCollateralERC20[_collateral][_borrower] -= _collateralAmount;\n                collateralData[_collateral][0].totalCollateral -= _collateralAmount;\n                ERC20(_collateral).safeTransfer(_receiver, _collateralAmount);\n            } else {\n                require(userCollateralNFTs[_collateral][_tokenId] == _borrower, \"not owner of nft\");\n                delete userCollateralNFTs[_collateral][_tokenId];\n                ERC721(_collateral).safeTransferFrom(address(this), _receiver, _tokenId);\n            }\n        }\n        emit RemoveCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    // liquidation logic\n\n    /// @notice collateral should be auctioned off at a minimum price chosen by the managers\n    /// underlying balance, collateral balance, what do we know about the user?\n    /// if the user's borrow shares are equal to an amount of asset that is greater than the maximum amount they can borrow, \n    /// they are suceptible to liquidation\n    /// how to determine what collateral should be auctioned off?\n    /// maxBorrowAmount\n    function _isLiquidatable(address _borrower) public view returns (bool, int256 accountLiq) {\n        uint256 _maxBorrowableAmount;\n\n        for (uint256 i; i < collaterals.length; i++) {\n            CollateralLabel memory _collateral = collaterals[i];\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxAmount / (10**_d); // <= precision of collateral.\n            } else {\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\n                    _maxBorrowableAmount += _collateralData.maxAmount;\n                }\n            }\n        }\n\n\n        return (_maxBorrowableAmount < totalBorrow.toAmount(userBorrowShares[_borrower], false), \n            int256(_maxBorrowableAmount) - int256(totalBorrow.toAmount(userBorrowShares[_borrower], false))\n        );\n    }\n\n    /// AUCTION LOGIC\n\n    event AuctionCreated(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event AuctionClosed(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event CollateralPurchased(uint256 indexed id, address indexed buyer, address indexed collateral, uint256 tokenId, uint256 amount);\n\n    function liquidate(\n        address _borrower\n    ) external nonReentrant returns (CollateralLabel memory _collateral, uint256 _auctionId){\n        _addInterest();\n        \n        (bool _liquidatable, int256 _accountLiq) = _isLiquidatable(_borrower);\n        require(_liquidatable, \"borrower is not liquidatable\");\n        require(userAuctionId[_borrower] == 0, \"auction already exists\");\n        // _accountLiq < 0 if _liquidatable.\n        //(_collateral, _auctionId) = _createAuction(_borrower, uint256(-_accountLiq));\n    }\n\n    // since we don't know the price of the collateral, will just use largest maxAmount collateral, presumably the most \"liquid\"\n    /// @dev _accountLiq in wad.\n    // function _createAuction(address _borrower, uint256 _accountLiq) internal returns (CollateralLabel memory _collateral, uint256 _auctionId) {\n    //     CollateralLabel[] memory _collaterals = collaterals;\n\n    //     uint256 maxBorrowableAmount;\n    //     for (uint256 i; i<_collaterals.length; i++) {\n    //         CollateralLabel memory _collateralLabel = _collaterals[i];\n    //         Collateral memory _collateralData = collateralData[_collateralLabel.tokenAddress][_collateralLabel.tokenId];\n    //         if (_collateralData.isERC20) {\n    //             uint256 _amount = userCollateralERC20[_collateralLabel.tokenAddress][_borrower] * _collateralData.maxAmount / 1e18; // <= precision of collateral.\n    //             if (_amount > maxBorrowableAmount) {\n    //                 maxBorrowableAmount = _amount;\n    //                 _collateral = _collateralLabel;\n    //             }\n    //         } else {\n    //             if (userCollateralNFTs[_collateralLabel.tokenAddress][_collateralLabel.tokenId] == _borrower) {\n    //                 if (_collateralData.maxAmount > maxBorrowableAmount) {\n    //                     maxBorrowableAmount = _collateralData.maxAmount;\n    //                     _collateral = _collateralLabel;\n    //                 }\n    //             }\n    //         }\n    //     }\n\n    //     // creates auction for collateral user collateral.\n    //     Collateral memory _data = collateralData[_collateral.tokenAddress][_collateral.tokenId];\n\n    //     uint256 _id = numAuctions + 1;\n\n    //     SD59x18 _balance;\n    //     if (_data.isERC20) {\n    //         uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n    //         _balance = sd(int256(userCollateralERC20[_collateral.tokenAddress][_borrower] * 10**(18-_d)));\n    //     } else {\n    //         _balance = toSD59x18(1);\n    //     }\n    //     console.log(\"accountLiq: \", _accountLiq);\n    //     console.logInt(SD59x18.unwrap(_balance));\n    //     console.log(\"maxAmount: \", _data.maxAmount);\n    //     console.logInt(int256(_data.maxAmount));\n\n    //     SD59x18 _initialPrice = sd(int256(_accountLiq)).div(_balance).add(sd(int256(_data.maxAmount))); // per collateral token.\n    //     // console.logInt(SD59x18.unwrap(_initialPrice));\n\n    //     console.log(\"shares: \", totalBorrow.toShares(uint256(SD59x18.unwrap(_initialPrice)), true));\n    //     console.log(\"total.shares: \", totalBorrow.shares);\n    //     console.log(\"total.amount: \", totalBorrow.amount);\n\n    //     SD59x18 _decayConstant = sd(1e17).div(toSD59x18(86400));// decayConstant * deltaTime * initial price = discount.\n    //     SD59x18 _minimumPrice = _initialPrice.div(toSD59x18(4)); // minimum price is 1/4 of initial price.\n        \n    //     // sd(1219450412706); // 10% a day. 1.219450412706322930873853944899453684098615428047153617638...  10^-6\n    //     // SD59x18 _emissionRate = _balance.div(toSD59x18(86400).div(toSD59x18(2))); // 1/2 balance in a day, tokens per second.\n    //     auctions[_id] = Auction({\n    //         collateral: _collateral.tokenAddress,\n    //         tokenId: _collateral.tokenId,\n    //         borrower: _borrower,\n    //         initialPrice: _initialPrice,\n    //         minimumPrice: _minimumPrice,\n    //         decayConstant: _decayConstant,\n    //         startTime: toSD59x18(int256(block.timestamp)),\n    //         //emissionRate: _emissionRate,\n    //         alive: true\n    //     });\n    \n    //     numAuctions = numAuctions + 1;\n    //     _auctionId = _id;\n    //     userAuctionId[_borrower] = _auctionId;\n\n    //     emit AuctionCreated(_id, _borrower, _collateral.tokenAddress, _collateral.tokenId);\n    // }\n\n    \n    // function closeAuction(address _borrower) public {\n    //     uint256 _id = userAuctionId[_borrower];\n    //     (bool _liquidatable, ) = _isLiquidatable(auctions[_id].borrower);\n    //     require(_id != 0, \"no auction exists\");\n\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //     }\n    // }\n\n    // function _closeAuction(uint256 _id) internal {\n    //     address _borrower = auctions[_id].borrower;\n    //     emit AuctionClosed(_id, _borrower, auctions[_id].collateral, auctions[_id].tokenId);\n    //     delete userAuctionId[_borrower];\n    //     delete auctions[_id];\n    // }\n\n    // function purchaseERC20Collateral(uint256 _id, uint256 _amount) external returns (uint256 _totalCost) {\n    //     Auction memory _auction = auctions[_id];\n\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //         revert(\"auction closed\");\n    //     }\n        \n    //     _totalCost = purchasePriceERC20(_id, _amount);\n    //     console.log(\"totalCost: \", _totalCost);\n\n    //     VaultAccount memory _totalBorrow = totalBorrow;\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\n       \n    //    // will revert if not enough collateral in user collateral balance.\n    //    _removeCollateral(_auction.collateral, _amount, _auction.tokenId, _auction.borrower, msg.sender);\n\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //     }\n    //     if (userCollateralERC20[_auction.collateral][_auction.borrower] == 0) {\n    //         delete userAuctionId[_auction.borrower];\n    //         delete auctions[_id];\n    //     }\n        \n    // }\n\n    // function purchasePriceERC20(uint256 _id, uint256 _numTokens) public view returns (uint256 totalCost) {\n    //     Auction memory _auction = auctions[_id];\n    //     require(_auction.alive, \"auction is not alive\");\n\n    //     uint256 _d = ERC20(_auction.collateral).decimals();\n        \n    //     SD59x18 _quantity = sd(int256(_numTokens * (10 ** (18 - _d))));\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime)).mul(_auction.initialPrice);\n    //     SD59x18 _price = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) // is initial price > minimum price + discount => initial price - discount > minimum price\n    //         ? _auction.initialPrice.sub(_discount) : _auction.minimumPrice;\n    //     totalCost = uint256(SD59x18.unwrap(_price.mul(_quantity)));\n    // }\n\n    // /// @param _id is the auction id to purchase the collateral from\n    // function purchaseERC721Collateral(uint256 _id) external returns (uint256 _totalCost) {\n    //     Auction memory _auction = auctions[_id];\n\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _auction.alive = false;\n    //         auctions[_id] = _auction;\n    //         delete userAuctionId[_auction.borrower];\n    //         revert(\"auction closed\");\n    //     }\n        \n    //     _totalCost = purchasePriceERC721(_id);\n\n    //     VaultAccount memory _totalBorrow = totalBorrow;\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\n       \n    //    // will revert if not enough collateral in user collateral balance.\n    //    _removeCollateral(_auction.collateral, 0, _auction.tokenId, _auction.borrower, msg.sender);\n\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //     }\n    //     if (userCollateralNFTs[_auction.collateral][_auction.tokenId] == address(0)) {\n    //         delete userAuctionId[_auction.borrower];\n    //         delete auctions[_id];\n    //     }\n    // }\n\n    // function purchasePriceERC721(uint256 _id) public view returns (uint256 totalCost) {\n    //     Auction memory _auction = auctions[_id];\n    //     require(_auction.alive, \"auction is not alive\");\n\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime));\n\n    //     totalCost = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) ? \n    //     uint256(SD59x18.unwrap(_auction.initialPrice.sub(_discount))) : uint256(SD59x18.unwrap(_auction.minimumPrice));\n        \n    // }\n\n    // instrument functions\n    function instrumentApprovalCondition() public override virtual view returns (bool) {\n        return true;\n    }\n\n    function borrowLiquidityAvailable(uint256 _borrowAmount) public view returns (bool){\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            return false;\n        }\n        return true; \n    }\n\n    function totalAssetAvailable() public view returns(uint256){\n        return _totalAssetAvailable(totalAsset, totalBorrow); \n    }\n\n\n    // ERC4626 functions.\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override virtual {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can withdraw\n        // check if there is enough asset to cover the withdraw.\n        uint256 totalAvailableAsset = _totalAssetAvailable(totalAsset, totalBorrow);\n        require(totalAvailableAsset >= assets, \"not enough asset\");\n\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount -= assets.safeCastTo128();\n        _totalAsset.shares -= shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n\n    }\n\n    function afterDeposit(uint256 assets, uint256 shares) internal override virtual {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can deposit\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount += assets.safeCastTo128();\n        _totalAsset.shares += shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n    }\n\n    function getUserSnapshot(address _address)\n        external\n        view\n        returns (\n            uint256 _userAssetShares,\n            uint256 _userAssetAmount,\n            uint256 _userBorrowShares,\n            uint256 _userBorrowAmount,\n            int256 _userAccountLiquidity\n        )\n    {\n        _userAssetShares = balanceOf[_address];\n        _userAssetAmount = totalAsset.toAmount(_userAssetShares, false);\n        _userBorrowShares = userBorrowShares[_address];\n        _userBorrowAmount = totalBorrow.toAmount(_userBorrowShares, false);\n        (, _userAccountLiquidity) = _isLiquidatable(_address);\n    }\n    function isWithdrawAble(address holder, uint256 amount) external view returns(bool){\n        return (previewRedeem(balanceOf[holder])>= amount && totalAssetAvailable() >= amount); \n    }\n\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toShares(_amount, _roundUp);\n    }\n\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalAsset.toShares(_amount, _roundUp);\n    }\n\n    function totalAssets() public view override virtual returns (uint256) {\n        return totalAsset.amount;\n    }\n\n    function convertToShares(uint256 assets) public view override virtual returns (uint256) {\n        return totalAsset.toShares(assets, false);\n    }\n\n    function convertToAssets(uint256 shares) public view override virtual returns (uint256) {\n        return totalAsset.toAmount(shares, false);\n    }\n\n\n    function previewMint(uint256 shares) public view override virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    function previewWithdraw(uint256 assets) public view override virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewRedeem(uint256 shares) public view override virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n}\n\n/**\nnonReentrant\ndeposit asset\nredeem/withdraw\nborrow\nadd collateral,\nremove collateral,\nliquidate,\nrepay,\nrepay behalf,\nupdate exchange rate,\nupdate interest rate,\nonlyVault\nupdate oracle,\nupdate rateCalculator\nminting, redeeming, depositing\n add collateral in batches\n batch liquidation\n update exchange rate + accue interest when *necessary\n virtual function, is approved borrower.\n instrument functions to override: \n function estimatedTotalAssets() public view virtual returns (uint256){}\n prepareWithdraw\n liquidatePosition => protocol liquidation for all outstanding debt.\n */"
    },
    "contracts/instruments/poolConstants.sol": {
      "content": "pragma solidity ^0.8.16;\n\n// taken from https://github.com/FraxFinance/fraxlend\nabstract contract PoolConstants {\n    uint256 internal constant LTV_PRECISION = 1e5; // 5 decimals\n    uint256 internal constant LIQ_PRECISION = 1e5;\n    uint256 internal constant UTIL_PREC = 1e5;\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant EXCHANGE_PRECISION = 1e18;\n    uint64 internal constant DEFAULT_INT = 158049988; // 0.5% annual rate 1e18 precision\n}"
    },
    "contracts/instruments/poolInstrument.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {PoolConstants} from \"./poolConstants.sol\";\nimport {VaultAccount, VaultAccountingLibrary} from \"./VaultAccount.sol\";\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {IRateCalculator} from \"./IRateCalculator.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Pausable} from \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {ERC4626} from \"lib/solmate/src/mixins/ERC4626.sol\";\nimport {ERC721TokenReceiver} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {ReputationManager} from \"../protocol/reputationmanager.sol\";\nimport {Auctioneer} from \"./auctioneer.sol\";\n\n// import \"@prb/math/SD59x18.sol\";\n\ninterface Bouncer {\n    function borrowerAllowed(address _borrower) external view returns (bool);\n}\n\ncontract BouncerLike is Bouncer {\n    function borrowerAllowed(address _borrower) external view override returns (bool) {\n        return true;\n    }\n}\n\n// https://github.com/FraxFinance/fraxlend\n/// ****THIS IS A PROOF OF CONCEPT INSTRUMENT.\ncontract PoolInstrument is\n    ERC4626,\n    Instrument,\n    PoolConstants,\n    ReentrancyGuard,\n    // Pausable,\n    ERC721TokenReceiver\n{\n    using SafeTransferLib for ERC20;\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n    /// @param lastBlock last block number\n    /// @param lastTimestamp last block.timestamp\n    /// @param ratePerSec rate per second of interest accrual\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @param tokenAddress collateral token address\n    /// @param tokenId collateral tokenId, 0 for ERC20.\n    struct CollateralLabel {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    /// @param totalCollateral total amount of collateral for a given ERC20 asset, will be zero for NFTs\n    /// @param maxAmount max amount in underlying that a user can \"owe\" per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    /// should always be more than the maxBorrowAmount, acts as buffer for protocol and borrower. this is the value to determine whether\n    /// a borrower is liquidatable\n    /// @param maxBorrowAmount max amount in underlying that a user can borrow per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    struct Config {\n        uint256 totalCollateral;\n        uint256 maxAmount;\n        uint256 maxBorrowAmount;\n        bool isERC20;\n        // auction parameters\n        uint256 tau; // seconds after auction start when the price reaches zero -> linearDecrease\n        uint256 cusp; // percentage price drop that can occur before an auction must be reset.\n        uint256 tail; // seconds that can elapse before an auction must be reset.\n        uint256 buf; // auction start price = buf * maxAmount\n    }\n\n    /// @notice amount: asset token borrowed, shares = total shares outstanding\n    VaultAccount public totalBorrow;\n    /// @notice amount: total asset supplied + interest earned, shares = total shares outstanding\n    VaultAccount public totalAsset;\n\n    mapping(bytes32 => Config) public collateralConfigs; // collateral address => tokenId (0 for erc20) => collateral data.\n    mapping(bytes32 => bool) public approvedCollateral;\n    mapping(bytes32 => mapping(address => uint256)) public userERC20s; // per collateral, user balance of collateral. id -> user -> balance.\n    mapping(bytes32 => address) public userERC721s; // nft addr => tokenId => owner.\n    mapping(address => uint256) public userBorrowShares; // user -> shares, this should be equivalent to balanceOf(user), since pool is vault.\n\n    // mapping(address=>uint256) private baseUnits; // equivalent to 10**decimals for ERC20s, 1 for NFTs.\n    mapping(address => mapping(bytes32 => bool)) public enabledCollateral; // user -> collateral -> enabled.\n    mapping(address => CollateralLabel[]) public userCollateral;\n\n    // *** id for collateral = keccak256(abi.encodePacked(collateral, tokenId))\n\n    IRateCalculator public rateContract;\n\n    /// @dev depends on rateCalculator used\n    bytes public rateInitCallData;\n\n    CurrentRateInfo public currentRateInfo;\n    CollateralLabel[] private collaterals; //approved collaterals.\n    ReputationManager private reputationManager;\n    Auctioneer private auctioneer;\n    uint256 public r; // reputation score for this instrument.\n\n    constructor(\n        address _vault,\n        address _reputationManager,\n        uint256 _r,\n        address _utilizer,\n        string memory _name,\n        string memory _symbol,\n        address _rateCalculator,\n        bytes memory _rateInitCallData,\n        CollateralLabel[] memory _collaterals,\n        Config[] memory _collateralData\n    )\n        Instrument(_vault, _utilizer)\n        ERC4626(Vault(_vault).UNDERLYING(), _name, _symbol)\n    {\n        rateContract = IRateCalculator(_rateCalculator);\n        rateInitCallData = _rateInitCallData;\n        rateContract.requireValidInitData(_rateInitCallData);\n\n        // need to check for added collateral that erc20 is erc20. ability to add or remove accepted collateral.\n\n        reputationManager = ReputationManager(_reputationManager);\n        r = _r;\n\n        for (uint256 i = 0; i < _collaterals.length; i++) {\n            _addAcceptedCollateral(\n                _collaterals[i].tokenAddress,\n                _collaterals[i].tokenId,\n                _collateralData[i]\n            );\n        }\n    }\n\n    /**\n     helper fxn for computing id for collateral, tokenId == 0 for ERC20s.\n     */\n    function computeId(address _addr, uint256 _tokenId)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_addr, _tokenId));\n    }\n\n    function getCollateralConfig(bytes32 collateralId)\n        public\n        view\n        returns (Config memory)\n    {\n        return collateralConfigs[collateralId];\n    }\n\n    function getAcceptedCollaterals()\n        public\n        view\n        returns (CollateralLabel[] memory)\n    {\n        return collaterals;\n    }\n\n    function setAuctioneer(address _auctioneer) public {\n        require(msg.sender == vault.owner(), \"only owner\");\n        auctioneer = Auctioneer(_auctioneer);\n    }\n\n    // event NewCollateralAdded(address collateral, uint256 tokenId, uint256 maxAmount, uint256 maxBorrowAmount, bool isERC20);\n    // legacy for tests, remove later.\n\n    function addAcceptedCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        Config calldata _config\n    ) public {\n        require(msg.sender == vault.owner(), \"only owner\");\n        _addAcceptedCollateral(_collateral, _tokenId, _config);\n    }\n\n    /**\n     @notice adds a new collateral to the instrument\n     */\n    function _addAcceptedCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        Config memory _config\n    ) internal {\n        // need to ensure that _config isERC20 is correct.\n        // max borrow must be less than max amount.\n        bytes32 id = computeId(_collateral, _tokenId);\n        require(!approvedCollateral[id], \"already approved\");\n        require(\n            _config.maxBorrowAmount < _config.maxAmount,\n            \"maxBorrowAmount must be less than maxAmount\"\n        );\n        if (_config.isERC20) {\n            require(_tokenId == 0, \"tokenId must be 0 for ERC20\");\n        }\n        _config.totalCollateral = 0;\n        collateralConfigs[id] = _config;\n        collaterals.push(CollateralLabel(_collateral, _tokenId));\n        approvedCollateral[id] = true;\n    }\n\n    function updateConfig(\n        CollateralLabel calldata _label,\n        Config calldata _config\n    ) public {\n        require(msg.sender == vault.owner(), \"!owner\");\n        bytes32 id = computeId(_label.tokenAddress, _label.tokenId);\n        require(approvedCollateral[id], \"!collateral_approved\");\n        collateralConfigs[id] = _config;\n    }\n\n    // INTERNAL HELPERS\n\n    modifier onlyApprovedCollateral(address _collateral, uint256 _tokenId) {\n        require(\n            approvedCollateral[computeId(_collateral, _tokenId)],\n            \"!collateral_approved\"\n        );\n        _;\n    }\n\n    function _totalAssetAvailable(\n        VaultAccount memory _totalAsset,\n        VaultAccount memory _totalBorrow\n    ) internal pure returns (uint256) {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    // INTEREST RATE LOGIC\n    event InterestAdded(\n        uint256 indexed timestamp,\n        uint256 interestEarned,\n        uint256 feesAmount,\n        uint256 feesShare,\n        uint64 newRate\n    );\n\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    function _addInterest()\n        internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // If there are no borrows or contract is paused, no interest adds and we reset interest rate\n        if (_totalBorrow.shares == 0) {\n            // if (!paused()) {\n            //     _currentRateInfo.ratePerSec = DEFAULT_INT;\n            // }\n            _currentRateInfo.ratePerSec = DEFAULT_INT;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp -\n                _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) /\n                _totalAsset.amount;\n            // console.log(\"_utilizationRate: \", _utilizationRate);\n            bytes memory _rateData = abi.encode(\n                _currentRateInfo.ratePerSec,\n                _deltaTime,\n                _utilizationRate,\n                block.number - _currentRateInfo.lastBlock\n            );\n            _newRate = IRateCalculator(rateContract).getNewRate(\n                _rateData,\n                rateInitCallData\n            );\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest addd\n            _interestEarned =\n                (_deltaTime *\n                    _totalBorrow.amount *\n                    _currentRateInfo.ratePerSec) /\n                1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n        emit InterestAdded(\n            block.timestamp,\n            _interestEarned,\n            _feesAmount,\n            _feesShare,\n            _newRate\n        );\n    }\n\n    // SOLVENCY* LOGIC\n\n    /// @notice Checks if total amount of asset user borrowed is less than max borrow threshold AFTER executing contract code\n    modifier canBorrow(address _borrower) {\n        _;\n        require(_canBorrow(_borrower), \"!solvent\");\n    }\n\n    modifier isSolvent(address _borrower) {\n        _;\n        bool isLiq = _isLiquidatable(_borrower);\n        require(!isLiq, \"!solvent\");\n    }\n\n    /// @notice checks if the borrower is can borrow\n    /// @dev collateral value is in asset, summed across all approved collaterals.\n    /// @dev will return true if the borrower has no collateral and also has no borrower shares.\n    /// @dev 0 addr cannot borrow.\n    function _canBorrow(address _borrower) public view returns (bool) {\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\n\n        if (userBorrowShares[_borrower] == 0) {\n            return true;\n        }\n        if (_maxBorrowableAmount == 0) {\n            return false;\n        }\n        return\n            _maxBorrowableAmount >=\n            totalBorrow.toAmount(userBorrowShares[_borrower], false);\n    }\n\n    function getMaxBorrow(address _borrower)\n        public\n        view\n        returns (uint256 _maxBorrowableAmount)\n    {\n        CollateralLabel[] memory userCollaterals = userCollateral[_borrower];\n\n        for (uint256 i; i < userCollaterals.length; i++) {\n            CollateralLabel memory _collateral = userCollaterals[i];\n            bytes32 id = computeId(\n                _collateral.tokenAddress,\n                _collateral.tokenId\n            );\n            Config memory _collateralData = collateralConfigs[id];\n            if (_collateralData.isERC20 && userERC20s[id][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxBorrowableAmount +=\n                    (userERC20s[id][_borrower] *\n                        _collateralData.maxBorrowAmount) /\n                    (10**_d); // <= precision of collateral.\n            } else if (userERC721s[id] == _borrower) {\n                _maxBorrowableAmount += _collateralData.maxBorrowAmount;\n            }\n        }\n    }\n\n    /// @notice returns how much collateral can be removed from a borrower given the debt condition\n    /// borrowed assets < maxBorrowAmount, then collateral can be removed,\n    // only needed for erc20s.\n    // function removeableCollateral(\n    //     address _borrower,\n    //     uint256 tokenId,\n    //     address collateral\n    // ) public view returns (uint256) {\n    //     //800 borrowable = 800 * 1, 600borrowed (800-x)*1 - 600 = 0 x=?\n    //     //800*1-x*1-600 , x = (800*1 - 600)/1\n    //     uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\n    //     bytes32 id = computeId(collateral, tokenId);\n    //     uint256 perUnitMaxBorrowAmount = collateralConfigs[id].maxBorrowAmount;\n    //     //check solvency\n    //     return\n    //         ((_maxBorrowableAmount -\n    //             totalBorrow.toAmount(userBorrowShares[_borrower], true)) *\n    //             ERC20(collateral).decimals()) / perUnitMaxBorrowAmount;\n    // }\n\n    // BORROW LOGIC\n    event Borrow(address indexed _borrower, uint256 _amount, uint256 _shares);\n\n    /// @param _borrowAmount amount of asset to borrow\n    /// @param _collateralAmount amount of collateral to add\n    /// @param _collateral address of collateral,\n    /// @param _reciever address of reciever of asset\n    function borrow(\n        uint256 _borrowAmount,\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _reciever,\n        bool _enable\n    )\n        external\n        canBorrow(msg.sender)\n        nonReentrant\n        // whenNotPaused\n        returns (uint256 _shares)\n    {\n        _addInterest();\n\n        if (\n            _collateral != address(0) && (_collateralAmount > 0 || _tokenId > 0)\n        ) {\n            bytes32 id = computeId(_collateral, _tokenId);\n            require(approvedCollateral[id], \"!unapproved\");\n            if (_enable) {\n                enableCollateral(_collateral, _tokenId);\n            }\n            _addCollateral(\n                msg.sender,\n                _collateral,\n                _collateralAmount,\n                msg.sender,\n                _tokenId\n            );\n        }\n        // borrow asset.\n        _shares = _borrow(_borrowAmount.safeCastTo128(), _reciever);\n    }\n\n    function _borrow(uint128 _borrowAmount, address _receiver)\n        internal\n        returns (uint256 _shares)\n    {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(\n            totalAsset,\n            _totalBorrow\n        );\n        if (_assetsAvailable < _borrowAmount) {\n            revert(\"!assetsAvailable\");\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _shares = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_shares);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _shares;\n\n        emit Borrow(msg.sender, _borrowAmount, _shares);\n\n        // Interactions\n        if (_receiver != address(this)) {\n            asset.safeTransfer(_receiver, _borrowAmount);\n        }\n    }\n\n    // REPAY LOGIC\n    event Repay(address indexed borrower, uint256 amount, uint256 shares);\n\n    // function repayWithAmount(uint256 _amount, address _borrower)\n    //     external\n    //     nonReentrant\n    //     returns (uint256 _sharesToRepay)\n    // {\n    //     VaultAccount memory _totalBorrow = totalBorrow;\n    //     _sharesToRepay = _totalBorrow.toShares(_amount, true);\n    //     _repay(\n    //         _totalBorrow,\n    //         _amount.safeCastTo128(),\n    //         _sharesToRepay.safeCastTo128(),\n    //         msg.sender,\n    //         _borrower\n    //     );\n    // }\n\n    function repay(uint256 _shares, address _borrower)\n        external\n        nonReentrant\n        returns (uint256 _amountToRepay)\n    {\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        console.log(\"amount to repay: \", _amountToRepay);\n        _repay(\n            _totalBorrow,\n            _amountToRepay.safeCastTo128(),\n            _shares.safeCastTo128(),\n            msg.sender,\n            _borrower\n        );\n    }\n\n    function _repay(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        // console.log(\"_shares: \", _shares);\n        // console.log(\"_amountToRepay: \", _amountToRepay);\n        // console.log(\n        //     \"userBorrowShares[_borrower]: \",\n        //     userBorrowShares[_borrower]\n        // );\n        // console.log(\"totalBorrow.amount: \", totalBorrow.amount);\n        // console.log(\"totalBorrow.shares: \", totalBorrow.shares);\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        emit Repay(_borrower, _amountToRepay, _shares);\n\n        // Interactions\n        if (_payer != address(this)) {\n            asset.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n\n        // need to check if liquidatable, if so and there are open auctions, then need to close those auctions.\n        if (auctioneer.getActiveUserAuctions(_borrower).length != 0) {\n            auctioneer.closeAllAuctions(_borrower);\n        }\n    }\n\n    // ADD/REMOVE/ENABLE/DISABLE COLLATERAL LOGIC\n    event AddCollateral(\n        address indexed borrower,\n        address collateral,\n        uint256 tokenId,\n        uint256 amount\n    );\n    event RemoveCollateral(\n        address indexed borrower,\n        address collateral,\n        uint256 tokenId,\n        uint256 amount\n    );\n\n    function enableCollateral(address _collateral, uint256 _tokenId)\n        public\n        onlyApprovedCollateral(_collateral, _tokenId)\n    {\n        // if already enabled, then return\n        bytes32 id = computeId(_collateral, _tokenId);\n        if (enabledCollateral[msg.sender][id]) {\n            return;\n        }\n        enabledCollateral[msg.sender][id] = true;\n        userCollateral[msg.sender].push(CollateralLabel(_collateral, _tokenId));\n    }\n\n    /**\n     can only disable collateral if no collateral balance.\n     */\n    function disableCollateral(address _collateral, uint256 _tokenId)\n        public\n        \n        onlyApprovedCollateral(_collateral, _tokenId)\n        isSolvent(msg.sender)\n    {\n        // if already enabled, then return\n        bytes32 id = computeId(_collateral, _tokenId);\n        if (!enabledCollateral[msg.sender][id]) {\n            return;\n        }\n\n        // require zero collateral, maybe this isn't necessary.\n        require(\n            userERC20s[id][msg.sender] == 0 ||\n                userERC721s[id] != address(msg.sender),\n            \"must remove all remaining collateral to disable\"\n        );\n\n        // switch w/ last and pop\n        CollateralLabel[] memory arr = userCollateral[msg.sender];\n        for (uint256 i; i < arr.length; i++) {\n            if (\n                arr[i].tokenAddress == _collateral && arr[i].tokenId == _tokenId\n            ) {\n                userCollateral[msg.sender][i] = userCollateral[msg.sender][\n                    userCollateral[msg.sender].length - 1\n                ];\n                userCollateral[msg.sender].pop();\n                break;\n            }\n        }\n\n        enabledCollateral[msg.sender][id] = false;\n    }\n\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation, or ERC721.approve().\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _borrower,\n        bool _enable\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant {\n        _addInterest();\n\n        if (_enable) {\n            enableCollateral(_collateral, _tokenId);\n        }\n\n        _addCollateral(\n            msg.sender,\n            _collateral,\n            _collateralAmount,\n            _borrower,\n            _tokenId\n        );\n    }\n\n    function _addCollateral(\n        address _sender,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _borrower,\n        uint256 _tokenId\n    ) internal {\n        // Interactions\n        bytes32 id = computeId(_collateral, _tokenId);\n        bool _isERC20 = collateralConfigs[id].isERC20;\n\n        if (_sender != address(this)) {\n            if (_isERC20) {\n                userERC20s[id][_borrower] += _collateralAmount;\n                collateralConfigs[id].totalCollateral += _collateralAmount;\n                ERC20(_collateral).safeTransferFrom(\n                    _sender,\n                    address(this),\n                    _collateralAmount\n                );\n            } else {\n                userERC721s[id] = _borrower;\n                ERC721(_collateral).safeTransferFrom(\n                    _sender,\n                    address(this),\n                    _tokenId\n                );\n            }\n        }\n        emit AddCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    /**\n     erc20: removes all collateral so that maxBorrow === existing borrow.\n     erc721: if can remove collateral, then removes it, otherwise reverts.\n     */\n    // function removeAvailableCollateral(\n    //     address _collateral,\n    //     uint256 _tokenId,\n    //     address _receiver\n    // )\n    //     external\n    //     nonReentrant\n    //     canBorrow(msg.sender)\n    //     onlyApprovedCollateral(_collateral, _tokenId)\n    //     returns (uint256 removeable)\n    // {\n    //     _addInterest();\n\n    //     removeable = removeableCollateral(msg.sender, _tokenId, _collateral);\n\n    //     _removeCollateral(\n    //         _collateral,\n    //         removeable,\n    //         _tokenId,\n    //         msg.sender,\n    //         _receiver\n    //     );\n    // }\n\n    function removeCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _receiver,\n        bool _disable\n    )\n        external\n        nonReentrant\n        canBorrow(msg.sender)\n        onlyApprovedCollateral(_collateral, _tokenId)\n    {\n        _addInterest();\n\n        if (_disable) {\n            disableCollateral(_collateral, _tokenId);\n        }\n\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        _removeCollateral(\n            _collateral,\n            _collateralAmount,\n            _tokenId,\n            msg.sender,\n            _receiver\n        );\n    }\n\n    function _removeCollateral(\n        address _collateral,\n        uint256 _collateralAmount,\n        uint256 _tokenId,\n        address _borrower,\n        address _receiver\n    ) internal {\n        // Interactions\n        bytes32 id = computeId(_collateral, _tokenId);\n        bool _isERC20 = collateralConfigs[id].isERC20;\n        if (_receiver != address(this)) {\n            if (_isERC20) {\n                // console.log(\"removing erc20 collateral\");\n                // console.log(\"userCollateralerc20: \", userERC20s[id][_borrower] );\n                // console.log(\"collateralAmount: \", _collateralAmount);\n                userERC20s[id][_borrower] -= _collateralAmount;\n                collateralConfigs[id].totalCollateral -= _collateralAmount;\n                ERC20(_collateral).safeTransfer(_receiver, _collateralAmount);\n            } else {\n                require(userERC721s[id] == _borrower, \"not owner of nft\");\n                delete userERC721s[id];\n                ERC721(_collateral).safeTransferFrom(\n                    address(this),\n                    _receiver,\n                    _tokenId\n                );\n            }\n        }\n        emit RemoveCollateral(\n            _borrower,\n            _collateral,\n            _tokenId,\n            _collateralAmount\n        );\n    }\n\n    // liquidation logic\n\n    /// @notice collateral should be auctioned off at a minimum price chosen by the managers\n    /// underlying balance, collateral balance, what do we know about the user?\n    /// if the user's borrow shares are equal to an amount of asset that is greater than the maximum amount they can borrow,\n    /// they are suceptible to liquidation\n    /// how to determine what collateral should be auctioned off?\n    /// maxBorrowAmount\n    function _isLiquidatable(address _borrower)\n        public\n        view\n        returns (bool)\n    {\n        return (accountLiquidity(_borrower) < 0);\n    }\n\n    function accountLiquidity(address _borrower) public view returns (int256) {\n        uint256 _maxAmount;\n\n        CollateralLabel[] memory userCollaterals = userCollateral[_borrower];\n        for (uint256 i; i < userCollaterals.length; i++) {\n            CollateralLabel memory _collateral = userCollaterals[i];\n            bytes32 id = computeId(\n                _collateral.tokenAddress,\n                _collateral.tokenId\n            );\n            Config memory _collateralData = collateralConfigs[id];\n            if (_collateralData.isERC20 && userERC20s[id][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxAmount +=\n                    (userERC20s[id][_borrower] * _collateralData.maxAmount) /\n                    (10**_d); // <= precision of collateral.\n            } else {\n                if (userERC721s[id] == _borrower) {\n                    _maxAmount += _collateralData.maxAmount;\n                }\n            }\n        }\n\n        return int256(_maxAmount) - int256(totalBorrow.toAmount(userBorrowShares[_borrower], true));\n    }\n\n    // function getUserCollateral(address _borrower)\n    //     external\n    //     view\n    //     returns (CollateralLabel[] memory)\n    // {\n    //     return userCollateral[_borrower];\n    // }\n\n    /**\n     @notice can only be called when user is liquidatable, all auctions are terminated if not the case.\n     need rewards for ppl who call this fxn right?\n     */\n    function triggerAuction(\n        address _borrower,\n        address _collateral,\n        uint256 _tokenId\n    )\n        external\n        onlyApprovedCollateral(_collateral, _tokenId)\n        nonReentrant\n        returns (bytes32 _auctionId)\n    {\n        _addInterest();\n\n        // bool _liquidatable = _isLiquidatable(_borrower);\n\n\n        if (_isLiquidatable(_borrower)) {\n            _auctionId = auctioneer.createAuction(\n                _borrower,\n                _collateral,\n                _tokenId\n            );\n            \n        }\n    }\n\n    /**\n     @param _amount: amount of collateral to purchase w/ collateral decimals.\n     will reset auction if either tau passed or cusp reached and user still insolvent.\n     watch for price increases, maxPrice should be param set by user. mkerdao\n     if collateral not erc20, then amount is ignored.\n     */\n    function purchaseCollateral(\n        address _borrower,\n        CollateralLabel calldata _label,\n        uint256 _amount,\n        uint256 _deadline\n    ) external returns (uint128 _totalCost) {\n        if (block.timestamp > _deadline) {\n            revert(\"past deadline\");\n        }\n\n        _addInterest();\n\n        bytes32 collateralId = computeId(_label.tokenAddress, _label.tokenId);\n\n        Config memory config = collateralConfigs[collateralId];\n\n        require(auctioneer.getAuction(_borrower, _label.tokenAddress, _label.tokenId).alive, \"!alive\");\n\n        (bool reset, bool closed) = checkAuction(_borrower, _label.tokenAddress, _label.tokenId);\n\n        if (reset || closed) {\n            return 0;\n        }\n\n        uint256 currentPrice = auctioneer.purchasePrice(\n            _borrower,\n            _label.tokenAddress,\n            _label.tokenId\n        ); // price of collateral in underlying.\n\n        if (config.isERC20) {\n            //TODO need to ensure safe to cast here.\n            _totalCost = uint128((_amount * currentPrice) / (10**ERC20(_label.tokenAddress).decimals())); // <= decimals of collateral.\n            \n            console.log(\"total cost: %s\", _totalCost);\n            if (_amount == userERC20s[collateralId][_borrower]) {\n                auctioneer.closeAuction(\n                    _borrower,\n                    _label.tokenAddress,\n                    _label.tokenId\n                );\n            }\n        } else {\n            _totalCost = uint128(currentPrice);\n            auctioneer.closeAuction(\n                _borrower,\n                _label.tokenAddress,\n                _label.tokenId\n            );\n\n            // if nft sold for more than borrowShares, then give rest of asset to borrower\n            if (_totalCost > totalBorrow.toAmount(userBorrowShares[_borrower], false)) {\n                uint256 difference = _totalCost - totalBorrow.toAmount(userBorrowShares[_borrower], false);\n                \n                // difference goes to the pool.\n                totalAsset.amount += difference.safeCastTo128();\n                asset.safeTransferFrom(msg.sender, address(this), difference);\n\n                _totalCost = uint128(totalBorrow.toAmount(userBorrowShares[_borrower], true));\n            }\n        }\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // console.log(\"cost share: %s\", totalBorrow.toShares(_totalCost, false));\n        // console.log(\"user borrow shares: %s\", userBorrowShares[_borrower]);\n        // console.log(\"gt?\", totalBorrow.toShares(_totalCost, false) > userBorrowShares[_borrower]);\n\n        _repay(\n            _totalBorrow,\n            _totalCost,\n            uint128(totalBorrow.toShares(_totalCost, false)),\n            msg.sender,\n            _borrower\n        );\n\n        // reverts if not enough collateral\n        _removeCollateral(\n            _label.tokenAddress,\n            _amount,\n            _label.tokenId,\n            _borrower,\n            msg.sender\n        );\n\n        // total cost of collateral in asset.\n    }\n\n    /**\n        @notice checks if auction is still valid -> borrower still liq + none of the auction end conditions have been met , if not resets auction.\n        only for alive auctions\n     */\n    function checkAuction(\n        address _borrower,\n        address _collateral,\n        uint256 _tokenId\n    ) public onlyApprovedCollateral(_collateral, _tokenId) returns (bool reset, bool closed) {\n        Auctioneer.Auction memory auction = auctioneer.getAuction(\n            _borrower,\n            _collateral,\n            _tokenId\n        );\n\n        Config memory config = collateralConfigs[computeId(_collateral, _tokenId)];\n\n        // close all auctions if liquidatable.\n        if (!_isLiquidatable(_borrower)) {\n            auctioneer.closeAllAuctions(\n                _borrower\n            );\n            return (false, true);\n        }\n        \n        if (\n            (block.timestamp > auction.creationTimestamp + config.tau) ||\n            (auctioneer.purchasePrice(_borrower, _collateral, _tokenId) < config.cusp.mulWadDown(config.maxAmount.mulWadDown(config.buf)))\n        ) {\n            auctioneer.resetAuction(\n                _borrower,\n                _collateral,\n                _tokenId\n            );\n            return (true, false);\n        }\n    }\n\n    /**\n     @notice returns cost of purchasing _numTokens of collateral in pool underlying.\n     */\n\n    // instrument functions\n    function instrumentApprovalCondition()\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    function totalAssetAvailable() public view returns (uint256) {\n        return _totalAssetAvailable(totalAsset, totalBorrow);\n    }\n\n    // ERC4626 functions.\n\n    function beforeWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can withdraw\n        // check if there is enough asset to cover the withdraw.\n        uint256 totalAvailableAsset = _totalAssetAvailable(\n            totalAsset,\n            totalBorrow\n        );\n        require(totalAvailableAsset >= assets, \"not enough asset\");\n\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount -= assets.safeCastTo128();\n        _totalAsset.shares -= shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n    }\n\n    function afterDeposit(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can deposit\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount += assets.safeCastTo128();\n        _totalAsset.shares += shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n    }\n\n    function getUserSnapshot(address _address)\n        external\n        view\n        returns (\n            uint256 _userAssetShares,\n            uint256 _userAssetAmount,\n            uint256 _userBorrowShares,\n            uint256 _userBorrowAmount,\n            int256 _userAccountLiquidity,\n            CollateralLabel[] memory _userCollaterals\n        )\n    {\n        _userAssetShares = balanceOf[_address];\n        _userAssetAmount = totalAsset.toAmount(_userAssetShares, false);\n        _userBorrowShares = userBorrowShares[_address];\n        _userBorrowAmount = totalBorrow.toAmount(_userBorrowShares, false);\n        _userAccountLiquidity = accountLiquidity(_address);\n        _userCollaterals = userCollateral[_address];\n    }\n\n    function isWithdrawAble(address holder, uint256 amount)\n        external\n        view\n        returns (bool)\n    {\n        return (previewRedeem(balanceOf[holder]) >= amount &&\n            totalAssetAvailable() >= amount);\n    }\n\n    function toBorrowShares(uint256 _amount, bool _roundUp)\n        external\n        view\n        returns (uint256)\n    {\n        return totalBorrow.toShares(_amount, _roundUp);\n    }\n\n    function toBorrowAmount(uint256 _shares, bool _roundUp)\n        external\n        view\n        returns (uint256)\n    {\n        return totalBorrow.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetAmount(uint256 _shares, bool _roundUp)\n        external\n        view\n        returns (uint256)\n    {\n        return totalAsset.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetShares(uint256 _amount, bool _roundUp)\n        external\n        view\n        returns (uint256)\n    {\n        return totalAsset.toShares(_amount, _roundUp);\n    }\n\n    function totalAssets() public view virtual override returns (uint256) {\n        return totalAsset.amount;\n    }\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {   \n        return totalAsset.toShares(assets, false);\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return totalAsset.toAmount(shares, false);\n    }\n\n    function previewMint(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    function assetOracle(uint256 totalSupply)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        // Default balance oracle\n        console.log('totalasset', uint256(totalAsset.amount), uint256(totalAsset.shares)); \n        console.log('totalSupply', totalSupply, previewMint(1e18)); \n        return totalSupply.mulWadDown(previewMint(1e18));\n        //TODO custom oracle\n    }\n\n    /// @notice to modify totalassets very privileged function \n    function modifyTotalAsset(bool add, uint256 amount) external \n    //onlyManager \n    {\n        if(add) totalAsset.amount += uint128(amount); \n        else totalAsset.amount -= uint128(amount); \n    }\n\n}\n\n/**\nnonReentrant\ndeposit asset\nredeem/withdraw\nborrow\nadd collateral,\nremove collateral,\nliquidate,\nrepay,\nrepay behalf,\nupdate exchange rate,\nupdate interest rate,\nonlyVault\nupdate oracle,\nupdate rateCalculator\n\nminting, redeeming, depositing\n\n add collateral in batches\n batch liquidation\n update exchange rate + accue interest when *necessary\n\n virtual function, is approved borrower.\n\n instrument functions to override: \n function estimatedTotalAssets() public view virtual returns (uint256){}\n prepareWithdraw\n liquidatePosition => protocol liquidation for all outstanding debt.\n */\n"
    },
    "contracts/instruments/priceCalculator.sol": {
      "content": ""
    },
    "contracts/instruments/VariableInterestRate.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.16;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ====================== VariableInterestRate ========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"./IRateCalculator.sol\";\n\n/// @title A formula for calculating interest rates as a function of utilization and time\n/// @author Drake Evans github.com/drakeevans\n/// @notice A Contract for calculating interest rates as a function of utilization and time\ncontract VariableInterestRate is IRateCalculator {\n    // Utilization Rate Settings\n    uint32 private constant MIN_UTIL = 75000; // 75%\n    uint32 private constant MAX_UTIL = 85000; // 85%\n    uint32 private constant UTIL_PREC = 1e5; // 5 decimals\n\n    // Interest Rate Settings (all rates are per second), 365.24 days per year\n    uint64 private constant MIN_INT = 79123523; // 0.25% annual rate\n    uint64 private constant MAX_INT = 146248476607; // 10,000% annual rate\n    uint256 private constant INT_HALF_LIFE = 43200e36; // given in seconds, equal to 12 hours, additional 1e36 to make math simpler\n\n    /// @notice The ```name``` function returns the name of the rate contract\n    /// @return memory name of contract\n    function name() external pure returns (string memory) {\n        return \"Variable Time-Weighted Interest Rate\";\n    }\n\n    /// @notice The ```getConstants``` function returns abi encoded constants\n    /// @return _calldata abi.encode(uint32 MIN_UTIL, uint32 MAX_UTIL, uint32 UTIL_PREC, uint64 MIN_INT, uint64 MAX_INT, uint256 INT_HALF_LIFE)\n    function getConstants() external pure returns (bytes memory _calldata) {\n        return abi.encode(MIN_UTIL, MAX_UTIL, UTIL_PREC, MIN_INT, MAX_INT, INT_HALF_LIFE);\n    }\n\n    /// @notice The ```requireValidInitData``` function No-op as this contract has no init data\n    function requireValidInitData(bytes calldata _initData) external pure {}\n\n    /// @notice The ```getNewRate``` function calculates the new interest rate as a function of time and utilization\n    /// @param _data abi.encode(uint64 _currentRatePerSec, uint256 _deltaTime, uint256 _utilization, uint256 _deltaBlocks)\n    /// @param _initData empty for this Rate Calculator\n    /// @return _newRatePerSec The new interest rate per second, 1e18 precision\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec) {\n        (uint64 _currentRatePerSec, uint256 _deltaTime, uint256 _utilization, ) = abi.decode(\n            _data,\n            (uint64, uint256, uint256, uint256)\n        );\n        if (_utilization < MIN_UTIL) {\n            uint256 _deltaUtilization = ((MIN_UTIL - _utilization) * 1e18) / MIN_UTIL;\n            uint256 _decayGrowth = INT_HALF_LIFE + (_deltaUtilization * _deltaUtilization * _deltaTime);\n            _newRatePerSec = uint64((_currentRatePerSec * INT_HALF_LIFE) / _decayGrowth);\n            if (_newRatePerSec < MIN_INT) {\n                _newRatePerSec = MIN_INT;\n            }\n        } else if (_utilization > MAX_UTIL) {\n            uint256 _deltaUtilization = ((_utilization - MAX_UTIL) * 1e18) / (UTIL_PREC - MAX_UTIL);\n            uint256 _decayGrowth = INT_HALF_LIFE + (_deltaUtilization * _deltaUtilization * _deltaTime);\n            _newRatePerSec = uint64((_currentRatePerSec * _decayGrowth) / INT_HALF_LIFE);\n            if (_newRatePerSec > MAX_INT) {\n                _newRatePerSec = MAX_INT;\n            }\n        } else {\n            _newRatePerSec = _currentRatePerSec;\n        }\n    }\n}\n"
    },
    "contracts/instruments/VaultAccount.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.16;\n\nstruct VaultAccount {\n    uint128 amount; // Total amount, analogous to market cap\n    uint128 shares; // Total shares, analogous to shares outstanding\n}\n\n/// @title VaultAccount Library\n/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto\n/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations\n/// @dev Uses uint128 to save on storage\nlibrary VaultAccountingLibrary {\n    /// @notice Calculates the shares value in relationship to `amount` and `total`\n    /// @dev Given an amount, return the appropriate number of shares\n    function toShares(\n        VaultAccount memory total,\n        uint256 amount,\n        bool roundUp\n    ) internal pure returns (uint256 shares) {\n        if (total.amount == 0) {\n            shares = amount;\n        } else {\n            shares = (amount * total.shares) / total.amount;\n            if (roundUp && (shares * total.amount) / total.shares < amount) {\n                shares = shares + 1;\n            }\n        }\n    }\n\n    /// @notice Calculates the amount value in relationship to `shares` and `total`\n    /// @dev Given a number of shares, returns the appropriate amount\n    function toAmount(\n        VaultAccount memory total,\n        uint256 shares,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        if (total.shares == 0) {\n            amount = shares;\n        } else {\n            amount = (shares * total.amount) / total.shares;\n            if (roundUp && (amount * total.shares) / total.amount < shares) {\n                amount = amount + 1;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/instrumentAssetOracleLib.sol": {
      "content": ""
    },
    "contracts/libraries/lendingOracleLib.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Controller} from \"../protocol/controller.sol\"; \nimport {Vault} from \"../vaults/vault.sol\"; \nimport  \"../global/types.sol\"; \nimport {Instrument} from \"../vaults/instrument.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\t\n/// @notice use managers to price risk of colalterals \nlibrary CollateralPricer{\n\tusing FixedPointMathLib for uint256; \n\n\tuint256 public constant BASE_UNIT = 1e18; \n\n\t/// @notice needs to be updated whenver BEFORE utilization rate is updated \n\t/// returns new LTV after utilization rate has been updated \n \tfunction storeNewLTV(\n \t\tPoolPricingParam storage _self,  \n \t\tuint256 uRate\n \t\t) internal returns(uint256){\n\n\t    uint256 accruedMax; \n\n\t    if(_self.prevURate> _self.urateUpper) \n\t    \taccruedMax = (BASE_UNIT - _self.incrementRate).rpow(block.timestamp - _self.prevAccrueTime, BASE_UNIT); \n\t    else if(_self.prevURate < _self.urateLower)\n\t    \taccruedMax = (BASE_UNIT + _self.incrementRate).rpow(block.timestamp - _self.prevAccrueTime, BASE_UNIT); \n\t    else accruedMax = BASE_UNIT; \n\n\t    _self.maxBorrowable = _self.maxBorrowable.mulWadDown(accruedMax); \n\t    _self.prevAccrueTime = block.timestamp; \n\t    _self.prevURate = uRate; \n\n\t    return _self.maxBorrowable; \n\t}\n\n\n\n\n\n}"
    },
    "contracts/libraries/pricerLib.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Controller} from \"../protocol/controller.sol\"; \nimport {Vault} from \"../vaults/vault.sol\"; \nimport  \"../global/types.sol\"; \nimport {Instrument} from \"../vaults/instrument.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\nlibrary PerpTranchePricer{\n    using FixedPointMathLib for uint256;\n    using PerpTranchePricer for PricingInfo; \n    uint256 constant BASE_UNIT = 1e18; \n\tuint256 constant BASE_MULTIPLIER = 5284965330; //10% at 60% util rate \n\n\tfunction setNewPrices(\n\t\tPricingInfo storage _self, \n\t\tuint256 psu,\n\t\tuint256 multiplier, \n\t\tuint256 id, \n\t\tbool constantRF\n\t\t) internal {\n\t\t_self.psu = psu; \n\t\t_self.URATE_MULTIPLIER = multiplier;  \n\t\t_self.ID = id; \n\t\t_self.constantRF = constantRF; \n\t}\n\n\tfunction setRF(PricingInfo storage _self, bool isConstant) internal{\n\t\t_self.constantRF = isConstant; \n\t}\n\n\t/// @notice needs to be updated whenver utilization rate is updated \n \tfunction storeNewPSU(\n \t\tPricingInfo storage _self, \n \t\tuint256 uRate\n \t\t) internal {\n\t    \n\t    // 1.00000003 ** x seconds\n\t    uint256 accruedPSU = (BASE_UNIT + _self.prevIntervalRp).rpow(block.timestamp - _self.prevAccrueTime, BASE_UNIT); \n\n\t    _self.psu = _self.psu.mulWadDown(accruedPSU); \n\t    _self.prevAccrueTime = block.timestamp; \n\t    _self.prevIntervalRp = uRateRpLinear(uRate, _self.URATE_MULTIPLIER); \n\t}\n\n\t/// @notice Get Promised return as function of uRate, 0<= uRate<= 1e18\n\tfunction uRateRpLinear(uint256 uRate, uint256 multiplier) internal pure returns(uint256){\n\t\treturn multiplier > 0? uRate.mulWadDown(multiplier) : uRate.mulWadDown(BASE_MULTIPLIER); \n\t}\n\n\t/// @notice can all seniors redeem for given psu \n\tfunction isSolvent(\n\t\taddress instrument, \n\t\tuint256 psu, \n\t\tuint256 juniorSupply, \n\t\tPoolData memory perp) public view returns(bool){\n\t\treturn(\n\t\t\tInstrument(instrument).assetOracle(juniorSupply + juniorSupply.mulWadDown(perp.leverageFactor))\n\t    \t .mulWadDown(perp.inceptionPrice)\n\t   \t\t>= psu.mulWadDown(juniorSupply.mulWadDown(perp.leverageFactor)) \n\t   \t); \n\t}\n\n\tfunction constantRF_PSU(\n\t\tuint256 inceptionPrice, \n\t\tuint256 promisedReturn, \n\t\tuint256 inceptionTime) public view returns(uint256){\n\t\treturn inceptionPrice.mulWadDown((BASE_UNIT+ promisedReturn).rpow(block.timestamp - inceptionTime, BASE_UNIT));\n\t}\n\n\tfunction refreshViewCurrentPricing(\n\t\tPricingInfo storage _self, \n\t\taddress instrument, \n\t\tuint256 uRate, \n\t\tuint256 juniorSupply, \n\t\tPoolData memory perp\n\t\t) public returns(uint256 psu, uint256 pju, uint256 levFactor){\n\t\t_self.storeNewPSU(uRate); \n\t\treturn viewCurrentPricing(_self, instrument, perp,juniorSupply ); \n\t}\n\n\tfunction viewCurrentPricing(\n\t\tPricingInfo memory _self,\n\t\taddress instrument, \n\t\tPoolData memory perp, \n\t\tuint256 juniorSupply\n\t\t) public view returns(uint256 psu, uint256 pju , uint256 levFactor ){\n\t    //TODO should not tick during assessment \n\t    localVars memory vars; \n\n\t    uint256 marketId = _self.ID; \n\t    levFactor = perp.leverageFactor; \n\t    require(perp.inceptionPrice > 0, \"0 price\"); \n\n\t    vars.seniorSupply = juniorSupply.mulWadDown(perp.leverageFactor); \n\t    vars.totalAssetsHeldScaled = Instrument(instrument).assetOracle(juniorSupply + vars.seniorSupply)\n\t    \t .mulWadDown(perp.inceptionPrice); \n\t    console.log('seniorsupply', vars.seniorSupply); \n\t    if (vars.seniorSupply == 0) return (_self.psu, _self.psu, levFactor); \t    \t\n\n\t\tif(_self.constantRF){\n\t\t\tpsu = perp.inceptionPrice.mulWadDown((BASE_UNIT+ perp.promisedReturn)\n    \t\t .rpow(block.timestamp - perp.inceptionTime, BASE_UNIT));\n\t\t\tconsole.log('psuhere', psu, perp.promisedReturn, block.timestamp); \n\t\t} else {\n\t\t\tpsu = _self.psu; \n\t\t}\n\n\t\t// Check if all seniors can redeem\n\t    if (vars.totalAssetsHeldScaled < psu.mulWadDown(vars.seniorSupply)){\n\t    \tpsu = vars.totalAssetsHeldScaled.divWadDown(vars.seniorSupply); \n\t    \tvars.belowThreshold = true; \n\t    }\n\t    console.log('psuhere', psu, block.timestamp); \n\t    // should be 0 otherwise \n\t    if(!vars.belowThreshold) pju = (vars.totalAssetsHeldScaled \n\t      - psu.mulWadDown(vars.seniorSupply)).divWadDown(juniorSupply); \n\n\t}\n\n  \n\n\tstruct localVars{\n\n\t    uint256 totalAssetsHeldScaled; \n\t    uint256 juniorSupply;\n\t    uint256 seniorSupply; \n\n\t    bool belowThreshold; \n\t}\n\n}\n\n"
    },
    "contracts/protocol/controller.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {Strings} from \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {VaultFactory} from \"./factories.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {config} from \"../utils/helpers.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {SyntheticZCBPoolFactory, ZCBFactory} from \"./factories.sol\";\nimport {ReputationManager} from \"./reputationmanager.sol\";\nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\";\nimport {LinearCurve} from \"../bonds/GBC.sol\"; \nimport {LeverageManager} from \"./leveragemanager.sol\"; \nimport {OrderManager} from \"./ordermanager.sol\"; \nimport {ValidatorManager} from \"./validatorManager.sol\";\n\nimport \"../global/GlobalStorage.sol\"; \nimport \"../global/types.sol\"; \nimport {PerpTranchePricer} from \"../libraries/pricerLib.sol\"; \n\ncontract Controller {\n    using SafeMath for uint256;\n    using FixedPointMathLib for uint256;\n    using PerpTranchePricer for PricingInfo; \n\n\n    ValidatorManager validatorManager;\n\n    mapping(uint256 => ApprovalData) approvalDatas;\n\n    function getApprovalData(uint256 marketId)\n        public\n        view\n        returns (ApprovalData memory data)\n    {\n        data = approvalDatas[marketId];\n    }\n\n    mapping(address => bool) public verified;\n    mapping(uint256 => MarketData) public market_data; // id => recipient\n    mapping(address => uint256) public ad_to_id; //utilizer address to marketId\n    mapping(uint256 => Vault) public vaults; // vault id to Vault contract\n    mapping(uint256 => uint256) public id_parent; //marketId-> vaultId\n    mapping(uint256 => uint256[]) public vault_to_marketIds;\n\n    address creator_address;\n\n    // IInterep interep;\n    MarketManager public marketManager;\n    VaultFactory public vaultFactory;\n    SyntheticZCBPoolFactory public poolFactory;\n    ReputationManager public reputationManager;\n    LeverageManager public leverageManager; \n    StorageHandler public Data; \n    OrderManager public orderManager; \n\n    /* ========== MODIFIERS ========== */\n    modifier onlyValidator(uint256 marketId) {\n        require(\n            isValidator(marketId, msg.sender) || msg.sender == creator_address,\n            \"!Val\"\n        );\n        _;\n    }\n\n    modifier onlyManager() {\n        require(\n            msg.sender == address(marketManager) \n            || msg.sender == address(leverageManager)\n            || msg.sender == address(orderManager)\n            || msg.sender == creator_address,\n            \"!manager\"\n        );\n        _;\n    }\n\n    constructor(\n        address _creator_address,\n        address _interep_address //TODO\n    ) {\n        creator_address = _creator_address;\n    }\n\n    /*----Setup Functions----*/\n\n    /**\n    abi.encode(\n        marketManager, \n        reputationManager, \n        validatorManager, \n        leverageManager, \n        orderManager,\n        vaultFactory,\n        poolFactory,\n        dataStore\n        )\n     */\n    function initialize(\n        bytes calldata _setup\n    ) external {\n        require(address(msg.sender) == address(creator_address));\n        (\n            address _marketManager,\n            address _reputationManager,\n            address _validatorManager,\n            address _leverageManager,\n            address _orderManager,\n            address _vaultFactory,\n            address _poolFactory,\n            address _dataStore\n        ) = abi.decode(_setup, (\n            address,\n            address,\n            address,\n            address,\n            address,\n            address,\n            address,\n            address\n        ));\n\n        marketManager = MarketManager(_marketManager);\n        reputationManager = ReputationManager(_reputationManager);\n        marketManager.setReputationManager(_reputationManager);\n        validatorManager = ValidatorManager(_validatorManager);\n        leverageManager = LeverageManager(_leverageManager); \n        marketManager.setLeverageManager(_leverageManager); \n        orderManager = OrderManager(_orderManager);\n        vaultFactory = VaultFactory(_vaultFactory);\n        poolFactory = SyntheticZCBPoolFactory(_poolFactory);\n        Data = StorageHandler(_dataStore); \n        marketManager.setDataStore( _dataStore); \n        reputationManager.setDataStore( _dataStore);\n        leverageManager.setDataStore(_dataStore);\n        orderManager.setDataStore(_dataStore); \n    }\n\n    // function setMarketManager(address _marketManager) public onlyManager {\n    //     require(_marketManager != address(0));\n    //     marketManager = MarketManager(_marketManager);\n        \n    // }\n\n    // function setReputationManager(address _reputationManager)\n    //     public\n    //     onlyManager\n    // {   require(address(marketManager)!= address(0), \"0mm\"); \n    //     reputationManager = ReputationManager(_reputationManager);\n    //     marketManager.setReputationManager(_reputationManager); \n    // }\n\n    // function setValidatorManager(address _validatorManager) public onlyManager {\n    //     validatorManager = ValidatorManager(_validatorManager);\n    // }\n\n    // function setLeverageManager(address _leverageManager) public onlyManager{\n    //     leverageManager = LeverageManager(_leverageManager); \n    //     marketManager.setLeverageManager(_leverageManager); \n    // }\n\n    // function setOrderManager(address _orderManager) public onlyManager{\n    //     orderManager = OrderManager(_orderManager); \n    // }\n\n    // function setVaultFactory(address _vaultFactory) public onlyManager {\n    //     vaultFactory = VaultFactory(_vaultFactory);\n    // }\n\n    // function setPoolFactory(address _poolFactory) public onlyManager {\n    //     poolFactory = SyntheticZCBPoolFactory(_poolFactory);\n    // }\n    // function setDataStore(address _dataStore) public onlyManager{\n    //     Data = StorageHandler(_dataStore); \n    //     marketManager.setDataStore( _dataStore); \n    //     reputationManager.setDataStore( _dataStore);\n    //     leverageManager.setDataStore(_dataStore);\n    //     orderManager.setDataStore(_dataStore); \n\n    // }\n\n    // function storeNewPrices(uint256 marketId, uint256 multiplier, uint256 initPrice) public {\n    //     Data.setNewPricingInfo( marketId,  initPrice,  multiplier); \n    //     // data.PriceInfos(marketId).setNewPrices(initPrice, multiplier, marketId); \n    // }\n\n\n    // function verifyAddress(\n    //     uint256 nullifier_hash,\n    //     uint256 external_nullifier,\n    //     uint256[8] calldata proof\n    // ) external  {\n    //     require(!verified[msg.sender], \"address already verified\");\n    //     interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\n    //     verified[msg.sender] = true;\n    // }\n    // bool public selfVerify = true; \n    // function canSelfVerify() external {\n    //     require(msg.sender == creator_address, \"!auth\"); \n    //     selfVerify = !selfVerify; \n    // }\n\n    function verifyAddress(address who) external{\n        require(msg.sender == creator_address, \"!auth\"); \n        verified[who] = true;\n        reputationManager.setTraderScore(who, 1e18); \n    }\n\n\n    // function testVerifyAddress() external {\n    //     require(selfVerify, \"!selfVerify\"); \n    //     verified[msg.sender] = true;\n    //     reputationManager.setTraderScore(msg.sender, 1e18); \n    // }\n\n    event RedeemTransfer(uint256 indexed marketId, uint256 amount, address to);\n\n\n    event VaultCreated(address indexed vault, uint256 vaultId, address underlying, bool onlyVerified, uint256 r, uint256 assetLimit, uint256 totalAssetLimit, MarketParameters defaultParams);\n    /// @notice creates vault\n    /// @param underlying: underlying asset for vault\n    /// @param _onlyVerified: only verified users can mint shares\n    /// @param _r: minimum reputation score to mint shares\n    /// @param _asset_limit: max number of shares for a single address\n    /// @param _total_asset_limit: max number of shares for entire vault\n    /// @param default_params: default params for markets created by vault\n    function createVault(\n        address underlying,\n        bool _onlyVerified,\n        uint256 _r,\n        uint256 _asset_limit,\n        uint256 _total_asset_limit,\n        MarketParameters memory default_params,\n        string calldata _description\n    ) public {\n        (Vault newVault, uint256 vaultId) = vaultFactory.newVault(\n            underlying,\n            address(this),\n            abi.encode(_onlyVerified, _r, _asset_limit, _total_asset_limit,_description),\n            default_params  \n        );\n\n        vaults[vaultId] = newVault;\n\n        emit VaultCreated(address(newVault), vaultId, underlying, _onlyVerified, _r, _asset_limit, _total_asset_limit, default_params);\n    }\n\n    function getInstrumentSnapShot(uint256 marketId) view public returns (uint256 managerStake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) {\n        CoreMarketData memory data = marketManager.getMarket(marketId); \n        ApprovalData memory approvalData = getApprovalData(marketId); \n        InstrumentData memory instrumentData = getVault(marketId).fetchInstrumentData(marketId);\n        managerStake = approvalData.managers_stake;\n        exposurePercentage = (approvalData.approved_principal- approvalData.managers_stake).divWadDown(getVault(marketId).totalAssets()+1);\n        seniorAPR = instrumentData.poolData.promisedReturn; \n        approvalPrice = instrumentData.poolData.inceptionPrice; \n\n        if(!instrumentData.isPool){\n            uint256 amountDelta;\n            uint256 resultPrice;\n\n            if(approvalData.managers_stake>0){\n                ( amountDelta,  resultPrice) = LinearCurve.amountOutGivenIn(\n                approvalData.managers_stake,\n                0, \n                data.bondPool.a_initial(), \n                data.bondPool.b(), \n                true \n                );\n            }\n            \n            uint256 seniorYield = instrumentData.faceValue -amountDelta\n                - (instrumentData.principal - approvalData.managers_stake); \n\n            seniorAPR = approvalData.approved_principal>0\n                ? seniorYield.divWadDown(1+instrumentData.principal - approvalData.managers_stake)\n                : 0; \n            approvalPrice = resultPrice; \n        }\n    }\n\n    function getVaultSnapShot(uint256 vaultId) view external returns (uint256 totalProtection, uint256 totalEstimatedAPR, uint256 goalAPR, uint256 exchangeRate) {\n        uint256[] memory marketIds = vault_to_marketIds[vaultId];\n        for (uint256 i = 0; i < marketIds.length; i++) {\n            (,uint256 exposurePercentage, uint256 seniorAPR,) = getInstrumentSnapShot(marketIds[i]);\n            totalEstimatedAPR += exposurePercentage.mulWadDown(seniorAPR);\n            totalProtection += marketManager.loggedCollaterals(marketIds[i]);\n        }\n\n        Vault vault = vaults[vaultId];\n\n        uint256 goalUtilizationRate = 9e17; //90% utilization goal? \n        if(vault.utilizationRate() <= goalUtilizationRate)\n         goalAPR = (goalUtilizationRate.divWadDown(1+vault.utilizationRate())).mulWadDown(totalEstimatedAPR); \n        else goalAPR = totalEstimatedAPR;\n\n        exchangeRate = vault.previewDeposit(1e18);\n    }\n\n    event MarketInitiated(uint256 indexed marketId, address indexed vault, address indexed recipient, address pool, address longZCB, address shortZCB, InstrumentData instrumentData);\n\n    /// @notice initiates market, called by frontend loan proposal or instrument form submit button.\n    /// @dev Instrument should already be deployed\n    /// @param recipient: utilizer for the associated instrument\n    /// @param instrumentData: instrument arguments\n    /// @param vaultId: vault identifier\n    function initiateMarket(\n        address recipient,\n        InstrumentData memory instrumentData,\n        uint256 vaultId\n    ) external returns(uint256){\n        require(recipient != address(0), \"address0R\");\n        require(instrumentData.instrument_address != address(0), \"address0I\");\n        require(address(vaults[vaultId]) != address(0), \"address0V\");\n\n        Vault vault = vaults[vaultId];\n        uint256 marketId = marketManager.marketCount();\n        id_parent[marketId] = vaultId;\n        vault_to_marketIds[vaultId].push(marketId);\n        market_data[marketId] = MarketData(\n            instrumentData.instrument_address,\n            recipient\n        );\n        marketManager.setParameters(\n            vault.get_vault_params(),\n            vault.utilizationRate(),\n            marketId\n        ); //TODO non-default\n\n        // Create new pool and bonds and store initial price and liquidity for the pool\n        (address longZCB, address shortZCB, SyntheticZCBPool pool) = poolFactory\n            .newPool(\n                address(vaults[vaultId].UNDERLYING()),\n                address(marketManager)\n            );\n\n        CoreMarketData memory marketData; \n        if (instrumentData.isPool) {\n          require(instrumentData.poolData.initPrice<= 1e18 \n            && instrumentData.poolData.initPrice< instrumentData.poolData.inceptionPrice, \"inceptionPrice<=initPrice\"); \n          require(instrumentData.poolData.promisedReturn>0, \"RETURN ERR\"); \n          instrumentData.poolData.inceptionTime = block.timestamp;\n\n          instrumentData.poolData.managementFee = pool\n            .calculateInitCurveParamsPool(\n                instrumentData.poolData.saleAmount,\n                instrumentData.poolData.initPrice,\n                instrumentData.poolData.inceptionPrice,\n                marketManager.getParameters(marketId).sigma\n            );\n\n            marketManager.newMarket(\n            marketId,\n            pool,\n            longZCB,\n            shortZCB,\n            instrumentData.description,\n            true\n            );\n            marketData = CoreMarketData(\n                pool,\n                ERC20(longZCB),\n                ERC20(shortZCB),\n                instrumentData.description,\n                block.timestamp, \n                0, \n                true\n            ); \n\n          // set validators\n          validatorManager.validatorSetup(\n            marketId,\n            instrumentData.poolData.saleAmount,\n            instrumentData.isPool\n        );\n        } else {\n            MarketParameters memory params = marketManager.getParameters(marketId); \n            pool.calculateInitCurveParams(\n                instrumentData.principal,\n                instrumentData.expectedYield,\n                params.sigma, \n                params.alpha, \n                params.delta\n            );\n\n            marketManager.newMarket(\n                marketId,\n                pool,\n                longZCB,\n                shortZCB,\n                instrumentData.description,\n                false\n            );         \n            marketData = CoreMarketData(\n                pool,\n                ERC20(longZCB),\n                ERC20(shortZCB),\n                instrumentData.description,\n                block.timestamp, \n                0, \n                false\n            ); \n\n            // set validators\n            validatorManager.validatorSetup(\n                marketId,\n                instrumentData.principal,\n                instrumentData.isPool\n            );\n        }\n        // Data.storeNewMarket(marketData); \n        Data.setNewInstrument(\n         Data.storeNewMarket(marketData), \n         instrumentData.poolData.inceptionPrice, \n         0, //TODO configurable \n         true, \n         instrumentData, \n         marketData); // TODO more params \n\n        // add vault proposal\n        instrumentData.marketId = marketId;\n        vault.addProposal(instrumentData);\n\n        emit MarketInitiated(marketId, address(vaults[vaultId]), recipient, address(pool), longZCB, shortZCB, instrumentData);\n\n        ad_to_id[recipient] = marketId; //only for testing purposes, one utilizer should be able to create multiple markets\n        return marketId; \n    }\n\n    /// @notice Resolve function 1\n    /// @dev Prepare market/instrument for closing, called separately before resolveMarket\n    /// this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest\n    /// or, in the event of a default, by validators who deem the principal recouperation is finished\n    /// and need to collect remaining funds by redeeming ZCB\n    function beforeResolve(uint256 marketId) external //onlyValidator(marketId)\n    {\n        (bool duringMarketAssessment, , , bool alive, , ) = marketManager\n            .restriction_data(marketId);\n        require(!duringMarketAssessment && alive, \"market conditions not met\");\n        require(\n            resolveCondition(marketId),\n            \"not enough validators have voted to resolve\"\n        );\n        vaults[id_parent[marketId]].beforeResolve(marketId);\n    }\n\n    event MarketResolved(uint256 indexed marketId, bool atLoss, uint256 extraGain, uint256 principalLoss, bool premature);\n\n    /// Resolve function 2\n    /// @notice main function called at maturity OR premature resolve of instrument(from early default)\n    /// @dev validators call this function from market manager\n    /// any funds left for the instrument, irrespective of whether it is in profit or inloss.\n    function resolveMarket(uint256 marketId) external onlyValidator(marketId) {\n        (\n            bool atLoss,\n            uint256 extra_gain,\n            uint256 principal_loss,\n            bool premature\n        ) = getVault(marketId).resolveInstrument(marketId);\n        // TODO updating if only market is pool. \n        updateRedemptionPrice(\n            marketId,\n            atLoss,\n            extra_gain,\n            principal_loss,\n            premature\n        );\n        validatorManager.updateValidatorStake(\n            marketId,\n            approvalDatas[marketId].approved_principal,\n            principal_loss\n        );\n\n        // Send all funds from the AMM to here, used for\n        cleanUpDust(marketId);\n\n        emit MarketResolved(marketId, atLoss, extra_gain, principal_loss, premature);\n    }\n\n    /// @dev Redemption price, as calculated (only once) at maturity for fixed term instruments,\n    /// depends on total_repayed/(principal + predetermined yield)\n    /// If total_repayed = 0, redemption price is 0\n    /// @param atLoss: defines circumstances where expected returns are higher than actual\n    /// @param loss: facevalue - returned amount => non-negative always?\n    /// @param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\n    function updateRedemptionPrice(\n        uint256 marketId,\n        bool atLoss,\n        uint256 extra_gain,\n        uint256 loss,\n        bool premature\n    ) internal {\n  \n        if (atLoss) assert(extra_gain == 0);\n\n        uint256 total_supply = marketManager.getZCB(marketId).totalSupply();\n        uint256 total_shorts = marketManager.getShortZCB(marketId).totalSupply(); \n\n        uint256 redemption_price;\n        if(premature && extra_gain>0){\n            redemption_price = calcIncompleteReturns(marketId, extra_gain); \n        } else{\n            if (!atLoss)\n                redemption_price = config.WAD +extra_gain.divWadDown(total_supply + total_shorts);\n            else {\n                if (config.WAD <= loss.divWadDown(total_supply)) {\n                    redemption_price = 0;\n                } else {\n                    redemption_price = config.WAD - loss.divWadDown(total_supply);\n                }\n            }\n        }\n\n        // Get funds used for redemption\n        getVault(marketId).trusted_transfer((total_supply - total_shorts).mulWadDown(redemption_price), \n            address(this)); \n\n        marketManager.deactivateMarket(\n            marketId,\n            atLoss,\n            !premature,\n            redemption_price\n        );\n    }\n\n    uint256 constant leverageFactor = 3e18; \n    /// @notice redeeming function for fixed instruements that did not pay off at maturity\n    function calcIncompleteReturns(\n        uint256 marketId, \n        uint256 incompleteReturns\n        ) public view returns(uint256 seniorReturn){\n        uint256 totalJuniorCollateral = marketManager.loggedCollaterals(marketId); \n        uint256 principal = getVault(marketId).fetchInstrumentData(marketId).principal; \n\n        seniorReturn = principal.mulWadDown(incompleteReturns).divWadDown(\n          leverageFactor.mulWadDown(totalJuniorCollateral) + principal - totalJuniorCollateral); \n    }\n\n\n\n    /// @notice function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast\n    /// or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc.\n    /// After, the resolveMarket function should be called in a new block\n    /// @dev withdraws all balance from the instrument.\n    /// If assets in instrument is not in underlying, need all balances to be divested to underlying\n    /// Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\n    /// @param emergency ascribes cases where the instrument should be forcefully liquidated back to the vault\n    function forceCloseInstrument(uint256 marketId, bool emergency)\n        external\n        returns (bool)\n    {\n        Vault vault = vaults[id_parent[marketId]];\n\n        // Prepare for close\n        vault.closeInstrument(marketId);\n\n        // Harvests/records all profit & losses\n        vault.beforeResolve(marketId);\n        return true;\n    }\n\n    /// @notice returns true if amount bought is greater than the insurance threshold\n    function marketCondition(uint256 marketId) public view returns (bool) {\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\n\n        // TODO add vault balances as well \n        if (isPool) {\n              console.log('marketcondition', marketManager.loggedCollaterals(marketId), \n               getVault(marketId)\n                    .fetchInstrumentData(marketId)\n                    .poolData\n                    .saleAmount); \n\n            return (marketManager.loggedCollaterals(marketId) >=\n                    Data.getInstrumentData(marketId)\n                    .poolData\n                    .saleAmount);\n  \n        } else {\n            uint256 principal = getVault(marketId)\n                .fetchInstrumentData(marketId)\n                .principal;\n                console.log('marketcondition', marketManager.loggedCollaterals(marketId), \n                principal.mulWadDown(\n                    marketManager.getParameters(marketId).alpha\n                )); \n            return (marketManager.loggedCollaterals(marketId) >=\n                principal.mulWadDown(\n                    marketManager.getParameters(marketId).alpha\n                ));\n        }\n    }\n\n    /// Approve without validators \n    // function testApproveMarket(uint256 marketId) external {\n    //     require(msg.sender == creator_address, \"!owner\");\n    //     require(marketCondition(marketId), \"market condition not met\");\n    //     approveMarket(marketId); \n    // }\n\n    event MarketApproved(uint256 indexed marketId, ApprovalData data);\n\n    /// @notice called by the validator from validatorApprove when market conditions are met\n    /// need to move the collateral in the wCollateral to\n    function approveMarket(uint256 marketId) public {\n        require(msg.sender == address(validatorManager) || msg.sender == creator_address, \"!validator\");\n        Vault vault = vaults[id_parent[marketId]];\n        SyntheticZCBPool pool = marketManager.getPool(marketId);\n\n        require(marketManager.getCurrentMarketPhase(marketId) == 3, \"!marketCondition\");\n        require(vault.instrumentApprovalCondition(marketId),\"!instrumentCondition\");\n        marketManager.approveMarket(marketId);\n\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\n        uint256 managerCollateral = marketManager.loggedCollaterals(marketId);\n        console.log(\"managerCollateral: \", managerCollateral, pool.baseBal());\n        console.log('?????', Data.getMarket(marketId).longZCB.totalSupply()-Data.getMarket(marketId).shortZCB.totalSupply()); \n\n        pool.flush(address(this), pool.baseBal()); \n        address instrument = address(vault.fetchInstrument(marketId)); \n        vault.UNDERLYING().approve(instrument, managerCollateral); \n\n        if (isPool) {\n            poolApproval(\n                marketId,\n                marketManager.getZCB(marketId).totalSupply(),\n                vault.fetchInstrumentData(marketId).poolData\n            );\n          require(ERC4626(instrument).deposit(managerCollateral, address(vault))>0, \"DEPOSIT_FAILED\");\n        } else {\n            if (vault.getInstrumentType(marketId) == 0) creditApproval(marketId, pool);\n            else generalApproval(marketId);\n            vault.UNDERLYING().transfer(instrument, managerCollateral); \n        }\n        approvalDatas[marketId].managers_stake = managerCollateral;\n\n        // TODO vault exchange rate should not change\n        // pull from pool to vault, which will be used to fund the instrument\n\n        // Trust and deposit to the instrument contract\n\n        vault.trustInstrument(marketId, approvalDatas[marketId], isPool);\n        \n        emit MarketApproved(marketId, approvalDatas[marketId]);\n    }\n\n    function poolApproval(\n        uint256 marketId,\n        uint256 juniorSupply,\n        PoolData memory data\n    ) internal {\n        require(data.leverageFactor > 0, \"0 LEV_FACTOR\");\n        approvalDatas[marketId] = ApprovalData(\n            0,\n            juniorSupply\n                .mulWadDown(config.WAD + data.leverageFactor)\n                .mulWadDown(data.inceptionPrice),\n            0\n        );\n\n    }\n\n    /// @notice receives necessary market information. Only applicable for creditlines\n    /// required for market approval such as max principal, quoted interest rate\n    function creditApproval(uint256 marketId, SyntheticZCBPool pool) internal {\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[id_parent[marketId]].viewPrincipalAndYield(marketId);\n\n        // get max_principal which is (s+1) * total long bought for creditline, or just be\n        // proposed principal for other instruments\n        uint256 max_principal = min(\n            (marketManager.getParameters(marketId).s + config.WAD).mulWadDown(\n                marketManager.loggedCollaterals(marketId)\n            ),\n            proposed_principal\n        );\n\n        // Required notional yield amount denominated in underlying  given credit determined by managers\n        uint256 quoted_interest = min(\n            pool.areaBetweenCurveAndMax(max_principal),\n            proposed_yield\n        );\n\n        approvalDatas[marketId] = ApprovalData(\n            0,\n            max_principal,\n            quoted_interest\n        );\n    }\n\n    function generalApproval(uint256 marketId) internal {\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\n            id_parent[marketId]\n        ].viewPrincipalAndYield(marketId);\n        approvalDatas[marketId] = ApprovalData(\n            0,\n            proposed_principal,\n            proposed_yield\n        );\n    }\n\n    event MarketDenied(uint256 indexed marketId);\n\n    function denyMarket(uint256 marketId) external onlyValidator(marketId) {\n        vaults[id_parent[marketId]].denyInstrument(marketId);\n        cleanUpDust(marketId);\n        marketManager.denyMarket(marketId);\n        emit MarketDenied(marketId);\n    }\n\n    /// @notice When market resolves, should collect remaining liquidity and/or dust from\n    /// the pool and send them back to the vault\n    /// @dev should be called before redeem_transfer is allowed\n    function cleanUpDust(uint256 marketId) internal {\n        marketManager.getPool(marketId).flush(address(this) , type(uint256).max);\n    }\n\n    function pullLeverage(uint256 marketId, uint256 amount) external onlyManager{\n        Vault vault = getVault(marketId); \n        vault.trusted_transfer(amount, msg.sender);\n        vault.modifyInstrumentHoldings(true, amount); \n    }\n    function pushLeverage(uint256 marketId, uint256 amount) external onlyManager{\n        Vault vault = getVault(marketId); \n        vault.UNDERLYING().transfer(address(vault), amount); \n        vault.modifyInstrumentHoldings(false, amount); \n    }\n\n    function returnLeverageCapital(uint256 marketId, uint256 amount) external  onlyValidator(marketId){\n\n    }// need to repay to vault everytime some is returned\n\n    function dustToVault(uint256 marketId, uint256 amount) external onlyValidator(marketId){\n        Vault vault = getVault(marketId);\n        vault.UNDERLYING().transfer(address(vault), amount); \n    }\n\n    /// @notice called only when redeeming, transfer funds from vault\n    function redeem_transfer(\n        uint256 amount,\n        address to,\n        uint256 marketId\n    ) external onlyManager {\n        getVault(marketId).UNDERLYING().transfer(to, amount); \n        emit RedeemTransfer(marketId, amount, to);\n    }\n\n    // function getValidatorPrice(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getValidatorPrice(marketId);\n    //     //return validator_data[marketId].avg_price;\n    // }\n\n    // function getValidatorCap(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getValidatorCap(marketId);\n    //     //return validator_data[marketId].val_cap;\n    // }\n\n    // function viewValidators(uint256 marketId)\n    //     public\n    //     view\n    //     returns (address[] memory)\n    // {\n    //     return validatorManager.viewValidators(marketId);\n    //     //return validator_data[marketId].validators;\n    // }\n\n    // function getNumApproved(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getNumApproved(marketId);\n    //     //return validator_data[marketId].numApproved;\n    // }\n\n    // function getNumResolved(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getNumResolved(marketId);\n    //     //return validator_data[marketId].numResolved;\n    // }\n\n    // function getTotalStaked(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getTotalStaked(marketId);\n    //     //return validator_data[marketId].totalStaked;\n    // }\n\n    // function getTotalValidatorSales(uint256 marketId)\n    //     public\n    //     view\n    //     returns (uint256)\n    // {\n    //     return validatorManager.getTotalValidatorSales(marketId);\n    //     //return validator_data[marketId].totalSales;\n    // }\n\n    // function getInitialStake(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getInitialStake(marketId);\n    //     //return validator_data[marketId].initialStake;\n    // }\n\n    // function getFinalStake(uint256 marketId) public view returns (uint256) {\n    //     return validatorManager.getFinalStake(marketId);\n    //     //return validator_data[marketId].finalStake;\n    // }\n\n\n    /**\n   @notice chainlink callback function, sets validators.\n   @dev TODO => can be called by anyone?\n   */\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords //internal\n    ) public //override\n    {\n        validatorManager.fulfillRandomWords(requestId, randomWords);\n        // uint256 marketId = requestToMarketId[requestId];\n        // (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n\n        // assert(randomWords.length == N);\n\n        // // address instrument = market_data[marketId].instrument_address;\n        // address utilizer = market_data[marketId].utilizer;\n\n        // address[] memory temp = reputationManager.filterTraders(r, utilizer);\n        // uint256 length = temp.length;\n\n        // // get validators\n        // for (uint8 i = 0; i < N; i++) {\n        //     uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\n        //     validator_data[marketId].validators.push(temp[j]);\n        //     temp[j] = temp[length - 1];\n        //     length--;\n        // }\n    }\n\n\n    /// @notice allows validators to buy at a discount + automatically stake a percentage of the principal\n    /// They can only buy a fixed amount of ZCB, usually a at lot larger amount\n    /// @dev get val_cap, the total amount of zcb for sale and each validators should buy\n    /// val_cap/num validators zcb\n    /// They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly\n    /// correlated instruments triggers controller.approveMarket\n    function validatorApprove(uint256 marketId) external returns (uint256) {\n        \n        (uint256 collateral_required, uint256 zcb_for_sale) = validatorManager.validatorApprove(marketId, msg.sender);\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\n        marketManager.validatorApprove(\n            marketId,\n            collateral_required,\n            zcb_for_sale,\n            msg.sender\n        );\n\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\n        if (approvalCondition(marketId)) {\n            approveMarket(marketId);\n            marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\n        }\n\n        return collateral_required;\n    }\n\n    /**\n   @notice conditions for approval => validator zcb stake fulfilled + validators have all approved\n   */\n    function approvalCondition(uint256 marketId) public view returns (bool) {\n        return validatorManager.approvalCondition(marketId);\n        // return (validator_data[marketId].totalSales >=\n        //     validator_data[marketId].val_cap &&\n        //     validator_data[marketId].validators.length ==\n        //     validator_data[marketId].numApproved);\n    }\n\n    /**\n   @notice returns true if user is validator for corresponding market\n   */\n    function isValidator(uint256 marketId, address user)\n        public\n        view\n        returns (bool)\n    {\n        return validatorManager.isValidator(marketId, user);\n    }\n\n    /**\n   @notice condition for resolving market, met when all the validators chosen for the market\n   have voted to resolve.\n   */\n    function resolveCondition(uint256 marketId) public view returns (bool) {\n        return validatorManager.resolveCondition(marketId);\n        // return (validator_data[marketId].numResolved ==\n        //     validator_data[marketId].validators.length);\n    }\n\n \n    function validatorResolve(uint256 marketId) external {\n        validatorManager.validatorResolve(marketId, msg.sender);\n        // require(isValidator(marketId, msg.sender), \"!val\");\n        // require(!validator_data[marketId].resolved[msg.sender], \"voted\");\n\n        // validator_data[marketId].resolved[msg.sender] = true;\n        // validator_data[marketId].numResolved++;\n    }\n\n \n    function unlockValidatorStake(uint256 marketId) external {\n        validatorManager.unlockValidatorStake(marketId, msg.sender);\n        // require(isValidator(marketId, msg.sender), \"!validator\");\n        // require(validator_data[marketId].staked[msg.sender], \"!stake\");\n        // (bool duringMarketAssessment, , , , , ) = marketManager\n        //     .restriction_data(marketId);\n\n        // // market early denial, no loss.\n        // ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\n        // if (duringMarketAssessment) {\n        //     ERC20(getVaultAd(marketId)).safeTransfer(\n        //         msg.sender,\n        //         validator_data[marketId].initialStake\n        //     );\n        //     validator_data[marketId].totalStaked -= validator_data[marketId]\n        //         .initialStake;\n        // } else {\n        //     // market resolved.\n        //     ERC20(getVaultAd(marketId)).safeTransfer(\n        //         msg.sender,\n        //         validator_data[marketId].finalStake\n        //     );\n        //     validator_data[marketId].totalStaked -= validator_data[marketId]\n        //         .finalStake;\n        // }\n\n        // validator_data[marketId].staked[msg.sender] = false;\n    }\n\n\n\n    function hasApproved(uint256 marketId, address validator)\n        public\n        view\n        returns (bool)\n    {\n        return validatorManager.hasApproved(marketId, validator);\n        // return validator_data[marketId].staked[validator];\n    }\n\n    /**\n   @notice called by marketManager.redeemDeniedMarket, redeems the discounted ZCB\n   */\n    function deniedValidator(uint256 marketId, address validator)\n        external\n        onlyManager\n        returns (uint256 collateral_amount)\n    {\n        collateral_amount = validatorManager.deniedValidator(\n            marketId,\n            validator\n        );\n        //??? is this correct\n        // collateral_amount = validator_data[marketId]\n        //     .sales[validator]\n        //     .mulWadDown(validator_data[marketId].avg_price);\n        // delete validator_data[marketId].sales[validator];\n    }\n\n    function redeemValidator(uint256 marketId, address validator)\n        external\n        onlyManager\n    {\n        validatorManager.redeemValidator(\n            marketId,\n            validator\n        );\n        //delete validator_data[marketId].sales[validator];\n    }\n\n    function getValidatorRequiredCollateral(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        return validatorManager.getValidatorRequiredCollateral(marketId);\n        // uint256 val_cap = validator_data[marketId].val_cap;\n        // (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\n        // uint256 zcb_for_sale = val_cap / N;\n        // return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\n    }\n\n    function getTraderScore(address trader) public view returns (uint256) {\n        return reputationManager.trader_scores(trader);\n    }\n\n    function isReputable(address trader, uint256 r) public view returns (bool) {\n      return reputationManager.isReputable(trader, r);\n    }\n\n\n    function getTotalSupply(uint256 marketId) external view returns (uint256) {\n        return marketManager.getZCB(marketId).totalSupply();\n    }\n\n    function getMarketId(address recipient) public view returns (uint256) {\n        return ad_to_id[recipient];\n    }\n\n    function getVault(uint256 marketId) public view returns (Vault) {\n        return vaults[id_parent[marketId]];\n    }\n\n    function getVaultAd(uint256 marketId) public view returns (address) {\n        return address(vaults[id_parent[marketId]]);\n    }\n\n    function isVerified(address addr) public view returns (bool) {\n        return verified[addr];\n    }\n\n    function getVaultfromId(uint256 vaultId) public view returns (address) {\n        return address(vaults[vaultId]);\n    }\n\n    function marketId_to_vaultId(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        return id_parent[marketId];\n    }\n\n    function marketIdToVaultId(uint256 marketId) public view returns (uint256) {\n        return id_parent[marketId];\n    }\n\n    function getMarketIds(uint256 vaultId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return vault_to_marketIds[vaultId];\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n"
    },
    "contracts/protocol/factories.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {Vault} from \"../vaults/vault.sol\";\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {Controller} from \"./controller.sol\";\nimport {oERC20} from \"../utils/ownedERC20.sol\"; \n\nimport \"../global/types.sol\"; \n\n/// @notice Anyone can create a vault. These can be users who  \n/// a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans)\n/// b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers)\n/// c) a vault for any long-tailed assets \n/// d) managers who wants leverage for yield opportunities on a specific asset \n/// e) uncollateralized lending platforms that wants to delegate the risk underwriting \n/// etc\n/// They need to specify \n/// 1. Vault mint conditions-> such as verified LPs(managers) only, \n/// 2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers)\n/// 3. Vault underlying \n/// @dev only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\n\ncontract VaultFactory{\n\n  address owner; \n  mapping(address=>bool) private _isVault; \n\n  uint256 public numVaults; \n  Controller controller; \n\n  constructor(address _controller){\n    owner = msg.sender; \n    controller = Controller(_controller);\n  }\n\n  function isVault(address v) external view returns(bool){\n    return _isVault[v]; \n  }\n\n  modifier onlyController(){\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \"is not controller\"); \n      _;\n  }\n\n  /**\n   @notice creates vault\n   @param underlying: underlying asset for vault\n   @param _controller: protocol controller\n   @param default_params: default params for markets created by vault\n   */\n  function newVault(\n    address underlying,\n    address _controller,\n    bytes memory _configData,\n    MarketParameters memory default_params\n  ) external onlyController returns(Vault, uint256) {\n    require(default_params.alpha >= 1e16, \"Alpha too small\"); \n    \n    Vault vault = new Vault(\n      underlying,\n       _controller,\n       owner, \n       //Params \n       _configData,\n       default_params\n       ); \n    _isVault[address(vault)] = true; \n    numVaults++;\n\n    return (vault, numVaults); \n    // vaultId is numVaults after new creation of the vault.\n\n  }\n}\n\ncontract ZCBFactory{\n    function newBond(\n        string memory name, \n        string memory description \n        ) public returns(address) {\n        oERC20 bondToken = new oERC20(name,description, 18);\n        return address(bondToken); \n    }\n}\n\ncontract SyntheticZCBPoolFactory{\n    address public immutable controller;\n    address public immutable zcbFactory; \n    constructor(address _controller, address _zcbFactory){\n        controller = _controller; \n        zcbFactory = _zcbFactory; \n    }\n\n    event PoolCreated(address pool, address longZCB, address shortZCB);\n\n    /// @notice param base is the collateral used in pool \n    function newPool(\n        address base, \n        address entry\n        ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\n        longZCB = ZCBFactory(zcbFactory).newBond(\"longZCB\", \"long\");\n        shortZCB = ZCBFactory(zcbFactory).newBond(\"shortZCB\", \"short\");\n\n        pool = new SyntheticZCBPool(\n            base, longZCB, shortZCB, entry, controller\n        ); \n        emit PoolCreated(address(pool), longZCB, shortZCB);\n    }\n}\n"
    },
    "contracts/protocol/leveragemanager.sol": {
      "content": "pragma solidity ^0.8.4; \n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\nimport  \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol\"; \nimport {Controller} from \"./controller.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\"; \n// import {PoolInstrument} from \"../instruments/oldpoolInstrument.sol\";\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {MarketManager} from \"./marketmanager.sol\"; \nimport {ReputationManager} from \"./reputationmanager.sol\"; \nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\"; \nimport {StorageHandler} from \"../global/GlobalStorage.sol\"; \nimport \"../global/types.sol\"; \n\n/// @notice borrow from leverageVault to leverage mint vaults\ncontract LeverageManager is ERC721Enumerable{\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n\n    uint256 constant precision =1e18; \n    Controller controller; \n    MarketManager marketManager; \n    ReputationManager reputationManager; \n  modifier _lock_() {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n    bool private _mutex; \n    constructor(\n        address controller_ad, \n        address marketManager_ad, \n        address reputationManager_ad\n        )ERC721Enumerable() ERC721(\"RAMM lv\", \"RammLV\") {\n        controller = Controller(controller_ad); \n        marketManager = MarketManager(marketManager_ad); \n        reputationManager = ReputationManager(reputationManager_ad); \n    }\n  modifier onlyController(){\n    require(address(controller) == msg.sender , \"!controller\"); \n    _;\n  }\n\n  StorageHandler public Data; \n  function setDataStore(address dataStore) public onlyController{\n    Data = StorageHandler(dataStore); \n  }\n    mapping(uint256=>mapping(address=> LeveredBond)) public leveragePosition; \n    struct LeveredBond{\n        uint256 debt; //how much collateral borrowed from vault \n        uint256 amount; // how much bonds were bought with the given leverage\n    }\n\n    struct LocalVars{\n        uint256 psu; \n        uint256 pju; \n        uint256 levFactor; \n        uint256 seniorAmount; \n        uint256 budget; \n\n        Vault vault; \n    }\n\n    function getPosition(uint256 marketId, address trader) public view returns(LeveredBond memory){\n        return leveragePosition[marketId][trader]; \n    }\n\n\n    /**\n    @dev amountIn -> vault underlying, amountOut -> longZCB.\n     */\n    event LeveredBondIssued(uint256 indexed marketId, address indexed trader, uint256 amountIn, uint256 amountOut, uint256 leverage, bool perpetual);\n    /// @notice issue longzcb to this contract, create note to for trader \n    function issuePerpBondLevered(\n        uint256 _marketId, \n        uint256 _amountIn, \n        uint256 _leverage\n        ) external returns(uint256 issueQTY){\n        require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= precision, \"!leverage\");\n\n        // need to require that !duringAssessment. \n\n        CoreMarketData memory market = marketManager.getMarket(_marketId); \n        ERC20 underlying = ERC20(address(market.bondPool.baseToken())); \n\n        // stack collateral from trader and loan from vault \n        uint256 amountPulled = _amountIn.divWadDown(_leverage); \n        marketManager.transferTraderCap(address(underlying), msg.sender, address(this), amountPulled); \n        // underlying.transferFrom(msg.sender, address(this), amountPulled); \n        controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n        underlying.approve(address(marketManager), _amountIn); \n        issueQTY = marketManager.issueBond(_marketId, _amountIn, address(this), msg.sender); \n\n        leveragePosition[_marketId][msg.sender].debt += (_amountIn - amountPulled); \n        leveragePosition[_marketId][msg.sender].amount += (issueQTY); \n\n        emit LeveredBondIssued(_marketId, msg.sender, _amountIn, issueQTY, _leverage, true);   \n    }\n\n\n    event LeveredBondRedeemed(uint256 indexed marketId, address indexed trader, uint256 redeemAmount, uint256 postRepayLeftOver, bool perpetual);\n    /// @notice redeem longzcb in this contract, send redeemed amount to vault\n    /// and if debt fully repaid, send remaining to trader \n    /// param redeemAmount is in longZCB \n    function redeemLeveredPerpLongZCB(\n        uint256 marketId,\n        uint256 redeemAmount\n        ) external  returns(\n            uint256 collateral_redeem_amount, \n            uint256 postRepayLeftOver, // underlying left that goes to trader.\n            uint256 paidDebt){\n        LocalVars memory vars; \n        vars.vault = controller.getVault(marketId); \n        LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n        require(position.amount>=redeemAmount, \"Amount ERR\"); \n\n        // Redeem longZCB in this address and get back collateral_redeem_amount to this address\n        /// Get back collateral, need to send repaid capital back to the vault \n        (collateral_redeem_amount, ) = \n            marketManager.redeemPerpLongZCB(marketId, redeemAmount, address(this), msg.sender); \n        vars.vault.UNDERLYING().transfer(address(vars.vault), collateral_redeem_amount); \n\n        // Need to first pay all of debt \n        if(position.debt > collateral_redeem_amount){\n            paidDebt = collateral_redeem_amount; \n            position.debt -= collateral_redeem_amount; \n        } else{\n            paidDebt = position.debt; \n            position.debt = 0 ; \n        }\n\n        unchecked{position.amount -= redeemAmount;}\n\n        // If debt is fully paid, can send unlocked funds \n        if (position.debt==0) {//100-70 = 30 send me back 30!!\n            postRepayLeftOver = collateral_redeem_amount - paidDebt; \n            vars.vault.withdrawFromPoolInstrument(marketId, postRepayLeftOver, msg.sender, 0); \n        }\n\n        leveragePosition[marketId][msg.sender] = position; \n\n        emit LeveredBondRedeemed(marketId, msg.sender, redeemAmount, postRepayLeftOver, true);\n    }\n\n    //event LeveredBondBuy(uint256 indexed marketId, address indexed trader, uint256 amountIn, uint256 amountOut, bool perpetual);\n\n    /// @notice for managers that are a) meet certain reputation threshold and b) choose to be more\n    /// capital efficient with their zcb purchase. \n    /// @param _amountIn (in collateral) already accounts for the leverage, so the actual amount manager is transferring\n    /// is _amountIn/_leverage \n    /// @dev the marketmanager should take custody of the quantity bought with leverage\n    /// and instead return notes of the levered position \n    function buyBondLevered(\n        uint256 _marketId, \n        uint256 _amountIn, \n        uint256 _priceLimit,\n        uint256 _leverage //in 18 dec \n        ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\n\n        // should not be able to call for perpetual market\n\n        require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= precision, \"!leverage\");\n        CoreMarketData memory market = marketManager.getMarket(_marketId); \n        ERC20 underlying = ERC20(address(market.bondPool.baseToken())); \n\n        // stack collateral from trader and borrowing from vault \n        uint256 amountPulled = _amountIn.divWadDown(_leverage); \n        marketManager.transferTraderCap(address(underlying), msg.sender, address(this), amountPulled); \n        controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n        // Buy bond to this address \n        bytes memory emptyByte; \n        underlying.approve(address(marketManager), _amountIn); \n        (amountIn, amountOut) = marketManager.buylongZCB(_marketId, int256(_amountIn),\n            _priceLimit, emptyByte, address(this), msg.sender);  \n   \n        // create note to trader \n        leveragePosition[_marketId][msg.sender].debt += (_amountIn - amountPulled); \n        leveragePosition[_marketId][msg.sender].amount += amountOut; \n\n        emit LeveredBondIssued(_marketId, msg.sender, _amountIn, amountOut, _leverage, false);\n    }\n\n    mapping(uint256=>mapping(address=> bool)) redeemed; \n\n    /// @notice redeem all longzcb holdings at maturity \n    function redeemLeveredBond(uint256 marketId) public{\n        require(marketManager.isMarketResolved( marketId), \"!resolved\"); \n        require(!redeemed[marketId][msg.sender], \"Redeemed\");\n        redeemed[marketId][msg.sender] = true; \n\n        if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender); \n\n        LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n        require(position.amount>0, \"0 Amount\"); \n\n        uint256 redemption_price = marketManager.redemption_prices(marketId); \n        uint256 collateral_back = redemption_price.mulWadDown(position.amount) ; \n        uint256 collateral_redeem_amount = collateral_back >= uint256(position.debt)  \n            ? collateral_back - uint256(position.debt) : 0; \n\n        if (!controller.isValidator(marketId, msg.sender)) {\n          reputationManager.recordPush(msg.sender, marketId, redemption_price, false, 0);\n        }\n        marketManager.burnAndTransfer(marketId, address(this), position.amount, msg.sender, collateral_redeem_amount); \n        controller.pushLeverage(marketId,  position.debt); \n\n        position.amount = 0; \n        position.debt = 0; \n        leveragePosition[marketId][msg.sender] = position;  \n\n        emit LeveredBondRedeemed(marketId, msg.sender, position.amount, 0, false);\n    }\n\n    event LeveredBondRedeemDenied(uint256 indexed marketId, address indexed trader);\n\n    function redeemDeniedLeveredBond(uint256 marketId) public returns(uint collateral_amount){\n        LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n        require(position.amount>0, \"ERR\"); \n        leveragePosition[marketId][msg.sender].amount = 0; \n\n        // TODO this means if trader's loss will be refunded if loss was realized before denied market\n        if (controller.isValidator(marketId, msg.sender)) {\n          collateral_amount = controller.deniedValidator(marketId, msg.sender);\n        }else{\n          collateral_amount = marketManager.longTrades(marketId, msg.sender);  \n          // delete longTrades[marketId][msg.sender]; \n        }\n\n        marketManager.burnAndTransfer(marketId, address(this), position.amount, msg.sender, collateral_amount); \n\n        emit LeveredBondRedeemDenied(marketId, msg.sender);\n    }\n\n    /// @notice returns the manager's maximum leverage \n    function getMaxLeverage(address manager) public view returns(uint256){\n        //TODO experiment \n        return 5e18 ;//min((controller.getTraderScore(manager) * 1e18).sqrt(), 5e18);\n    }\n    /// @notice called by pool when buying, transfers funds from trader to pool \n    function tradeCallBack(uint256 amount, bytes calldata data) external{\n        SyntheticZCBPool(msg.sender).baseToken().transferFrom(abi.decode(data, (address)), msg.sender, amount); \n    }\n\n\n\n\n    mapping(uint256=> Position) public positions; \n    mapping(uint256=> address)  leveragePools; \n\n    struct Position{\n        address vaultAd; \n        uint256 totalShares; \n\n        uint256 suppliedCapital; \n        uint256 borrowedCapital; \n\n        uint256 borrowTimeStamp;\n        uint256 endStateBalance; \n    }\n\n    function getPosition(uint256 tokenId) public view returns (Position memory position){\n        return positions[tokenId]; \n    }\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint176 private _nextId = 1;\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\n    uint80 private _nextPoolId = 1;\n\n    function addLeveragePool(uint256 vaultId, address pool) public \n    //onlyowner\n    {\n        leveragePools[vaultId] = pool; \n    }\n    /// @notice Allow people to borrow from leverageVault and use that to\n    /// create leveraged Vault positions \n    /// @dev steps\n    // 0. transfer to this address\n    // 1. mint vault to this address\n    // 2. borrow to this address,\n    // 3. mint new vault to this address \n    // 4. borrow new vault to this \n    function _mintWithLeverage(\n        uint256 vaultId, \n        uint256 availableLiquidity, \n        uint256 borrowAmount, \n        uint256 collateralAmount, \n        MintLocalVars memory vars) \n        internal{\n\n        // Check collateral specific borrowable \n        uint256 maxBorrowableAmount = min(borrowAmount, vars.collateralPower.mulWadDown(collateralAmount)); \n\n        // Check if liquidity available\n        vars.maxBorrowableAmount = min(maxBorrowableAmount, availableLiquidity); \n\n        // Depleted lendingpool if availableLiquidity < maxBorrowableAmount\n        vars.noMoreLiq = (vars.maxBorrowableAmount < maxBorrowableAmount); \n\n        vars.vault.approve(address(vars.leveragePool), collateralAmount); \n\n        vars.leveragePool.borrow(\n            vars.maxBorrowableAmount, address(vars.vault), \n            0, collateralAmount, address(this),\n            true\n            ); \n\n        console.log('new collateral amount', collateralAmount); \n        console.log('maxBorrowableAmount', vars.maxBorrowableAmount); \n\n        vars.shares = vars.vault.deposit(vars.maxBorrowableAmount, address(this));      \n    }\n\n    struct MintLocalVars{\n        Vault vault; \n        PoolInstrument leveragePool; \n\n        uint256 totalBorrowAmount; \n        uint256 maxBorrowAmount; \n        bool noMoreLiq; \n        uint256 shares; \n        uint256 mintedShares; \n        uint256 borrowedAmount; \n\n        uint256 availableLiquidity; \n        uint256 maxBorrowableAmount; \n        uint256 collateralPower; \n\n    }\n\n    function mintLev() public {\n        //1. borrow from child pool, \n        //2. if child pool has not enough liq, go to parent pool \n        //3. debt: 10 to child pool, 5 to parent pool or 15 to child pool\n        // or 15 to parent pool. First pay off parent pool, \n        // \n    }\n    /// @notice Implements a leverage loop \n    // TODO implement with flash minting, maybe more gas efficient \n    function mintWithLeverage(\n        uint256 vaultId, \n        uint256 suppliedCapital, \n        uint256 leverageFactor) public returns(uint256 tokenId, Position memory newPosition) {\n        MintLocalVars memory vars; \n        vars.vault = controller.vaults(vaultId); \n\n        ERC20 underlying = ERC20(address(vars.vault.UNDERLYING()));\n        underlying.transferFrom(msg.sender, address(this), suppliedCapital); \n        underlying.approve(address(vars.vault), suppliedCapital.mulWadDown(precision + leverageFactor)); \n\n        vars.leveragePool = PoolInstrument(leveragePools[vaultId]); \n        vars.availableLiquidity = vars.leveragePool.totalAssetAvailable(); \n\n        if(vars.availableLiquidity == 0) revert(\"Not Enough Liq\"); \n        (,,vars.collateralPower,,,,,) = vars.leveragePool.collateralConfigs(vars.leveragePool.computeId(address(vars.vault),0)); \n\n        // Initial minting \n        vars.shares = vars.vault.deposit(suppliedCapital, address(this));\n\n        // borrow until leverage is met, \n        vars.totalBorrowAmount = suppliedCapital.mulWadDown(leverageFactor); \n\n        while(true){\n            vars.mintedShares += vars.shares; \n            console.log('___NEW___'); \n            console.log('totalBorrowAmount', vars.borrowedAmount); \n            console.log('borrowedAmount Left', vars.totalBorrowAmount); \n            _mintWithLeverage( \n                vaultId, \n                vars.availableLiquidity, \n                vars.totalBorrowAmount, \n                vars.shares,\n                vars \n            ); \n\n            vars.borrowedAmount += vars.maxBorrowableAmount; \n\n            if(vars.totalBorrowAmount>= vars.maxBorrowableAmount)\n                (vars.totalBorrowAmount) -= vars.maxBorrowableAmount;\n\n            else vars.totalBorrowAmount = 0; \n\n            if(vars.totalBorrowAmount == 0 || vars.noMoreLiq) break; \n        }\n        vars.mintedShares += vars.shares; \n\n        _mint(msg.sender,  (tokenId = _nextId++)); \n\n        newPosition = Position(\n            address(vars.vault),\n            vars.mintedShares, \n            suppliedCapital, \n            vars.borrowedAmount, \n            block.timestamp, \n            vars.shares\n        );\n\n        positions[tokenId] = newPosition; \n\n\n\n    }\n\n    struct RewindLocalVars{\n        uint256 assetReturned; \n\n        uint256 withdrawAmount; \n        uint256 removed; \n        uint256 totalAssetReturned;\n        uint256 sharesRedeemed; \n\n    }\n\n    /// @notice Allows leverage minters to close their positions, and share profit with the leverageVault\n    /// @dev step goes 1. repay to instrument,  \n    function rewindPartialLeverage(\n        uint256 vaultId, \n        uint256 tokenId, \n        uint256 withdrawAmount) public{\n        //0. redeem \n        //1. repay to leverage pool\n        //2. get vault collateral back \n        //3. redeem\n        //4. repay to leverage pool \n        RewindLocalVars memory vars; \n\n        Position memory position = positions[tokenId]; \n        require(position.totalShares >= withdrawAmount, \"larger than position\"); \n\n        Vault vault = controller.vaults(vaultId); \n\n        ERC20 underlying = ERC20(address(vault.UNDERLYING())); \n        PoolInstrument leveragePool = PoolInstrument(leveragePools[vaultId]); \n        underlying.approve(address(leveragePool), vault.previewMint(withdrawAmount)); //TODO \n\n        vars.withdrawAmount = withdrawAmount; \n\n        // Begin with initial redeem \n\n\n        // vars.redeemedShares = position.endStateBalance; \n\n        while(vars.withdrawAmount!=0 ){\n            vars.sharesRedeemed = min(position.endStateBalance, vars.withdrawAmount); \n            vars.assetReturned = vault.redeem(\n                vars.sharesRedeemed, \n                address(this),\n                address(this)//70, 100=70, 80,30= 30\n                ); \n            // leveragePool.repayWithAmount(vars.assetReturned, address(this)); //70->80 toBorrowShares\n            leveragePool.repay(leveragePool.toBorrowShares(vars.assetReturned, true), address(this));\n            // get 70 collateral in, 30 collateral in, \n            \n            uint256 _maxBorrowableAmount = leveragePool.getMaxBorrow(address(this));\n            uint256 perUnitMaxBorrowAmount = leveragePool.getCollateralConfig(leveragePool.computeId(address(vault), tokenId)).maxBorrowAmount;\n        //check solvency\n            vars.removed = ((_maxBorrowableAmount -\n                leveragePool.toBorrowAmount(leveragePool.userBorrowShares(address(this)), true)) *\n                1e18) / perUnitMaxBorrowAmount;\n\n            leveragePool.removeCollateral(\n                 address(vault),\n                0,\n                vars.removed,\n                address(this),\n                false\n            ); \n            \n            // get 80 collateral out , 34 collateral out\n            console.log('___NEW___'); \n            console.log('withdraw left', vars.withdrawAmount); \n            console.log('redeemed shares',min(position.endStateBalance, vars.withdrawAmount) ); \n            console.log('redeemed/repayed', vars.assetReturned); \n            console.log('removed', vars.removed); \n\n            // Revert if err\n            vars.withdrawAmount -= vars.sharesRedeemed; \n\n            vars.totalAssetReturned += vars.assetReturned; \n\n            position.endStateBalance = position.endStateBalance >= vars.withdrawAmount\n                                        ? position.endStateBalance - vars.withdrawAmount + vars.removed \n                                        : vars.removed; \n            console.log('totalAssetReturned', vars.totalAssetReturned);                             \n            console.log('endStateBalance', position.endStateBalance); \n\n        }// how does this take care of losses? how does interest accrue? \n        position.totalShares -= withdrawAmount; \n\n        if(position.borrowedCapital >= vars.totalAssetReturned)\n            position.borrowedCapital -= vars.totalAssetReturned;\n\n        else {\n            position.borrowedCapital = 0; \n            // revert if withdraw amount was too large \n            position.suppliedCapital -= vars.totalAssetReturned - position.borrowedCapital; \n        }\n\n        positions[tokenId] = position; \n\n    }\n\n    function getTokenIds(address _owner) public view returns (uint[] memory) {\n        uint[] memory _tokensOfOwner = new uint[](balanceOf(_owner));\n        uint i;\n\n        for (i=0;i<balanceOf(_owner);i++){\n            _tokensOfOwner[i] =tokenOfOwnerByIndex(_owner, i);\n        }\n        return (_tokensOfOwner);\n    }\n\n    function getPositions(address _owner) public view returns(Position[] memory){\n        uint[] memory ids = getTokenIds(_owner); \n        Position[] memory openpositions = new Position[](ids.length); \n        for(uint i=0; i<ids.length; i++){\n            openpositions[i] = positions[ids[i]]; \n        }\n        return openpositions; \n    }\n\n// 60 c repay-> 70 v remove -> 70 v redeem-> 70c repay-> 80v remove -> 80v redeem \n// 70 + \n    /// @notice when debt is 0, user can claim their endstate balance \n    function deletePosition() public {\n\n    }\n\n\n    function viewPNL () public {}\n\n\n    function rewindFull()public{}\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function tokenURI(uint256 id) public view override returns (string memory){}\n\n\n}\n\n// function redeemLeveredPoolLongZCB(\n//         uint256 marketId, \n//         uint256 redeemAmount\n//         ) external  returns(\n//             uint256 collateral_redeem_amount, \n//             uint256 postRepayLeftOver, \n//             uint256 paidDebt){\n//         LocalVars memory vars; \n//         LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n//         require(position.amount>redeemAmount, \"Amount ERR\"); \n\n//         Vault vault = controller.getVault(marketId); \n//         MarketManager.CoreMarketData memory market = marketManager.getMarket(marketId); \n//         require(market.isPool, \"!pool\"); \n\n//         (vars.psu, vars.pju, vars.levFactor) = vault.poolZCBValue(marketId);\n//         collateral_redeem_amount = vars.pju.mulWadDown(redeemAmount); \n//         vars.seniorAmount= redeemAmount.mulWadDown(vars.levFactor).mulWadDown(vars.psu); \n\n//         // Need to check if redeemAmount*levFactor can be withdrawn from the pool. If so, do so. \n//         vault.withdrawFromPoolInstrument(marketId, collateral_redeem_amount, address(this), vars.seniorAmount); \n\n//         // Need to first pay all of debt \n//         if(position.debt > collateral_redeem_amount){\n//             paidDebt = position.debt - collateral_redeem_amount; \n//             position.debt -= collateral_redeem_amount; \n//         } else{\n//             paidDebt = position.debt; \n//             position.debt = 0 ; \n//         }\n\n//         position.amount -= redeemAmount; \n//         market.bondPool.trustedBurn(address(this), redeemAmount, true); \n\n//         if (position.debt==0) {\n//             postRepayLeftOver = collateral_redeem_amount - paidDebt; \n//             controller.redeem_transfer(postRepayLeftOver, msg.sender, marketId);\n//         }\n        \n//         // Update reputation \n//         reputationManager.recordPush(msg.sender, marketId, vars.pju, false, redeemAmount); \n//         leveragePosition[marketId][msg.sender] = position; \n//     }\n\n    // /// @notice issue bond to this address, and give trader note\n    // function issuePoolBondLevered(\n    //     uint256 _marketId, \n    //     uint256 _amountIn, \n    //     uint256 _leverage\n    //     ) external  returns(uint256 issueQTY){\n    //     LocalVars memory vars; \n    //     require(marketManager.isMarketApproved(_marketId), \"Pre Approval\"); \n    //     marketManager._canIssue(msg.sender, int256(_amountIn), _marketId); \n    //     MarketManager.CoreMarketData memory market = marketManager.getMarket(_marketId); \n\n    //     Vault vault = controller.getVault(_marketId); \n    //     ERC20 underlying = ERC20(address(market.bondPool.BaseToken())); \n    //     address instrument = address(vault.Instruments(_marketId)); \n\n    //     // stack collateral from trader and borrowing from vault \n    //     uint256 amountPulled = _amountIn.divWadDown(_leverage); \n    //     underlying.transferFrom(msg.sender, address(this), amountPulled); \n    //     controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n    //     // Get price and sell longZCB with this price\n    //     (vars.psu, vars.pju, vars.levFactor) = vault.poolZCBValue(_marketId);\n\n    //     underlying.approve(instrument, _amountIn); \n    //     ERC4626(instrument).deposit(_amountIn, address(vault)); \n\n    //     issueQTY = _amountIn.divWadUp(vars.pju); //TODO rounding errs\n    //     market.bondPool.trustedDiscountedMint(address(this), issueQTY); \n\n    //     // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu  \n    //     vault.depositIntoInstrument(_marketId, issueQTY.mulWadDown(1e18 + vars.levFactor).mulWadDown(vars.psu), true);\n\n    //     //TODO Need totalAssets and exchange rate to remain same assertion \n    //     //TODO vault always has to have more shares, all shares minted goes to vault \n    //     vars.budget = marketManager.getTraderBudget( _marketId, msg.sender); \n    //     reputationManager.recordPull(msg.sender, _marketId, issueQTY, _amountIn, vars.budget, true); \n    //     leveragePosition[_marketId][msg.sender] = LeveredBond(_amountIn - amountPulled , issueQTY) ;\n    // }\n\n\n"
    },
    "contracts/protocol/marketmanager.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport \"./reputationtoken.sol\";\nimport {Controller} from \"./controller.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {VRFConsumerBaseV2} from \"../chainlink/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"../chainlink/VRFCoordinatorV2Interface.sol\";\nimport {config} from \"../utils/helpers.sol\";\nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {ReputationManager} from \"./reputationmanager.sol\";\nimport {StorageHandler} from \"../global/GlobalStorage.sol\";\nimport {PerpTranchePricer} from \"../libraries/pricerLib.sol\";\n\nimport \"../global/types.sol\";\n\ncontract MarketManager {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n    using PerpTranchePricer for PricingInfo;\n\n    // Chainlink state variables\n    // VRFCoordinatorV2Interface COORDINATOR;\n    // uint64 private immutable subscriptionId;\n    // bytes32 private keyHash;\n    // uint32 private callbackGasLimit = 100000;\n    // uint16 private requestConfirmations = 3;\n    // uint256 total_validator_bought; // should be a mapping no?\n    bool private _mutex;\n\n    // ReputationNFT repToken;\n    Controller controller;\n    ReputationManager reputationManager;\n    CoreMarketData[] public markets;\n    address public owner;\n\n    // mapping(uint256 => uint256) requestToMarketId; // chainlink request id to marketId\n    // mapping(uint256 => ValidatorData) validator_data;\n    mapping(uint256 => uint256) public redemption_prices; //redemption price for each market, set when market resolves\n    // mapping(uint256=>mapping(address=>uint256)) private assessment_prices;\n    // mapping(uint256=>mapping(address=>bool)) private assessment_trader;\n    // mapping(uint256=>mapping(address=>uint256) ) public assessment_probs;\n    mapping(uint256 => MarketPhaseData) public restriction_data; // market ID => restriction data\n    mapping(uint256 => MarketParameters) public parameters; //marketId-> params\n    mapping(uint256 => mapping(address => bool)) private redeemed;\n    mapping(uint256 => mapping(address => uint256)) public longTrades;\n    mapping(uint256 => mapping(address => uint256)) public shortTrades;\n    mapping(uint256 => uint256) public loggedCollaterals;\n\n    modifier onlyController() {\n        require(\n            address(controller) == msg.sender ||\n                msg.sender == owner ||\n                msg.sender == address(this),\n            \"!controller\"\n        );\n        _;\n    }\n\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    constructor(\n        address _creator_address,\n        address _controllerAddress,\n        address _vrfCoordinator, // 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\n        bytes32 _keyHash, // 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\n        uint64 _subscriptionId // 1713,\n    ) //VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed)\n    {\n        controller = Controller(_controllerAddress);\n        // keyHash = bytes32(0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f);\n        // subscriptionId = 1713;\n        // COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);\n\n        // push empty market\n        markets.push(makeEmptyMarketData());\n\n        owner = msg.sender;\n    }\n\n    StorageHandler public Data;\n\n    function setDataStore(address dataStore) public onlyController {\n        Data = StorageHandler(dataStore);\n    }\n\n    //TODO setcontroller\n    function makeEmptyMarketData() public pure returns (CoreMarketData memory) {\n        return\n            CoreMarketData(\n                SyntheticZCBPool(address(0)),\n                ERC20(address(0)),\n                ERC20(address(0)),\n                \"\",\n                0,\n                0,\n                false\n            );\n    }\n\n    function marketCount() public view returns (uint256) {\n        return markets.length;\n    }\n\n    function getMarket(uint256 _id)\n        public\n        view\n        returns (CoreMarketData memory)\n    {\n        if (_id >= markets.length) {\n            return makeEmptyMarketData();\n        } else {\n            return markets[_id];\n        }\n    }\n\n    /// @notice parameters have to be set prior\n    // event MarketCreated(uint256 indexed marketId, address bondPool, address longZCB, address shortZCB, string description, bool isPool);\n\n    function newMarket(\n        uint256 marketId,\n        SyntheticZCBPool bondPool,\n        address _longZCB,\n        address _shortZCB,\n        string calldata _description,\n        // uint256 _duration,\n        bool isPool\n    ) external onlyController {\n        uint256 creationTimestamp = block.timestamp;\n\n        //emit MarketCreated(marketId, address(bondPool), _longZCB, _shortZCB, _description, isPool);\n\n        markets.push(\n            CoreMarketData(\n                bondPool,\n                ERC20(_longZCB),\n                ERC20(_shortZCB),\n                _description,\n                creationTimestamp,\n                0, //TODO resolution timestamp,\n                isPool\n            )\n        );\n\n        uint256 base_budget = 1000 * config.WAD; //TODO\n        setMarketPhase(marketId, true, true, base_budget);\n\n        // _validatorSetup(marketId, principal, creationTimestamp, _duration, isPool);\n    }\n\n    /*----Phase Functions----*/\n\n    event MarketParametersSet(\n        uint256 indexed marketId,\n        MarketParameters params\n    );\n\n    /// @notice list of parameters in this system for each market, should vary for each instrument\n    /// @dev calculates market driven s from utilization rate. If u-r high,  then s should be low, as 1) it disincentivizes\n    /// managers to approving as more proportion of the profit goes to the LP, and 2) disincentivizes the borrower\n    /// to borrow as it lowers approved principal and increases interest rate\n    function setParameters(\n        MarketParameters memory param,\n        uint256 utilizationRate,\n        uint256 marketId\n    ) public onlyController {\n        require(\n            param.N <= reputationManager.getTraders().length,\n            \"not enough rated traders\"\n        );\n        parameters[marketId] = param;\n        parameters[marketId].s = param.s.mulWadDown(\n            config.WAD - utilizationRate\n        ); // experiment\n        emit MarketParametersSet(marketId, param);\n    }\n\n    function setReputationManager(address _reputationManager)\n        external\n        onlyController\n    {\n        reputationManager = ReputationManager(_reputationManager);\n    }\n\n    address leverageManager_ad;\n\n    function setLeverageManager(address _leverageManager)\n        external\n        onlyController\n    {\n        leverageManager_ad = _leverageManager;\n    }\n\n    event MarketPhaseSet(uint256 indexed marketId, MarketPhaseData data);\n\n    /// @notice sets market phase data\n    /// @dev called on market initialization by controller\n    /// @param base_budget: base budget (amount of vault tokens to spend) as a market manager during the assessment stage\n    function setMarketPhase(\n        uint256 marketId,\n        bool duringAssessment,\n        bool _onlyReputable,\n        uint256 base_budget\n    ) internal {\n        MarketPhaseData storage data = restriction_data[marketId];\n        data.onlyReputable = _onlyReputable;\n        data.duringAssessment = duringAssessment;\n        // data.min_rep_score = calcMinRepScore(marketId);\n        data.base_budget = base_budget;\n        data.alive = true;\n        emit MarketPhaseSet(marketId, restriction_data[marketId]);\n    }\n\n    // event MarketReputationSet(uint256 indexed marketId, bool onlyReputable);\n\n    /// @notice used to transition from reputationphases\n    // function setReputationPhase(\n    //   uint256 marketId,\n    //   bool _onlyReputable\n    // ) public onlyController {\n    //   restriction_data[marketId].onlyReputable = _onlyReputable;\n    //   emit MarketReputationSet(marketId, _onlyReputable);\n    // }\n\n    event DeactivatedMarket(\n        uint256 indexed marketId,\n        bool atLoss,\n        bool resolve,\n        uint256 rp\n    );\n\n    /// @notice Called when market resolves\n    /// @param resolve is true when instrument does not resolve prematurely\n    function deactivateMarket(\n        uint256 marketId,\n        bool atLoss,\n        bool resolve,\n        uint256 rp\n    ) public onlyController {\n        restriction_data[marketId].resolved = resolve;\n        restriction_data[marketId].atLoss = atLoss;\n        restriction_data[marketId].alive = false;\n        redemption_prices[marketId] = rp;\n        emit DeactivatedMarket(marketId, atLoss, resolve, rp);\n    }\n\n    event MarketDenied(uint256 indexed marketId);\n\n    /// @notice called by validator only\n    function denyMarket(uint256 marketId) external onlyController {\n        //TODO should validators be able to deny even though they've approved.\n        require(restriction_data[marketId].duringAssessment, \"!assessment\");\n        MarketPhaseData storage data = restriction_data[marketId];\n        data.alive = false;\n        data.resolved = true;\n        emit MarketDenied(marketId);\n    }\n\n    event MarketApproved(uint256 indexed marketId);\n\n    /// @notice main approval function called by controller\n    /// @dev if market is alive and market is not during assessment, it is approved.\n    function approveMarket(uint256 marketId) external onlyController {\n        restriction_data[marketId].duringAssessment = false;\n        emit MarketApproved(marketId);\n    }\n\n    function getPhaseData(uint256 marketId)\n        public\n        view\n        returns (MarketPhaseData memory)\n    {\n        return restriction_data[marketId];\n    }\n\n    function isMarketResolved(uint256 marketId) public view returns (bool) {\n        return (!restriction_data[marketId].alive &&\n            restriction_data[marketId].resolved);\n    }\n\n    function isMarketApproved(uint256 marketId) public view returns (bool) {\n        return (!restriction_data[marketId].duringAssessment &&\n            restriction_data[marketId].alive);\n    }\n\n    /// @notice returns whether current market is in phase\n    /// 1: onlyReputable, which also means market is in assessment\n    /// 2: not onlyReputable but in asseessment\n    /// 3: in assessment but canbeapproved\n    /// 4: post assessment(accepted or denied), amortized liquidity\n    function getCurrentMarketPhase(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        if (restriction_data[marketId].onlyReputable) {\n            // assert(!controller.marketCondition(marketId) && !isMarketApproved(marketId) && restriction_data[marketId].duringAssessment );\n            return 1;\n        } else if (\n            restriction_data[marketId].duringAssessment &&\n            !restriction_data[marketId].onlyReputable\n        ) {\n            // assert(!isMarketApproved(marketId));\n            if (controller.marketCondition(marketId)) return 3;\n            return 2;\n        } else if (isMarketApproved(marketId)) {\n            // assert (!restriction_data[marketId].duringAssessment && controller.marketCondition(marketId));\n            return 4;\n        }\n    }\n\n    /// @notice get trade budget = f(reputation), returns in collateral_dec\n    /// sqrt for now\n    function getTraderBudget(uint256 marketId, address trader)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 repscore = reputationManager.trader_scores(trader);\n        if (repscore == 0) return 0;\n        return\n            restriction_data[marketId].base_budget.mulWadDown(\n                (repscore * config.WAD).sqrt()\n            );\n    }\n\n    function getParameters(uint256 marketId)\n        public\n        view\n        returns (MarketParameters memory)\n    {\n        return parameters[marketId];\n    }\n\n    function getPool(uint256 marketId) public view returns (SyntheticZCBPool) {\n        return markets[marketId].bondPool;\n    }\n\n    function getZCB(uint256 marketId) public view returns (ERC20) {\n        return markets[marketId].longZCB;\n    }\n\n    function getShortZCB(uint256 marketId) public view returns (ERC20) {\n        return markets[marketId].shortZCB;\n    }\n\n    /// @notice whether new longZCB can be issued\n    function _canIssue(\n        address trader,\n        int256 amount,\n        uint256 marketId,\n        uint256 budget\n    ) public view {\n        //TODO per market queue\n        //if(queuedRepUpdates[trader] > queuedRepThreshold)\n        //  revert(\"rep queue\");\n\n        // if (!controller.isVerified(trader))\n        //   revert(\"!verified\");\n\n        if (budget <= uint256(amount)) revert(\"budget\");//TODO do addition \n\n        if (controller.getTraderScore(trader) == 0) revert(\"!rep\");\n    }\n\n    /// @notice performs checks for buy function\n    /// @param amount: collateral used to buy ZCB.\n    function _canBuy(\n        address trader,\n        int256 amount,\n        uint256 marketId,\n        uint256 budget\n    ) public view {\n        //If after assessment there is a set buy threshold, people can't buy above this threshold\n        require(restriction_data[marketId].alive, \"!Active\");\n        // TODO: upper bound\n        // TODO: check if this is correct\n        // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \"market maturity reached\");\n        // TODO: check if enough liquidity\n        bool _duringMarketAssessment = restriction_data[marketId]\n            .duringAssessment;\n        bool _onlyReputable = restriction_data[marketId].onlyReputable;\n\n        if (amount > 0) {\n            if (_duringMarketAssessment) {\n                _canIssue(trader, amount, marketId, budget);\n            }\n        }\n\n        //During the early risk assessment phase only reputable can buy\n        if (_onlyReputable) {\n            if (!controller.isReputable(trader, parameters[marketId].r)) {\n                revert(\"insufficient rep\");\n            }\n        }\n    }\n\n    /// @notice amount is in zcb_amount_in TODO\n    function _canSell(\n        address trader,\n        uint256 amount,\n        uint256 marketId\n    ) public view returns (bool) {\n        require(restriction_data[marketId].alive, \"!Active\");\n        // TODO need to check amount is capped, and trader has enough vault locked\n        //TODO: check if this is correct\n        // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \"market maturity reached\");\n\n        // if(restriction_data[marketId].duringAssessment) {\n        //   // restrict attacking via disapproving the utilizer by just shorting a bunch\n        //  // if(amount>= hedgeAmount) return false;\n\n        //   //else return true;\n        // }\n        // else{\n        //   // restrict naked CDS amount\n\n        //   //\n        // }\n\n        return true;\n    }\n\n    // VALIDATOR FUNCTIONS\n\n    /**\n   @notice called when the validator votes to approve the market => stakes vt + recieves discounted ZCB\n   the staked amount goes to the controller while the discounted ZCB goes to the market manager.\n   */\n    function validatorApprove(\n        uint256 marketId,\n        uint256 collateral_required,\n        uint256 zcb_for_sale,\n        address validator\n    ) external onlyController {\n        loggedCollaterals[marketId] += collateral_required;\n        SyntheticZCBPool bondPool = getPool(marketId);\n        bondPool.baseToken().transferFrom(\n            validator,\n            address(bondPool),\n            collateral_required\n        );\n        bondPool.trustedDiscountedMint(validator, zcb_for_sale);\n    }\n\n    // event MarketCollateralUpdate(uint256 marketId, uint256 totalCollateral);\n    // event TraderCollateralUpdate(uint256 marketId, address manager, uint256 totalCollateral, bool isLong);\n\n    event TraderUpdate(\n        uint256 indexed marketId,\n        address trader,\n        uint256 totalCollateral,\n        bool isLong,\n        uint256 shortCollateral,\n        uint256 collateral,\n        bool isBuy\n    );\n\n    /// @notice log how much collateral trader has at stake,\n    /// to be used for redeeming, restricting trades\n    function _logTrades(\n        uint256 marketId,\n        address trader,\n        uint256 collateral,\n        uint256 shortCollateral,\n        bool isBuy,\n        bool isLong\n    ) internal {\n        if (isLong) {\n            // TODO queuerep needs to be per market\n            // If buying bond during assessment, trader is manager, so should update\n            if (isBuy) {\n                longTrades[marketId][trader] += collateral;\n                loggedCollaterals[marketId] += collateral;\n                queuedRepUpdates[trader] += 1;\n            } else {\n                longTrades[marketId][trader] -= collateral;\n                loggedCollaterals[marketId] -= collateral;\n            }\n        } else {\n            if (isBuy) {\n                // shortCollateral is amount trader pays to buy shortZCB\n                shortTrades[marketId][trader] += shortCollateral;\n                // collateral is the area under the curve that is subtracted due to the (short)selling\n                loggedCollaterals[marketId] -= collateral;\n            } else {\n                // revert if underflow, which means trader sold short at a profit, which is not allowed during assessment\n                shortTrades[marketId][trader] -= shortCollateral;\n                loggedCollaterals[marketId] += collateral;\n            }\n        }\n\n        emit TraderUpdate(\n            marketId,\n            trader,\n            loggedCollaterals[marketId],\n            isLong,\n            shortCollateral,\n            collateral,\n            isBuy\n        );\n    }\n\n    /// @notice general limitorder claim + liquidity provision funnels used post-assessment,\n    /// which will be recorded if necessary\n    /// param type: 1 if open long, 2 if close long, 3 if open short, 4 if close short\n    /// type 5: partially claim , TODO do all possible trading functions\n    function claimFunnel(\n        uint256 marketId,\n        uint16 point,\n        uint256 funnel\n    ) external returns (uint256 claimedAmount) {\n        SyntheticZCBPool bondPool = markets[marketId].bondPool;\n\n        // if (funnel == 1) claimedAmount = bondPool.makerClaimOpen(point,true, msg.sender);\n        // else if (funnel == 2) claimedAmount = bondPool.makerClaimClose(point,true, msg.sender);\n        // else if (funnel == 3) claimedAmount = bondPool.makerClaimOpen(point,false, msg.sender);\n        // else if (funnel == 4) claimedAmount = bondPool.makerClaimClose(point,false, msg.sender);\n    }\n\n    /// @notice called by pool when buying, transfers funds from trader to pool\n    function tradeCallBack(uint256 amount, bytes calldata data) external {\n        SyntheticZCBPool(msg.sender).baseToken().transferFrom(\n            abi.decode(data, (address)),\n            msg.sender,\n            amount\n        );\n    }\n\n    function issueBond(\n        uint256 _marketId,\n        uint256 _amountIn,\n        address _caller,\n        address trader\n        ) external returns (uint256 issueQTY) {\n        LocarVars memory vars;\n        require(\n            msg.sender == address(this) || msg.sender == leverageManager_ad,\n            \"invalid entry\"\n        );\n\n        // msg.sender == caller?\n        _canIssue(\n            trader,\n            int256(_amountIn),\n            _marketId,\n            getTraderBudget(_marketId, trader)\n        );\n\n        vars.vault = controller.getVault(_marketId);\n        vars.underlying = ERC20(\n            address(markets[_marketId].bondPool.baseToken())\n        );\n        vars.instrument = address(vars.vault.Instruments(_marketId));\n\n        // Get price a_lock_nd sell longZCB with this price\n        // (vars.psu, vars.pju, vars.levFactor ) = vars.vault.poolZCBValue(_marketId);\n        (vars.psu, vars.pju, vars.levFactor) = Data.viewCurrentPricing(_marketId);\n        vars.underlying.transferFrom(_caller, address(this), _amountIn);\n        vars.underlying.approve(vars.instrument, _amountIn);\n        ERC4626(vars.instrument).deposit(_amountIn, address(vars.vault));\n\n        issueQTY = _amountIn.divWadUp(vars.pju); //TODO rounding errs\n        markets[_marketId].bondPool.trustedDiscountedMint(_caller, issueQTY);\n        vars.seniorAmount = issueQTY.mulWadDown(vars.levFactor).mulWadDown(vars.psu);  \n\n        // Check if pju/psu is high enough, x/small pju will blow up senior amount \n        require(vars.pju.divWadDown(vars.psu) >= Constants.THRESHOLD_PJU, \"Low Junior Price\"); \n\n        // Check if vault has enough liquidity + buffer \n        console.log('senioramount', vars.seniorAmount, vars.vault.UNDERLYING().balanceOf(address(vars.vault)), \n          vars.vault.utilizationRateAfter(vars.seniorAmount) ); \n        console.log('util before after',vars.vault.utilizationRateAfter(0), \n            vars.vault.utilizationRateAfter(vars.seniorAmount)); \n        console.log('pju issue', vars.pju, vars.psu); \n\n        require(\n          vars.vault.utilizationRateAfter(vars.seniorAmount) \n          <= Constants.MAX_VAULT_URATE, \n          \"Not enough vault liquidity\"\n        ); \n\n        // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu\n        vars.vault.depositIntoInstrument(_marketId,vars.seniorAmount,true);\n\n        reputationManager.recordPull(\n            trader,\n            _marketId,\n            issueQTY,\n            _amountIn, \n            getTraderBudget(_marketId, trader),\n            true\n        );\n    }\n\n    /// @notice after assessment, let managers buy newly issued longZCB if the instrument is pool based\n    /// funds + funds * levFactor will be directed to the instrument\n    function issuePoolBond(uint256 _marketId, uint256 _amountIn)\n        external\n        _lock_\n        returns (uint256 issueQTY)\n    {\n        require(!restriction_data[_marketId].duringAssessment, \"Pre Approval\");\n\n        issueQTY = this.issueBond(_marketId, _amountIn, msg.sender, msg.sender);\n        //TODO Need totalAssets and exchange rate to remain same assertion\n        //TODO vault always has to have more shares, all shares minted goes to vault\n  \n    }\n\n    function redeemPerpLongZCB(\n        uint256 marketId,\n        uint256 redeemAmount,\n        address caller,\n        address trader\n    )\n        external\n        returns (uint256 collateral_redeem_amount, uint256 seniorAmount)\n    {\n        require(\n            msg.sender == address(this) || msg.sender == leverageManager_ad,\n            \"invalid entry\"\n        );\n        Vault vault = controller.getVault(marketId);\n        CoreMarketData memory market = markets[marketId];\n        LocarVars memory vars;\n\n        require(market.isPool, \"!pool\");\n\n        (vars.psu, vars.pju, vars.levFactor) = Data.viewCurrentPricing(\n            marketId\n        );\n        collateral_redeem_amount = vars.pju.mulWadDown(redeemAmount);\n        seniorAmount = redeemAmount.mulWadDown(vars.levFactor).mulWadDown(\n            vars.psu\n        );\n\n        // Need to check if redeemAmount*levFactor can be withdrawn from the pool and do so\n        vault.withdrawFromPoolInstrument(\n            marketId,\n            collateral_redeem_amount,\n            caller,\n            seniorAmount\n        );\n\n        market.bondPool.trustedBurn(caller, redeemAmount, true);\n\n        reputationManager.recordPush(\n            trader,\n            marketId,\n            vars.pju,\n            false,\n            redeemAmount\n        );\n\n        // TODO assert pju stays same\n        // TODO assert need totalAssets and exchange rate to remain same\n    }\n\n    function redeemPoolLongZCB(uint256 marketId, uint256 redeemAmount)\n        external\n        _lock_\n        returns (uint256 collateral_redeem_amount, uint256 seniorAmount)\n    {\n        (collateral_redeem_amount, seniorAmount) = this.redeemPerpLongZCB(\n            marketId,\n            redeemAmount,\n            msg.sender,\n            msg.sender\n        );\n    }\n\n    mapping(address => uint8) public queuedRepUpdates;\n    uint8 public constant queuedRepThreshold = 3; // at most 3 simultaneous assessment per manager\n\n    event BondBuy(\n        uint256 indexed marketId,\n        address indexed trader,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    struct LocarVars {\n        uint256 upperBound;\n        uint256 budget;\n        uint256 repThreshold;\n        uint256 pju;\n        uint256 psu;\n        uint256 levFactor;\n        uint256 seniorAmount; \n\n        Vault vault;\n        ERC20 underlying;\n        address instrument;\n        MarketPhaseData phaseData;\n    }\n\n    /// @notice main entry point for longZCB buys (during assessment for now), only during assessment\n    /// @param _amountIn is negative if specified in zcb quantity\n    function buyBond(\n        uint256 _marketId,\n        int256 _amountIn,\n        uint256 _priceLimit,\n        bytes calldata _tradeRequestData\n    ) external returns (uint256 amountIn, uint256 amountOut) {\n        (amountIn, amountOut) = this.buylongZCB(\n            _marketId,\n            _amountIn,\n            _priceLimit,\n            _tradeRequestData,\n            msg.sender,\n            msg.sender\n        );\n\n        emit BondBuy(_marketId, msg.sender, amountIn, amountOut); // get current price as well.\n    }\n\n    function buylongZCB(\n        uint256 _marketId,\n        int256 _amountIn,\n        uint256 _priceLimit,\n        bytes calldata _tradeRequestData,\n        address caller,\n        address trader\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut) {\n        require(\n            msg.sender == address(this) || msg.sender == leverageManager_ad,\n            \"invalid entry\"\n        );\n\n        LocarVars memory vars;\n        vars.phaseData = restriction_data[_marketId];\n\n        require(!vars.phaseData.resolved, \"not resolved\");\n        require(vars.phaseData.duringAssessment, \"only assessment\");\n\n        vars.budget = getTraderBudget(_marketId, trader);\n        _canBuy(trader, _amountIn, _marketId, vars.budget);\n\n        CoreMarketData memory marketData = markets[_marketId];\n        SyntheticZCBPool bondPool = marketData.bondPool;\n\n        // TODO fix pricelimit\n        (amountIn, amountOut) = bondPool.takerOpen(\n            true,\n            _amountIn,\n            _priceLimit,\n            abi.encode(caller)\n        );\n\n        // Revert if cross bound\n        vars.upperBound = bondPool.upperBound();\n        if (vars.upperBound != 0 && vars.upperBound < bondPool.getCurPrice())\n            revert(\"exceed bound\");\n\n        //Need to log assessment trades for updating reputation scores or returning collateral when market denied\n        _logTrades(_marketId, trader, amountIn, 0, true, true);\n\n        vars.budget = getTraderBudget(_marketId, trader);\n        reputationManager.recordPull(\n            trader,\n            _marketId,\n            amountOut,\n            amountIn,\n            vars.budget,\n            marketData.isPool\n        );\n\n        // Phase Transitions when conditions met\n        if (vars.phaseData.onlyReputable) {\n            vars.repThreshold = parameters[_marketId].omega.mulWadDown(\n                controller\n                    .getVault(_marketId)\n                    .fetchInstrumentData(_marketId)\n                    .principal\n            );\n\n            if (loggedCollaterals[_marketId] >= vars.repThreshold) {\n                restriction_data[_marketId].onlyReputable = false;\n                emit MarketPhaseSet(_marketId, restriction_data[_marketId]);\n            }\n        }\n    }\n\n    event BondShort(\n        uint256 indexed marketId,\n        address indexed trader,\n        uint256 amountMint,\n        uint256 amountIn\n    );\n\n    /// @param _amountIn: amount of short trader is willing to buy\n    /// @param _priceLimit: slippage tolerance on trade\n    function shortBond(\n        uint256 _marketId,\n        uint256 _amountIn,\n        uint256 _priceLimit,\n        bytes calldata _tradeRequestData\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut) {\n        require(\n            restriction_data[_marketId].duringAssessment,\n            \"only assessment\"\n        );\n        // require(_canSell(msg.sender, _amountIn, _marketId),\"Restricted\");\n\n        //TODO requirements: locked VT, amount only required to hedge\n        // amountIn is base collateral down the curve(under), amountOut is collateral used to buy shortZCB\n        (amountIn, amountOut) = markets[_marketId].bondPool.takerOpen(\n            false,\n            int256(_amountIn),\n            _priceLimit,\n            abi.encode(msg.sender)\n        );\n        _logTrades(_marketId, msg.sender, amountIn, amountIn, true, false);\n\n        emit BondShort(_marketId, msg.sender, _amountIn, amountIn);\n    }\n\n    event RedeemDenied(uint256 marketId, address trader, bool isLong);\n\n    /// @notice called by traders when market is denied before approval TODO\n    /// ??? if the market is denied, this function is called and everything is redeemed\n    /// validator will need to call this on denial + isLong = true to redeem their collateral.\n    function redeemDeniedMarket(uint256 marketId, bool isLong) external _lock_ {\n        require(\n            !restriction_data[marketId].alive,\n            \"Market Still During Assessment\"\n        ); // TODO\n        require(\n            restriction_data[marketId].duringAssessment,\n            \"Market has been approved\"\n        );\n        SyntheticZCBPool bondPool = markets[marketId].bondPool;\n\n        uint256 collateral_amount;\n        uint256 balance;\n        // Get collateral at stake in shorts, which will be directly given back to traders\n        if (!isLong) {\n            balance = markets[marketId].shortZCB.balanceOf(msg.sender);\n            require(balance >= 0, \"Empty\");\n\n            // TODO this means if trader's loss will be refunded if loss was realized before denied market\n            collateral_amount = shortTrades[marketId][msg.sender];\n            delete shortTrades[marketId][msg.sender];\n            emit RedeemDenied(marketId, msg.sender, false);\n\n            //Burn all their balance\n            bondPool.trustedBurn(msg.sender, balance, false);\n        }\n        // Get collateral at stake in longs, which will be directly given back to traders\n        else {\n            balance = markets[marketId].longZCB.balanceOf(msg.sender);\n            require(balance >= 0, \"Empty\");\n\n            // TODO this means if trader's loss will be refunded if loss was realized before denied market\n            if (\n                controller.isValidator(marketId, msg.sender) &&\n                controller.hasApproved(marketId, msg.sender)\n            ) {\n                collateral_amount = controller.deniedValidator(\n                    marketId,\n                    msg.sender\n                );\n            } else {\n                collateral_amount = longTrades[marketId][msg.sender];\n                delete longTrades[marketId][msg.sender];\n                emit RedeemDenied(marketId, msg.sender, true);\n            }\n\n            // Burn all their balance\n            bondPool.trustedBurn(msg.sender, balance, true);\n\n            // This means that the sender is a manager\n            if (queuedRepUpdates[msg.sender] > 0) {\n                unchecked {\n                    queuedRepUpdates[msg.sender] -= 1;\n                }\n            }\n        }\n\n        // Before redeem_transfer is called all funds for this instrument should be back in the vault\n        controller.redeem_transfer(collateral_amount, msg.sender, marketId);\n        //TODO need to check if last redeemer, so can kill market.\n    }\n\n    /// @notice trader will redeem entire balance of ZCB\n    /// Needs to be called at maturity, market needs to be resolved first(from controller)\n    function redeem(uint256 marketId)\n        external\n        _lock_\n        returns (uint256 collateral_redeem_amount)\n    {\n        require(!restriction_data[marketId].alive, \"!Active\");\n        require(restriction_data[marketId].resolved, \"!resolved\");\n        require(!redeemed[marketId][msg.sender], \"Redeemed\");\n        redeemed[marketId][msg.sender] = true;\n\n        SyntheticZCBPool bondPool = markets[marketId].bondPool;\n\n        if (controller.isValidator(marketId, msg.sender))\n            controller.redeemValidator(marketId, msg.sender);\n\n        uint256 zcb_redeem_amount = markets[marketId].longZCB.balanceOf(\n            msg.sender\n        );\n        uint256 redemption_price = redemption_prices[marketId];\n        collateral_redeem_amount = redemption_price.mulWadDown(\n            zcb_redeem_amount\n        );\n\n        if (!controller.isValidator(marketId, msg.sender)) {\n            // TODO should validators get reputation if they do ok.\n            reputationManager.recordPush(\n                msg.sender,\n                marketId,\n                redemption_price,\n                false,\n                zcb_redeem_amount\n            );\n        }\n\n        // This means that the sender is a manager\n        if (queuedRepUpdates[msg.sender] > 0) {\n            unchecked {\n                queuedRepUpdates[msg.sender] -= 1;\n            }\n        }\n\n        bondPool.trustedBurn(msg.sender, zcb_redeem_amount, true);\n        controller.redeem_transfer(\n            collateral_redeem_amount,\n            msg.sender,\n            marketId\n        );\n    }\n\n    /// @notice called by short buyers when market is resolved for fixed term instruments\n    function redeemShortZCB(uint256 marketId)\n        external\n        _lock_\n        returns (uint256 collateral_redeem_amount)\n    {\n        require(!restriction_data[marketId].alive, \"Active\");\n        require(restriction_data[marketId].resolved, \"!resolved\");\n        require(!redeemed[marketId][msg.sender], \"Redeemed\");\n        require(!markets[marketId].isPool, \"pool\");\n\n        redeemed[marketId][msg.sender] = true;\n        SyntheticZCBPool bondPool = markets[marketId].bondPool;\n\n        uint256 shortZCB_redeem_amount = markets[marketId].shortZCB.balanceOf(\n            msg.sender\n        );\n        uint256 long_redemption_price = redemption_prices[marketId];\n        uint256 redemption_price = long_redemption_price >= config.WAD\n            ? 0\n            : config.WAD - long_redemption_price;\n        collateral_redeem_amount = redemption_price.mulWadDown(\n            shortZCB_redeem_amount\n        );\n\n        bondPool.trustedBurn(msg.sender, shortZCB_redeem_amount, false);\n        controller.redeem_transfer(\n            collateral_redeem_amount,\n            msg.sender,\n            marketId\n        );\n    }\n\n    /// @notice redeemAmount is in shortZCB\n    function redeemPerpShortZCB(uint256 marketId, uint256 redeemAmount)\n        external\n        returns (\n            uint256 collateral_redeem_amount,\n            uint256 seniorAmount,\n            uint256 juniorAmount\n        )\n    {\n        LocarVars memory vars;\n\n        vars.vault = controller.getVault(marketId);\n        CoreMarketData memory market = markets[marketId];\n\n        require(market.isPool, \"!pool\");\n\n        (vars.psu, vars.pju, vars.levFactor) = Data.viewCurrentPricing(\n            marketId\n        );\n        collateral_redeem_amount = (Data.zcbMaxPrice(marketId) - vars.pju)\n            .mulWadDown(redeemAmount);\n        juniorAmount = vars.pju.mulWadDown(redeemAmount);\n        seniorAmount = redeemAmount.mulWadDown(vars.levFactor).mulWadDown(\n            vars.psu\n        );\n\n        // Deposit BACK to the instrument TODO deposit limit reached?\n        vars.vault.depositIntoInstrument(\n            marketId,\n            juniorAmount + seniorAmount,\n            true\n        );\n\n        market.bondPool.trustedBurn(msg.sender, redeemAmount, false);\n        controller.redeem_transfer(\n            collateral_redeem_amount,\n            msg.sender,\n            marketId\n        );\n\n        // reputationManager.recordPus h(trader, marketId, vars.pju, false, redeemAmount);\n    }\n\n    function burnAndTransfer(\n        uint256 marketId,\n        address burnWho,\n        uint256 burnAmount,\n        address sendWho,\n        uint256 sendAmount\n    ) external {\n        require(msg.sender == leverageManager_ad, \"unauthorized\");\n\n        markets[marketId].bondPool.trustedBurn(burnWho, burnAmount, true);\n        controller.redeem_transfer(sendAmount, sendWho, marketId);\n    }\n\n    /// @notice marketmanager is the only approved contract\n    function transferTraderCap(\n        address token,\n        address trader,\n        address to,\n        uint256 amount\n    ) external {\n        require(msg.sender == leverageManager_ad, \"unauthorized\");\n        ERC20(token).transferFrom(trader, to, amount);\n    }\n}\n\n"
    },
    "contracts/protocol/ordermanager.sol": {
      "content": "pragma solidity ^0.8.16;\nimport \"../global/types.sol\";\nimport {StorageHandler} from \"../global/GlobalStorage.sol\"; \nimport {Controller} from \"./controller.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\ncontract OrderManager{\n\tusing FixedPointMathLib for uint256; \n\n\tuint256 public constant PRECISION = 1e18; \n\tuint256 Id; \n\tuint256 public MAXPRICE = 1e18; \n  \tuint256 constant priceDelta = 1e16; \n\n  \tStorageHandler public Data; \n\n  \tController controller; \n  \taddress owner; \n\n  \tconstructor(address _controller){\n  \t\tcontroller = Controller(_controller); \n  \t\towner = msg.sender; \n  \t}\n\n  \tfunction setDataStore(address dataStore) public {\n  \t\trequire(msg.sender== address(controller), \"unauthorized\"); \n    \tData = StorageHandler(dataStore); \n  \t}\n\n\tevent OrderSubmitted(uint256 indexed marketId, uint256 indexed price, address owner, Order order);\n  \tevent OrderFilled(uint256 indexed marketId, uint256 indexed price, Order order, uint256 amount);\n\n  \tmapping(bytes32=>uint256[]) idsByPriceAndDir; \n  \tmapping(uint256=>Order) ordersById; //orderId-> orderId \n\n  \t/// @notice post assessment function. amountIn is in longZCB or shortZCb\n  \tfunction submitOrder(\n   \t \tuint256 marketId, \n    \tuint256 amount, \n    \tbool isLong, \n    \tuint256 price\n    \t) public returns(uint256){\n  \t\t// TODO conditions : only postassessment, shortzcb, longzcb \n    \tCoreMarketData memory market = Data.getMarket(marketId); \n    \tOrder memory order = Order(isLong, price, amount, Id, msg.sender); \n\n    \tuint256 pullCollateral = isLong? amount.mulWadDown(price): amount.mulWadDown(MAXPRICE - price); \n\n    \tERC20(market.bondPool.baseToken()).transferFrom(msg.sender, address(controller), amount.mulWadDown(price));\n\n    \tordersById[Id] = order; \n    \tidsByPriceAndDir[keccak256(abi.encodePacked(pointToPrice(price), isLong ))].push(Id); \n    \tId++; \n\n    \temit OrderSubmitted(marketId, price, msg.sender, order); \n    \treturn Id-1; \n  \t}\n\n  \tfunction removeOrder(uint256 marketId, uint256 orderId, uint256 amount ) public {\n     \tOrder memory order = ordersById[orderId]; \n     \trequire(msg.sender == order.owner, \"not submitter\");\n     \trequire(amount<= order.amount, \"insufficient order amount\"); \n    \tunchecked{ordersById[orderId].amount -= amount;}\n    \tcontroller.redeem_transfer(amount.mulWadDown(order.price), msg.sender, marketId); \n  \t}\n\n  \tfunction fillCompleteSingleOrderMint(uint256 marketId, uint256 orderId) public {\n    \tfillSingleOrderMint(marketId, ordersById[orderId], ordersById[orderId].amount); \n  \t}\t\n\n\t/// @notice fill mutiple orders in a given price \n\tfunction fillMultipleOrders(\n\t\tuint256 marketId, \n\t\tuint256 price, \n\t\tuint256 fillAmount, \n\t\tbool fillLong\n\t\t) public {\n\t\tOrder memory order; \n\t\tuint256[] memory ids = idsByPriceAndDir[keccak256(abi.encodePacked(pointToPrice(price), fillLong))]; \n\t\tconsole.log('id', ids.length); \n\t\tfor (uint i=0; i< ids.length; i++){\n\n\t\t  order = ordersById[ids[i]]; \n\t\t  fillSingleOrderMint(marketId, order, min(order.amount, fillAmount) ); \n\t\t  fillAmount = fillAmount> order.amount? fillAmount - order.amount : 0; \n\n\t\t  if(fillAmount == 0) break; \n\t\t}\n\t}\n\n\t/// @notice When an order is filled for longZCB,\n\t/// need to mint an equivalent amount of shortZCB and vice versa \n\tfunction fillSingleOrderMint(\n\t\tuint256 marketId,\n\t\tOrder memory order, \n\t\tuint256 fillAmount) internal {\n\t\tCoreMarketData memory market = Data.getMarket(marketId); \n\t\trequire(order.amount>= fillAmount, \"not enough fill liq\"); \n\n\t\t// TODO require maxprice less than order price even if max price changes? \n\t\tuint256 fillerAmount = fillAmount.mulWadDown(MAXPRICE - order.price); \n\n\t\tERC20(market.bondPool.baseToken()).transferFrom(msg.sender, address(controller), fillerAmount); // funds should go to the?\n\n\t\tmarket.bondPool.trustedMint(order.owner, fillAmount, order.isLong); \n\t\tmarket.bondPool.trustedMint(msg.sender, fillAmount, !order.isLong); \n\n\t\tordersById[order.orderId].amount -= fillAmount; \n\n\t\temit OrderFilled(marketId, order.price, order, fillAmount); \n\t}\n\n\tfunction viewOpenOrdersByPrice(uint256 price, bool isLong) public view returns(uint256[] memory){\n\t\t// uint256[] memory id; \n\t\t// return id; \n\t\treturn idsByPriceAndDir[keccak256(abi.encodePacked(pointToPrice(price), isLong ))]; \n\t}\n\n\tfunction pointToPrice(uint256 point) public pure returns(uint256){\n\t \treturn(uint256(point) * priceDelta); \n\t}\n\n\t/// @notice will round down to nearest integer \n\tfunction priceToPoint(uint256 price) public pure returns(uint256){\n\t \treturn (price.divWadDown(priceDelta))/PRECISION; \n\t}\n\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t \treturn a <= b ? a : b;\n\t}\n\n}"
    },
    "contracts/protocol/reputationmanager.sol": {
      "content": "pragma solidity ^0.8.16;\nimport \"lib/forge-std/src/console.sol\";\n\nimport {config} from \"../utils/helpers.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Controller} from \"./controller.sol\"; \nimport {StorageHandler} from \"../global/GlobalStorage.sol\"; \n\ncontract ReputationManager {\n    using FixedPointMathLib for uint256;\n\n    mapping(address=>uint256) public trader_scores; // trader address => score\n    mapping(address=>bool) public isRated;\n    address[] public traders;\n\n    address controller;\n    address marketManager;\n\n    address deployer;\n\n    modifier onlyProtocol() {\n        require(msg.sender == controller || msg.sender == marketManager || msg.sender == deployer, \"ReputationManager: !protocol\");\n        _;\n    }\n    // event pullLogged(uint256 marketId, address recipient, );\n    event reputationUpdated(uint256 marketId, address recipient);\n\n    constructor(\n        address _controller,\n        address _marketManager\n    ) {\n       controller = _controller;\n       marketManager = _marketManager;\n       deployer = msg.sender;\n    }\n  StorageHandler public Data; \n  function setDataStore(address dataStore) public onlyProtocol{\n    Data = StorageHandler(dataStore); \n  }\n    struct RepLog{\n        uint256 collateralAmount; \n        uint256 bondAmount; \n        uint256 budget; \n        bool perpetual; \n        //TODO place this info elsewhere or do packing\n    }\n\n    mapping(address=> mapping(uint256=> RepLog)) public repLogs; //trader=> marketid=>replog \n\n    function getRepLog(address trader, uint256 marketId) external view returns(RepLog memory){\n        return repLogs[trader][marketId]; \n    }\n\n    event RecordPull(address indexed trader, uint256 marketId, uint256 bondAmount, uint256 collateral_amount, uint256 budget, bool perpetual);\n\n    /// @notice record for reputation updates whenever trader buys longZCB\n    function recordPull(\n        address trader, \n        uint256 marketId, \n        uint256 bondAmount, \n        uint256 collateral_amount, \n        uint256 budget,\n        bool perpetual\n        ) external onlyProtocol{\n        RepLog memory newLog = repLogs[trader][marketId]; \n        newLog.collateralAmount += collateral_amount; \n        newLog.bondAmount += bondAmount; \n        newLog.perpetual = perpetual; \n        newLog.budget = budget; \n\n        repLogs[trader][marketId] = newLog;   \n\n        emit RecordPull(trader, marketId, bondAmount, collateral_amount, budget, perpetual);\n    }\n\n    event RecordPush(address indexed trader, uint256 marketId, uint256 bondPrice, bool premature, uint256 redeemAmount, bool perpetual);\n\n    /// @notice updates reputation whenever trader redeems \n    /// param premature is true if trader redeems/sells before maturity \n    /// param redeemAmount is 0 if !perpetual, since for those traders will redeem all at once \n    function recordPush(\n        address trader, \n        uint256 marketId, \n        uint256 bondPrice, \n        bool premature, \n        uint256 redeemAmount//in bonds \n        ) external onlyProtocol {\n        RepLog memory newLog = repLogs[trader][marketId]; \n\n        uint256 avgPrice = newLog.collateralAmount.divWadDown(newLog.bondAmount); \n\n        // Penalize premature sells \n        if(premature){\n            _updateReputation(marketId, trader, false, 1e18, newLog); \n            delete repLogs[trader][marketId]; \n        }\n        // What about when trader buys during assessment at discount?  \n        // if instrument is perpetual, increment if exit price > avgPrice by \n        // proportional to the diff in price  \n        if(newLog.perpetual){\n            if (bondPrice >= avgPrice) \n                _updateReputation(marketId, trader, true,  bondPrice-avgPrice, newLog); \n            else \n                _updateReputation(marketId, trader, false,  avgPrice - bondPrice, newLog); \n\n            require(newLog.collateralAmount >= redeemAmount.mulWadDown(avgPrice), \"logERR1\");\n            require(newLog.bondAmount>= redeemAmount, \"logERR2\"); \n            unchecked{\n                newLog.collateralAmount -= redeemAmount.mulWadDown(avgPrice);\n                newLog.bondAmount -= redeemAmount; \n                repLogs[trader][marketId] = newLog; \n            }\n        }\n\n        // if instrument is fixed term, increment if redemptionprice >= 1, \n        // no change if 1>= redemption price >= avgPrice and decrement otherwise \n        else{\n            //bondPrice is redemptionprice for fixed term instruments\n            if(bondPrice>= 1e18)\n                _updateReputation(marketId, trader, true, bondPrice-avgPrice, newLog); \n            \n            else if(bondPrice <= avgPrice && bondPrice < 1e18)\n                _updateReputation(marketId, trader, false, avgPrice-bondPrice, newLog);  \n            // Redeeming everything at maturity \n            delete repLogs[trader][marketId];             \n        }\n\n        emit RecordPush(trader, marketId, bondPrice, premature, redeemAmount, newLog.perpetual);\n\n    }\n\n    /// @notice given a hypoethetical bond price, calculate how much reputation one will gain\n    function expectedRepGain(\n        address trader, \n        uint256 marketId, \n        uint256 bondPrice, \n        uint256 incremntalAmount, \n        uint256 incrementalBondAmount) external view returns(int256 expectedGain){\n        RepLog memory log = repLogs[trader][marketId]; \n\n        uint256 avgPrice = (log.collateralAmount+incremntalAmount)\n            .divWadDown(log.bondAmount + incrementalBondAmount); \n        uint256 priceChange = bondPrice- avgPrice; \n        uint256 implied_probs; \n\n        if(log.perpetual){\n            implied_probs = log.collateralAmount.divWadDown(log.budget); \n            expectedGain = (bondPrice >= avgPrice)\n                ? int256(priceChange.mulWadDown(implied_probs))\n                : -int256(priceChange.mulWadDown(implied_probs)); \n        } else {\n            implied_probs = calcImpliedProbability(\n                log.bondAmount, \n                log.collateralAmount, \n                log.budget\n                ); \n            if(bondPrice>= 1e18)\n                expectedGain = int256(priceChange.mulWadDown(implied_probs)); \n            else if(bondPrice <= avgPrice && bondPrice < 1e18)\n                expectedGain = -int256(priceChange.mulWadDown(implied_probs)); \n        }\n    }\n\n    /// @notice when market is resolved(maturity/early default), calculates score\n    /// and update each assessment phase trader's reputation, called by individual traders when redeeming\n    function _updateReputation(\n        uint256 marketId,\n        address trader,\n        bool increment, \n        uint256 priceChange, \n        RepLog memory log\n    ) internal {\n\n        uint256 implied_probs = log.perpetual\n            ? log.collateralAmount.divWadDown(log.budget)\n            : calcImpliedProbability(\n                log.bondAmount, \n                log.collateralAmount, \n                log.budget\n                ); \n\n        uint256 change = priceChange.mulWadDown(implied_probs); \n                        // log.perpetual\n                        // ? priceChange.mulWadDown(implied_probs) * \n                        // : implied_probs.mulDivDown(implied_probs, config.WAD);\n\n        if (increment) {\n            incrementScore(trader, change);\n        } else {\n            decrementScore(trader, change);\n        }\n    }\n\n    //function expectedRepGain()\n\n\n    /// @notice calculates implied probability of the trader, used to\n    /// update the reputation score by brier scoring mechanism\n    /// @param budget of trader in collateral decimals\n    function calcImpliedProbability(\n        uint256 bondAmount,\n        uint256 collateral_amount,\n        uint256 budget\n    ) public pure returns (uint256) {\n        require(bondAmount > 0 && collateral_amount > 0, \"0div\"); \n      // TODO underflows when avgprice bigger than wad\n        uint256 avg_price = collateral_amount.divWadDown(bondAmount);\n        uint256 b = avg_price.mulWadDown(config.WAD - avg_price);\n        uint256 ratio = bondAmount.divWadDown(budget);\n\n        return ratio.mulWadDown(b) + avg_price;\n    }\n\n    function calculateMinScore(uint256 percentile) view external returns (uint256) {\n        uint256 l = traders.length * config.WAD;\n        if (percentile / 1e2 == 0) {\n        return 0;\n        }\n        uint256 x = l.mulWadDown(percentile / 1e2);\n        x /= config.WAD;\n        return trader_scores[traders[x - 1]];\n    }\n\n    // change visiblity, external only for testing.\n    function setTraderScore(address trader, uint256 score) external {\n        uint256 prev_score = trader_scores[trader];\n        if (score > prev_score) {\n        incrementScore(trader, score - prev_score);\n        } else if (score < prev_score) {\n        decrementScore(trader, prev_score - score);\n        }\n    }\n    \n    function isReputable(address trader, uint256 percentile) view external returns (bool) {\n        uint256 k = findTrader(trader);\n        uint256 n = (traders.length - (k+1))*config.WAD;\n        uint256 N = traders.length*config.WAD;\n        uint256 p = uint256(n).divWadDown(N)*10**2;\n\n        if (p >= percentile) {\n        return true;\n        } else {\n        return false;\n        }\n    }\n\n    // TODO \n    function expectedIncrement(address manager) public view returns(uint256){\n\n    }\n\n    /**\n    @dev percentile is is wad 0-100\n    @notice returns a list of top X percentile traders excluding the utilizer. \n    */\n    function filterTraders(uint256 percentile, address utilizer) view public returns (address[] memory) {\n        uint256 l = traders.length * config.WAD;\n        \n        // if below minimum percentile, return all traders excluding the utilizer\n        if (percentile / 1e2 == 0) {\n        if (isRated[utilizer]) {\n            address[] memory result = new address[](traders.length - 1);\n\n            uint256 j = 0;\n            for (uint256 i=0; i<traders.length; i++) {\n            if (utilizer == traders[i]) {\n                j = 1;\n                continue;\n            }\n            result[i - j] = traders[i];\n            }\n            return result;\n        } else {\n            return traders;\n        }\n        }\n\n        uint256 x = l.mulWadDown((config.WAD*100 - percentile) / 1e2);\n        x /= config.WAD;\n\n        address[] memory selected; \n        if (utilizer == address(0) || !isRated[utilizer]) {\n        selected = new address[](x);\n        for (uint256 i=0; i<x; i++) {\n            selected[i] = traders[i];\n        }\n        } else {\n        selected = new address[](x - 1);\n        uint256 j=0;\n        for (uint256 i = 0; i<x; i++) {\n            if (traders[i] == utilizer) {\n            j = 1;\n            continue;\n            }\n            selected[i - j] = traders[i];\n        }\n        }\n\n        return selected;\n    }\n\n    function getTraders() view public returns (address[] memory) {\n        return traders;\n    }\n\n    event ScoreUpdated(address trader, uint256 score);\n    /**\n    @notice increments trader's score\n    @dev score >= 0, update > 0\n    */\n    function incrementScore(address trader, uint256 update) onlyProtocol public {\n        trader_scores[trader] += update;\n        _updateRanking(trader, true);\n        emit ScoreUpdated(trader, trader_scores[trader]);\n    }\n\n    function testIncrementScore(uint256 update) public {\n        trader_scores[msg.sender] += update;\n        _updateRanking(msg.sender, true);\n        emit ScoreUpdated(msg.sender, trader_scores[msg.sender]);\n    }\n\n    function getScore(address trader) view public returns (uint256) {\n        return trader_scores[trader];\n    }\n\n    /**\n    @notice decrements trader's score\n    @dev score >= 0, update > 0\n    */\n    function decrementScore(address trader, uint256 update) onlyProtocol public {\n        if (update >= trader_scores[trader]) {\n        trader_scores[trader] = 0;\n        } else {\n        trader_scores[trader] -= update;\n        }\n        _updateRanking(trader, false);\n        emit ScoreUpdated(trader, trader_scores[trader]);\n    }\n\n    /**\n    @notice updates top trader array\n    @dev holy moly is this ugly\n    */\n    function _updateRanking(address trader, bool increase) internal {\n        uint256 score = trader_scores[trader];\n\n        if (!isRated[trader]) {\n        isRated[trader] = true;\n        if (traders.length == 0) {\n            traders.push(trader);\n            return;\n        }\n        for (uint256 i=0; i<traders.length; i++) {\n            if (score > trader_scores[traders[i]]) {\n            traders.push(address(0));\n            _shiftRight(i, traders.length-1);\n            traders[i] = trader;\n            return;\n            }\n            if (i == traders.length - 1) {\n            traders.push(trader);\n            return;\n            }\n        }\n        } else {\n        uint256 k = findTrader(trader);\n        //swap places with someone.\n        if ((k == 0 && increase)\n        || (k == traders.length - 1 && !increase)) {\n            return;\n        }\n\n        if (increase) {\n            for (uint256 i=0; i<k; i++) {\n            if (score > trader_scores[traders[i]]) {\n                _shiftRight(i,k);\n                traders[i] = trader;\n                return;\n            }\n            }\n        } else {\n            for (uint256 i=traders.length - 1; i>k; i--) {\n            if (score < trader_scores[traders[i]]) {\n                _shiftLeft(k, i);\n                traders[i] = trader;\n                return;\n            }\n            }\n        }\n        }\n    }\n\n    function findTrader(address trader) public view returns (uint256) {\n    for (uint256 i=0; i<traders.length; i++) {\n        if (trader == traders[i]) {\n            return i;\n        }\n        }\n    }\n\n    /**\n    @notice helpers\n    */\n    function _shiftRight(uint256 pos, uint256 end) internal {\n        for (uint256 i=end; i>pos; i--) {\n        traders[i] = traders[i-1];\n        }\n    }\n\n    function _shiftLeft(uint256 pos, uint256 end) internal {\n        for (uint256 i=pos; i<end; i++) {\n        traders[i] = traders[i+1];\n        }\n    }\n    \n}"
    },
    "contracts/protocol/reputationtoken.sol": {
      "content": "pragma solidity ^0.8.16; \n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {Controller} from \"./controller.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\n\n\ncontract ReputationNFT is ERC721 {\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\n  mapping(address => uint256) internal _ownerToId;\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\n\n  uint256 private nonce = 1;\n  Controller controller;\n  uint256 SCALE = 1e18;\n\n\n  struct ReputationData {\n    uint256 n; // number of markets participated in => regular uint256\n    uint256 score; \n  }\n\n  struct TraderData { // for each market\n    address trader;\n    uint256 tokensBought;\n  }\n\n  struct TopReputation{\n    address trader; \n    uint256 score; \n  }\n\n  uint256 private constant topRep = 100; \n  TopReputation[topRep] topReputations; \n\n  mapping(uint256=>mapping(address=>bool)) canTrade; //marketID-> address-> cantrade\n  mapping(uint256=>bool) allowAll; \n  mapping(address=>bool) isUnique; \n  address[] unique_traders; \n  mapping(uint256=>mapping(address=>uint256)) public balances; // marketId => market manager address => how much collateral already bought.\n\n  modifier onlyController() {\n    require(msg.sender == address(controller));\n    _;\n  }\n\n  constructor (\n    address _controller\n  ) ERC721(\"Debita Reputation Token\", \"DRT\") {\n    controller = Controller(_controller);\n  }\n\n  /**\n   @notice incrementBalance\n   */\n  function incrementBalance(uint256 marketId, address trader, uint256 amount) external onlyController {\n    balances[marketId][trader] += amount;\n  }\n\n  /**\n   @notice called post reputation update\n   */\n  function removeBalance(uint256 marketId, address trader) external onlyController {\n    delete balances[marketId][trader];\n  }\n\n  function _baseURI() internal pure returns (string memory baseURI) {\n    baseURI = \"\";\n  }\n\n  function tokenURI(uint256 id) public view override returns (string memory) {\n    require(_ownerOf[id] != address(0), \"Invalid Identifier\");\n\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \"\";\n  }\n\n  function mint(address to) external {\n    require(_ownerToId[to] == uint256(0), \"can only mint one reputation token\");\n    super._mint(to, nonce);\n    _ownerToId[to] = nonce;\n\n    // Set default score, if this goes to 0 cannot trade\n    _reputation[_ownerToId[to]].score = 1e18; \n\n    nonce++;\n  }\n\n  function getReputationScore(address owner) view external returns (uint256){\n    require(_ownerToId[owner] != uint256(0), \"No Id found\");\n    return _reputation[_ownerToId[owner]].score;\n  }\n\n  function setReputationScore(address owner, uint256 score) external returns (uint256) \n  //onlyOwner\n  {\n    require(_ownerToId[owner] != uint256(0), \"No Id found\");\n    return _reputation[_ownerToId[owner]].score = score;\n  }\n\n\n  function updateScore(address to, int256 score) external onlyController{\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    if (score > 0) data.score = data.score + uint256(score);\n    else{\n        if (data.score <= uint256(-score)) data.score = 0; \n        else data.score = data.score - uint256(-score);\n      } \n\n    storeTopX(data.score, to); \n  }\n\n\n  function addScore(address to, uint256 score) external onlyController\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    data.score = data.score + score; \n\n    storeTopX(data.score, to); \n  }\n\n  function decrementScore(address to, uint256 score) external onlyController\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    if (data.score <= score) data.score = 0; \n    else data.score = data.score - score; \n\n    storeTopX(data.score, to); \n  }\n\n  function addAverageScore(address to, uint256 score) external onlyController\n\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    \n    if (data.n == 0) {\n      data.score = score;\n    } else {\n      data.score = (data.score / data.n + score) / (data.n + 1);\n    }\n\n    data.n++;\n  }\n\n  /**\n   @notice reset scores\n   */\n  function resetScore(address to) external {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n    delete _reputation[_ownerToId[to]];\n  }\n\n  /// @notice called by controller when initiating market,\n  function storeTopReputation(uint256 topX, uint256 marketId) external onlyController{\n    if (getAvailableTopX() < topX) {\n      allowAll[marketId] =true; \n      return; \n    }\n\n    for (uint256 i; i<topX; i++){\n      canTrade[marketId][topReputations[i].trader] = true;\n    }\n\n  }\n\n  /// @notice gets the x's ranked score from all reputation scores \n  /// @dev returns 0 if topX is greater then avaiable nonzero rep scores-> everyone is allowed\n  /// during reputation constraint periods \n  function getMinRepScore(uint256 topX) public view returns(uint256) {\n    if (getAvailableTopX() < topX) {\n      return 0; \n    }\n    return topReputations[topX].score;\n  }\n\n  function getAvailableTopX() public view returns(uint256){\n    return unique_traders.length; \n  }\n\n  function getAvailableTraderNum() public view returns(uint256){\n    return nonce -1; \n  }\n\n  /// @notice whether trader is above reputation threshold \n  function traderCanTrade(uint256 marketId, address trader) external returns(bool){\n    return allowAll[marketId]? true : canTrade[marketId][trader]; \n  }\n\n  /// @notice called whenever a score is incremented   \n  function storeTopX(uint256 score, address trader) internal {\n    uint256 i = 0;\n\n    for(i; i < topReputations.length; i++) {\n      if(topReputations[i].score < score) {\n        break;\n      }\n    }\n    // shifting the array of position (getting rid of the last element) \n    for(uint j = topReputations.length - 1; j > i; j--) {\n        topReputations[j].score = topReputations[j - 1].score;\n        topReputations[j].trader = topReputations[j - 1].trader;\n    }\n    // update the new max element \n    topReputations[i].score = score;\n    topReputations[i].trader = trader;\n\n    if (isUnique[trader]) return; \n    isUnique[trader] = true; \n    unique_traders.push(trader);\n\n  }\n\n  function testStore() public view {\n    for (uint i=0; i<10; i++){\n      console.log('score', topReputations[i].score); \n    }\n  }  \n}"
    },
    "contracts/protocol/validatorManager.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {Controller} from \"./controller.sol\";\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {ReputationManager} from \"./reputationmanager.sol\";\nimport {SyntheticZCBPool} from \"../bonds/bondPool.sol\";\nimport {config} from \"../utils/helpers.sol\";\nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\n\ncontract ValidatorManager {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    Controller private controller;\n    ReputationManager private reputationManager;\n    MarketManager private marketManager;\n    address private creator ; \n\n    modifier onlyController () {\n        require(msg.sender == address(controller), \"not controller\");\n        _;\n    }\n\n     /*----Validator Logic----*/\n    struct ValidatorData {\n        mapping(address => uint256) sales; // amount of zcb bought per validator\n        mapping(address => bool) staked; // true if address has staked vt (approved)\n        mapping(address => bool) resolved; // true if address has voted to resolve the market\n        address[] validators;\n        uint256 val_cap; // total zcb validators can buy at a discount\n        uint256 avg_price; //price the validators can buy zcb at a discount\n        bool requested; // true if already requested random numbers from array.\n        uint256 totalSales; // total amount of zcb bought;\n        uint256 totalStaked; // total amount of vault token staked.\n        uint256 numApproved;\n        uint256 initialStake; // amount staked\n        uint256 finalStake; // amount of stake recoverable post resolve\n        uint256 numResolved; // number of validators calling resolve on early resolution.\n    }\n\n    mapping(uint256 => uint256) requestToMarketId;\n    mapping(uint256 => ValidatorData) public validator_data;\n    \n    constructor (\n        address _controller,\n        address _marketManager,\n        address _reputationManager\n        ) {\n        controller = Controller(_controller);\n        reputationManager = ReputationManager(_reputationManager);\n        marketManager = MarketManager(_marketManager);\n        creator = msg.sender; \n    }\n\n    function validatorSetup(\n        uint256 marketId,\n        uint256 principal,\n        bool isPool\n    ) external onlyController {\n        require(principal != 0, \"0 principal\");\n\n\n        _getValidators(marketId);\n\n        _setValidatorCap(marketId, principal, isPool);\n\n        _setValidatorStake(marketId, principal);\n    }\n\n    function _getValidators(uint256 marketId) public {\n        // retrieve traders that meet requirement.\n        // address instrument = market_data[marketId].instrument_address;\n        (,address utilizer) = controller.market_data(marketId);\n\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n        address[] memory selected = reputationManager.filterTraders(\n            r,\n            utilizer\n        );\n\n        // if there are not enough traders, set validators to all selected traders.\n        if (selected.length <= N) {\n            validator_data[marketId].validators = selected;\n\n            if (selected.length < N) {\n                revert(\"not enough rated traders\");\n            }\n\n            return;\n        }\n\n        validator_data[marketId].requested = true;\n\n        uint256 _requestId = 1;\n        // uint256 _requestId = COORDINATOR.requestRandomWords(\n        //   keyHash,\n        //   subscriptionId,\n        //   requestConfirmations,\n        //   callbackGasLimit,\n        //   uint32(parameters[marketId].N)\n        // );\n\n        requestToMarketId[_requestId] = marketId;\n    }\n\n    function _setValidatorCap(\n        uint256 marketId,\n        uint256 principal,\n        bool isPool //??\n    ) internal {\n        SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\n        (, uint256 sigma, , , , , , ) = marketManager.parameters(marketId);\n        require(config.isInWad(sigma) && config.isInWad(principal), \"paramERR\");\n        ValidatorData storage valdata = validator_data[marketId];\n\n        uint256 valColCap = (sigma.mulWadDown(principal));\n\n        // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved\n        uint256 discount_cap = bondingPool.discount_cap();\n        uint256 avgPrice = valColCap.divWadDown(discount_cap+1);\n\n        valdata.val_cap = discount_cap;\n        valdata.avg_price = avgPrice;\n    }\n\n     /**\n   @notice sets the amount of vt staked by a single validator for a specific market\n   @dev steak should be between 1-0 wad.\n   */\n    function _setValidatorStake(uint256 marketId, uint256 principal) internal {\n        //get vault\n        uint256 vaultId = controller.id_parent(marketId);\n        Vault vault = controller.vaults(vaultId);\n        // ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\n        uint256 shares = vault.convertToShares(principal);\n        (, , , , , , , uint256 steak) = marketManager.parameters(marketId);\n        validator_data[marketId].initialStake = steak.mulWadDown(shares);\n    }\n\n    function deniedValidator(uint256 marketId, address validator)\n        external\n        onlyController\n        returns (uint256 collateral_amount)\n    {\n        //??? is this correct\n        collateral_amount = validator_data[marketId]\n            .sales[validator]\n            .mulWadDown(validator_data[marketId].avg_price);\n        delete validator_data[marketId].sales[validator];\n    }\n\n    function redeemValidator(uint256 marketId, address validator)\n        external\n        onlyController\n    {\n        delete validator_data[marketId].sales[validator];\n    }\n\n    function getValidatorRequiredCollateral(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 val_cap = validator_data[marketId].val_cap;\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\n        uint256 zcb_for_sale = val_cap / N;\n        return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\n    }\n\n    function unlockValidatorStake(uint256 marketId, address validator) onlyController external {\n        require(isValidator(marketId, validator), \"!validator\");\n        require(validator_data[marketId].staked[validator], \"!stake\");\n        (bool duringMarketAssessment, , , , , ) = marketManager\n            .restriction_data(marketId);\n\n        // market early denial, no loss.\n        uint256 vaultId = controller.id_parent(marketId);\n        Vault vault = controller.vaults(vaultId);\n        if (duringMarketAssessment) {\n            ERC20(controller.getVaultAd(marketId)).safeTransfer(\n                validator,\n                validator_data[marketId].initialStake\n            );\n            validator_data[marketId].totalStaked -= validator_data[marketId]\n                .initialStake;\n        } else {\n            // market resolved.\n            ERC20(controller.getVaultAd(marketId)).safeTransfer(\n                validator,\n                validator_data[marketId].finalStake\n            );\n            validator_data[marketId].totalStaked -= validator_data[marketId]\n                .finalStake;\n        }\n\n        validator_data[marketId].staked[validator] = false;\n    }\n\n     function updateValidatorStake(\n        uint256 marketId,\n        uint256 principal,\n        uint256 principal_loss\n    ) public onlyController {\n        if (principal_loss == 0) {\n            validator_data[marketId].finalStake = validator_data[marketId]\n                .initialStake;\n            return;\n        }\n\n        uint256 vaultId = controller.id_parent(marketId);\n        Vault vault = controller.vaults(vaultId);\n        uint256 p_shares = vault.convertToShares(principal);\n        uint256 p_loss_shares = vault.convertToShares(principal_loss);\n\n        uint256 totalStaked = validator_data[marketId].totalStaked;\n        uint256 newTotal = totalStaked /\n            2 +\n            (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(\n                totalStaked / 2\n            );\n\n        ERC4626(controller.getVaultAd(marketId)).burn(totalStaked - newTotal);\n        validator_data[marketId].totalStaked = newTotal;\n\n        validator_data[marketId].finalStake =\n            newTotal /\n            validator_data[marketId].validators.length;\n    }\n\n    function validatorResolve(uint256 marketId, address validator) onlyController external {\n        require(isValidator(marketId, validator), \"!val\");\n        require(!validator_data[marketId].resolved[validator], \"voted\");\n\n        validator_data[marketId].resolved[validator] = true;\n        validator_data[marketId].numResolved++;\n    }\n\n    function isValidator(uint256 marketId, address user)\n        public\n        view\n        returns (bool)\n    {   if(user == creator) return true;  \n        address[] storage _validators = validator_data[marketId].validators;\n        for (uint256 i = 0; i < _validators.length; i++) {\n            if (_validators[i] == user) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function validatorApprove(uint256 marketId, address validator) external returns (uint256 collateral_required, uint256 zcb_for_sale) {\n        require(isValidator(marketId, validator), \"!Val\");\n        require(controller.marketCondition(marketId), \"!condition\");\n\n        ValidatorData storage valdata = validator_data[marketId];\n        require(!valdata.staked[validator], \"!staked\");\n\n        // staking logic, TODO optional since will throw error on transfer.\n        // require(ERC20(getVaultAd(marketId)).balanceOf(validator) >= valdata.initialStake, \"not enough tokens to stake\");\n\n        // staked vault tokens go to controller\n        ERC20(controller.getVaultAd(marketId)).safeTransferFrom(\n            validator,\n            address(this),\n            valdata.initialStake\n        );\n\n        valdata.totalStaked += valdata.initialStake;\n        valdata.staked[validator] = true;\n\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\n        zcb_for_sale = valdata.val_cap / N;\n        collateral_required = zcb_for_sale.mulWadDown(\n            valdata.avg_price\n        );\n\n        require(valdata.sales[validator] <= zcb_for_sale, \"approved\");\n\n        valdata.sales[validator] += zcb_for_sale;\n        valdata.totalSales += (zcb_for_sale + 1); //since division rounds down ??\n        valdata.numApproved += 1;\n\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\n        // marketManager.validatorApprove(\n        //     marketId,\n        //     collateral_required,\n        //     zcb_for_sale,\n        //     validator\n        // );\n\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\n        if (controller.approvalCondition(marketId)) {\n            controller.approveMarket(marketId);\n            // marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\n        }\n    }\n\n    function approvalCondition(uint256 marketId) public view returns (bool) {\n        return (validator_data[marketId].totalSales >=\n            validator_data[marketId].val_cap &&\n            validator_data[marketId].validators.length ==\n            validator_data[marketId].numApproved);\n    }\n\n\n    function getValidatorPrice(uint256 marketId) public view returns (uint256) {\n        return validator_data[marketId].avg_price;\n    }\n\n    function getValidatorCap(uint256 marketId) public view returns (uint256) {\n        return validator_data[marketId].val_cap;\n    }\n\n    function viewValidators(uint256 marketId)\n        public\n        view\n        returns (address[] memory)\n    {\n        return validator_data[marketId].validators;\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords //internal\n    ) external onlyController\n    {\n        uint256 marketId = requestToMarketId[requestId];\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n\n        assert(randomWords.length == N);\n\n        // address instrument = market_data[marketId].instrument_address;\n        (,address utilizer) = controller.market_data(marketId);\n\n        address[] memory temp = reputationManager.filterTraders(r, utilizer);\n        uint256 length = temp.length;\n\n        // get validators\n        for (uint8 i = 0; i < N; i++) {\n            uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\n            validator_data[marketId].validators.push(temp[j]);\n            temp[j] = temp[length - 1];\n            length--;\n        }\n    }\n\n    function _weightedRetrieve(\n        address[] memory group,\n        uint256 length,\n        uint256 randomWord\n    ) internal view returns (uint256) {\n        uint256 sum_weights;\n\n        for (uint8 i = 0; i < length; i++) {\n            sum_weights += controller.getTraderScore(group[i]); //repToken.getReputationScore(group[i]);\n        }\n\n        uint256 tmp = randomWord % sum_weights;\n\n        for (uint8 i = 0; i < length; i++) {\n            uint256 wt = controller.getTraderScore(group[i]);\n            if (tmp < wt) {\n                return i;\n            }\n            unchecked {\n                tmp -= wt;\n            }\n        }\n    }\n\n    function resolveCondition(uint256 marketId) public view returns (bool) {\n        return (validator_data[marketId].numResolved ==\n            validator_data[marketId].validators.length);\n    }\n\n    function hasApproved(uint256 marketId, address validator)\n        public\n        view\n        returns (bool)\n    {\n        return validator_data[marketId].staked[validator];\n    }\n\n    function getNumApproved(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getNumApproved(marketId);\n        return validator_data[marketId].numApproved;\n    }\n\n    function getNumResolved(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getNumResolved(marketId);\n        return validator_data[marketId].numResolved;\n    }\n\n    function getTotalStaked(uint256 marketId) public view returns (uint256) {\n        // return validatorManager.getTotalStaked(marketId);\n        return validator_data[marketId].totalStaked;\n    }\n\n    function getTotalValidatorSales(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        // return validatorManager.getTotalValidatorSales(marketId);\n        return validator_data[marketId].totalSales;\n    }\n\n    function getInitialStake(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getInitialStake(marketId);\n        return validator_data[marketId].initialStake;\n    }\n\n    function getFinalStake(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getFinalStake(marketId);\n        return validator_data[marketId].finalStake;\n    }\n}"
    },
    "contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n    // function isContract(address account) internal view returns (bool) {\n    //     // This method relies on extcodesize, which returns 0 for contracts in\n    //     // construction, since the code is only stored at the end of the\n    //     // constructor execution.\n\n    //     uint256 size;\n    //     // solhint-disable-next-line no-inline-assembly\n    //     assembly { size := extcodesize(account) }\n    //     return size > 0;\n    // }\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
    },
    "contracts/utils/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}"
    },
    "contracts/utils/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/utils/common/Uint.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.4;\n\nuint256 constant MAX_VAL = type(uint256).max;\n\n// reverts on overflow\nfunction safeAdd(uint256 x, uint256 y) pure returns (uint256) {\n    return x + y;\n}\n\n// does not revert on overflow\nfunction unsafeAdd(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return x + y;\n}}\n\n// does not revert on overflow\nfunction unsafeSub(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return x - y;\n}}\n\n// does not revert on overflow\nfunction unsafeMul(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return x * y;\n}}\n\n// does not overflow\nfunction mulModMax(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return mulmod(x, y, MAX_VAL);\n}}\n\n// does not overflow\nfunction mulMod(uint256 x, uint256 y, uint256 z) pure returns (uint256) { unchecked {\n    return mulmod(x, y, z);\n}}\n"
    },
    "contracts/utils/fetcher.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {MarketManager} from \"../protocol/marketmanager.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {VaultFactory} from \"../protocol/factories.sol\";\nimport {Controller} from \"../protocol/controller.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {LinearCurve} from \"../bonds/GBC.sol\"; \nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\";\n// import {PoolInstrument } from \"../instruments/oldpoolInstrument.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\nimport {CoveredCallOTC} from \"../vaults/dov.sol\";\nimport { CreditLine } from \"../vaults/instrument.sol\";\n\nimport \"../global/types.sol\"; \n\ncontract Fetcher {\n    using FixedPointMathLib for uint256;\n\n    /**\n        static => only called on creation of vault or market.\n        dynamic => called continuously.\n     */\n    struct AssetBundle {\n        address addr;\n        string symbol;\n        uint256 decimals;\n        string name;\n    }\n\n    struct CollateralBundle {\n        address tokenAddress;\n        uint256 tokenId;\n        uint256 decimals;\n        uint256 maxAmount;\n        uint256 borrowAmount;\n        uint256 totalCollateral; //only for ERC20.\n        string symbol;\n        string name;\n        bool isERC20;\n        address owner; // only for ERC721.\n    }\n\n    struct ValidatorBundle {\n        address[] validators;\n        uint256 val_cap;\n        uint256 avg_price;\n        uint256 totalSales;\n        uint256 totalStaked;\n        uint256 numApproved;\n        uint256 initialStake;\n        uint256 finalStake;\n        uint256 numResolved;\n    }\n\n    // change types\n    struct VaultBundle {\n        string name;\n        string symbol;\n        string description;\n        uint256 vaultId;\n        uint256[] marketIds;\n        MarketParameters default_params;\n        bool onlyVerified; \n        uint256 r; //reputation ranking  \n        uint256 asset_limit; \n        uint256 total_asset_limit;\n        AssetBundle want;\n        uint256 totalShares;\n        uint256 totalAssets;\n        address vault_address;\n        uint256 exchangeRate;\n        uint256 utilizationRate;\n        uint256 totalEstimatedAPR; \n        uint256 goalAPR; \n        uint256 totalProtection;\n        uint256 totalInstrumentHoldings;\n    }\n\n    struct MarketBundle {\n        uint256 marketId;\n        uint256 vaultId;\n        uint256 creationTimestamp;\n        uint256 resolutionTimestamp;\n\n        bool marketConditionMet;\n        uint256 approvedPrincipal;\n        uint256 approvedYield;\n        uint256 managerStake;\n        uint256 totalCollateral; // loggedCollateral\n        uint256 redemptionPrice;\n\n        // bond pool data\n        address bondPool;\n        address longZCB;\n        uint256 longZCBSupply;\n        address shortZCB;\n        uint256 shortZCBSupply;\n        uint256 longZCBPrice;\n        uint256 a_initial;\n        uint256 b_initial;\n        uint256 b;\n        uint256 discountCap;\n        uint256 discountedReserves;\n\n        MarketParameters parameters;\n        MarketPhaseData phase;\n        ValidatorBundle validatorData;\n    }\n\n    struct PoolBundle {\n        uint256 saleAmount;\n        uint256 initPrice; // init price of longZCB in the amm \n        uint256 promisedReturn; //per unit time \n        uint256 inceptionTime;\n        uint256 inceptionPrice; // init price of longZCB after assessment \n        uint256 leverageFactor; //leverageFactor * manager collateral = capital from vault to instrument\n        uint256 managementFee; // sum of discounts for high reputation managers/validators\n        uint256 pju;\n        uint256 psu;\n        // lending pool data\n        uint128 totalBorrowedAssets;\n        uint128 totalSuppliedAssets;\n        uint256 totalAvailableAssets;\n        \n        // rates\n        uint256 ratePerSec;\n        uint256 lastUpdate;\n        uint256 utilizationRate;\n        address rateContract;\n        string rateName;\n        uint256 exchangeRate;\n        // constants\n        CollateralBundle[] collaterals;\n    }\n\n    struct OptionsBundle {\n        uint256 strikePrice;\n        uint256 pricePerContract;\n        uint256 shortCollateral;\n        uint256 longCollateral;\n        uint256 maturityDate;\n        uint256 tradeTime;\n        address oracle;\n        bool approvalStatus;\n    }\n\n    struct CreditlineBundle {\n        address collateral;\n        address oracle;\n        // tenor === instrument duration.\n        uint256 collateralBalance;\n        uint256 principalRepayed;\n        uint256 interestRepayed;\n        uint256 totalOwed;\n        bool approvalCondition;\n        CreditLine.CollateralType collateralType;\n        CreditLine.LoanStatus loanStatus;\n\n    }\n\n    struct InstrumentBundle {\n        uint256 marketId;\n        uint256 vaultId;\n        address utilizer;\n        bool trusted;\n        bool isPool;\n        uint256 balance;\n        uint256 faceValue;\n\n        // proposed\n        uint256 principal;\n        uint256 expectedYield;\n\n        uint256 duration;\n        string description;\n        address instrument_address;\n        InstrumentType instrument_type;\n        uint256 maturityDate;\n        bytes32 name;\n        uint256 seniorAPR; \n        uint256 exposurePercentage;\n        uint256 managers_stake; \n        uint256 approvalPrice;\n        PoolBundle poolData;\n        OptionsBundle optionsData;\n        CreditlineBundle creditlineData;\n    }\n\n    function buildAssetBundle(ERC20 _asset) internal view returns (AssetBundle memory _bundle) {\n        _bundle.addr = address(_asset);\n        _bundle.symbol = _asset.symbol();\n        _bundle.decimals = _asset.decimals();\n        _bundle.name = _asset.name();\n    }\n\n    /**\n     @dev vaultId retrieved from vaultIds public array in controller.\n     @notice retrieves all the static data associated with a vaultId.\n     */\n    function fetchInitial(\n        Controller _controller,\n        MarketManager _marketManager,\n        uint256 vaultId\n    ) \n    public \n    view \n    returns (\n        VaultBundle memory vaultBundle,\n        MarketBundle[] memory marketBundle,\n        InstrumentBundle[] memory instrumentBundle,\n        uint256 timestamp\n    )\n    {\n        timestamp = block.timestamp;\n        // vault bundle\n        Vault vault = _controller.vaults(vaultId);\n\n        if (address(vault) == address(0)) {\n            return (makeEmptyVaultBundle(), new MarketBundle[](0), new InstrumentBundle[](0), timestamp);\n        }\n\n        vaultBundle.name = vault.name();\n        vaultBundle.symbol = vault.symbol();\n        vaultBundle.vaultId = vaultId;\n        vaultBundle.marketIds = _controller.getMarketIds(vaultId);\n        vaultBundle.default_params = vault.get_vault_params();\n        vaultBundle.onlyVerified = vault.onlyVerified();\n        vaultBundle.want = buildAssetBundle(vault.asset());\n        vaultBundle.r = vault.r();\n        vaultBundle.asset_limit = vault.asset_limit();\n        vaultBundle.total_asset_limit = vault.total_asset_limit();\n        vaultBundle.totalShares = vault.totalSupply();\n        vaultBundle.totalAssets = vault.totalAssets(); \n        vaultBundle.vault_address = address(vault);\n        vaultBundle.utilizationRate = vault.utilizationRate();\n        vaultBundle.totalInstrumentHoldings = vault.totalInstrumentHoldings();\n        vaultBundle.description = vault.description();\n     \n        (uint256 totalProtection, uint256 totalEstimatedAPR, uint256 goalAPR, uint256 exchangeRate) = _controller.getVaultSnapShot(vaultId);\n        vaultBundle.totalProtection = totalProtection;\n        vaultBundle.totalEstimatedAPR = totalEstimatedAPR;\n        vaultBundle.goalAPR = goalAPR;\n        vaultBundle.exchangeRate = exchangeRate;\n\n        if (vaultBundle.marketIds.length == 0) {\n            return (vaultBundle, new MarketBundle[](0), new InstrumentBundle[](0), timestamp);\n        }\n\n        // associated markets\n        // (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n        marketBundle = new MarketBundle[](vaultBundle.marketIds.length);\n        instrumentBundle = new InstrumentBundle[](vaultBundle.marketIds.length);\n\n        for (uint256 i; i < vaultBundle.marketIds.length; i++) {\n            marketBundle[i] = buildMarketBundle(vaultBundle.marketIds[i], vaultId, _controller, _marketManager);\n            // (uint256 managers_stake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) = \n            instrumentBundle[i] = buildInstrumentBundle(vaultBundle.marketIds[i], vaultId, _controller, _marketManager);\n        }\n    }\n\n\n    function buildInstrumentBundle(uint256 mid, uint256 vid, Controller controller, MarketManager marketManager) internal view returns (InstrumentBundle memory bundle) {\n        Vault vault = controller.vaults(vid);\n        (,address utilizer) = controller.market_data(mid);\n        InstrumentData memory data = vault.fetchInstrumentData(mid);\n\n\n        (uint256 managerStake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) = controller.getInstrumentSnapShot(mid);\n        bundle.managers_stake = managerStake;\n        bundle.exposurePercentage = exposurePercentage;\n        bundle.seniorAPR = seniorAPR;\n        bundle.approvalPrice = approvalPrice;\n\n        bundle.marketId = mid;\n        bundle.vaultId = vid;\n        bundle.isPool = data.isPool;\n        bundle.trusted = data.trusted;\n        bundle.balance = vault.asset().balanceOf(address(data.instrument_address));\n        bundle.principal = data.principal;\n        bundle.expectedYield = data.expectedYield;\n        bundle.duration = data.duration;\n        bundle.description = data.description;\n        bundle.instrument_type = data.instrument_type;\n        bundle.maturityDate = data.maturityDate;\n        bundle.instrument_address = address(data.instrument_address);\n        bundle.utilizer = utilizer;\n        bundle.name = data.name;\n        if (data.instrument_type == InstrumentType.LendingPool) {\n            bundle.poolData = buildPoolBundle(mid, vid, controller, marketManager);\n        } else if (data.instrument_type == InstrumentType.CoveredCallShort) {\n            bundle.optionsData = buildCoveredCallBundle(bundle.instrument_address);\n        } else if (data.instrument_type == InstrumentType.CreditLine) {\n            bundle.creditlineData = buildCreditlineBundle(bundle.instrument_address);\n        }\n    }\n\n    function buildCreditlineBundle(address instrument) internal view returns (CreditlineBundle memory bundle) {\n        CreditLine creditline = CreditLine(instrument);\n        bundle.collateral = creditline.collateral();\n        bundle.collateralBalance = creditline.collateral_balance();\n        bundle.collateralType = creditline.collateral_type();\n        bundle.oracle = creditline.oracle();\n        bundle.loanStatus = creditline.loanStatus();\n        bundle.principalRepayed = creditline.principalRepayed();\n        bundle.totalOwed = creditline.totalOwed();\n        bundle.interestRepayed = creditline.interestRepayed();\n        // bundle.approvalCondition = creditline.instrumentApprovalCondition();\n    }\n\n    function buildCoveredCallBundle(address instrument) internal view returns (OptionsBundle memory bundle) {\n        CoveredCallOTC instrumentContract = CoveredCallOTC(instrument);\n        // (uint256 _strikePrice, uint256 _pricePerContract, uint256 _shortCollateral, uint256 _longCollateral, uint256 _maturityDate, uint256 _tradeTime, address _oracle) = instrumentContract.instrumentStaticSnapshot();\n        uint256 _strikePrice = instrumentContract.strikePrice();\n        uint256 _pricePerContract = instrumentContract.pricePerContract();\n        uint256 _shortCollateral = instrumentContract.shortCollateral();\n        uint256 _longCollateral = instrumentContract.longCollateral();\n        uint256 _maturityDate = instrumentContract.maturityTime();\n        uint256 _tradeTime = instrumentContract.tradeTime();\n        address _oracle = instrumentContract.oracle();\n\n        bundle.strikePrice = _strikePrice;\n        bundle.pricePerContract = _pricePerContract;\n        bundle.shortCollateral = _shortCollateral;\n        bundle.longCollateral = _longCollateral;\n        bundle.maturityDate = _maturityDate;\n        bundle.tradeTime = _tradeTime;\n        bundle.oracle = _oracle;\n        bundle.approvalStatus = instrumentContract.instrumentApprovalCondition();\n    }\n\n    function buildPoolBundle(uint256 mid, uint256 vid, Controller controller, MarketManager marketManager) internal view returns (PoolBundle memory bundle) {\n        Vault vault = controller.vaults(vid);\n        address instrument = address(vault.Instruments(mid));\n        InstrumentData memory instrumentData = vault.fetchInstrumentData(mid);\n\n        bundle.saleAmount = instrumentData.poolData.saleAmount;\n        bundle.initPrice = instrumentData.poolData.initPrice;\n        bundle.promisedReturn = instrumentData.poolData.promisedReturn;\n        bundle.inceptionTime = instrumentData.poolData.inceptionTime;\n        bundle.inceptionPrice = instrumentData.poolData.inceptionPrice;\n        bundle.leverageFactor = instrumentData.poolData.leverageFactor;\n        bundle.managementFee = instrumentData.poolData.managementFee;\n        (uint256 psu, uint256 pju, ) = vault.poolZCBValue(mid);\n        bundle.psu = psu;\n        bundle.pju = pju;\n\n        PoolInstrument.CollateralLabel[] memory labels = PoolInstrument(instrument).getAcceptedCollaterals();\n        uint256 l = labels.length;\n        bundle.collaterals = new CollateralBundle[](l);\n        for (uint256 i; i < l; i++) {\n            (uint256 totalCollateral,\n            uint256 maxAmount,\n            uint256 maxBorrowAmount,\n            bool isERC20, , , ,) = PoolInstrument(instrument).collateralConfigs(PoolInstrument(instrument).computeId(labels[i].tokenAddress, labels[i].tokenId));\n            bundle.collaterals[i] = buildCollateralBundle(labels[i].tokenAddress, labels[i].tokenId, maxAmount, maxBorrowAmount, isERC20, totalCollateral);\n            bundle.collaterals[i].owner = PoolInstrument(instrument).userERC721s(PoolInstrument(instrument).computeId(labels[i].tokenAddress, labels[i].tokenId));\n        }\n        \n        \n        (,uint64 lastTimestamp,uint64 ratePerSec) = PoolInstrument(instrument).currentRateInfo();\n        bundle.ratePerSec = ratePerSec;\n        bundle.lastUpdate = lastTimestamp;\n\n        (uint128 borrowAmount,) = PoolInstrument(instrument).totalBorrow();\n        (uint128 assetAmount,) = PoolInstrument(instrument).totalAsset();\n\n        bundle.utilizationRate = assetAmount == 0 ? 0 : borrowAmount * 1e18 / assetAmount;\n        bundle.rateContract = address(PoolInstrument(instrument).rateContract());\n        bundle.rateName = PoolInstrument(instrument).rateContract().name();\n        bundle.exchangeRate = PoolInstrument(instrument).previewMint(1e18);\n\n        bundle.totalBorrowedAssets = borrowAmount;\n        bundle.totalSuppliedAssets = assetAmount;\n        bundle.totalAvailableAssets = PoolInstrument(instrument).totalAssetAvailable();\n    }\n\n    function buildCollateralBundle(address tokenAddress, uint256 tokenId, uint256 maxAmount, uint256 borrowAmount, bool isERC20, uint256 totalCollateral) internal view returns (CollateralBundle memory bundle) {\n        bundle.tokenAddress = tokenAddress;\n        bundle.tokenId = tokenId;\n        bundle.maxAmount = maxAmount;\n        bundle.borrowAmount = borrowAmount;\n        bundle.isERC20 = isERC20;\n        bundle.totalCollateral = totalCollateral;\n        if (isERC20) {\n            bundle.name = ERC20(tokenAddress).name();\n            bundle.symbol = ERC20(tokenAddress).symbol();\n            bundle.decimals = ERC20(tokenAddress).decimals();\n        } else {\n            bundle.name = ERC721(tokenAddress).name();\n            bundle.symbol = ERC721(tokenAddress).symbol();\n        }\n    }\n\n    function buildMarketBundle(uint256 mid, uint256 vid, Controller controller, MarketManager marketManager) internal view returns (MarketBundle memory bundle) {\n        bundle.marketId = mid;\n        bundle.vaultId = vid;\n        CoreMarketData memory data = marketManager.getMarket(mid);\n        bundle.creationTimestamp = data.creationTimestamp;\n        bundle.resolutionTimestamp = data.resolutionTimestamp;\n        bundle.marketConditionMet = controller.marketCondition(mid);\n\n        ApprovalData memory approvalData = controller.getApprovalData(mid);\n        bundle.approvedPrincipal = approvalData.approved_principal;\n        bundle.approvedYield = approvalData.approved_yield;\n        bundle.managerStake = approvalData.managers_stake;\n\n        bundle.totalCollateral = marketManager.loggedCollaterals(mid);\n        bundle.redemptionPrice = marketManager.redemption_prices(mid);\n\n        bundle.phase = marketManager.getPhaseData(mid);\n        bundle.parameters = marketManager.getParameters(mid);\n\n        bundle.bondPool = address(data.bondPool);\n        bundle.longZCB = address(data.longZCB);\n        bundle.shortZCB = address(data.shortZCB);\n        bundle.shortZCBSupply = data.shortZCB.totalSupply();\n        bundle.longZCBSupply = data.longZCB.totalSupply();\n        bundle.longZCBPrice = data.bondPool.getCurPrice();\n        bundle.a_initial = data.bondPool.a_initial();\n        bundle.b_initial = data.bondPool.b_initial();\n        bundle.b = data.bondPool.b();\n        bundle.discountCap = data.bondPool.discount_cap();\n        bundle.discountedReserves = data.bondPool.discountedReserves();\n        \n        // bundle.validatorData = buildValidatorBundle(mid, controller);\n\n    }\n\n    // function buildValidatorBundle(uint256 mid, Controller controller) view internal returns (ValidatorBundle memory bundle)  {\n    //     bundle.avg_price = controller.getValidatorPrice(mid);\n    //     bundle.validators = controller.viewValidators(mid);\n    //     bundle.totalSales = controller.getTotalValidatorSales(mid);\n    //     bundle.totalStaked = controller.getTotalStaked(mid);\n    //     bundle.numApproved = controller.getNumApproved(mid);\n    //     bundle.initialStake = controller.getInitialStake(mid);\n    //     bundle.finalStake = controller.getFinalStake(mid);\n    //     bundle.numResolved = controller.getNumResolved(mid);\n    //     bundle.val_cap = controller.getValidatorCap(mid);\n    // }\n\n// (uint256 managers_stake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice)\n    // function computeInstrumentProfile(\n    //     uint256 mid, \n    //     InstrumentBundle memory bundle, \n    //     Controller controller, \n    //     MarketManager marketmanager\n    //     ) internal view {\n    //     // get senior instrument apr, approval price, manager's stake, \n    //     MarketManager.CoreMarketData memory data = marketmanager.getMarket(mid); \n    //     Controller.ApprovalData memory approvalData = controller.getApprovalData(mid); \n    //     bundle.managers_stake = approvalData.managers_stake;\n\n    //     bundle.exposurePercentage = (bundle.balance).divWadDown(\n    //         controller.getVault(mid).totalAssets()+1);\n    //     bundle.seniorAPR = bundle.poolData.promisedReturn; \n    //     bundle.approvalPrice = bundle.poolData.inceptionPrice; \n\n    //     if(!bundle.isPool){\n    //         uint256 amountDelta;\n    //         uint256 resultPrice;\n\n    //         if(approvalData.managers_stake>0){\n    //             ( amountDelta,  resultPrice) = LinearCurve.amountOutGivenIn(\n    //             approvalData.managers_stake,\n    //             0, \n    //             data.bondPool.a_initial(), \n    //             data.bondPool.b(), \n    //             true \n    //             );\n    //         }\n            \n    //         uint256 seniorYield = bundle.faceValue -amountDelta\n    //             - (bundle.principal - approvalData.managers_stake); \n\n    //         bundle.seniorAPR = approvalData.approved_principal>0\n    //             ? seniorYield.divWadDown(1+bundle.principal - approvalData.managers_stake)\n    //             : 0; \n    //         bundle.approvalPrice = resultPrice; \n    //     }\n\n    // }\n\n    function makeEmptyVaultBundle() pure internal returns (VaultBundle memory) {\n        return VaultBundle(\n            \"\",\n            \"\",\n            \"\",\n            0,\n            new uint256[](0),\n           MarketParameters(0,0,0,0,0,0,0,0),\n            false,\n            0,\n            0,\n            0,\n            AssetBundle(address(0), \"\", 0, \"\"),\n            0,\n            0,\n            address(0),\n            0,\n            0,\n            0, \n            0,0,\n            0\n        );\n    }\n}"
    },
    "contracts/utils/helpers.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nlibrary config{\n\n  uint256 public constant WAD_PRECISION = 18; \n  uint256 public constant WAD = 1e18; \n  uint256 public constant USDC_dec = 1e6; \n  uint256 public constant roundLimit = 1e14; //0.0001 \n\n  //Max amount in one transaction \n  uint256 private constant max_amount = 1e8 * WAD; \n\n  //Min amount in one transaction \n  uint256 private constant min_amount = WAD/1e4; \n\n  function convertToWad(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\n    //number should not be 18 dec, but in collateral_dec\n    new_number = number * (10 ** (WAD_PRECISION - dec));\n    assert(new_number <= max_amount); \n  }\n\n  function wadToDec(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\n    // number should be 18 dec \n    assert(isInWad(number)); \n    new_number = number/(10 ** (WAD_PRECISION - dec)); \n\n  }\n\n  function isInWad(uint256 number) internal pure returns(bool){\n    return (number >= min_amount); \n  }\n\n\n\n\n}"
    },
    "contracts/utils/Multicall.sol": {
      "content": ""
    },
    "contracts/utils/owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor (address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}"
    },
    "contracts/utils/ownedERC20.sol": {
      "content": "pragma solidity ^0.8.9;\n\ncontract oERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n    \n    function mint(address to, uint256 amount) public {\n        _mint(to, amount); \n    }\n    function burn(address to, uint256 amount) public {\n        _burn(to, amount); \n    }\n}"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}"
    },
    "contracts/utils/TestNFT.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\n\n\ncontract TestNFT is ERC721 {\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n    }\n\n    function freeMint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function tokenURI(uint256 id) public view override virtual returns (string memory) {\n        return \"tokenURI\";\n    }\n}"
    },
    "contracts/utils/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/vaults/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n    mapping(address=>bool) Authorized; \n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(msg.sender, _owner);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return(user == owner || Authorized[user]);\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setNewAuthority(address newAuthority) public {\n        require(msg.sender == owner );\n        Authorized[newAuthority] = true; \n\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/vaults/auth/authorities/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    },
    "contracts/vaults/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "contracts/vaults/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "contracts/vaults/dov.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport \"./vault.sol\";\n// import {ERC20} from \"./tokens/ERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\n// import {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {Vault} from \"./vault.sol\"; \n\n/// @notice This contract acts as an OTC option platform\n/// Utilizer will \"propose\" a strike price to buy\n/// At maturity, premiums from utilizer will be collected by the vault when expires\n/// below strike price \ncontract CoveredCallOTC is Instrument{\n    using FixedPointMathLib for uint256; \n\n    address public immutable utilizer;\n    uint256 public immutable strikePrice;\n    uint256 public immutable pricePerContract; \n    uint256 public immutable shortCollateral; \n    uint256 public immutable longCollateral;\n    address public immutable cash; \n    uint256 public immutable maturityTime; \n    uint256 public immutable tradeTime; \n\n    address public oracle ;\n    uint256 public profit; \n    uint256 public constant timeThreshold = 10; \n    bool utilizerClaimed; \n\n    /// @param _shortCollateral depends on how much underlyingAsset is in the vault. \n    /// @param _pricePerContract is the price that the utilizer is willing to buy \n    /// the call option. Usually implied vol here is lower than external implied vol values \n    constructor(address _vault,\n        address _utilizer,\n        uint256 _strikePrice, \n        uint256 _pricePerContract, // depends on IV, price per contract denominated in underlying  \n        uint256 _shortCollateral, // collateral for the sold options-> this is in underlyingAsset i.e weth \n        uint256 _longCollateral, // collateral amount in underlying for long to pay. (price*quantity)\n        address _cash,\n        uint256 duration,\n        uint256 _tradeTime// when the trade will occur \n        ) Instrument(_vault, _utilizer){\n        // TODO shortcollateral must equal principal \n        require(_longCollateral == _shortCollateral.mulWadDown(_pricePerContract), \"incorrect setting\"); \n        utilizer = _utilizer;\n        strikePrice = _strikePrice; \n        pricePerContract = _pricePerContract; \n        shortCollateral = _shortCollateral; \n        longCollateral = _longCollateral; \n        cash = _cash;\n        tradeTime = block.timestamp+ _tradeTime; \n        maturityTime = block.timestamp + duration;\n    }\n\n    function setOracle(address _oracle) public {\n        require(msg.sender ==Vault(vault).owner(), \"not owner\"); \n        oracle = _oracle; \n    }\n\n    function returnCollateral() public onlyUtilizer{\n        // can't return when approved, only can return when denied.  \n        require(block.timestamp<= tradeTime, \"redeem window passed\"); \n        underlying.transfer(msg.sender, longCollateral); \n    }\n\n    /// @notice returns true if the instrument can be approved\n    /// and funds can be directed from vault. Utilizer must have escrowed\n    /// to this contract before  \n    function instrumentApprovalCondition() public override view returns(bool){\n        return underlying.balanceOf(address(this)) >= longCollateral;\n    }\n    uint256 public testqueriedPrice=1e18; \n    /// @notice queries oracle for the latest price of the underlying \n    function queryPrice() public view returns(uint256 price){\n        //return testqueriedPrice; \n        return strikePrice;  \n    }\n\n    /// @notice for a given queriedPrice(usually the spot chainlink price at maturity)\n    /// what is the profit returned to the utilizer \n    /// @dev utillizers can call this function at maturity so they can realize profit it is positive \n    /// if they miss the window(timethreshold), they can't realize profit. \n    /// param queriedPrice must be the exact price at which option is exercised, at maturity\n    function profitForUtilizer() internal{\n        // require(block.timestamp <= maturityTime + timeThreshold  && \n        //     block.timestamp >= maturityTime- timeThreshold , \"Time window err\"); \n        require(profit == 0, \"profit already set\"); \n        uint256 queriedPrice = queryPrice(); \n\n        // Under strike price \n        if (queriedPrice <= strikePrice) profit = 0; \n\n        // Profit denominated in the base asset for the underlyingAsset, normally a stablecoin \n        else {\n            uint256 profitInCash = (queriedPrice - strikePrice).mulWadDown(shortCollateral); \n\n            // profit in underlying should be divided by the price \n            profit = profitInCash.divWadDown(queriedPrice); \n        }\n    }\n\n    /// @notice either option buyers(utilizers) or sellers(protocol)\n    /// can claim their proportion of the winnings \n    function claim() external onlyUtilizer{\n        require(maturityTime < block.timestamp, \"not matured\");\n        profitForUtilizer(); \n\n        if (profit==0) return; \n        // require(profit> 0, \"0profit\"); \n\n        underlying.transfer(msg.sender, profit); \n        profit = 0; \n        utilizerClaimed = true; \n        vault.pingMaturity(address(this), false); \n    }\n\n    /// @notice called at maturity\n    function readyForWithdrawal() public view override returns(bool){\n        return ( (block.timestamp >= maturityTime + timeThreshold && profit == 0)\n                || utilizerClaimed); \n    }\n\n    /**\n    deposit for the utilizer\n     */\n    function deposit() public onlyUtilizer {\n        transfer_liq_from(msg.sender, address(this), longCollateral);\n    }\n\n    function instrumentStaticSnapshot() public view returns (uint256 _strikePrice, uint256 _pricePerContract, uint256 _shortCollateral, uint256 _longCollateral, uint256 _maturityTime, uint256 _tradeTime, address _oracle){\n        return (strikePrice, pricePerContract, shortCollateral, longCollateral, maturityTime, tradeTime, oracle);\n    }\n}\n\n// TODO extra gains redemption price effects \n\n// Vault supplies to this instrument, validators can manually do twaps. If price deviates too much \n// between assessment period start to end, validators can pull out, and create new proposals. \n\n// everytime a manager buys, the same amount needs to be deposited into lyra. lyra wil\n// 0.97 buy-> \n// issue poollongzcb-> supply to instrument from vault-> triggers and open position  to lyra\n// redeem poollongzcb-> withdraw from instrument to vault -> triggers and close position -> realize profit back to vault \n// pool zcb value is derived from options price using it as an exchange rate. \n// contract CoveredCallLyra is Instrument{\n//     using FixedPointMathLib for uint256; \n\n//     address public immutable utilizer;\n//     uint256 public immutable strikePrice;\n//     uint256 public immutable pricePerContract; \n//     uint256 public immutable shortCollateral; \n//     uint256 public immutable longCollateral;\n//     address public immutable cash; \n//     uint256 public immutable maturityTime; \n//     uint256 public immutable tradeTime; \n\n//     address public oracle ;\n//     uint256 public profit; \n//     uint256 public constant timeThreshold = 10; \n//     bool utilizerClaimed; \n\n//     /// @param _shortCollateral depends on how much underlyingAsset is in the vault. \n//     /// @param _pricePerContract is the price that the utilizer is willing to buy \n//     /// the call option. Usually implied vol here is lower than external implied vol values \n//     constructor(address _vault,\n//         address _utilizer,\n//         uint256 _strikePrice, \n//         uint256 _pricePerContract, // depends on IV, price per contract denominated in underlying  \n//         uint256 _shortCollateral, // collateral for the sold options-> this is in underlyingAsset i.e weth \n//         uint256 _longCollateral, // collateral amount in underlying for long to pay. (price*quantity)\n//         address _cash,\n//         uint256 duration,\n//         uint256 _tradeTime// when the trade will occur \n//         ) Instrument(_vault, _utilizer){\n//         // TODO shortcollateral must equal principal \n//         require(_longCollateral == _shortCollateral.mulWadDown(_pricePerContract), \"incorrect setting\"); \n//         utilizer = _utilizer;\n//         strikePrice = _strikePrice; \n//         pricePerContract = _pricePerContract; \n//         shortCollateral = _shortCollateral; \n//         longCollateral = _longCollateral; \n//         cash = _cash;\n//         tradeTime = block.timestamp+ _tradeTime; \n//         maturityTime = block.timestamp + duration;\n//     }\n\n//     // @notice when buyer buys longZCB, funds are directed to here  triggers the contract to supply to lyra \n//     function deposit() public onlyVault{\n\n//     }\n\n//     /// @notice returns true if the instrument can be approved\n//     /// and funds can be directed from vault. Utilizer must have escrowed\n//     /// to this contract before  \n//     function instrumentApprovalCondition() public override view returns(bool){\n//         return underlying.balanceOf(address(this)) >= longCollateral;\n//     }\n\n//     /// @notice short sell a single batch of call options in lyra \n//     function performsSingleTrade() public \n//    // onlyValidator \n//     {\n//         lyraOp.openPosition(TradeInputParameters memory params)\n//     }\n\n\n//     /// @notice pull out funds back to vault when price deviation exceeds threshold \n//     function invalidateInstrument() public \n//     //onlyValidator\n//     {\n\n//     }\n\n\n\n\n\n\n\n// }\n//If you are indeed a scammer, not difficult to make bots that terrorize your account. I really don't deal well with liars and those who rip people off. \n"
    },
    "contracts/vaults/instrument.sol": {
      "content": "\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.16;\n\nimport \"./vault.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport \"../global/types.sol\"; \n\n/// @notice Minimal interface for Vault compatible strategies.\nabstract contract Instrument {\n\n    modifier onlyUtilizer() {\n        require(msg.sender == Utilizer, \"!Utilizer\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == vault.owner() || isValidator[msg.sender], \"!authorized\");\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == address(vault), \"caller must be vault\");\n        _;\n    }\n\n    modifier notLocked() {\n        require(!locked); \n        _; \n    }\n\n    constructor (\n        address _vault,\n        address _Utilizer\n    ) {\n        vault = Vault(_vault);\n        underlying =vault.UNDERLYING();\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \n        Utilizer = _Utilizer;\n    }\n\n\n    ERC20 public underlying;\n    Vault public vault; \n    bool locked; \n    uint256 private constant MAX_UINT = 2**256 - 1;\n    uint256 private maturity_balance; \n    uint256 rawFunds; \n\n    /// @notice address of user who submits the liquidity proposal \n    address public Utilizer; \n    address[] public validators; //set when deployed, but can't be ch\n    mapping(address=>bool) isValidator;\n\n    /**\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\n     */\n    function onMarketApproval(uint256 principal, uint256 yield) virtual external {}\n\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\n        require(_Utilizer != address(0));\n        Utilizer = _Utilizer;\n    }\n\n    // function setValidator(address _validator) external {\n    //     require(msg.sender == vault.owner(), \"Not owner\"); \n    //     validators.push(_validator); \n    //     isValidator[_validator] = true;     \n    // }\n    function setVault(address newVault) external onlyAuthorized {\n        vault = Vault(newVault); \n    }\n\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\n    /// @param amount The amount of underlying tokens to withdraw.\n    /// @return An error code, or 0 if the withdrawal was successful.\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\n        //TODO if this is pool redeemig to vault, need to redeem pool shares \n        return underlying.transfer(address(vault), amount); \n    }\n\n    /// @notice Returns a user's Instrument balance in underlying tokens.\n    /// @param user The user to get the underlying balance of.\n    /// @return The user's Instrument balance in underlying tokens.\n    /// @dev May mutate the state of the Instrument by accruing interest.\n    /// TODO need to incorporate the capital supplied by pool bond issuers\n    function balanceOfUnderlying(address user) public view virtual returns (uint256){\n        if(user == address(this)) return underlying.balanceOf(user) - rawFunds;\n        return underlying.balanceOf(user); \n    }\n\n    /// @notice raw funds should not be harvested by the vault\n    // function pullRawFunds(uint256 amount) public {\n    //     underlying.transferFrom(msg.sender,address(this), amount); \n    //     rawFunds += amount; \n    // }\n\n\n\n    function estimatedTotalAssets() public view virtual returns (uint256){}\n\n\n    /// @notice Free up returns for vault to pull,  checks if the instrument is ready to be withdrawed, i.e all \n    /// loans have been paid, all non-underlying have been liquidated, etc\n    function readyForWithdrawal() public view virtual returns(bool){\n        return true; \n    }\n\n    /// @notice checks whether the vault can withdraw and record profit from this instrument \n    /// for this instrument to resolve \n    /// For creditlines, all debts should be repaid\n    /// for strategies, all assets should be divested + converted to Underlying\n    /// this function is important in preventing manipulations, \n    /// @dev prepareWithdraw->vault.beforeResolve->vault.resolveInstrument in separate txs\n    function prepareWithdraw()\n        external \n        onlyVault \n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        ){\n            require(readyForWithdrawal(), \"not ready to withdraw\"); \n\n            // Lock additional drawdowns or usage of instrument balance \n            lockLiquidityFlow();    \n\n        }\n\n\n    function liquidatePosition(uint256 _amountNeeded) public  virtual returns (uint256 _liquidatedAmount, uint256 _loss){}\n\n\n    function liquidateAllPositions() public  virtual returns (uint256 _amountFreed){}\n\n    function lockLiquidityFlow() internal{\n        locked = true; \n    }\n\n    function isLocked() public view returns(bool){\n        return true; \n    }\n\n    event LiquidityTransfer(address indexed from ,address indexed to, uint256 amount);\n    function transfer_liq(address to, uint256 amount) internal notLocked {\n        underlying.transfer(to, amount);\n        emit LiquidityTransfer(address(this), to, amount);\n    }\n\n    function transfer_liq_from(address from, address to, uint256 amount) internal notLocked {\n        underlying.transferFrom(from, to, amount);\n        emit LiquidityTransfer(from, to, amount);\n    }\n\n    /// @notice called before resolve, to avoid calculating redemption price based on manipulations \n    function store_internal_balance() external onlyVault{\n\n        maturity_balance = balanceOfUnderlying(address(this)); \n\n    }\n\n    function getMaturityBalance() public view returns(uint256){\n        return maturity_balance; \n    }\n\n    function isLiquid(uint256 amount) public virtual view returns(bool){\n        //TODO \n        console.log('isliquid', balanceOfUnderlying(address(this)), amount); \n        return balanceOfUnderlying(address(this)) >= amount; \n    }\n\n    // function beforeApprove(Vault.InstrumentData memory _instrumentData) onlyVault virtual external  {}\n\n\n    /// @notice Before supplying liquidity from the vault to this instrument,\n    /// which is done automatically when instrument is trusted, \n    /// need to check if certain conditions that are required to this specific \n    /// instrument is met. For example, for a creditline with a collateral \n    /// requirement need to check if this address has the specific amount of collateral\n    /// @dev called to be checked at the approve phase from controller  \n    function instrumentApprovalCondition() public virtual view returns(bool); \n\n    /// @notice fetches how much asset the instrument has in underlying for the given share supply \n    function assetOracle(uint256 supply) public view virtual returns(uint256){}\n}\n\n\n\n \n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\n/// approved borrowers will interact with this contract to borrow, repay. \n/// and vault will supply principal and harvest principal/interest \ncontract CreditLine is Instrument {\n    using FixedPointMathLib for uint256;\n    address public immutable borrower; \n\n    //  variables initiated at creation\n    uint256 principal;\n    uint256 notionalInterest; \n    uint256 faceValue; //total amount due, i.e principal+interest\n    uint256 duration; // normalized to a year 1 means 1 year, 0.5 means 6 month \n    uint256 interestAPR; \n\n    // Modify-able Global Variables during repayments, borrow\n    uint256 public totalOwed; \n    uint256 public principalOwed; \n    uint256 public interestOwed;\n    uint256 public accumulated_interest; \n    uint256 public principalRepayed;\n    uint256 public interestRepayed; \n\n    // Collateral Info \n    enum CollateralType{\n        liquidatable, \n        nonLiquid, \n        ownership,        \n        none\n    }\n    address public collateral; \n    address public oracle; \n    uint256 public collateral_balance; \n    CollateralType public collateral_type; \n\n    uint256 drawdown_block; \n    bool didDrawdown; \n\n    uint256 gracePeriod; \n    uint256 resolveBlock; \n    uint256 constant DUST = 1e18; //1usd\n\n    enum LoanStatus{\n        notApproved,\n        approvedNotDrawdowned,\n        drawdowned, \n        partially_repayed,\n        prepayment_fulfilled, \n        matured, \n        grace_period, \n        isDefault\n    }\n\n    LoanStatus public loanStatus; \n\n    uint256 lastRepaymentTime; \n    uint256 gracePeriodStart; \n    Proxy proxy; \n\n    /// @notice both _collateral and _oracle could be 0\n    /// address if fully uncollateralized or does not have a price oracle \n    /// param _notionalInterest and _principal is initialized as desired variables\n    constructor(\n        address vault,\n        address _borrower, \n        uint256 _principal,\n        uint256 _notionalInterest, \n        uint256 _duration,\n        uint256 _faceValue,\n        address _collateral, //collateral for the dao, could be their own native token or some tokenized revenue \n        address _oracle, // oracle for price of collateral \n        uint256 _collateral_balance, //promised collateral balance\n        uint256 _collateral_type\n    )  Instrument(vault, _borrower) {\n        borrower = _borrower; \n        principal =  _principal; \n        notionalInterest = _notionalInterest; \n        duration = _duration;   \n        faceValue = _faceValue;\n\n        collateral = _collateral; \n        oracle = _oracle; \n        collateral_balance = _collateral_balance; \n        collateral_type = CollateralType(_collateral_type); \n\n        loanStatus = LoanStatus.notApproved; \n\n        proxy = new Proxy(address(this), _borrower); \n    }\n\n    function getCurrentTime() internal view returns(uint256){\n        return block.timestamp + 31536000/2; \n    }\n    function getProxy() public view returns(address){\n        return address(proxy); \n    }\n\n    /// @notice checks if the creditline is ready to be withdrawed, i.e all \n    /// loans have been paid, all non-underlying have been liquidated, etc\n    function readyForWithdrawal() public view override returns(bool){\n        if (loanStatus == LoanStatus.matured || loanStatus == LoanStatus.isDefault\n            || loanStatus == LoanStatus.prepayment_fulfilled) return true; \n        return true; \n        //return false  \n    }\n\n    function getApprovedBorrowConditions() public view returns(uint256, uint256){\n        if (vault.isTrusted(this)) return(principal, notionalInterest) ;\n\n        return (0,0); \n    }\n\n    /// @notice if possible, and borrower defaults, liquidates given collateral to underlying\n    /// and push back to vault. If not possible, push the collateral back to\n    function liquidateAndPushToVault() internal  {}\n    function auctionAndPushToVault() internal {} \n    function isLiquidatable(address collateral) public view returns(bool){}\n\n    /// @notice if collateral is liquidateable and has oracle, fetch value of collateral \n    /// and return ratio to principal \n    function getCollateralRatio() public view returns(uint256){\n\n    }\n    /// @notice After grace period auction off ownership to some other party and transfer the funds back to vault \n    /// @dev assumes collateral has already been transferred to vault, needs to be checked by the caller \n    function liquidateOwnership(address buyer) public virtual onlyAuthorized{\n        // TODO implement auction \n        proxy.changeOwnership(buyer);\n    }\n\n    /// @notice transfers collateral back to vault when default \n    function pushCollateralToVault(uint256 amount, address to) public virtual onlyAuthorized{\n        require(loanStatus == LoanStatus.isDefault); \n        ERC20(collateral).transfer(to, amount); \n    }\n\n\n\n    /// @notice validators have to check these conditions at a human level too before approving \n    function instrumentApprovalCondition() public override view returns(bool){\n        // check if borrower has correct identity \n\n        // check if enough collateral has been added as agreed   \n        if (collateral_type == CollateralType.liquidatable || collateral_type == CollateralType.nonLiquid){\n            if (ERC20(collateral).balanceOf(address(this)) >= collateral_balance){\n                return false;\n            } \n        }\n\n        // // check if validator(s) are set \n        // if (validators.length == 0) {revert(\"No validators\"); }\n\n        // Check if proxy has been given ownership\n        if (collateral_type == CollateralType.ownership && proxy.numContracts() == 0) revert(\"Ownership \"); \n\n        return true; \n    } \n\n    event DepositCollateral(uint256 amount);\n    /// @notice borrower deposit promised collateral  \n    function depositCollateral(uint256 amount) external onlyUtilizer {\n        require(collateral!= address(0)); \n        ERC20(collateral).transferFrom(msg.sender, address(this), amount); \n        emit DepositCollateral(amount);\n    }\n\n    /// @notice can only redeem collateral when debt is fully paid \n    function releaseAllCollateral() internal {\n        require(loanStatus == LoanStatus.matured || loanStatus == LoanStatus.prepayment_fulfilled, \"Loan status err\"); \n\n        ERC20(collateral).transfer(msg.sender,collateral_balance); \n    }\n\n\n\n    /// @notice should only be called when (portion of) principal is repayed\n    function adjustInterestOwed() internal {\n\n        uint256 remainingDuration = (drawdown_block + toSeconds(duration)) - getCurrentTime();\n\n        interestOwed = interestAPR.mulWadDown(toYear(remainingDuration).mulWadDown(principalOwed)); \n    }\n\n    /// @param quoted_yield is in notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \n    /// where area under curve is max_principal \n    function onMarketApproval(uint256 max_principal, uint256 quoted_yield) external override onlyVault {\n        principal = max_principal; \n        notionalInterest = quoted_yield; //this accounts for duration as well\n        interestAPR = quoted_yield.divWadDown(duration.mulWadDown(principal)); \n\n        loanStatus = LoanStatus.approvedNotDrawdowned;\n    }\n\n    function onMaturity() external onlyUtilizer {\n        require(loanStatus == LoanStatus.prepayment_fulfilled || loanStatus == LoanStatus.matured,\"Not matured\"); \n        require(block.number > resolveBlock, \"Block equal\"); \n\n        if (collateral_type == CollateralType.liquidatable || collateral_type == CollateralType.nonLiquid ){\n            releaseAllCollateral(); \n        }\n\n        else proxy.changeOwnership(borrower);\n        \n        bool isPrepaid = loanStatus == LoanStatus.prepayment_fulfilled? true:false;\n        // Write to storage resolve details (principal+interest repaid, is prepaid, etc) \n        vault.pingMaturity(address(this), isPrepaid); \n\n    }\n\n    /// @notice borrower can see how much to repay now starting from last repayment time, also used to calculated\n    /// how much interest to repay for the current principalOwed, which can be changed \n    function interestToRepay() public view returns(uint256){\n\n        // Normalized to year\n        uint256 elapsedTime = toYear(getCurrentTime() - lastRepaymentTime);\n        // Owed interest from last timestamp till now  + any unpaid interest that has accumulated\n        return elapsedTime.mulWadDown(interestAPR.mulWadDown(principalOwed)) + accumulated_interest ; \n    }\n\n    event Drawdown(uint256 amount);\n    /// @notice Allows a borrower to borrow on their creditline.\n    /// This creditline allows only lump sum drawdowns, all approved principal needs to be borrowed\n    /// which would start the interest timer \n    function drawdown() external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n        require(loanStatus == LoanStatus.approvedNotDrawdowned, \"Already borrowed\"); \n        loanStatus = LoanStatus.drawdowned; \n\n        drawdown_block = block.timestamp; \n        lastRepaymentTime = block.timestamp;//-31536000/2; \n\n        totalOwed = principal + notionalInterest; \n        principalOwed = principal; \n        interestOwed = notionalInterest;\n\n        transfer_liq(msg.sender, principal); \n\n        emit Drawdown(principal);\n    }\n\n    event Repay(uint256 amount);\n    /// @notice allows a borrower to repay their loan\n    /// Standard repayment structure is repaying interest for the owed principal periodically and\n    /// whenever principal is repayed interest owed is decreased proportionally \n    function repay( uint256 _repay_amount) external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n\n        uint256 owedInterest = interestToRepay(); \n        uint256 repay_principal; \n        uint256 repay_interest = _repay_amount; \n\n        // Push remaineder to repaying principal \n        if (_repay_amount >= owedInterest){\n            repay_principal += (_repay_amount - owedInterest);  \n            repay_interest = owedInterest; \n            accumulated_interest = 0; \n        }\n\n        //else repay_amount is less than owed interest, accumulate the debt \n        else accumulated_interest = owedInterest - repay_interest;\n\n        if(handleRepay(repay_principal, repay_interest)){\n\n            // Save resolve block, so that onMaturity can be called later\n            resolveBlock = block.number; \n\n            // Prepayment //TODO cases where repayed a significant portion at the start but paid rest at maturity date\n            if (isPaymentPremature()) loanStatus = LoanStatus.prepayment_fulfilled; \n\n            // Repayed at full maturity \n            else loanStatus = LoanStatus.matured; \n\n        }\n\n        lastRepaymentTime = getCurrentTime();  \n\n        transfer_liq_from(msg.sender, address(this), _repay_amount);\n\n        emit Repay(_repay_amount);\n\n    }   \n\n    /// @notice updates balances after repayment\n    /// need to remove min.\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal returns(bool){\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \n        principalOwed -= Math.min(repay_principal, principalOwed);\n        interestOwed -= Math.min(repay_interest, interestOwed);\n\n        principalRepayed += repay_principal;\n        interestRepayed += repay_interest; \n        if (repay_principal > 0) adjustInterestOwed(); \n\n        bool fullyRepayed = (principalOwed == 0 && interestOwed == 0)? true : false; \n        return fullyRepayed; \n    }\n\n    function setGracePeriod() external {}\n\n    /// @notice callable by anyone \n    function beginGracePeriod() external {\n       // require(block.timestamp >= drawdown_block + toSeconds(duration), \"time err\"); \n        require(principalOwed > 0 && interestOwed > 0, \"repaid\"); \n        gracePeriodStart = block.timestamp; \n        loanStatus = LoanStatus.grace_period; \n    }\n\n    function declareDefault() external onlyAuthorized {\n       // require(gracePeriodStart + gracePeriod >= block.timestamp);\n        require(loanStatus == LoanStatus.grace_period); \n\n        loanStatus = LoanStatus.isDefault; \n    }\n\n    /// @notice should be called  at default by validators\n    /// calling this function will go thorugh the necessary process\n    /// to recoup bad debt, and will push the remaining funds to vault\n    function onDefault() external onlyAuthorized{\n        require(loanStatus == LoanStatus.isDefault); \n\n        // If collateral is liquidateable, liquidate at dex and push to vault\n        if (isLiquidatable(collateral)) {\n            liquidateAndPushToVault(); //TODO get pool \n        }\n\n        // Else for non liquid governance tokens or ownership, should auction off \n        else {\n            auctionAndPushToVault(); \n        }\n\n        //Testing purposes only \n        underlying.transferFrom(msg.sender, address(this), principal/2); \n\n    }\n\n    /// @notice when principal/interest owed becomes 0, need to find out if this is prepaid\n    function isPaymentPremature() internal returns(bool){\n        // bool timeCondition = getCurrentTime() <= drawdown_block + toSeconds(duration); \n        bool amountCondition = (principal+notionalInterest) > (principalRepayed + interestRepayed) + DUST; \n\n        // timeCondition implies amountCondition, but not the other way around \n        return amountCondition; \n    }\n\n\n    function toYear(uint256 sec) internal pure returns(uint256){\n        return (sec*1e18)/uint256(31536000); \n    }\n\n    function toSeconds(uint256 y) internal pure returns(uint256){\n        return uint256(31536000).mulWadDown(y); \n    }\n\n    function getRemainingOwed() public view returns(uint256, uint256){\n        return(principalOwed, interestOwed); \n    }\n\n    function getCurrentLoanStatus() public view returns(uint256){}\n\n\n\n\n\n}\n\n\ncontract Proxy{\n    address owner; \n    address delegator; \n\n    address[] public ownedContracts;\n    mapping(address=>bytes4) public ownerTransferFunctions; \n    mapping(address=>bool) public isValidContract; \n\n    /// @notice owner is first set to be the instrument contract\n    /// and is meant to be changed back to the borrower or whoever is\n    /// buying the ownership \n    constructor(address _owner, address _delegator){\n        owner = _owner; \n        delegator = _delegator; \n\n    }\n\n    function changeOwnership(address newOwner) external {\n        require(msg.sender == owner, \"Not owner\"); \n        owner = newOwner; \n    }\n\n    function numContracts() public view returns(uint256){\n        return ownedContracts.length; \n    }\n\n    /// @notice temporarily delegate ownership of relevant contract \n    /// to this address, and stores the ownership transfering function\n    /// called when initialized\n    /// @param ownershipFunction is selector of the functions that transfers\n    /// ownership \n    /// @dev called by the borrower during assessment, after they had given ownership \n    /// of the contract to this address first, \n    /// but ownerTransferfunction/contract needs to be checked before approval by the validators\n    /// Validators are responsible for checking if there isn't any other ownership transferring functions \n    /// and check that the contract is legit, and think ways that the borrower can game the system. \n    function delegateOwnership(\n        address _contract, \n        bytes4 ownershipFunction) external \n    {\n        ownedContracts.push(_contract); \n        isValidContract[_contract] = true; \n        ownerTransferFunctions[_contract] = ownershipFunction; \n\n    }\n\n    /// @notice transfers ownership to borrower or any other party if necessary\n    function grantOwnership(\n        address _contract, \n        address newOwner,\n        bytes calldata data, \n        bool isSingleArgument) external{   \n        require(msg.sender == owner);\n        require(isValidContract[_contract]);\n        if(newOwner != address(this)) isValidContract[_contract] = false; \n\n        if(isSingleArgument){\n            (bool success, ) = _contract.call(\n                abi.encodeWithSelector(\n                    ownerTransferFunctions[_contract], \n                    newOwner\n                )\n            );  \n            require(success, \"!success\"); \n        }\n\n        else{\n            require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \"func not allowed\"); \n            (bool success, ) = _contract.call(data);\n            require(success, \"!success\"); \n\n        }\n    }\n\n    /// @notice function that ownership delegators use to call functions \n    /// in their contract other than the transferFunction contract \n    function proxyFunc(address _contract, bytes calldata data) external{\n        require(msg.sender == delegator); \n        require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \"func not allowed\"); \n\n        (bool success, ) = _contract.call(data); \n        require(success, \"!success\"); \n\n    }\n\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\n        if (inBytes.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            outBytes4 := mload(add(inBytes, 4))\n        }\n    }\n\n    function getOwner() public view returns(address){\n        return owner; \n    }\n}\n\n\ncontract MockBorrowerContract{\n\n    address public owner; \n    constructor(){\n        owner = msg.sender;  \n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == owner, \"notowner\"); \n        owner = newOwner; \n    } \n\n    function onlyOwnerFunction(uint256 a) public {\n        console.log('msgsender', msg.sender, owner); \n        require(msg.sender == owner, \"notowner\"); \n        console.log('hello', a); \n    }\n\n    function autoDelegate(address proxyad) public {\n        Proxy(proxyad).delegateOwnership(address(this), this.changeOwner.selector); \n    }\n    fallback () external {\n        console.log('hi?'); \n    }\n}\n"
    },
    "contracts/vaults/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\n// import {ERC20} from \"../../ERC20/ERC20.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    uint immutable underlying_decimals; \n    uint8 constant default_decimals = 18; \n    bool public decimal_mismatch; \n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, default_decimals) {\n        asset = _asset;\n\n        underlying_decimals = _asset.decimals(); \n        decimal_mismatch = (_asset.decimals() != default_decimals);\n        if(decimal_mismatch) assert(_asset.decimals() < default_decimals);  \n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function burn(uint256 shares) public virtual {\n        _burn(msg.sender, shares);\n    }\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \n                : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if(decimal_mismatch) shares = decSharesToAssets(shares); \n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \n                : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \n                : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \n\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \n                : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    function decAssetsToShares(uint256 assets) public view virtual returns(uint256) {\n        return assets * (10 ** (default_decimals - underlying_decimals)); \n    }\n\n    function decSharesToAssets(uint256 shares) public view virtual returns(uint256){\n        return shares / (10**(default_decimals - underlying_decimals)); \n    }\n}\n"
    },
    "contracts/vaults/nftLending.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport \"./vault.sol\";\n// import {ERC20} from \"./tokens/ERC20.sol\";\n// import {ERC4626} from \"./mixins/ERC4626.sol\"; \nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\n// import {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {ERC721} from \"./tokens/ERC721.sol\"; \n\n// Need to be \n// 1. quick to borrow\n// 2. can add new nft to borrow through longZCB governance \n// 3. managers underwrite and absorb loss \n// 4. liquidatation thorugh auctions or managers buy \n// 5. \n// THINK of a system where managers approve a criterion and profit\n// from all investment from these criterion. \n// Instance generated for a new ERC721 \n\n/// @notice people can submit an NFT collateral\n/// from a predtermined set\ncontract SimpleNFTPool is Instrument, ERC4626{\n\n    using FixedPointMathLib for uint256; \n\n    constructor(\n        address _vault,\n        address _utilizer, \n        address _underlying \n        \n        ) Instrument(_vault, _utilizer) ERC4626(ERC20(_underlying),\"Mock\", \"Mock\" ){\n        utilizer = _utilizer; \n        underlying = ERC20(_underlying); // already specified \n        \n    }\n\n    mapping(bytes32=> bool )public  accepted; \n    bytes32[] acceptedList; \n    address public utilizer;  \n\n    function borrowAllowed() public returns(bool){\n        return true; \n    }\n    function totalAssets() public view override returns (uint256){\n        return asset.balanceOf(address(this)); \n    }\n    function borrow(\n        address tokenAddress,\n        uint256 tokenId, \n        uint256 borrowAmount) external{\n        borrowAllowed();\n        require(accepted[keccak256(abi.encodePacked(tokenAddress, tokenId))], \"Unaccepted\"); \n\n        ERC721(tokenAddress).transferFrom(msg.sender, address(this), tokenId); \n        ERC20(underlying).transfer(msg.sender, borrowAmount ); \n\n    }\n\n    function repay(\n        address tokenAddress,\n        uint256 tokenId, \n        uint256 repayAmount\n        ) external{\n        require(accepted[keccak256(abi.encodePacked(tokenAddress, tokenId))], \"Unaccepted\"); \n        ERC20(underlying).transferFrom(msg.sender, address(this), repayAmount); \n        ERC721(tokenAddress).transferFrom(address(this), msg.sender, tokenId); \n    }\n\n    function addAcceptableCollateral(address tokenAddress, uint256 tokenId) external{\n        bytes32 key = keccak256(abi.encodePacked(tokenAddress, tokenId)); \n        accepted[key] = true;\n        acceptedList.push(key); \n    }\n\n    function instrumentApprovalCondition() public override view returns(bool){\n        return true; \n    }\n    function assetOracle(uint256 supply) public view override returns(uint256){\n        return supply; \n    }\n\n\n\n    \n\n}  \n\n\n\n\n\n\n\n\n\n\n"
    },
    "contracts/vaults/pvault.sol": {
      "content": "pragma solidity ^0.8.4;\n\n    struct ResolveVar{\n        uint256 endBlock; \n        bool isPrepared; \n    }\n// import {Auth} from \"./auth/Auth.sol\";\n// import {ERC4626} from \"./mixins/ERC4626.sol\";\n\n// import {SafeCastLib} from \"./utils/SafeCastLib.sol\";\n// import {SafeTransferLib} from \"./utils/SafeTransferLib.sol\";\n// import {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\n\n// import {ERC20} from \"./tokens/ERC20.sol\";\n// import {Instrument} from \"./instrument.sol\";\n// import {Controller} from \"../protocol/controller.sol\";\n// import {MarketManager} from \"../protocol/marketmanager.sol\"; \n// import \"openzeppelin-contracts/utils/math/Math.sol\";\n// import \"forge-std/console.sol\";\n\n// /// @notice Vault where its instrument is lending for investors to mint\n// /// vaults with leverage. No l\n// contract LeverageVault is ERC4626{\n//     using SafeCastLib for uint256; \n//     using SafeTransferLib for ERC20;\n//     using FixedPointMathLib for uint256;\n\n//     uint256 internal BASE_UNIT;\n//     uin\n// }\n// contract LeverageVault is ERC4626, Auth{\n//     using SafeCastLib for uint256; \n//     using SafeTransferLib for ERC20;\n//     using FixedPointMathLib for uint256;\n\n\n//     event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n//     event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n//     event InstrumentTrusted(address indexed user, Instrument indexed instrument);\n//     event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\n//     event InstrumentHarvest(address indexed instrument, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\n\n//     /*///////////////////////////////////////////////////////////////\n//                                  CONSTANTS\n//     //////////////////////////////////////////////////////////////*/\n\n//     uint256 internal BASE_UNIT;\n//     uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\n//     ERC20 public immutable UNDERLYING;\n//     Controller private controller;\n//     MarketManager.MarketParameters default_params; \n\n//     ///// For Factory\n//     bool public onlyVerified; \n//     uint256 public r; //reputation ranking  \n//     uint256 public asset_limit; \n//     uint256 public total_asset_limit; \n\n//     mapping(Instrument => InstrumentData) public instrument_data;\n//     mapping(address => uint256) public  num_proposals;\n//     mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\n//     mapping(uint256 => bool) resolveBeforeMaturity;\n//     mapping(uint256=>ResolveVar) prepareResolveBlock;\n\n//     enum InstrumentType {\n//         CreditLine,\n//         CoveredCall,\n//         Other\n//     }\n\n//     /// @param trusted Whether the Instrument is trusted.\n//     /// @param balance The amount of underlying tokens held in the Instrument.\n//     struct InstrumentData {\n//         // Used to determine if the Vault will operate on a Instrument.\n//         bool trusted;\n//         // Balance of the contract denominated in Underlying, \n//         // used to determine profit and loss during harvests of the Instrument.  \n//         // represents the amount of debt the Instrument has incurred from this vault   \n//         uint256 balance; // in underlying\n//         uint256 faceValue; // in underlying\n//         uint256 marketId;\n//         uint256 principal; //this is total available allowance in underlying\n//         uint256 expectedYield; // total interest paid over duration in underlying\n//         uint256 duration;\n//         string description;\n//         address Instrument_address;\n//         InstrumentType instrument_type;\n//         uint256 maturityDate;\n//     }\n\n//     struct ResolveVar{\n//         uint256 endBlock; \n//         bool isPrepared; \n//     }\n\n//     constructor(\n//         address _UNDERLYING,\n//         address _controller, \n//         address owner, \n\n//         bool _onlyVerified, //\n//         uint256 _r, //reputation ranking\n//         uint256 _asset_limit, \n//         uint256 _total_asset_limit,\n\n//         MarketManager.MarketParameters memory _default_params\n\n//     )\n//         ERC4626(\n//             ERC20(_UNDERLYING),\n//             string(abi.encodePacked(\"debita \", ERC20(_UNDERLYING).name(), \" Vault\")),\n//             string(abi.encodePacked(\"db\", ERC20(_UNDERLYING).symbol()))\n//         )  Auth(owner)\n\n//     {\n//         UNDERLYING = ERC20(_UNDERLYING);\n//         //BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\n//         BASE_UNIT = 10**18; \n//         controller = Controller(_controller);\n//         set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \n//         default_params = _default_params; \n//         //totalSupply = type(uint256).max;\n//     }\n\n//     function getInstrumentType(uint256 marketId) public view returns(uint256){\n//         // return 0 if credit line //TODO \n//         return 0; \n//     }\n\n//     function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\n//         return instrument_data[_instrument];\n//     }\n    \n//     modifier onlyController(){\n//         require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \"is not controller\"); \n//         _;\n//     }\n\n//     /// @notice called by controller at maturity \n//     function controller_burn(uint256 amount, address bc_address) external onlyController {\n//         _burn(bc_address,amount); \n//     }\n//     /// @notice called by controller at maturity, since redeem amount > balance in bc\n//     function controller_mint(uint256 amount, address to) external onlyController {\n//         _mint(to , amount); \n//     }\n//     /// @notice amount is always in WAD, so need to convert if decimals mismatch\n//     function trusted_transfer(uint256 amount, address to) external onlyController{\n//         if (decimal_mismatch) amount = decSharesToAssets(amount); \n//         UNDERLYING.transfer(to, amount); \n//     }\n\n//     function balanceInUnderlying(address ad) external view returns(uint256){\n//         return previewRedeem(balanceOf[ad]); \n//     }\n\n//     /// @notice burns all balance of address \n//     function burnAll(address to) private{\n//       _burn(to, balanceOf[to]); \n//     }\n\n//     /// @notice Harvest a trusted Instrument, records profit/loss \n//     function harvest(address instrument) public {\n//         require(instrument_data[Instrument(instrument)].trusted, \"UNTRUSTED_Instrument\");\n//         InstrumentData storage data = instrument_data[Instrument(instrument)]; \n\n//         uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n        \n//         uint256 balanceLastHarvest = data.balance;\n        \n//         uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\n        \n//         if (balanceLastHarvest == balanceThisHarvest) {\n//             return;\n//         }\n        \n//         data.balance = balanceThisHarvest;\n\n//         uint256 delta;\n       \n//         bool net_positive = balanceThisHarvest >= balanceLastHarvest;\n        \n//         delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\n\n//         totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\n\n//         emit InstrumentHarvest(instrument, balanceThisHarvest, delta, net_positive);\n//     }\n\n//     /// @notice Deposit a specific amount of float into a trusted Instrument.\n//     /// Called when market is approved. \n//     /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n//     function depositIntoInstrument(uint256 marketId, uint256 underlyingAmount) internal{\n//       Instrument instrument = fetchInstrument(marketId); \n//       require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n\n//       if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n//       if (underlyingAmount > UNDERLYING.balanceOf(address(this))) revert(\"Not enough bal in vault\"); \n//       console.log('deposit amount and current balance', underlyingAmount, UNDERLYING.balanceOf(address(this)));\n\n//       totalInstrumentHoldings += underlyingAmount; \n\n//       instrument_data[instrument].balance += underlyingAmount;\n\n//       require(UNDERLYING.transfer(address(instrument), underlyingAmount), \"DEPOSIT_FAILED\");\n\n//       emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\n//     }\n\n//     /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n//     function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) internal {\n//       require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n      \n//       if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n//       instrument_data[instrument].balance -= underlyingAmount;\n      \n//       totalInstrumentHoldings -= underlyingAmount;\n      \n//       require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n      \n//       emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\n\n//     }\n\n//     /// @notice Stores a Instrument as trusted when its approved\n//     function trustInstrument(uint256 marketId, Controller.ApprovalData memory data) external onlyController{\n//       instrument_data[fetchInstrument(marketId)].trusted = true;\n\n//       //Write to storage \n//       InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \n//       instrumentData.principal = data.approved_principal; \n//       instrumentData.expectedYield = data.approved_yield;\n//       instrumentData.faceValue = data.approved_principal + data.approved_yield; \n\n//       depositIntoInstrument(marketId, data.approved_principal);\n    \n//       setMaturityDate(marketId);\n\n//       fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \n//     }\n\n//     /// @notice Stores a Instrument as untrusted\n//     function distrustInstrument(Instrument instrument) external onlyController {\n//       instrument_data[instrument].trusted = false; \n//     }\n\n\n//     /// @notice returns true if Instrument is approved\n//     function isTrusted(Instrument instrument) public view returns(bool){\n//       return instrument_data[instrument].trusted; \n//     }\n\n//     /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n//     function totalAssets() public view override returns(uint256){\n//       return totalInstrumentHoldings + totalFloat();\n//     }\n\n//     function utilizationRate() public view returns(uint256){\n\n//         if (totalInstrumentHoldings==0) return 0;  \n//         return totalInstrumentHoldings.divWadDown(totalAssets()); \n\n//     }\n//     function totalFloat() public view returns (uint256) {\n//         return UNDERLYING.balanceOf(address(this));\n//     }\n\n//     function fetchInstrument(uint256 marketId) public view returns(Instrument){\n//       return Instruments[marketId]; \n//     }\n\n//     function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n//         return instrument_data[Instruments[marketId]];\n//     }\n//     /**\n//      called on market denial + removal, maybe no chekcs?\n//      */\n//     function removeInstrument(uint256 marketId) internal {\n//         InstrumentData storage data = instrument_data[Instruments[marketId]];\n//         require(data.marketId > 0, \"instrument doesn't exist\");\n//         delete instrument_data[Instruments[marketId]];\n//         delete Instruments[marketId];\n//         // emit event here;\n//     }\n\n\n\n//     /// @notice add instrument proposal created by the Utilizer \n//     /// @dev Instrument instance should be created before this is called\n//     /// need to add authorization\n//     function addProposal(\n//         InstrumentData memory data\n//     ) external onlyController {\n//         require(data.principal > 0, \"principal must be greater than 0\");\n//         require(data.duration > 0, \"duration must be greater than 0\");\n//         require(data.faceValue > 0, \"faceValue must be greater than 0\");\n//         require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); \n//         require(data.marketId > 0, \"must be valid instrument\");\n\n//         num_proposals[msg.sender] ++; \n\n//         instrument_data[Instrument(data.Instrument_address)] = (\n//           InstrumentData(\n//             false, \n//                 0, \n//                 data.faceValue, \n//                 data.marketId, \n//                 data.principal, \n//                 data.expectedYield, \n//                 data.duration, \n//                 data.description, \n//                 data.Instrument_address,\n//                 data.instrument_type,\n//                 0\n//             )\n//         ); \n\n//         Instruments[data.marketId] = Instrument(data.Instrument_address);\n//         assert(data.marketId !=0); \n//     }\n\n//     /**\n//      @notice called by controller on approveMarket.\n//      */\n//     function setMaturityDate(uint256 marketId) internal {\n\n//         instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n//     }\n\n//     /// @notice function called when instrument resolves from within\n//     function pingMaturity(address instrument, bool premature) external {\n//         require(msg.sender == instrument || isTrusted(Instrument(instrument))); \n//         uint256 marketId = instrument_data[Instrument(instrument)].marketId; \n//         beforeResolve(marketId); \n//         resolveBeforeMaturity[marketId] = premature; \n//     }\n\n\n//     /// @notice RESOLVE FUNCTION #1\n//     /// Checks if instrument is ready to be resolved and locks capital.\n//     /// records blocknumber such that resolveInstrument is called after this function \n//     /// records balances+PnL of instrument\n//     /// @dev need to store internal balance that is used to calculate the redemption price \n//     function beforeResolve(uint256 marketId) public {\n//         Instrument _instrument = Instruments[marketId]; \n\n//         require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n//         require(isTrusted( _instrument), \"Not trusted\"); \n\n//         // Should revert if can't be resolved \n//         _instrument.prepareWithdraw(); \n\n//         // Record profit/loss used for calculation of redemption price \n//         harvest(address(_instrument));\n\n//         _instrument.store_internal_balance(); \n//         prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \n//       }\n\n//     /// @notice RESOLVE FUNCTION #2\n//     /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \n//     /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\n//     function resolveInstrument(\n//         uint256 marketId\n//     ) external onlyController\n//     returns(bool, uint256, uint256, bool) {\n//         Instrument _instrument = Instruments[marketId];\n//         ResolveVar memory rvar = prepareResolveBlock[marketId]; \n//         require(_instrument.isLocked(), \"Not Locked\");\n//         require(rvar.isPrepared && rvar.endBlock < block.number, \"can't resolve\"); \n\n//         uint256 bal = UNDERLYING.balanceOf(address(this)); \n//         uint256 instrument_balance = _instrument.getMaturityBalance(); \n\n//         InstrumentData memory data = instrument_data[_instrument];\n\n//         bool prematureResolve = resolveBeforeMaturity[marketId]; \n//         bool atLoss; \n//         uint256 total_loss; \n//         uint256 extra_gain; \n\n//         // If resolved at predetermined maturity date, loss is defined by\n//         // the event the instrument has paid out all its yield + principal \n//         if (!prematureResolve){\n//             atLoss = instrument_balance < data.faceValue;\n//             total_loss = atLoss ? data.faceValue - instrument_balance : 0;\n//             extra_gain = !atLoss ? instrument_balance - data.faceValue : 0;\n//             console.log(data.faceValue);  \n//         }\n\n//         // If resolved before predetermined maturity date, loss is defined by \n//         // the event the instrument has balance less then principal \n//         else {\n//             atLoss = instrument_balance < data.principal; \n//             total_loss = atLoss? data.principal - instrument_balance :0; \n//         }\n\n//         withdrawFromInstrument(_instrument, instrument_balance);\n//         removeInstrument(data.marketId);\n\n//         return(atLoss, extra_gain, total_loss, prematureResolve); \n//     }\n\n//     /// @notice when market resolves, send back pulled collateral from managers \n//     function repayDebt(address to, uint256 amount) external onlyController{\n//         UNDERLYING.transfer(to, amount); \n//     }\n\n//     /**\n//      called on market denial by controller.\n//      */\n//     function denyInstrument(uint256 marketId) external onlyController {\n//         InstrumentData storage data = instrument_data[Instruments[marketId]];\n\n//         require(marketId > 0 && data.Instrument_address != address(0), \"invalid instrument\");\n\n//         require(!data.trusted, \"can't deny approved instrument\");\n        \n//         removeInstrument(marketId);\n//     }\n\n\n//     function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\n//       return Instruments[marketId].instrumentApprovalCondition(); \n//     }\n\n\n//     /// TODO \n//     function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\n//       return amount; \n//     }\n\n\n//     /// @notice types of restrictions are: \n//     /// a) verified address b) reputation scores \n//     function receiver_conditions(address receiver) public view returns(bool){\n//         return true; \n//     }\n\n//     /// @notice called when constructed, params set by the creater of the vault \n//     function set_minting_conditions(\n//       bool _onlyVerified, \n//       uint256 _r, \n//       uint256 _asset_limit,\n//       uint256 _total_asset_limit) internal{\n//         onlyVerified = _onlyVerified; \n//         r = _r; \n//         asset_limit = _asset_limit; \n//         total_asset_limit = _total_asset_limit; \n//     } \n\n\n//     function get_vault_params() public view returns(MarketManager.MarketParameters memory){\n//       return default_params; \n//     }\n\n\n//     function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n//       require(enoughLiqudity(assets), \"Not enough liqudity in vault\"); \n\n//     }\n\n//     /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\n//     /// (excluding those supplied to existing instruments)\n//     /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\n//     /// should be (soft)maxed and tunable by a parameter \n//     function enoughLiqudity(uint256 amounts) public view returns(bool){\n//         return (UNDERLYING.balanceOf(address(this)) >= amounts); \n//     }\n\n\n//     /// @notice function that closes instrument prematurely \n//     function closeInstrument(uint256 marketId) external onlyController{\n//       Instrument instrument = fetchInstrument( marketId); \n\n//       // If instrument has non-underlying tokens, liquidate them first. \n//       instrument.liquidateAllPositions(); \n\n//     }\n\n//     function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\n//         InstrumentData memory data = instrument_data[Instruments[marketId]];\n//         return (data.principal, data.expectedYield); \n//     }\n\n//     /// @notice a minting restrictor is set for different vaults \n//     function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\n//         if (!receiver_conditions(receiver)) revert(\"Minting Restricted\"); \n//         assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n//         // Need to transfer before minting or ERC777s could reenter.\n//         asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n//         _mint(receiver, shares);\n\n//         emit Deposit(msg.sender, receiver, assets, shares);\n\n//         afterDeposit(assets, shares);\n//     }\n\n\n//     /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \n//      function redeem(\n//         uint256 shares,\n//         address receiver,\n//         address owner\n//     ) public virtual override returns (uint256 assets) {\n//         if (msg.sender != owner) {\n//             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n//             if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n//         }\n\n//         // Check for rounding error since we round down in previewRedeem.\n//         require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n//         beforeWithdraw(assets, shares);\n\n//         assets = deduct_withdrawal_fees(assets); \n\n//         _burn(owner, shares);\n\n//         emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n//         asset.safeTransfer(receiver, assets);\n//     }\n\n\n\n// //deprecated\n//     /// @notice RESOLVE FUNCTION #1\n//     /// checks if instrument is ready to be resolved\n//     /// and locks capital inside the instrument \n//     /// @dev resolving is separated into three tx \n//     /// prepareResolve->beforeResolve->resolveinstrument\n//     function prepareResolve(uint256 marketId) public {\n//         Instrument _instrument = Instruments[marketId]; \n\n//         require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n//         require(isTrusted( _instrument), \"Not trusted\"); \n\n//         // This will check if instrument is ready to be resolved (i.e all debts payed, investments liquidated, etc)\n//         // and lock further drawdowns or usage of capital \n//         _instrument.prepareWithdraw(); \n//     }\n\n// }"
    },
    "contracts/vaults/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/vaults/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/vaults/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/vaults/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "contracts/vaults/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "contracts/vaults/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/vaults/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/vaults/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "contracts/vaults/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/vaults/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/vaults/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    },
    "contracts/vaults/vault.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {Auth} from \"./auth/Auth.sol\";\nimport {ERC4626} from \"lib/solmate/src/mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\";\nimport {Controller} from \"../protocol/controller.sol\";\nimport {MarketManager} from \"../protocol/marketmanager.sol\"; \nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\nimport \"../global/types.sol\"; \n\n\ncontract Vault is ERC4626{\n    using SafeCastLib for uint256; \n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n\n    /*///////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal BASE_UNIT;\n    uint256 public totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\n    ERC20 public immutable UNDERLYING;\n    Controller private controller;\n    MarketParameters default_params; \n    string public description;\n\n    ///// For Factory\n    bool public onlyVerified; \n    uint256 public r; //reputation ranking  \n    uint256 public asset_limit; \n    uint256 public total_asset_limit; \n\n    mapping(Instrument => InstrumentData) public instrument_data;\n    // mapping(address => uint256) public  num_proposals;\n    mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\n    mapping(uint256 => bool) resolveBeforeMaturity;\n    mapping(uint256=>ResolveVar) prepareResolveBlock;\n\n    enum InstrumentType {\n        CreditLine,\n        CoveredCallShort,\n        LendingPool, \n        StraddleBuy,\n        LiquidityProvision, \n        Other\n    }\n\n    address public owner; \n\n    constructor(\n        address _UNDERLYING,\n        address _controller, \n        address _owner,\n        bytes memory _configData,\n        MarketParameters memory _default_params\n    )\n        ERC4626(\n            ERC20(_UNDERLYING),\n            string(abi.encodePacked(\"Ramm \", ERC20(_UNDERLYING).name(), \" Vault\")),\n            string(abi.encodePacked(\"RAMM\", ERC20(_UNDERLYING).symbol()))\n        )  \n\n    {\n          \n        (\n            bool _onlyVerified, \n            uint256 _r, \n            uint256 _asset_limit, \n            uint256 _total_asset_limit,\n            string memory _description\n        ) = abi.decode(_configData, (bool, uint256, uint256, uint256, string));\n        description = _description;\n        owner = _owner; \n        UNDERLYING = ERC20(_UNDERLYING);\n        require(UNDERLYING.decimals() == 18, \"decimals\"); \n        BASE_UNIT = 1e18; \n        controller = Controller(_controller);\n        //set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \n        onlyVerified = _onlyVerified; \n        r = _r; \n        asset_limit = _asset_limit; \n        total_asset_limit = _total_asset_limit; \n        default_params = _default_params; \n    }\n\n    function getInstrumentType(uint256 marketId) public view returns(uint256){\n        // return 0 if credit line //TODO \n        return 0; \n    }\n\n    function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\n        return instrument_data[_instrument];\n    }\n    \n    function _onlyController() view internal {\n        require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \"is not controller\"); \n    }\n\n    modifier onlyController(){\n        _onlyController();\n        _;\n    }\n\n    /// @notice amount is always in WAD, so need to convert if decimals mismatch\n    function trusted_transfer(uint256 amount, address to) external onlyController{\n        UNDERLYING.transfer(to, amount); \n    }\n\n    function modifyInstrumentHoldings(bool up, uint256 amount) external onlyController{\n      if(up) totalInstrumentHoldings += amount;\n      else totalInstrumentHoldings -= amount; \n    }\n\n    function balanceInUnderlying(address ad) external view returns(uint256){\n        return previewRedeem(balanceOf[ad]); \n    }\n\n    event InstrumentHarvest(address indexed instrument, uint256 totalInstrumentHoldings, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\n\n    /// @notice Harvest a trusted Instrument, records profit/loss \n    function harvest(address instrument) public {\n      require(instrument_data[Instrument(instrument)].trusted, \"UNTRUSTED_Instrument\");\n      InstrumentData storage data = instrument_data[Instrument(instrument)]; \n\n      uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n      uint256 balanceLastHarvest = data.balance;\n      uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\n      \n      if (balanceLastHarvest == balanceThisHarvest) {\n          return;\n      }\n\n      data.balance = balanceThisHarvest;\n\n      uint256 delta;\n      bool net_positive = balanceThisHarvest >= balanceLastHarvest;\n      delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\n      totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\n\n      emit InstrumentHarvest(instrument, totalInstrumentHoldings, balanceThisHarvest, delta, net_positive);\n    }\n\n    event InstrumentDeposit(uint256 indexed marketId, address indexed instrument, uint256 amount, bool isPool);\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\n    /// Called when market is approved. \n    /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n    function depositIntoInstrument(\n      uint256 marketId, \n      uint256 underlyingAmount,\n      bool isPerp) onlyTrustedInstrument(fetchInstrument(marketId)) public virtual\n  //onlyManager\n    {\n      Instrument instrument = fetchInstrument(marketId); \n      uint256 curBalance = UNDERLYING.balanceOf(address(this)); \n\n      totalInstrumentHoldings += underlyingAmount; \n      instrument_data[instrument].balance += underlyingAmount;\n\n      if(!isPerp) require(UNDERLYING.transfer(address(instrument), underlyingAmount), \"DEPOSIT_FAILED\");\n      else{\n        // TODO keep track of all this \n        UNDERLYING.approve(address(instrument), underlyingAmount); \n        require(ERC4626(address(instrument)).deposit(underlyingAmount, address(this))>0, \"DEPOSIT_FAILED\");\n      }\n\n      emit InstrumentDeposit(marketId, address(instrument), underlyingAmount, isPerp);\n    }\n\n    modifier onlyTrustedInstrument(Instrument instrument) {\n      _onlyTrustedInstrument(instrument);\n      _;\n    }\n\n    function _onlyTrustedInstrument(Instrument instrument) internal view {\n      require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n    }\n\n    event InstrumentWithdrawal(uint256 indexed marketId, address indexed instrument, uint256 amount);\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n    function withdrawFromInstrument(\n      Instrument instrument, \n      uint256 underlyingAmount, \n      bool redeem\n      ) onlyTrustedInstrument(instrument) internal virtual {\n\n      instrument_data[instrument].balance -= underlyingAmount;\n      \n      totalInstrumentHoldings -= underlyingAmount;\n      console.log('redeemamount', underlyingAmount); \n      if (redeem) require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n\n      emit InstrumentWithdrawal(instrument_data[instrument].marketId, address(instrument), underlyingAmount);\n    }\n\n    function withdrawFromPoolInstrument(\n      uint256 marketId, \n      uint256 instrumentPullAmount, \n      address pushTo, \n      uint256 underlyingAmount\n      ) public virtual \n    //onlyManager\n    { \n      // Send to withdrawer \n      Instrument instrument = fetchInstrument( marketId); \n      require(instrument.isLiquid(underlyingAmount + instrumentPullAmount), \"!liq\");\n\n      ERC4626(address(instrument)).withdraw(underlyingAmount + instrumentPullAmount, address(this), address(this)); \n      UNDERLYING.transfer(pushTo, instrumentPullAmount); \n\n      //TODO instrument balance should decrease to 0 and stay solvent  \n      //TODO can everyone redeem? does vault's instument share balance change when\n      // mint-> redeem at different pjus? \n      withdrawFromInstrument(fetchInstrument(marketId), underlyingAmount, false);\n    }\n\n\n    event InstrumentTrusted(uint256 indexed marketId, address indexed instrument, uint256 principal, uint256 expectedYield, uint256 maturityDate);\n    /// @notice Stores a Instrument as trusted when its approved\n    function trustInstrument(\n      uint256 marketId,\n      ApprovalData memory data, \n      bool isPool\n      ) external virtual onlyController{\n      instrument_data[fetchInstrument(marketId)].trusted = true;\n\n      //Write to storage \n      if(!isPool){\n        InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \n        instrumentData.principal = data.approved_principal; \n        instrumentData.expectedYield = data.approved_yield;\n        instrumentData.faceValue = data.approved_principal + data.approved_yield; \n\n        depositIntoInstrument(marketId, data.approved_principal - data.managers_stake, false);\n        \n        // setMaturityDate(marketId);\n        instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n\n        fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \n\n      } else{\n        instrument_data[Instruments[marketId]].poolData.inceptionTime = block.timestamp; \n        console.log('from vault', data.approved_principal - data.managers_stake); \n        depositIntoInstrument(marketId, data.approved_principal - data.managers_stake, true);\n      }\n      emit InstrumentTrusted(marketId, address(Instruments[marketId]), data.approved_principal, data.approved_yield, instrument_data[fetchInstrument(marketId)].maturityDate);\n    }\n\n    /// @notice fetches how much asset the instrument has in underlying. \n    function instrumentAssetOracle(\n      uint256 marketId, \n      uint256 juniorSupply, \n      uint256 seniorSupply) public view returns(uint256){\n      // Default balance oracle \n      ERC4626 instrument = ERC4626(address(Instruments[marketId])); \n      return (juniorSupply + seniorSupply).mulWadDown(instrument.previewMint(BASE_UNIT)); \n      //TODO custom oracle \n    }\n\n    /// @notice Stores a Instrument as untrusted\n    // not needed?\n    function distrustInstrument(Instrument instrument) external onlyController {\n      instrument_data[instrument].trusted = false; \n    }\n\n    /// @notice returns true if Instrument is approved\n    function isTrusted(Instrument instrument) public view returns(bool){\n      return instrument_data[instrument].trusted; \n    }\n\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n    function totalAssets() public view override returns(uint256){\n      return totalInstrumentHoldings + totalFloat();\n    }\n\n    function utilizationRate() public view returns(uint256){\n        if (totalInstrumentHoldings==0) return 0;  \n        return totalInstrumentHoldings.divWadDown(totalAssets()); \n    }\n\n    function utilizationRateAfter(uint256 amount) public view returns(uint256){\n      return (totalInstrumentHoldings + amount).divWadDown(totalAssets()); \n    } \n\n    function totalFloat() public view returns (uint256) {\n        return UNDERLYING.balanceOf(address(this));\n    }\n\n    function fetchInstrument(uint256 marketId) public view returns(Instrument){\n      return Instruments[marketId]; \n    }\n\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n      return instrument_data[Instruments[marketId]];\n    }\n\n    function fetchPoolTrancheData(uint256 marketId) public view returns(uint256, uint256, uint256, uint256, uint256){\n      // InstrumentData memory data = instrument_data[Instruments[marketId]]; \n      return (instrument_data[Instruments[marketId]].poolData.promisedReturn, instrument_data[Instruments[marketId]].poolData.inceptionTime, \n            instrument_data[Instruments[marketId]].poolData.inceptionPrice, instrument_data[Instruments[marketId]].poolData.leverageFactor, instrument_data[Instruments[marketId]].poolData.managementFee); \n    }\n  \n    event InstrumentRemoved(uint256 indexed marketId, address indexed instrumentAddress);\n    /**\n     called on market denial + removal, maybe no chekcs?\n     */\n    function removeInstrument(uint256 marketId) internal {\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\n        require(data.marketId > 0, \"instrument doesn't exist\");\n        delete instrument_data[Instruments[marketId]];\n        delete Instruments[marketId];\n        // emit event here;\n        emit InstrumentRemoved(marketId, address(Instruments[marketId]));\n    }\n\n    // event PoolAdded(\n    //   uint256 indexed marketId,\n    //   address indexed instrumentAddress,\n    //   bytes32 indexed name,\n    //   uint256 saleAmount, \n    //   uint256 initPrice, // init price of longZCB in the amm \n    //   uint256 promisedReturn, //per unit time \n    //   uint256 inceptionTime,\n    //   uint256 inceptionPrice, // init price of longZCB after assessment \n    //   uint256 leverageFactor, //leverageFactor * manager collateral = capital from vault to instrument\n    //   uint256 managementFee\n    // );\n\n    // event InstrumentAdded(\n    //   uint256 indexed marketId,\n    //   address indexed instrumentAddress,\n    //   bytes32 indexed name,\n    //   uint256 faceValue,\n    //   uint256 principal,\n    //   uint256 expectedYield,\n    //   uint256 duration,\n    //   uint256 maturityDate,\n    //   InstrumentType instrumentType,\n    //   bool isPool\n    // );\n\n    // event ProposalAdded(InstrumentData data);\n    /// @notice add instrument proposal created by the Utilizer \n    /// @dev Instrument instance should be created before this is called\n    /// need to add authorization\n    function addProposal(\n        InstrumentData memory data\n    ) external onlyController {\n      if(!data.isPool){\n        require(data.principal > 0, \"principal must be greater than 0\");\n        require(data.duration > 0, \"duration must be greater than 0\");\n        require(data.faceValue > 0, \"faceValue must be greater than 0\");\n        require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); \n        require(data.marketId > 0, \"must be valid instrument\");\n      }\n        // num_proposals[msg.sender] ++; \n        // TODO indexed by id\n        instrument_data[Instrument(data.instrument_address)] = data;  \n\n        Instruments[data.marketId] = Instrument(data.instrument_address);\n        // emit ProposalAdded(data);\n    }\n\n    //event MaturityDateSet(uint256 indexed marketId, address indexed instrument, uint256 maturityDate);\n  \n    // function setMaturityDate(uint256 marketId) internal {\n\n    //     instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n    //     emit MaturityDateSet(marketId, address(fetchInstrument(marketId)), instrument_data[fetchInstrument(marketId)].maturityDate);\n    // }\n\n    /// @notice function called when instrument resolves from within\n    function pingMaturity(address instrument, bool premature) external {\n        require(msg.sender == instrument || isTrusted(Instrument(instrument))); \n        uint256 marketId = instrument_data[Instrument(instrument)].marketId; \n        beforeResolve(marketId); \n        resolveBeforeMaturity[marketId] = premature; \n    }\n\n    /// @notice RESOLVE FUNCTION #1\n    /// Checks if instrument is ready to be resolved and locks capital.\n    /// records blocknumber such that resolveInstrument is called after this function \n    /// records balances+PnL of instrument\n    /// @dev need to store internal balance that is used to calculate the redemption price \n    function beforeResolve(uint256 marketId) public {\n        Instrument _instrument = Instruments[marketId]; \n\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n        require(isTrusted( _instrument), \"Not trusted\"); \n\n        // Should revert if can't be resolved \n        _instrument.prepareWithdraw();\n\n        // Record profit/loss used for calculation of redemption price \n        harvest(address(_instrument));\n\n        _instrument.store_internal_balance(); \n        prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \n      }\n\n    //event InstrumentResolve(uint256 indexed marketId, uint256 instrumentBalance, bool atLoss, uint256 extraGain, uint256 totalLoss, bool prematureResolve);\n    /// @notice RESOLVE FUNCTION #2\n    /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \n    /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\n    function resolveInstrument(\n        uint256 marketId\n    ) external onlyController\n    returns(bool, uint256, uint256, bool) {\n        Instrument _instrument = Instruments[marketId];\n        ResolveVar memory rvar = prepareResolveBlock[marketId]; \n        require(_instrument.isLocked(), \"Not Locked\");\n        // require(rvar.isPrepared && rvar.endBlock < block.number, \"can't resolve\"); \n\n        // uint256 bal = UNDERLYING.balanceOf(address(this)); \n        uint256 instrument_balance = _instrument.getMaturityBalance(); \n\n        bool prematureResolve = resolveBeforeMaturity[marketId]; \n        bool atLoss; \n        uint256 total_loss; \n        uint256 extra_gain; \n\n        // If resolved at predetermined maturity date, loss is defined by\n        // the event the instrument has paid out all its yield + principal \n        if (!prematureResolve){\n            atLoss = instrument_balance < instrument_data[_instrument].faceValue;\n            total_loss = atLoss ? instrument_data[_instrument].faceValue - instrument_balance : 0;\n            extra_gain = !atLoss ? instrument_balance - instrument_data[_instrument].faceValue : 0;\n        }\n\n        // If resolved before predetermined maturity date, loss is defined by \n        // the event the instrument has balance less then principal \n        else {\n            atLoss = instrument_balance < instrument_data[_instrument].principal; \n            total_loss = atLoss? instrument_data[_instrument].principal - instrument_balance :0; \n            extra_gain = !atLoss? instrument_balance - instrument_data[_instrument].principal: 0; \n        }\n        console.log('atloss?', instrument_data[_instrument].faceValue, instrument_balance); \n\n        withdrawFromInstrument(_instrument, instrument_balance, true);\n        removeInstrument(instrument_data[_instrument].marketId);\n\n        //emit InstrumentResolve(marketId, instrument_balance, atLoss, extra_gain, total_loss, prematureResolve);\n\n        return(atLoss, extra_gain, total_loss, prematureResolve); \n    }\n\n    /// @notice when market resolves, send back pulled collateral from managers \n    function repayDebt(address to, uint256 amount) external onlyController{\n        UNDERLYING.transfer(to, amount); \n    }\n\n    event InstrumentDeny(uint256 indexed marketId);\n\n    function denyInstrument(uint256 marketId) external onlyController {\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\n\n        require(marketId > 0 && data.instrument_address != address(0), \"invalid instrument\");\n\n        require(!data.trusted, \"can't deny approved instrument\");\n        emit InstrumentDeny(marketId);\n        removeInstrument(marketId);\n    }\n\n\n    function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\n      return Instruments[marketId].instrumentApprovalCondition(); \n    }\n\n    /// TODO \n    function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\n      return amount; \n    }\n\n    /// @notice types of restrictions are: \n    /// a) verified address b) reputation scores \n    function receiver_conditions(address receiver) public view returns(bool){\n        return true; \n    }\n\n    function get_vault_params() public view returns(MarketParameters memory){\n      return default_params; \n    }\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n      require(enoughLiqudity(assets), \"Not enough liqudity in vault\"); \n\n    }\n\n    /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\n    /// (excluding those supplied to existing instruments)\n    /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\n    /// should be (soft)maxed and tunable by a parameter \n    function enoughLiqudity(uint256 amounts) public view returns(bool){\n        return (UNDERLYING.balanceOf(address(this)) >= amounts); \n    }\n\n    /// @notice function that closes instrument prematurely \n    function closeInstrument(uint256 marketId) external onlyController{\n      Instrument instrument = fetchInstrument( marketId); \n\n      // If instrument has non-underlying tokens, liquidate them first. \n      instrument.liquidateAllPositions(); \n    }\n\n    function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\n        // InstrumentData memory data = instrument_data[Instruments[marketId]];\n        return (instrument_data[Instruments[marketId]].principal, instrument_data[Instruments[marketId]].expectedYield); \n    }\n\n    /// @notice a minting restrictor is set for different vaults \n    function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\n        if (!receiver_conditions(receiver)) revert(\"Minting Restricted\"); \n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.transferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \n     function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        assets = deduct_withdrawal_fees(assets); \n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.transfer(receiver, assets);\n    }\n\n\n struct localVars{\n    uint256 promised_return; \n    uint256 inceptionTime; \n    uint256 inceptionPrice; \n    uint256 leverageFactor; \n    uint256 managementFee; \n\n    uint256 srpPlusOne; \n    uint256 totalAssetsHeldScaled; \n    uint256 juniorSupply;\n    uint256 seniorSupply; \n\n    bool belowThreshold; \n  }\n\n  \n\n\n  /// @notice get programmatic pricing of a pool based longZCB \n  /// returns psu: price of senior(VT's share of investment) vs underlying \n  /// returns pju: price of junior(longZCB) vs underlying\n  // TODO inception price needs to be modifyable for changing senior returns \n  function poolZCBValue(uint256 marketId) \n    public \n    view\n    returns(uint256 psu, uint256 pju, uint256 levFactor){\n      //TODO should not tick during assessment \n    localVars memory vars; \n\n    (vars.promised_return, vars.inceptionTime, vars.inceptionPrice, vars.leverageFactor, \n      vars.managementFee) = fetchPoolTrancheData(marketId); \n    levFactor = vars.leverageFactor; \n\n    require(vars.inceptionPrice > 0, \"0\"); \n\n    // Get senior redemption price that increments per unit time \n    vars.srpPlusOne = vars.inceptionPrice.mulWadDown((BASE_UNIT+ vars.promised_return)\n      .rpow(block.timestamp - vars.inceptionTime, BASE_UNIT));\n\n    // Get total assets held by the instrument \n    vars.juniorSupply = controller.getTotalSupply(marketId); \n    vars.seniorSupply = vars.juniorSupply.mulWadDown(vars.leverageFactor); \n    vars.totalAssetsHeldScaled = instrumentAssetOracle(marketId, vars.juniorSupply, vars.seniorSupply)\n      .mulWadDown(vars.inceptionPrice); \n\n    if (vars.seniorSupply == 0) return(vars.srpPlusOne,vars.srpPlusOne,levFactor); \n    \n    // Check if all seniors can redeem\n    if (vars.totalAssetsHeldScaled >= vars.srpPlusOne.mulWadDown(vars.seniorSupply))\n      psu = vars.srpPlusOne; \n    else{\n      psu = vars.totalAssetsHeldScaled.divWadDown(vars.seniorSupply);\n      vars.belowThreshold = true;  \n    }\n    // should be 0 otherwise \n    if(!vars.belowThreshold) pju = (vars.totalAssetsHeldScaled \n      - vars.srpPlusOne.mulWadDown(vars.seniorSupply)).divWadDown(vars.juniorSupply); \n    uint pju_ = (BASE_UNIT+ vars.leverageFactor).mulWadDown(previewMint(BASE_UNIT.mulWadDown(vars.inceptionPrice))) \n      -  vars.srpPlusOne.mulWadDown(vars.leverageFactor);\n\n    // assert(pju_ >= pju-10 || pju_ <= pju+10); \n        // console.log('ok????'); \n\n    }\n\n}\n"
    },
    "lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "lib/openzeppelin-contracts/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "lib/solmate/src/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "lib/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        require(x < 1 << 16);\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363736393539373438393936"
      }
    }
  }
}