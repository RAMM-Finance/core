{
  "language": "Solidity",
  "sources": {
    "contracts/bonds/boundedDerivatives.sol": {
      "content": "pragma solidity ^0.8.9;\nimport \"./GBC.sol\"; \n// import {BoundedDerivativesPool, LinearCurve} from \"./GBC.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"./libraries.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\n/// @notice Uses AMM as a derivatives market,where the price is bounded between two price\n/// and mints/burns tradeTokens. \n/// stores all baseTokens for trading, and also stores tradetokens when providing liquidity, \n/// @dev Short loss is bounded as the price is bounded, no need to program liquidations logic \ncontract BoundedDerivativesPool is GranularBondingCurve{\n    using FixedPointMath for uint256;\n    using SafeCast for uint256; \n    // using Position for Position.Info;\n    // uint256 constant PRECISION = 1e18; \n    ERC20 public  BaseToken; \n    ERC20 public  TradeToken; \n    ERC20 public  s_tradeToken; \n    uint256 public constant maxPrice = 1e18; \n\n    bool immutable noCallBack; \n    constructor(\n        address base, \n        address trade, \n        address s_trade, \n        bool _noCallBack\n        // address _pool \n        ) GranularBondingCurve(base, trade){\n        BaseToken =  ERC20(base);\n        TradeToken = ERC20(trade);\n        s_tradeToken = ERC20(s_trade);\n        noCallBack = _noCallBack; \n    }\n\n    /// @notice recipient recieves amountOut in exchange for giving this contract amountIn (base)\n    function mintAndPull(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\n        \n        // Mint and Pull \n        if(isLong) TradeToken.mint(recipient, amountOut); \n        else s_tradeToken.mint(recipient, amountOut); \n        BaseToken.transferFrom(recipient,address(this), amountIn); \n    }\n\n    function burnAndPush(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\n        // Burn and Push \n        if(isLong) TradeToken.burn(recipient, amountIn); \n        else s_tradeToken.burn(recipient, amountIn); \n   \n        BaseToken.transfer(recipient, amountOut); \n    }\n\n    function baseBal() internal view returns(uint256){\n        return BaseToken.balanceOf(address(this)); \n    }\n\n    /// @notice Long up the curve, or short down the curve \n    /// @param amountIn is base if long, trade if short\n    /// @param priceLimit is slippage tolerance\n    function takerOpen(\n        bool isLong, \n        int256 amountIn,\n        uint256 priceLimit, \n        bytes calldata data\n        ) external  returns(uint256 poolamountIn, uint256 poolamountOut ){\n        if(isLong){\n            // Buy up \n            (poolamountIn, poolamountOut) = trade(\n                msg.sender, \n                true, \n                amountIn, \n                priceLimit, \n                data\n            ); \n            if (noCallBack) mintAndPull(msg.sender, poolamountOut, poolamountIn, true);\n\n            else {\n                uint256 bal = baseBal(); \n                iTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \n                require(baseBal() >= poolamountIn + bal, \"balERR\"); \n                TradeToken.mint(abi.decode(data, (address)), poolamountOut); \n            }\n        }\n\n        else{\n            // just shift pool state\n            (poolamountIn, poolamountOut) = trade(\n                address(this), \n                false, \n                amountIn, \n                priceLimit, \n                data\n            ); \n            uint b = baseBal(); \n            console.log('basebal',b , poolamountOut); \n            require(poolamountOut <= baseBal(), \"!ammLiq\"); \n            uint256 cached_poolamountOut = poolamountOut; \n            // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\n            poolamountOut = poolamountIn.mulWadDown(maxPrice) - poolamountOut;\n\n            // One s_tradeToken is a representation of debt+sell of one tradetoken\n            // Escrow collateral required for shorting, where price for long + short = maxPrice, \n            // so (maxPrice-price of trade) * quantity\n            if (noCallBack) mintAndPull(msg.sender, poolamountIn, poolamountOut, false);\n\n            else{\n                uint256 bal = baseBal(); \n                iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \n                require(baseBal() >= poolamountOut + bal, \"balERR\"); \n                s_tradeToken.mint(abi.decode(data,(address)), poolamountIn); \n\n                // need to send cached poolamountOut(the area under the curve) data for accounting purposes\n                poolamountIn = cached_poolamountOut; \n            }\n\n            // BaseToken.transferFrom(msg.sender, address(this), poolamountIn.mulWadDown(maxPrice) - poolamountOut); \n            // s_tradeToken.mint(msg.sender, uint256(amountIn)); \n        }\n\n    }\n\n    /// @param amountIn is trade if long, ALSO trade if short, since getting rid of s_trade \n    function takerClose(\n        bool isLong, \n        int256 amountIn,\n        uint256 priceLimit, \n        bytes calldata data\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\n\n        // Sell down\n        if(isLong){\n            (poolamountIn, poolamountOut) = trade(\n                msg.sender,\n                false, \n                amountIn, //this should be trade tokens\n                priceLimit, \n                data\n            ); \n\n            if (noCallBack) burnAndPush(msg.sender, poolamountOut, poolamountIn, true);\n\n            else burnAndPush(abi.decode(data, (address)), poolamountOut, poolamountIn, true );                             \n        }\n\n        else{            \n            // buy up with the baseToken that was transferred to this contract when opened, in is base out is trade\n            (poolamountIn, poolamountOut) = trade(\n                msg.sender, \n                true, \n                amountIn, \n                priceLimit, \n                data\n            ); \n            uint256 cached_poolamountIn = poolamountIn; \n\n            // collateral used to buy short \n            poolamountIn = poolamountOut.mulWadDown(maxPrice) - poolamountIn; \n\n            if (noCallBack) burnAndPush(msg.sender, poolamountIn,poolamountOut, false);\n            else {\n                burnAndPush(abi.decode(data, (address)), poolamountIn, poolamountOut,false ); \n                poolamountOut = cached_poolamountIn; \n            }\n\n            // s_tradeToken.burn(msg.sender, poolamountOut); \n            // BaseToken.transfer(msg.sender, poolamountOut.mulWadDown(maxPrice) - poolamountIn);\n        }\n    }\n\n    /// @notice provides oneTimeliquidity in the range (point,point+1)\n    /// @param amount is in base if long, trade if in short  \n    function makerOpen(\n        uint16 point, \n        uint256 amount,\n        bool isLong,\n        address recipient\n        )external  returns(uint256 toEscrowAmount, uint128 crossId){\n\n        if(isLong){\n            // escrowAmount is base \n            (toEscrowAmount, crossId) = placeLimitOrder(\n                recipient,\n                point, \n                uint128(liquidityGivenBase(pointToPrice(point+1), pointToPrice(point), amount)), \n                false\n                ); \n            BaseToken.transferFrom(recipient, address(this), toEscrowAmount); \n        }\n\n        // need to set limit for sells, but claiming process is different then regular sells \n        else{\n            // escrowAmount is trade \n            (toEscrowAmount, crossId) = placeLimitOrder(\n                recipient, \n                point,\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)) , \n                true\n                ); \n\n            // escrow amount is (maxPrice - avgPrice) * quantity \n            uint256 escrowCollateral = toEscrowAmount - baseGivenLiquidity(\n                    pointToPrice(point+1), \n                    pointToPrice(point), \n                    uint256(amount) //positive since adding asks, not subtracting \n                    ); \n            BaseToken.transferFrom(recipient, address(this), escrowCollateral); \n            toEscrowAmount = escrowCollateral; \n        }\n\n    }\n\n    function makerClaimOpen(\n        uint16 point, \n        bool isLong, \n        address recipient\n        )external returns(uint256 claimedAmount){\n\n        if(isLong){\n            uint256 claimedAmount = claimFilledOrder(recipient, point, false ); \n\n            // user already escrowed funds, so need to send him tradeTokens \n            TradeToken.mint(recipient, claimedAmount);          \n        }\n\n        else{           \n            s_tradeToken.mint(recipient, \n                tradeGivenLiquidity(\n                    pointToPrice(point+1), \n                    pointToPrice(point), \n                    getLiq(msg.sender, point, true)\n                    )\n                ); \n\n            // open short is filled sells, check if sells are filled. If it is,\n            // claimedAmount of basetokens should already be in this contract \n            claimedAmount = claimFilledOrder(recipient, point, true ); \n        }\n\n    }\n    /// @notice amount is trade if long, but ALSO trade if short(since trade quantity also coincides\n    /// with shortTrade quantity )\n    function makerClose(\n        uint16 point, \n        uint256 amount,\n        bool isLong, \n        address recipient\n        )external returns(uint256 toEscrowAmount, uint128 crossId){\n\n        if(isLong){\n            // close long is putting up trades for sells, \n            (toEscrowAmount, crossId) = placeLimitOrder(\n                recipient, \n                point, \n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \n                true\n                ); \n            //maybe burn it when claiming, and just escrow? \n            TradeToken.burn(recipient, toEscrowAmount); \n        }\n\n        else{\n            // Place limit orders for buys \n            (toEscrowAmount, crossId) = placeLimitOrder(\n                recipient, \n                point,\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \n                false\n                ); \n\n            // burn s_tradeTokens, \n            s_tradeToken.burn(recipient, amount); \n\n        }\n    }\n\n    function makerClaimClose(\n        uint16 point, \n        bool isLong, \n        address recipient\n        ) external returns(uint256 claimedAmount){\n\n        if(isLong){\n            // Sell is filled, so need to transfer back base \n            claimedAmount = claimFilledOrder(recipient, point, true ); \n            BaseToken.transfer(recipient, claimedAmount); \n        }\n        else{\n            uint128 liq = getLiq(recipient, point, false); \n\n            // Buy is filled, which means somebody burnt trade, so claimedAmount is in trade\n            claimedAmount = claimFilledOrder(recipient, point, false);\n            claimedAmount = claimedAmount.mulWadDown(maxPrice) \n                            - baseGivenLiquidity(\n                            pointToPrice(point+1), \n                            pointToPrice(point), \n                            liq); \n            BaseToken.transfer(recipient, claimedAmount);\n        }\n    }    \n\n    function makerPartiallyClaim(\n        uint16 point, \n        bool isLong,\n        bool open, \n        address recipient\n        ) external returns(uint256 baseAmount, uint256 tradeAmount){\n   \n        if(open){\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false); \n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true);\n        }\n        else{\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true); \n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false);\n        }\n        \n        BaseToken.transfer(recipient, baseAmount);\n        TradeToken.mint(recipient, tradeAmount); \n    }\n\n    /// @notice amount is in base if long, trade if short \n    function makerReduceOpen(\n        uint16 point, \n        uint256 amount, \n        bool isLong, \n        address recipient\n        ) external{\n    \n        if(isLong){\n            uint256 returned_amount =reduceLimitOrder(\n                recipient, \n                point, \n                liquidityGivenBase(\n                    pointToPrice(point+1), \n                    pointToPrice(point),\n                    amount\n                    ).toUint128(), \n                false\n                ); \n            // need to send base back \n            BaseToken.transfer(recipient, returned_amount); \n        }\n        else {\n            uint128 liq = liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amount).toUint128(); \n            // Reduce asks \n            reduceLimitOrder(\n                recipient, \n                point, \n                liq, \n                true\n                ); \n\n            // Need to send escrowed basetoken back, which is shortTrade quantity - baseGivenLiquidity \n            BaseToken.transfer(recipient, \n                amount - baseGivenLiquidity(pointToPrice(point+1), pointToPrice(point), liq));\n        }\n    }\n\n    /// @notice amount is in trade if long, ALSO trade if short \n    function makerReduceClose(      \n        uint16 point, \n        uint256 amount, \n        bool isLong,\n        address recipient\n        ) external{\n\n        if(isLong){\n            uint256 returned_amount = reduceLimitOrder(\n                recipient, \n                point, \n                liquidityGivenTrade(\n                    uint256(pointToPrice(point+1)), \n                    uint256(pointToPrice(point)), amount).toUint128(), \n                true\n                ); \n            // need to send trade back \n            TradeToken.mint(recipient, returned_amount); \n        }\n\n        else{\n            // reduce limit bids \n            reduceLimitOrder(\n                recipient, \n                point, \n                liquidityGivenTrade(\n                    uint256(pointToPrice(point+1)), \n                    uint256(pointToPrice(point)), amount).toUint128(), \n                false\n            ); \n             \n            s_tradeToken.mint(recipient, amount); \n        }\n    }\n\n    // TODO separate contracts \n    // function provideLiquidity(\n    //     uint16 pointLower,\n    //     uint16 pointUpper,\n    //     uint128 amount, \n    //     bytes calldata data \n    //     ) external {\n\n    //     (uint256 amount0, uint256 amount1) = provide(\n    //         msg.sender, \n    //         pointLower, \n    //         pointUpper, \n    //         amount, \n    //         data \n    //     ); \n    //     BaseToken.transferFrom(msg.sender, address(this), amount0); \n    //     // TradeToken.transferFrom(msg.sender, address(this), amount1);\n    //     TradeToken.burn(msg.sender, amount1);\n    // }\n\n    // function withdrawLiquidity(\n    //     uint16 pointLower,\n    //     uint16 pointUpper,\n    //     uint128 amount, \n    //     bytes calldata data \n    //     )external{\n\n    //     (uint256 amountBase, uint256 amountTrade) = remove(\n    //         msg.sender, \n    //         pointLower, \n    //         pointUpper, \n    //         amount\n    //     ); \n      \n    //     collect(\n    //         msg.sender, \n    //         pointLower,\n    //         pointUpper,\n    //         type(uint128).max,\n    //         type(uint128).max\n    //     ); \n\n    //     BaseToken.transfer(msg.sender,  amountBase); \n    //     TradeToken.mint(msg.sender, amountTrade); \n    // }\n\n    //TODO fees, skipping uninit for gas, below functions\n    // possible attacks: manipulation of price with no liquidityregions, add a bid/ask and a naive \n    // trader fills, and immediately submit a ask much higher/lower\n    // gas scales with number of loops, so need to set ticks apart large, or provide minimal liquidity in each tick\n\n}\n\ninterface iTradeCallBack{\n    function tradeCallBack(\n        uint256 amount0,\n bytes calldata data    ) external;\n} \n"
    },
    "contracts/bonds/GBC.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n// import {ERC20} from \"./aave/Libraries.sol\"; \nimport {SafeCast, FixedPointMath, ERC20} from \"./libraries.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \n/// @dev all funds will be handled in the child contract \ncontract GranularBondingCurve{\n    using FixedPointMath for uint256;\n    using Tick for mapping(uint16 => Tick.Info);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n    using SafeCast for uint256; \n\n\n    modifier onlyEntry(){\n        require(entry == msg.sender  ,\"Not Entry\"); \n        _;\n    }\n    \n    bool private _mutex;\n    modifier _lock_() {\n        require(!_mutex, \"ERR_REENTRY\");\n        _mutex = true;\n        _;\n        _mutex = false;\n    }\n\n    constructor(\n        address _baseToken,\n        address _tradeToken\n        //uint256 _priceDelta\n        ) {\n        tradeToken = _tradeToken; \n        baseToken = _baseToken; \n        //priceDelta = _priceDelta; \n        fee =0; \n        factory = address(0); \n        tickSpacing = 0; \n        //Start liquidity \n        liquidity = 100 * uint128(PRECISION); \n\n        owner = msg.sender; \n    }\n\n    address public immutable owner; \n    uint24 public immutable  fee;\n    Slot0 public slot0; // global state?\n    address public immutable  factory;\n    address public immutable  tradeToken;\n    address public immutable  baseToken;\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\n\n    uint128 public liquidity;\n\n    mapping(uint16 => Tick.Info) public  ticks;\n\n    mapping(bytes32 => Position.Info) public  positions;\n\n    // mapping(uint16=> PricePoint) Points; \n\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\n    uint256 public constant ROUNDLIMIT = 1e4; \n    uint256 public constant PRECISION = 1e18; \n    address public entry; \n\n    /// @notice previliged function called by the market maker \n    /// if he is the one providing all the liquidity \n    function setLiquidity(uint128 liq) internal  \n    //onlyEntry\n    {\n        liquidity = liq; \n    }\n\n    function setEntry(address _entry) external onlyEntry{\n        entry = _entry; \n    }\n    function lock() external onlyEntry{\n        slot0.unlocked = !slot0.unlocked; \n    }\n\n    function positionIsFilled(\n        address recipient, \n        uint16 point, \n        bool isAsk\n    ) \n        public view returns(bool){\n        Position.Info storage position = positions.get(recipient, point, point+1);\n\n        uint128 numCross = ticks.getNumCross(point, isAsk); \n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\n\n        return (liq>0 && numCross > crossId); \n    }\n\n    function setPriceAndPoint(uint256 price) internal  \n    //onlyOwner\n    {\n        slot0.point = priceToPoint(price);         \n        slot0.curPrice = price.toUint160(); \n    }\n\n    function getCurPrice() external view returns(uint256){\n        return slot0.curPrice; \n    }\n\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\n        return uint256(ticks.oneTimeLiquidity(point)); \n    }    \n\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\n        return ticks.getNumCross(point, moveUp); \n    }\n\n\n    struct Slot0 {\n        // the current price\n        uint160 curPrice;\n        // the current tick\n        uint16 point;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n\n        // Whether liquidity provision is amortized \n        bool amortized; \n\n        // Where to modify liquidity \n        uint16 modifyLiqPoint; \n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        uint256 amountCalculated;\n        // current sqrt(price)\n        uint256 curPrice;\n        // the tick associated with the current price\n        uint16 point;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobal;\n        // amount of input token paid as protocol fee\n        uint128 protocolFee;\n        // the current liquidity in range\n        uint128 liquidity;\n        uint128 liquidityStart; \n\n\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint256 priceStart;\n        // the next tick to swap to from the current tick in the swap direction\n        uint16 pointNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // price for the next tick (1/0)\n        uint256 priceNextLimit;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n\n        uint128 liqDir; \n    }\n\n    struct swapVars{\n        uint256 a;\n        uint256 s; \n        uint256 b; \n    }\n\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\n    /// -amountSpecified is in trade if moveUp, else is in base \n    /// returns amountIn if moveUp, cash, else token\n    /// returns amountOut if moveUp, token, else cash \n    function trade(\n        address recipient, \n        bool moveUp, \n        int256 amountSpecified, \n        uint256 priceLimit, \n        bytes calldata data\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\n        console.logString('---New Trade---'); \n\n        Slot0 memory slot0Start = slot0; \n        uint256 pDelta = priceDelta; \n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amountSpecified, \n            amountCalculated: 0, \n            curPrice: uint256(slot0Start.curPrice),\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\n            protocolFee: 0, \n            liquidity: liquidity, \n            liquidityStart: liquidity,\n            point: slot0.point\n            }); \n        swapVars memory vars = swapVars({\n            a:0,\n            b:0,\n            s:0\n            });\n\n        bool exactInput = amountSpecified > 0;\n\n        // increment price by 1/1e18 if at boundary, and go back up a point,\n        // should be negligible compared to fees TODO \n        if (mod0(state.curPrice, pDelta) && !moveUp) {\n            state.curPrice += 1; \n            state.point = priceToPoint(state.curPrice);\n            slot0.point = state.point; \n            slot0Start.point = state.point; \n        }\n        \n        require(moveUp? priceLimit>= state.curPrice : priceLimit<= state.curPrice, \"plimitERR\" ); \n        priceLimit = pointToPrice(priceToPoint(priceLimit)); \n\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\n            StepComputations memory step; \n            step.priceStart = state.curPrice; \n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \n\n            step.pointNext = moveUp? state.point + 1 : state.point-1; \n\n            // Need liquidity for both move up and move down for path independence within a \n            // given point range. Either one of them should be 0 \n            step.liqDir = ticks.oneTimeLiquidity(state.point);\n            vars.a = exactInput \n                ? inv(state.liquidity + step.liqDir)\n                : invRoundUp(state.liquidity + step.liqDir); \n            vars.b = yInt(state.curPrice, moveUp); \n            vars.s = xMax(state.curPrice, vars.b, vars.a); \n \n            //If moveup, amountIn is in cash, amountOut is token and vice versa \n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\n                state.curPrice, \n                step.priceNextLimit,    \n                state.amountSpecifiedRemaining, \n                fee, \n                vars               \n                ); \n\n            {console.log('________'); \n            console.log('CURPRICE', state.curPrice); \n            console.log('trading; liquidity, amountleft', state.liquidity); \n            console.log(uint256(state.amountSpecifiedRemaining));\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \n            console.log('a', vars.a); }\n            console.log('amountinandout', step.amountIn, step.amountOut); \n            console.log('s,b', vars.s, vars.b); \n\n            if (exactInput){\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \n            }\n            else{\n                state.amountSpecifiedRemaining += int256(step.amountIn); \n            }\n            state.amountCalculated += step.amountOut; \n\n            if (state.liquidity>0)\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \n\n            // If next limit reached, cross price range and change slope(liquidity)\n            if (state.curPrice == step.priceNextLimit){\n\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\n                // Else if crossing DOWN, bids are all filled \n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \n\n                int128 liquidityNet = ticks.cross(\n                    step.pointNext, \n                    feeGrowthGlobalBase,\n                    feeGrowthGlobalTrade\n                    ); \n\n                if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint)\n                    liquidityNet = liquidityNet += dynamicLiq[step.pointNext]; \n                    console.log('dynamicLiq', uint256(int256(dynamicLiq[step.pointNext])), uint256(int256(liquidityNet))); \n\n                if (!moveUp) liquidityNet = -liquidityNet; \n\n\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\n                state.point = step.pointNext;  \n            }\n        }\n\n        slot0.curPrice = state.curPrice.toUint160(); \n        if(state.point != slot0Start.point) slot0.point = state.point; \n            \n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\n\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \n            \n        // (amountIn, amountOut) = exactInput\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \n\n        (amountIn, amountOut) = exactInput\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \n                    console.log('???', uint256(state.amountSpecifiedRemaining) , uint256(amountSpecified)); \n\n    }\n\n    function placeLimitOrder(\n        address recipient, \n        uint16 point, \n        uint128 amount,\n        bool isAsk  \n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \n        //TODO mint NFT \n        // Should only accept asks for price above the current point range\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\"ask below prie\"); \n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\"bids above prie\"); \n\n        Position.Info storage position = positions.get(recipient, point, point+1);\n\n        numCross = ticks.getNumCross(point, isAsk); \n        position.updateLimit(int128(amount), isAsk, numCross); \n\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \n\n        // If placing bids, need to escrow baseAsset, vice versa \n        address tokenToEscrow = isAsk? tradeToken : baseToken;\n\n        amountToEscrow = isAsk\n                ? tradeGivenLiquidity(\n                    pointToPrice(point+1), \n                    pointToPrice(point), \n                    uint256(amount) \n                    )\n            \n                : baseGivenLiquidity(\n                    pointToPrice(point+1), \n                    pointToPrice(point), \n                    uint256(amount) \n                    ); \n\n        console.log('amountbid', amountToEscrow); \n\n    }\n\n    function reduceLimitOrder(\n        address recipient, \n        uint16 point, \n        uint128 amount,\n        bool isAsk \n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \"Can't reduce order for current tick\"); \n\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\n\n        position.updateLimit(-int128(amount), isAsk, 0); \n\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \n\n        address tokenToReturn = isAsk? tradeToken : baseToken;\n        \n        amountToReturn = isAsk\n            ? tradeGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(amount) \n                )\n         \n            : baseGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(amount) \n                );\n    }\n\n    /// @notice called when maker wants to claim when the the price is at the \n    /// point he submitted the order\n    function claimPartiallyFilledOrder(\n        address recipient, \n        uint16 point,\n        bool isAsk\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\n        Slot0 memory _slot0 = slot0; \n\n        Position.Info storage position = positions.get(recipient, point, point+1);\n        require(priceToPoint(uint256(_slot0.curPrice)) == point, \"Not cur price\"); \n\n        // Assume trying to withdraw all liquidity provided \n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \n       \n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \n\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \n\n        // Get total trade filled OR remaining\n        tradeAmount = tradeGivenLiquidity(\n            pointToPrice(point+1),\n            _slot0.curPrice, \n            liqToWithdraw\n        ); \n           \n        // Get total base filled OR remaining \n        baseAmount = baseGivenLiquidity(\n            _slot0.curPrice, \n            pointToPrice(point), \n            liqToWithdraw\n            ); \n\n    }\n\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \n    /// or crossDown \n    function claimFilledOrder(\n        address recipient, \n        uint16 point, \n        bool isAsk \n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\n        Position.Info storage position = positions.get(recipient, point, point+1);\n\n        uint128 numCross = ticks.getNumCross(point, isAsk); \n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \n        require(numCross > crossId, \"Position not filled\");\n\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\n\n        // Sold to base when asks are filled\n        if(isAsk) claimedAmount = baseGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(liq) \n                ); \n\n        // Bought when bids are filled so want tradeTokens\n        else claimedAmount = tradeGivenLiquidity(\n                pointToPrice(point+1), \n                pointToPrice(point), \n                uint256(liq) \n                ); \n\n        position.updateLimit(-int128(liq), isAsk, 0); \n        \n        // Need to burn AND \n\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        uint16 pointLower;\n        uint16 pointUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n    }\n\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\n    function provide(\n        address recipient, \n        uint16 pointLower, \n        uint16 pointUpper, \n        uint128 amount, \n        bytes calldata data \n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\n        require(amount > 0, \"0 amount\"); \n\n        (,  amount0,  amount1) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient, \n                pointLower : pointLower, \n                pointUpper: pointUpper, \n                liquidityDelta: int128(amount)//.toInt128()\n                })\n            ); \n\n        //mintCallback\n\n    }\n\n    function remove(\n        address recipient, \n        uint16 pointLower, \n        uint16 pointUpper, \n        uint128 amount\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\n\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient, \n                pointLower : pointLower, \n                pointUpper: pointUpper, \n                liquidityDelta: -int128(amount)//.toInt128()\n                })\n            ); \n\n        if(amount0>0 || amount1> 0){\n            (position.tokensOwed0, position.tokensOwed1) = (\n                position.tokensOwed0 + amount0,\n                position.tokensOwed1 + amount1\n            );\n        }\n        return (amount0, amount1); \n    }\n\n    function collect(\n        address recipient,\n        uint16 tickLower,\n        uint16 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\n\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\n\n        if (amount0 > 0) {\n            position.tokensOwed0 -= amount0;\n        }\n        if (amount1 > 0) {\n            position.tokensOwed1 -= amount1;\n        }\n    }\n\n\n    function _modifyPosition(ModifyPositionParams memory params)\n    private \n    returns(\n        Position.Info storage position, \n        uint256 baseAmount, \n        uint256 tradeAmount\n        )\n    {\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\n\n        position = _updatePosition(\n            params.owner,\n            params.pointLower,\n            params.pointUpper,\n            params.liquidityDelta,\n            _slot0.point\n        );\n\n        if (params.liquidityDelta != 0){\n            if (_slot0.point < params.pointLower){\n                // in case where liquidity is just asks waiting to be sold into, \n                // so need to only provide tradeAsset \n                tradeAmount = tradeGivenLiquidity(\n                    pointToPrice(params.pointUpper), \n                    pointToPrice(params.pointLower), \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                    ); \n            } else if( _slot0.point < params.pointUpper){\n                uint128 liquidityBefore = liquidity; \n\n                // Get total asks to be submitted above current price\n                tradeAmount = tradeGivenLiquidity(\n                    pointToPrice(params.pointUpper),\n                    _slot0.curPrice, \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                    ); \n\n                // Get total bids to be submitted below current price \n                baseAmount = baseGivenLiquidity(\n                    _slot0.curPrice, \n                    pointToPrice(params.pointLower), \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                    ); \n\n                // Slope changes since current price is in this range \n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\n\n            } else{\n                // liquidity is just bids waiting to be bought into \n                baseAmount = baseGivenLiquidity(\n                    pointToPrice(params.pointUpper), \n                    pointToPrice(params.pointLower), \n                    params.liquidityDelta >= 0\n                        ? uint256(int256(params.liquidityDelta))\n                        : uint256(int256(-params.liquidityDelta))\n                ); \n            }\n        }\n    }\n\n    uint256 public feeGrowthGlobalBase;\n    uint256 public feeGrowthGlobalTrade;\n\n    function _updatePosition(\n        address owner, \n        uint16 pointLower, \n        uint16 pointUpper, \n        int128 liquidityDelta, \n        uint16 point \n        ) private returns(Position.Info storage position){\n\n        position = positions.get(owner, pointLower, pointUpper); \n\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \n\n        if(liquidityDelta != 0){\n\n            ticks.update(\n                pointLower, \n                point, \n                liquidityDelta, \n                feeGrowthGlobalBase,\n                feeGrowthGlobalTrade,\n                false\n                ); \n\n            ticks.update(\n                pointUpper, \n                point, \n                liquidityDelta, \n                feeGrowthGlobalBase,\n                feeGrowthGlobalTrade,\n                true\n                ); \n        } \n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \n    }\n\n\n    mapping(uint16=> int128) dynamicLiq; \n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\n        dynamicLiq[point] = liq; \n    }\n    function setModifyLiqPoint(uint16 point) internal{\n        slot0.modifyLiqPoint = point;  \n    }\n    function amortizeLiq() internal{\n        slot0.amortized = true; \n    }\n\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\n        require(p2>=p1, \"price ERR\"); \n        return (p2-p1).mulWadDown(L); \n    }\n\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\n        require(p2>=p1, \"price ERR\"); \n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \n    }\n\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\n        require(p2>=p1, \"price ERR\"); \n        return T.divWadDown(p2-p1); \n    }\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\n        require(p2>=p1, \"price ERR\"); \n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \n    }\n\n    function pointToPrice(uint16 point) public pure returns(uint160){\n        return(uint256(point) * priceDelta).toUint160(); \n    }\n\n    /// @notice will round down to nearest integer \n    function priceToPoint(uint256 price) public pure returns(uint16){\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \n    }\n\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        if(a==0) return type(uint256).max; \n        return (curPrice-b).divWadDown(a); \n    }\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        return (curPrice-b).divWadUp(a); \n    }\n\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\n    /// the current point\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\n        uint16 point = priceToPoint(curPrice); \n\n        // If at boundary when moving down, decrement point by one\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \n    }\n\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\n        if (moveUp) return uint256(point+1) * pDelta; \n        else return uint256(point) * pDelta; \n    }\n\n    function inv(uint256 l) internal pure returns(uint256){\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \n    }\n    function invRoundUp(uint256 l) internal pure returns(uint256){\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\n        return (a%b ==0); \n    }\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\n        return  isAsk\n                ? positions.get(to, point, point+1).askLiq\n                : positions.get(to, point, point+1).bidLiq; \n    }\n\n}\n\nlibrary LinearCurve{\n    uint256 public constant PRECISION = 1e18; \n    using FixedPointMath for uint256; \n\n\n    /// @notice Compute results of swap given amount in and params\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// b is 0 and s is curPrice/a during variable liquidity phase\n    function swapStep(\n        uint256 curPrice, \n        uint256 targetPrice, \n        int256 amountRemaining, \n        uint24 feePips,    \n        GranularBondingCurve.swapVars memory vars       \n        ) \n        public \n        pure \n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\n\n        bool moveUp = targetPrice >= curPrice; \n        bool exactInput = amountRemaining >= 0; \n\n        // If move up and exactInput, amountIn is base, amountOut is trade \n        if (exactInput){\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\n\n            if (moveUp){\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \n\n                // If overshoot go to next point\n                if (nextPrice >= targetPrice){\n                    nextPrice = targetPrice; \n\n                    // max amount out for a given price range is Pdelta / a \n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \n                }            \n                else {\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \n                }   \n            }\n\n            // amountIn is trade, amountOut is base \n            else {\n                // If amount is greater than s, then need to cap it \n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \n                // If undershoot go to previous point \n                if(nextPrice <= targetPrice && vars.a > 0){//TODO might introduce bugs \n                    nextPrice = targetPrice; \n\n                    // max amount out is area under curve \n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \n\n                }\n                else{\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \n                }\n            }\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \n        }\n\n        else {\n            if(moveUp){\n                uint256 remaining = uint256(-amountRemaining); \n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \n\n                // if overshoot\n                if(nextPrice>=targetPrice){\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \n                    nextPrice = targetPrice; \n\n                    // Prevent stuck cases where point is almost filled but not quite \n                    if(remaining - amountIn<=1e4){\n                        amountIn = remaining; \n                    } \n                }\n                else amountIn = remaining; \n\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\n\n            }\n            else{\n                //TODO \n            }\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\n            amountOut = amountOut + feeAmount;\n        }\n    }\n\n\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\n    /// @param amount: amount of base in\n    /// returns amountDelta wanted token returned \n    function amountOutGivenIn( \n        uint256 amount,\n        uint256 s, \n        uint256 a, \n        uint256 b, \n        bool up\n        ) \n        public \n        pure \n        returns(uint256 amountDelta, uint256 resultPrice) {\n        \n        // If liquidity is not infinite \n        if(a > 0){\n            if (up){\n                //TODO overflow on small amount \n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \n                uint256 y = 2*( a.mulWadDown(amount)); \n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\n                uint256 z = (a.mulWadDown(s) + b); \n                amountDelta = (x_y_sqrt-z).divWadDown(a);\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \n            } else{\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \n                amountDelta = amount.mulWadDown(z); \n                resultPrice = a.mulWadDown(s-amount) + b; \n            }\n        }\n\n        // When a = 0, infinite liquidity and constant price\n        else{     \n            if(up){\n                amountDelta = amount.divWadDown(b); \n            } else{\n                amountDelta = amount.mulWadDown(b); \n            }\n            resultPrice = b;             \n        }\n    }\n\n    /// @notice calculates area under the curve from s to s+amount\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\n     /// returned in collateral decimals\n    function areaUnderCurve(\n        uint256 amount, \n        uint256 s, \n        uint256 a, \n        uint256 b) \n        public\n        pure \n        returns(uint256 area){\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \n    }\n    function areaUnderCurveRoundUp(\n        uint256 amount, \n        uint256 s, \n        uint256 a, \n        uint256 b) \n        public\n        pure \n        returns(uint256 area){\n        // you want area to be big for a given amount \n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \n    }\n\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\n        if(a==0) return type(uint256).max; \n        return (curPrice-b).divWadDown(a); \n    }\n\n}\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    using FixedPointMath for uint256;\n\n    // info stored for each user's position\n    struct Info {\n        uint128 bidCrossId; \n        uint128 askCrossId; \n        uint128 askLiq; \n        uint128 bidLiq; \n\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        // the fees owed to the position owner in token0/token1\n        uint256 tokensOwed0;\n        uint256 tokensOwed1;\n\n        \n    }\n\n    function updateLimit(\n        Info storage self,\n        int128 limitLiqudityDelta, \n        bool isAsk, \n        uint128 crossId\n        ) internal {\n\n        if (isAsk) {\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \n        } \n\n        else {\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \n        }\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(\n        mapping(bytes32 => Info) storage self,\n        address owner,\n        uint16 tickLower,\n        uint16 tickUpper\n    ) internal view returns (Position.Info storage position) {\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function update(\n        Info storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal {\n        Info memory _self = self;\n\n        uint128 liquidityNext;\n        if (liquidityDelta == 0) {\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\n            liquidityNext = _self.liquidity;\n        } else {\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\n        }\n\n        // calculate accumulated fees\n        uint128 tokensOwed0 = uint128(\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\n                .mulDivDown(uint256(_self.liquidity), 1e18)\n            );\n        uint128 tokensOwed1 =uint128(\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\n                .mulDivDown(uint256(_self.liquidity), 1e18)\n            );\n            \n        // update the position\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\n            self.tokensOwed0 += tokensOwed0;\n            self.tokensOwed1 += tokensOwed1;\n        }\n    }\n\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n\n/// @title Tick\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary Tick {\n    using FixedPointMath for uint256;\n\n    using SafeCast for int256;\n\n    // info stored for each initialized individual tick\n    struct Info {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint256 feeGrowthOutsideBase;\n        uint256 feeGrowthOutsideTrade;\n        // the cumulative tick value on the other side of the tick\n        int56 tickCumulativeOutside;\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint160 secondsPerLiquidityOutsideX128;\n        // the seconds spent on the other side of the tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint32 secondsOutside;\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n        bool initialized;\n\n        uint128 askLiquidityGross; \n        uint128 bidLiquidityGross;\n        uint128 askNumCross; \n        uint128 bidNumCross; \n    }\n\n    function getNumCross(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick, \n        bool isAsk\n        ) internal view returns(uint128){\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \n    }\n\n    function oneTimeLiquidity(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick \n        ) internal view returns(uint128){\n        Tick.Info memory info = self[tick]; \n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \n        return info.askLiquidityGross + info.bidLiquidityGross; \n    }\n\n    function deleteOneTimeLiquidity(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick, \n        bool isAsk\n        ) internal {\n        Tick.Info storage info = self[tick]; \n        if(isAsk) {\n            info.askLiquidityGross = 0;\n            info.askNumCross++; \n            console.log('tick??', tick); \n        }\n        else {\n            info.bidLiquidityGross = 0; \n            info.bidNumCross++; \n        }\n    }\n\n    function updateOneTimeLiquidity(\n        mapping(uint16=> Tick.Info) storage self, \n        uint16 tick, \n        int128 oneTimeLiquidityDelta,\n        bool isAsk\n        ) internal {\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\n    }\n\n    function update(\n        mapping(uint16 => Tick.Info) storage self,\n        uint16 tick,\n        uint16 tickCurrent,\n        int128 liquidityDelta,\n        uint256 feeGrowthGlobalBase, \n        uint256 feeGrowthGlobalTrade, \n        bool upper\n    ) internal returns (bool flipped) {\n        Tick.Info storage info = self[tick];\n\n        uint128 liquidityGrossBefore = info.liquidityGross; \n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if(liquidityGrossBefore == 0) {\n            if(tick<=tickCurrent){\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \n            }\n            info.initialized = true; \n        }\n        info.liquidityGross = liquidityGrossAfter;\n\n        info.liquidityNet = upper \n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \n    }\n\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\n        delete self[tick];\n    }\n\n    function cross(\n        mapping(uint16 => Tick.Info) storage self,\n        uint16 tick, \n        uint256 feeGrowthGlobalBase,\n        uint256 feeGrowthGlobalTrade\n    ) internal returns (int128 liquidityNet) {\n        Tick.Info storage info = self[tick]; \n\n        liquidityNet = info.liquidityNet; \n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\n    }\n\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n\n    function getFeeGrowthInside(\n        mapping(uint16 => Tick.Info) storage self,\n        uint16 tickLower,\n        uint16 tickUpper,\n        uint16 tickCurrent,\n        uint256 feeGrowthGlobalBase,\n        uint256 feeGrowthGlobalTrade\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\n        Info storage lower = self[tickLower];\n        Info storage upper = self[tickUpper];\n\n        // calculate fee growth below\n        uint256 feeGrowthBelowBase;\n        uint256 feeGrowthBelowTrade;\n        if (tickCurrent >= tickLower) {\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\n        } else {\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\n        }\n\n        // calculate fee growth above\n        uint256 feeGrowthAboveBase;\n        uint256 feeGrowthAboveTrade;\n        if (tickCurrent < tickUpper) {\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\n        } else {\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\n        }\n\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\n    }\n}\n\n\ncontract SpotPool is GranularBondingCurve{\n\n    ERC20 BaseToken; //junior\n    ERC20 TradeToken; //senior \n    // GranularBondingCurve public pool; \n\n    constructor(\n        address _baseToken, \n        address _tradeToken\n        )GranularBondingCurve(_baseToken,_tradeToken){\n        BaseToken = ERC20(_baseToken); \n        TradeToken = ERC20(_tradeToken); \n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \n    }\n\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\n\n        if(up){\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\n            console.log('togive', amountOut, amountIn); \n            TradeToken.transfer(recipient, amountOut); \n            console.log('balofre', BaseToken.balanceOf(recipient));\n            BaseToken.transferFrom(recipient, address(this), amountIn);\n        }\n\n        else{\n            BaseToken.transfer(recipient, amountOut); \n            TradeToken.transferFrom(recipient, address(this), amountIn);\n        }\n    }\n\n    // function getCurPrice() external view returns(uint256){\n    //     return uint256(pool.getCurPrice());\n    // }\n\n    /// @notice if buyTradeForBase, move up, and vice versa \n    function takerTrade(\n        address recipient, \n        bool buyTradeForBase, \n        int256 amountIn,\n        uint256 priceLimit, \n        bytes calldata data        \n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\n\n        (poolamountIn, poolamountOut) = this.trade(\n            recipient, \n            buyTradeForBase, \n            amountIn,  \n            priceLimit, \n            data\n        ); \n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \n    }\n\n    /// @notice specify how much trade trader intends to sell/buy \n    function makerTrade(\n        bool buyTradeForBase,\n        uint256 amountIn,\n        uint16 point\n        ) external {\n        (uint256 toEscrowAmount, uint128 crossId) \n                = this.placeLimitOrder(msg.sender, \n                    point, \n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \n                    !buyTradeForBase); \n\n        // Collateral for bids\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \n\n        // or asks\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \n    }\n\n    function makerClaim(\n        uint16 point, \n        bool buyTradeForBase\n        ) external {\n        uint256 claimedAmount = this.claimFilledOrder(\n            msg.sender, \n            point, \n            !buyTradeForBase\n        ); \n\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\n        else BaseToken.transfer(msg.sender, claimedAmount); \n\n    }\n}\n\n\n\n\n\n"
    },
    "contracts/bonds/libraries.sol": {
      "content": "pragma solidity ^0.8.9;\n\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMath {\n\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\n    //     require((z = uint256(y)) == y);\n    // }\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\n    //     require((z = uint160(y)) == y);\n    // }\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\n        require((z = uint128(y)) == y);\n    }\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n\n\ncontract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n    function mint(address to, uint256 amount) public {\n      _mint(to, amount); \n    }\n    function burn(address to, uint256 amount) public {\n      _burn(to, amount); \n    }\n}"
    },
    "contracts/bonds/synthetic.sol": {
      "content": "pragma solidity ^0.8.9;\nimport { LinearCurve} from \"./GBC.sol\"; \nimport {BoundedDerivativesPool} from \"./boundedDerivatives.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"./libraries.sol\"; \nimport \"lib/forge-std/src/console.sol\";\n\ncontract ZCBFactory{\n    function newBond(\n        string memory name, \n        string memory description \n        ) public returns(address) {\n        ERC20 bondToken = new ERC20(name,description, 18);\n        return address(bondToken); \n    }\n\n}\ncontract SyntheticZCBPoolFactory{\n    address public immutable controller;\n    address public immutable zcbFactory; \n    constructor(address _controller, address _zcbFactory){\n        controller = _controller; \n        zcbFactory = _zcbFactory; \n    }\n\n    event PoolCreated(address pool, address longZCB, address shortZCB);\n\n    /// @notice param base is the collateral used in pool \n    function newPool(\n        address base, \n        address entry\n        ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\n        longZCB = ZCBFactory(zcbFactory).newBond(\"longZCB\", \"long\");\n        shortZCB = ZCBFactory(zcbFactory).newBond(\"shortZCB\", \"short\");\n\n        pool = new SyntheticZCBPool(\n            base, longZCB, shortZCB, entry, controller\n        ); \n        emit PoolCreated(address(pool), longZCB, shortZCB);\n    }\n}\n\ncontract SyntheticZCBPool is BoundedDerivativesPool{\n    using FixedPointMathLib for uint256;\n\n    uint256 public a_initial;\n    uint256 public b_initial; // b without discount cap \n    uint256 public b;\n    uint256 public discount_cap; \n    uint256 public discountedReserves; \n    uint256 public upperBound; \n    address public immutable controller; \n    uint256 public constant precision = 1e18; \n    constructor(address base, \n        address trade, \n        address s_trade, \n        address _entry, \n        address _controller\n        )BoundedDerivativesPool(base,trade,s_trade, false){\n        entry = _entry; \n        controller = _controller; \n        }\n\n    /// @notice calculate and store initial curve params that takes into account\n    /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\n    /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \n    /// @param sigma is the proportion of P that is going to be bought at a discount  \n    function calculateInitCurveParams(\n        uint256 P, \n        uint256 I, \n        uint256 sigma,\n        uint256 alpha, \n        uint256 delta) external {\n        require(msg.sender == controller, \"unauthorized\"); \n        b_initial = (2*P).divWadDown(P+I) - precision; \n        a_initial = (precision-b_initial).divWadDown(P+I); \n\n        // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\n        (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\n        (, upperBound )= LinearCurve.amountOutGivenIn(P.mulWadDown(alpha+delta), 0, a_initial, b_initial,true); \n\n        // Set initial liquidity and price \n        setLiquidity(uint128(precision.divWadDown(a_initial))); \n        setPriceAndPoint(b);\n    }\n\n    /// @notice calculates initparams for pool based instruments \n    /// param endPrice is the inception Price of longZCB, or its price when there is no discount\n    function calculateInitCurveParamsPool(\n        uint256 saleAmount, \n        uint256 initPrice, \n        uint256 endPrice, \n        uint256 sigma\n        ) external returns(uint256 managementFee){\n        require(msg.sender == controller, \"unauthorized\"); \n        //TODO these fails at some inputs\n        uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \n        uint256 a = (endPrice - initPrice).divWadDown(saleAmountQty); \n        \n        //Set discount cap as saleAmount * sigma \n        (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \n        b = initPrice; \n\n        // How much total discounts are validators and managers getting\n        managementFee = discount_cap.mulWadDown(endPrice) \n            - saleAmount.mulWadDown(sigma) + saleAmountQty.mulWadDown(endPrice) - saleAmount ; \n\n        // set initial liquidity and price \n        setLiquidity(uint128(precision.divWadDown(a))); \n        setPriceAndPoint(b); \n        setDynamicLiquidity(priceToPoint(endPrice), type(int128).max); \n        setModifyLiqPoint(priceToPoint(endPrice)); \n    }\n\n    /// @notice computes area between the curve and max price for given storage parameters\n    function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\n        (uint256 amountDelta, ) = LinearCurve.amountOutGivenIn(amount, 0, a_initial, b_initial, true); \n        return amountDelta.mulWadDown(maxPrice) - amount; \n    }\n\n    /// @notice mints new zcbs \n    function trustedDiscountedMint(\n        address receiver, \n        uint256 amount \n        ) external{\n        require(msg.sender == entry, \"entryERR\"); \n\n        TradeToken.mint(receiver, amount);\n        discountedReserves += amount;\n    }\n\n\n    function trustedBurn(\n        address trader, \n        uint256 amount, \n        bool long\n        ) external {\n        require(msg.sender == entry, \"entryERR\"); \n        if (long) TradeToken.burn(trader, amount); \n        else s_tradeToken.burn(trader, amount);\n    }\n\n    function flush(address flushTo, uint256 amount) external {\n        require(msg.sender == controller, \"entryERR\"); \n        if (amount == type(uint256).max) BaseToken.transfer(flushTo, baseBal()); \n        else BaseToken.transfer(flushTo, amount); \n    }\n\n    /// @notice resets AMM liquidity to 0 and make it ready to be liq provisioned \n    /// by anyone \n    function resetLiq() external{\n        require(msg.sender == controller, \"entryERR\"); \n        setLiquidity(0); \n        amortizeLiq(); \n    }\n\n}\n"
    },
    "contracts/chainlink/VRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {VRFConsumerBaseV2} from \"../chainlink/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"../chainlink/VRFCoordinatorV2Interface.sol\";\n\ncontract ChainlinkClient is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface COORDINATOR;\n\n    // Your subscription ID.\n    uint64 private immutable s_subscriptionId;\n\n    // Goerli coordinator. For other networks,\n    // see https://docs.chain.link/docs/vrf-contracts/#configurations\n\n\n    // The gas lane to use, which specifies the maximum gas price to bump to.\n    // For a list of available gas lanes on each network,\n    // see https://docs.chain.link/docs/vrf-contracts/#configurations\n    bytes32 private keyHash;\n\n    // Depends on the number of requested values that you want sent to the\n    // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\n    // so 100,000 is a safe default for this example contract. Test and adjust\n    // this limit based on the network that you select, the size of the request,\n    // and the processing of the callback request in the fulfillRandomWords()\n    // function.\n    uint32 private callbackGasLimit = 100000;\n\n    // The default is 3, but you can set this higher.\n    uint16 private requestConfirmations = 3;\n\n    uint256[] public s_randomWords;\n    uint256 public s_requestId;\n    address s_owner;\n\n    mapping(uint256 => bool) used; // marketId => whether vrf has been called for a specific market\n    mapping(uint256 => address[]) candidates; // marketId => possible validators.\n\n    constructor(\n        bytes32 _keyHash,\n        address _vrfCoordinator,\n        uint64 subscriptionId\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\n        s_owner = msg.sender;\n        s_subscriptionId = subscriptionId;\n        keyHash = _keyHash;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == s_owner);\n        _;\n    }\n\n    /**\n     @notice called by oracle on completion\n     */\n    function fulfillRandomWords(\n        uint256, /* requestId */\n        uint256[] memory randomWords\n    ) internal override {\n        s_randomWords = randomWords;\n    }\n\n    function requestRandomWords(\n        uint32 numWords,\n        uint256 marketId,\n        address[] memory _candidates\n    ) external onlyOwner {\n        require(!used[marketId], \"random words already requested for this marketId\");\n        used[marketId] = true;\n        candidates[marketId] = _candidates;\n\n        // Will revert if subscription is not set and funded.\n        s_requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n    }\n\n    /**\n     @dev should only be called by marketManager.\n     */\n    function deleteWords() external {\n        delete s_randomWords;\n    }\n\n    function wordLength() external returns (uint256) {\n        return s_randomWords.length;\n    }\n\n    function getNums() external returns (uint256[] memory) {\n        return s_randomWords;\n    }\n}\n"
    },
    "contracts/chainlink/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}"
    },
    "contracts/chainlink/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}"
    },
    "contracts/global/GlobalStorage.sol": {
      "content": "pragma solidity ^0.8.16;\nimport \"./types.sol\"; \nimport {PerpTranchePricer} from \"../libraries/pricerLib.sol\"; \nimport {Instrument} from \"../vaults/instrument.sol\"; \n\n\ncontract StorageHandler{\n\tusing PerpTranchePricer for PricingInfo; \n\n\tuint256 constant BASE_UNIT = 1e18; \n\n\tmapping(uint256=> PricingInfo) public PricingInfos; \n\tmapping(uint256=> InstrumentData) public InstrumentDatas; \n\t// mapping(uint256=>CoreMarketData) public MarketDatas; \n  \tCoreMarketData[] public markets;\n\n\n    modifier onlyProtocol() {\n        \n        _;\n    }\n\n\n\t/// @notice called at market creation \n\tfunction setNewInstrument(\n\t\tuint256 marketId, \n\t\tuint256 initialPrice, \n\t\tuint256 multiplier, \n\t\tbool constantRF, \n\t\tInstrumentData memory idata, \n\t\tCoreMarketData memory mdata) external onlyProtocol{\n\t\tPricingInfos[marketId].setNewPrices(initialPrice, multiplier, marketId, constantRF); \n\n\t\tstoreNewProposal(marketId, idata); \n\t\t// storeNewMarket(marketId, mdata); \n\t}\n\n\n    //--- Pricing ---// \n\n\tfunction getPricingInfo(uint256 marketId) public view returns(PricingInfo memory){\n\t\treturn PricingInfos[marketId]; \n\t}\n\n\tfunction updatePricingInfo(uint256 marketId, PricingInfo memory newInfo) external onlyProtocol{\n\t\tPricingInfos[marketId] = newInfo; \n\t}\n\n\tfunction refreshPricing(uint256 marketId, uint256 uRate) public onlyProtocol{\n\t\tPricingInfos[marketId].storeNewPSU(uRate); \n\t}\n\n\tfunction viewCurrentPricing(uint256 marketId) public view returns(uint256, uint256, uint256) {\n\t\tInstrumentData memory data = InstrumentDatas[marketId]; \n\t\tPricingInfos[marketId].viewCurrentPricing(\n\t\t\tdata.instrument_address, \n\t\t\tdata.poolData, \n\t\t\tmarkets[marketId].longZCB.totalSupply()\n\t\t); \n\t}\n\n\n\n\n\n\t//--- Instrument ---//\n\n\tfunction storeNewProposal(uint256 marketId, InstrumentData memory data) public onlyProtocol{\n\t\tInstrumentDatas[marketId] = data; \n\t}\n\n\n\t//--- Market ---//\n\tfunction storeNewMarket(CoreMarketData memory data) public onlyProtocol returns(uint256 marketId){\n\t\t// MarketDatas[marketId] = data; \n\t\tmarketId = markets.length; \n\t\tmarkets.push(data); \n\t\t// uint256 base_budget = 1000 * BASE_UNIT; //TODO \n\t\t// setMarketPhase(marketId, true, true, base_budget);\n\t}\n\n\n\n\n\n}\n\n\n\n\t// function queryTrancheAssetOracle(uint256 marketId, uint256 supply) public view returns(uint256){\n\t// \tuint256 juniorSupply = markets[marketId].longZCB.totalSupply(); \n\t// \tuint256 seniorSupply = juniorSupply.mulWadDown()\n\t// \tInstrument(Instrument[marketId].instrument_address).assetOracle(supply); \n\t// }\n\n// library GlobalStorage{\n\n//    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots\n//     /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.\n//     uint256 private constant STORAGE_SLOT_BASE = 1000000;\n\n\n//     /// @dev Storage IDs for storage buckets. Each id maps to an internal storage\n//     /// slot used for a particular mapping\n//     ///     WARNING: APPEND ONLY\n//     enum StorageId {\n//            Unused,\n\n//         _PricingInfo \n//     }\n\n\n// \tfunction PricingInfos() public returns(mapping(uint256=> PricingInfo) storage store) {\n//         uint256 slot = _getStorageSlot(StorageId._PricingInfo);\n//         assembly { store.slot := slot }\n//     }\n\n\n//     /// @dev Get the storage slot given a storage ID.\n//     /// @param storageId An entry in `StorageId`\n//     /// @return slot The storage slot.\n//     function _getStorageSlot(StorageId storageId)\n//         private\n//         pure\n//         returns (uint256 slot)\n//     {\n//         // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\n//         // because Solidity will do a range check on `storageId` during the cast.\n//         return uint256(storageId) + STORAGE_SLOT_BASE;\n//     }\n\n// }"
    },
    "contracts/global/types.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {SyntheticZCBPool} from \"../bonds/synthetic.sol\"; \nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nstruct PricingInfo{\n\tuint256 psu; \n\n\tuint256 prevAccrueTime; \n\tuint256 prevIntervalRp; //per second compounding promised return, function of urate \n\n\t// Constants for a given market \n\tuint256 URATE_MULTIPLIER; \n\tuint256 ID; \n\n\tbool constantRF; \n}\n\n\nstruct MarketData {\n    address instrument_address;\n    address utilizer;\n}\n\nstruct ApprovalData {\n    uint256 managers_stake;\n    uint256 approved_principal;\n    uint256 approved_yield;\n}\n\nstruct InstrumentData {\n\tbytes32 name;\n\tbool isPool; \n\t// Used to determine if the Vault will operate on a Instrument.\n\tbool trusted;\n\t// Balance of the contract denominated in Underlying, \n\t// used to determine profit and loss during harvests of the Instrument.  \n\t// represents the amount of debt the Instrument has incurred from this vault   \n\tuint256 balance; // in underlying, IMPORTANT to get this number right as it modifies key states \n\tuint256 faceValue; // in underlying\n\tuint256 marketId;\n\tuint256 principal; //this is total available allowance in underlying\n\tuint256 expectedYield; // total interest paid over duration in underlying\n\tuint256 duration;\n\tstring description;\n\taddress instrument_address;\n\tInstrumentType instrument_type;\n\tuint256 maturityDate;\n\tPoolData poolData; \n}\n\n/// @notice probably should have default parameters for each vault\nstruct PoolData{\n\tuint256 saleAmount; \n\tuint256 initPrice; // init price of longZCB in the amm \n\tuint256 promisedReturn; //per unit time \n\tuint256 inceptionTime;\n\tuint256 inceptionPrice; // init price of longZCB after assessment \n\tuint256 leverageFactor; // leverageFactor * manager collateral = capital from vault to instrument\n\tuint256 managementFee; // sum of discounts for high reputation managers/validators\n}\n\nstruct CoreMarketData {\n\tSyntheticZCBPool bondPool; \n\tERC20 longZCB;\n\tERC20 shortZCB; \n\tstring description; // instrument description\n\tuint256 creationTimestamp;\n\tuint256 resolutionTimestamp;\n\tbool isPool; \n}\n\nstruct MarketPhaseData {\n\tbool duringAssessment;\n\tbool onlyReputable;\n\tbool resolved;\n\tbool alive;\n\tbool atLoss;\n\t// uint256 min_rep_score;\n\tuint256 base_budget;\n}\n\n  /// @param N: upper bound on number of validators chosen.\n  /// @param sigma: validators' stake\n  /// @param alpha: minimum managers' stake\n  /// @param omega: high reputation's stake \n  /// @param delta: Upper and lower bound for price which is added/subtracted from alpha \n  /// @param r: reputation percentile for reputation constraint phase\n  /// @param s: senior coefficient; how much senior capital the managers can attract at approval \n  /// @param steak: steak*approved_principal is the staking amount.\n  /// param beta: how much volatility managers are absorbing \n  /// param leverage: how much leverage managers can apply \n  /// param base_budget: higher base_budget means lower decentralization, \n  /// @dev omega always <= alpha\n struct MarketParameters{\n\tuint256 N;\n\tuint256 sigma; \n\tuint256 alpha; \n\tuint256 omega;\n\tuint256 delta; \n\tuint256 r;\n\tuint256 s;\n\tuint256 steak;\n  }\n\n\n\nstruct ResolveVar{\n\tuint256 endBlock; \n\tbool isPrepared; \n}\n\n\n\n\n\nenum InstrumentType {\n    CreditLine,\n    CoveredCallShort,\n    LendingPool, \n    StraddleBuy,\n    LiquidityProvision, \n    Other\n}\n"
    },
    "contracts/instruments/IPoolInstrument.sol": {
      "content": ""
    },
    "contracts/instruments/IRateCalculator.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity >=0.8.16;\n\ninterface IRateCalculator {\n    function name() external pure returns (string memory);\n\n    function requireValidInitData(bytes calldata _initData) external pure;\n\n    function getConstants() external pure returns (bytes memory _calldata);\n\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec);\n}\n"
    },
    "contracts/instruments/LinearInterestRate.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.16;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ======================= LinearInterestRate =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"./IRateCalculator.sol\";\n\n/// @title A formula for calculating interest rates linearly as a function of utilization\n/// @author Drake Evans github.com/drakeevans\ncontract LinearInterestRate is IRateCalculator {\n    uint256 private constant MIN_INT = 0; // 0.00% annual rate\n    uint256 private constant MAX_INT = 146248508681; // 10,000% annual rate\n    uint256 private constant MAX_VERTEX_UTIL = 1e5; // 100%\n    uint256 private constant UTIL_PREC = 1e5;\n\n    /// @notice The ```name``` function returns the name of the rate contract\n    /// @return memory name of contract\n    function name() external pure returns (string memory) {\n        return \"Linear Interest Rate\";\n    }\n\n    /// @notice The ```getConstants``` function returns abi encoded constants\n    /// @return _calldata abi.encode(uint256 MIN_INT, uint256 MAX_INT, uint256 MAX_VERTEX_UTIL, uint256 UTIL_PREC)\n    function getConstants() external pure returns (bytes memory _calldata) {\n        return abi.encode(MIN_INT, MAX_INT, MAX_VERTEX_UTIL, UTIL_PREC);\n    }\n\n    /// @notice The ```requireValidInitData``` function reverts if initialization data fails to be validated\n    /// @param _initData abi.encode(uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization)\n    function requireValidInitData(bytes calldata _initData) public pure {\n        (uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization) = abi.decode(\n            _initData,\n            (uint256, uint256, uint256, uint256)\n        );\n        require(\n            _minInterest < MAX_INT && _minInterest <= _vertexInterest && _minInterest >= MIN_INT,\n            \"LinearInterestRate: _minInterest < MAX_INT && _minInterest <= _vertexInterest && _minInterest >= MIN_INT\"\n        );\n        require(\n            _maxInterest <= MAX_INT && _vertexInterest <= _maxInterest && _maxInterest > MIN_INT,\n            \"LinearInterestRate: _maxInterest <= MAX_INT && _vertexInterest <= _maxInterest && _maxInterest > MIN_INT\"\n        );\n        require(\n            _vertexUtilization < MAX_VERTEX_UTIL && _vertexUtilization > 0,\n            \"LinearInterestRate: _vertexUtilization < MAX_VERTEX_UTIL && _vertexUtilization > 0\"\n        );\n    }\n\n    /// @notice Calculates interest rates using two linear functions f(utilization)\n    /// @dev We use calldata to remain un-opinionated about future implementations\n    /// @param _data abi.encode(uint64 _currentRatePerSec, uint256 _deltaTime, uint256 _utilization, uint256 _deltaBlocks)\n    /// @param _initData abi.encode(uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization)\n    /// @return _newRatePerSec The new interest rate per second, 1e18 precision\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec) {\n        requireValidInitData(_initData);\n        (, , uint256 _utilization, ) = abi.decode(_data, (uint64, uint256, uint256, uint256));\n        (uint256 _minInterest, uint256 _vertexInterest, uint256 _maxInterest, uint256 _vertexUtilization) = abi.decode(\n            _initData,\n            (uint256, uint256, uint256, uint256)\n        );\n        if (_utilization < _vertexUtilization) {\n            uint256 _slope = ((_vertexInterest - _minInterest) * UTIL_PREC) / _vertexUtilization;\n            _newRatePerSec = uint64(_minInterest + ((_utilization * _slope) / UTIL_PREC));\n        } else if (_utilization > _vertexUtilization) {\n            uint256 _slope = (((_maxInterest - _vertexInterest) * UTIL_PREC) / (UTIL_PREC - _vertexUtilization));\n            _newRatePerSec = uint64(_vertexInterest + (((_utilization - _vertexUtilization) * _slope) / UTIL_PREC));\n        } else {\n            _newRatePerSec = uint64(_vertexInterest);\n        }\n    }\n}\n"
    },
    "contracts/instruments/oldpoolInstrument.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {PoolConstants} from \"./poolConstants.sol\";\nimport {VaultAccount, VaultAccountingLibrary} from \"./VaultAccount.sol\";\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {IRateCalculator} from \"./IRateCalculator.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Pausable} from \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {ERC4626} from \"lib/solmate/src/mixins/ERC4626.sol\";\nimport {ERC721TokenReceiver} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport \"lib/forge-std/src/console.sol\";\n// import \"@prb/math/SD59x18.sol\";\n\n// https://github.com/FraxFinance/fraxlend\n/// ****THIS IS A PROOF OF CONCEPT INSTRUMENT.\ncontract PoolInstrument is ERC4626, Instrument, PoolConstants, ReentrancyGuard, Pausable, ERC721TokenReceiver {\n    using SafeTransferLib for ERC20;\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n\n    /// @param lastBlock last block number\n    /// @param lastTimestamp last block.timestamp\n    /// @param ratePerSec rate per second of interest accrual\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @param tokenAddress collateral token address\n    /// @param tokenId collateral tokenId, 0 for ERC20.\n    struct CollateralLabel {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    /// @param totalCollateral total amount of collateral for a given ERC20 asset, will be zero for NFTs\n    /// @param maxAmount max amount in underlying that a user can \"owe\" per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    /// should always be more than the maxBorrowAmount, acts as buffer for protocol and borrower. this is the value to determine whether\n    /// a borrower is liquidatable\n    /// @param maxBorrowAmount max amount in underlying that a user can borrow per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    struct Collateral {\n        uint256 totalCollateral; \n        uint256 maxAmount;\n        uint256 maxBorrowAmount;\n        bool isERC20;\n    }\n\n    /// @notice dutch auctions for NFTs, GDA for illiquid ERC20s.\n    /// @param borrower address of borrower\n    /// @param collateral address of collateral\n    /// @param tokenId tokenId of collateral, 0 for ERC20\n    /// @param initialPrice initial price of collateral currently is (account liquidity / collateral amount) + maxAmount.\n    /// @param decayConstant parameter that controls price decay, stored as a 59x18 fixed precision number\n    /// @param startTime for dutch auction: start time of auction, for GDA: time of last auction.\n    /// @param emissionRate for dutch auction: 0, for GDA: amount of collateral to be auctioned off per second.\n    // struct Auction {\n    //     address borrower;\n    //     address collateral;\n    //     uint256 tokenId;\n    //     SD59x18 initialPrice;\n    //     SD59x18 minimumPrice;\n    //     SD59x18 decayConstant;\n    //     SD59x18 startTime;\n    //     // SD59x18 emissionRate;\n    //     bool alive;\n    // }\n\n    /// @notice amount: asset token borrowed, shares = total shares outstanding\n    VaultAccount public totalBorrow;\n    /// @notice amount: total asset supplied + interest earned, shares = total shares outstanding\n    VaultAccount public totalAsset;\n\n    mapping(address=>mapping(uint256 => Collateral)) public collateralData; // collateral address => tokenId (0 for erc20) => collateral data.\n    mapping(address=>mapping(uint256=>bool)) public approvedCollateral;\n    mapping(address=>mapping(address=>uint256)) public userCollateralERC20; // per collateral, user balance of collateral.\n    mapping(address=>mapping(uint256 => address)) public userCollateralNFTs; // nft addr => tokenId => owner.\n    mapping(address=>uint256) public userBorrowShares;\n    mapping(address=>uint256) public userAuctionId; // user => current auction id, if 0 then no auction.\n    \n    /// @dev auction id => order of creation.\n    // mapping(uint256=>Auction) public auctions; // auction id => auction data, auction id is in order of creation.\n\n    uint256 public numAuctions; // number of auction ids.\n\n    IRateCalculator public rateContract;\n\n    /// @dev depends on rateCalculator used\n    bytes public rateInitCallData;\n    \n    CurrentRateInfo public currentRateInfo;\n    CollateralLabel[] collaterals; //approved collaterals.\n    address controller;\n    \n    constructor (\n        address _vault,\n        address _controller,\n        address _utilizer,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _rateCalculator,\n        bytes memory _rateInitCallData,\n        CollateralLabel[] memory _collaterals,\n        Collateral[] memory _collateralDatas\n    ) Instrument(_vault, _utilizer) ERC4626(ERC20(_asset), _name, _symbol) {\n        controller = _controller;\n        rateContract = IRateCalculator(_rateCalculator);\n        rateInitCallData = _rateInitCallData;\n        rateContract.requireValidInitData(_rateInitCallData);\n\n        for (uint i = 0; i < _collaterals.length; i ++) {\n            collaterals.push(_collaterals[i]);\n            Collateral memory _collateral = _collateralDatas[i];\n            _collateral.totalCollateral = 0;\n            collateralData[_collaterals[i].tokenAddress][_collaterals[i].tokenId] = _collateral;\n        }\n    }\n\n    // should be gated function\n    /// tokenId 0 for ERC20.\n    // function initialize(\n    // ) external {\n\n    // }\n\n    function getAcceptedCollaterals() view public returns (CollateralLabel[] memory) {\n        return collaterals;\n    }\n\n    event NewCollateralAdded(address collateral, uint256 tokenId, uint256 maxAmount, uint256 maxBorrowAmount, bool isERC20);\n    // legacy for tests, remove later.\n    function addAcceptedCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _maxAmount,\n        uint256 _maxBorrowAmount,\n        bool _isERC20\n    ) external  {\n        require(msg.sender == controller || msg.sender == address(vault), \"!authorized\");\n        if (approvedCollateral[_collateral][_tokenId]) return; \n        require(_maxAmount > _maxBorrowAmount, \"maxAmount must be greater than maxBorrowAmount\");\n        approvedCollateral[_collateral][_tokenId] = true;\n        collaterals.push(CollateralLabel(_collateral, _tokenId));\n        collateralData[_collateral][_tokenId] = Collateral(0,_maxAmount, _maxBorrowAmount, _isERC20);\n        emit NewCollateralAdded(_collateral, _tokenId, _maxAmount, _maxBorrowAmount, _isERC20);\n    }\n\n    // INTERNAL HELPERS\n\n    modifier onlyApprovedCollateral(address _collateral, uint256 _tokenId) {\n        require(approvedCollateral[_collateral][_tokenId], \"collateral not approved\");\n        _;\n    }\n\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    // INTEREST RATE LOGIC\n    event InterestAdded(uint256 indexed timestamp, uint256 interestEarned, uint256 feesAmount, uint256 feesShare, uint64 newRate);\n\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    function _addInterest() internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n        console.log(\"total borrower shares: \", totalBorrow.shares);\n\n        // If there are no borrows or contract is paused, no interest adds and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            // console.log(\"_utilizationRate: \", _utilizationRate);\n            bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest addd\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n        console.log(\"_interestEarned: \", _interestEarned);\n        emit InterestAdded(block.timestamp, _interestEarned, _feesAmount, _feesShare, _newRate);\n        // console.log(\"ratePerSec: \", _currentRateInfo.ratePerSec);\n    }\n\n    // SOLVENCY* LOGIC\n\n    /// @notice Checks if total amount of asset user borrowed is less than max borrow threshold AFTER executing contract code\n    modifier canBorrow(address _borrower) {\n        _;\n        require(_canBorrow(_borrower), \"borrower is insolvent\");\n    }\n\n\n    /// @notice checks if the borrower is can borrow\n    /// @dev collateral value is in asset, summed across all approved collaterals.\n    /// @dev will return true if the borrower has no collateral and also has no borrower shares.\n    /// @dev 0 addr cannot borrow.\n    function _canBorrow(address _borrower) public view returns (bool) {\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\n\n        if (userBorrowShares[_borrower] == 0) {\n            return true;\n        }\n        if (_maxBorrowableAmount == 0) {\n            return false;\n        }\n        return _maxBorrowableAmount >= totalBorrow.toAmount(userBorrowShares[_borrower], false);\n    }\n\n    function getMaxBorrow(address _borrower) public view returns(uint256 _maxBorrowableAmount){\n\n        for (uint256 i; i < collaterals.length; i++) {\n            CollateralLabel memory _collateral = collaterals[i];\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxBorrowAmount / (10**_d); // <= precision of collateral.\n            } else {\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\n                    _maxBorrowableAmount += _collateralData.maxBorrowAmount;\n                }\n            }\n        }\n    }\n\n    /// @notice returns how much collateral can be removed, given the borrower's current debt condition\n    function removeableCollateral(address _borrower, uint256 tokenId, address collateral) public view returns(uint256){\n        //800 borrowable = 800 * 1, 600borrowed (800-x)*1 - 600 = 0 x=? \n        //800*1-x*1-600 , x = (800*1 - 600)/1\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower); \n        uint256 perUnitMaxBorrowAmount = collateralData[collateral][tokenId].maxBorrowAmount; \n        //check solvency\n        return (_maxBorrowableAmount - totalBorrow.toAmount(userBorrowShares[_borrower], true)) \n            * 1e18/ perUnitMaxBorrowAmount; \n    }  \n\n    // BORROW LOGIC\n    event Borrow(address indexed _borrower, uint256 _amount, uint256 _shares);\n\n    /// @param _borrowAmount amount of asset to borrow\n    /// @param _collateralAmount amount of collateral to add\n    /// @param _collateral address of collateral, \n    /// @param _reciever address of reciever of asset\n    function borrow(\n        uint256 _borrowAmount,\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _reciever\n    ) canBorrow(msg.sender) nonReentrant whenNotPaused external returns (uint256 _shares) {\n        _addInterest();\n\n        if (_collateral != address(0) && (_collateralAmount > 0 || _tokenId > 0)) {\n            require(approvedCollateral[_collateral][_tokenId], \"unapproved collateral\");\n            _addCollateral(msg.sender, _collateral, _collateralAmount, msg.sender, _tokenId);\n        }\n        // borrow asset.\n        _shares = _borrow(_borrowAmount.safeCastTo128(), _reciever);\n    }\n\n    function _borrow(\n        uint128 _borrowAmount,\n        address _receiver\n    ) internal returns (uint256 _shares) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert(\"insufficient contract asset balance\");\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _shares = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_shares);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _shares;\n\n        emit Borrow(msg.sender, _borrowAmount, _shares);\n\n        // Interactions\n        if (_receiver != address(this)) {\n            asset.safeTransfer(_receiver, _borrowAmount);\n        }\n    }\n\n    // REPAY LOGIC\n    event Repay(address indexed borrower, uint256 amount, uint256 shares);\n\n    function repayWithAmount(\n        uint256 _amount, \n        address _borrower\n        )   external nonReentrant returns (uint256 _sharesToRepay){\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _sharesToRepay = _totalBorrow.toShares(_amount, true); \n        _repay(_totalBorrow, _amount.safeCastTo128(), _sharesToRepay.safeCastTo128(), msg.sender, _borrower);\n    }\n\n    function repay(\n        uint256 _shares,\n        address _borrower\n    ) external nonReentrant returns (uint256 _amountToRepay) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        console.log(\"amount to repay: \", _amountToRepay);\n        _repay(_totalBorrow, _amountToRepay.safeCastTo128(), _shares.safeCastTo128(), msg.sender, _borrower);\n    }\n\n    function _repay(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        console.log(\"_shares: \", _shares);\n        console.log(\"_amountToRepay: \", _amountToRepay);\n        console.log(\"userBorrowShares[_borrower]: \", userBorrowShares[_borrower]);\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        emit Repay(_borrower, _amountToRepay, _shares);\n\n        // Interactions\n        if (_payer != address(this)) {\n            asset.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n    }\n\n\n    // ADD/REMOVE COLLATERAL LOGIC\n    event AddCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\n    event RemoveCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\n\n    \n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation, or ERC721.approve().\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _borrower\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant {\n        _addInterest();\n        _addCollateral(msg.sender, _collateral, _collateralAmount, _borrower, _tokenId);\n    }\n\n    function _addCollateral(\n        address _sender,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _borrower,\n        uint256 _tokenId\n    ) internal {\n\n        // Interactions\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\n    \n        if (_sender != address(this)) {\n            if (_isERC20)  {\n                userCollateralERC20[_collateral][_borrower] += _collateralAmount;\n                collateralData[_collateral][0].totalCollateral += _collateralAmount;\n                ERC20(_collateral).safeTransferFrom(_sender, address(this), _collateralAmount);\n            } else {\n                userCollateralNFTs[_collateral][_tokenId] = _borrower;\n                ERC721(_collateral).safeTransferFrom(_sender, address(this), _tokenId);\n            }\n        }\n        emit AddCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    function removeAvailableCollateral(\n        address _collateral, \n        uint256 _tokenId,\n        address _receiver\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) returns(uint256 removeable){\n        _addInterest();\n\n        removeable = removeableCollateral(msg.sender,  _tokenId,  _collateral); \n\n        _removeCollateral(_collateral, \n            removeable,\n            _tokenId, msg.sender, _receiver);\n    }\n\n    function removeCollateral(\n        address _collateral, \n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _receiver\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) {\n        _addInterest();\n\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        _removeCollateral(_collateral, _collateralAmount, _tokenId, msg.sender, _receiver);\n    }\n\n    function _removeCollateral(\n        address _collateral,\n        uint256 _collateralAmount,\n        uint256 _tokenId,\n        address _borrower,\n        address _receiver\n    ) internal {\n\n        // Interactions\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\n        if (_receiver != address(this)) {\n            if (_isERC20) {\n                console.log(\"removing erc20 collateral\");\n                console.log(\"userCollateralerc20: \", userCollateralERC20[_collateral][_borrower] );\n                console.log(\"collateralAmount: \", _collateralAmount);\n                console.log(\"total: \", collateralData[_collateral][0].totalCollateral);\n                userCollateralERC20[_collateral][_borrower] -= _collateralAmount;\n                collateralData[_collateral][0].totalCollateral -= _collateralAmount;\n                ERC20(_collateral).safeTransfer(_receiver, _collateralAmount);\n            } else {\n                require(userCollateralNFTs[_collateral][_tokenId] == _borrower, \"not owner of nft\");\n                delete userCollateralNFTs[_collateral][_tokenId];\n                ERC721(_collateral).safeTransferFrom(address(this), _receiver, _tokenId);\n            }\n        }\n        emit RemoveCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    // liquidation logic\n\n    /// @notice collateral should be auctioned off at a minimum price chosen by the managers\n    /// underlying balance, collateral balance, what do we know about the user?\n    /// if the user's borrow shares are equal to an amount of asset that is greater than the maximum amount they can borrow, \n    /// they are suceptible to liquidation\n    /// how to determine what collateral should be auctioned off?\n    /// maxBorrowAmount\n    function _isLiquidatable(address _borrower) public view returns (bool, int256 accountLiq) {\n        uint256 _maxBorrowableAmount;\n\n        for (uint256 i; i < collaterals.length; i++) {\n            CollateralLabel memory _collateral = collaterals[i];\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxAmount / (10**_d); // <= precision of collateral.\n            } else {\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\n                    _maxBorrowableAmount += _collateralData.maxAmount;\n                }\n            }\n        }\n\n\n        return (_maxBorrowableAmount < totalBorrow.toAmount(userBorrowShares[_borrower], false), \n            int256(_maxBorrowableAmount) - int256(totalBorrow.toAmount(userBorrowShares[_borrower], false))\n        );\n    }\n\n    /// AUCTION LOGIC\n\n    event AuctionCreated(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event AuctionClosed(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event CollateralPurchased(uint256 indexed id, address indexed buyer, address indexed collateral, uint256 tokenId, uint256 amount);\n\n    function liquidate(\n        address _borrower\n    ) external nonReentrant returns (CollateralLabel memory _collateral, uint256 _auctionId){\n        _addInterest();\n        \n        (bool _liquidatable, int256 _accountLiq) = _isLiquidatable(_borrower);\n        require(_liquidatable, \"borrower is not liquidatable\");\n        require(userAuctionId[_borrower] == 0, \"auction already exists\");\n        // _accountLiq < 0 if _liquidatable.\n        //(_collateral, _auctionId) = _createAuction(_borrower, uint256(-_accountLiq));\n    }\n\n    // since we don't know the price of the collateral, will just use largest maxAmount collateral, presumably the most \"liquid\"\n    /// @dev _accountLiq in wad.\n    // function _createAuction(address _borrower, uint256 _accountLiq) internal returns (CollateralLabel memory _collateral, uint256 _auctionId) {\n    //     CollateralLabel[] memory _collaterals = collaterals;\n\n    //     uint256 maxBorrowableAmount;\n    //     for (uint256 i; i<_collaterals.length; i++) {\n    //         CollateralLabel memory _collateralLabel = _collaterals[i];\n    //         Collateral memory _collateralData = collateralData[_collateralLabel.tokenAddress][_collateralLabel.tokenId];\n    //         if (_collateralData.isERC20) {\n    //             uint256 _amount = userCollateralERC20[_collateralLabel.tokenAddress][_borrower] * _collateralData.maxAmount / 1e18; // <= precision of collateral.\n    //             if (_amount > maxBorrowableAmount) {\n    //                 maxBorrowableAmount = _amount;\n    //                 _collateral = _collateralLabel;\n    //             }\n    //         } else {\n    //             if (userCollateralNFTs[_collateralLabel.tokenAddress][_collateralLabel.tokenId] == _borrower) {\n    //                 if (_collateralData.maxAmount > maxBorrowableAmount) {\n    //                     maxBorrowableAmount = _collateralData.maxAmount;\n    //                     _collateral = _collateralLabel;\n    //                 }\n    //             }\n    //         }\n    //     }\n\n    //     // creates auction for collateral user collateral.\n    //     Collateral memory _data = collateralData[_collateral.tokenAddress][_collateral.tokenId];\n\n    //     uint256 _id = numAuctions + 1;\n\n    //     SD59x18 _balance;\n    //     if (_data.isERC20) {\n    //         uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n    //         _balance = sd(int256(userCollateralERC20[_collateral.tokenAddress][_borrower] * 10**(18-_d)));\n    //     } else {\n    //         _balance = toSD59x18(1);\n    //     }\n    //     console.log(\"accountLiq: \", _accountLiq);\n    //     console.logInt(SD59x18.unwrap(_balance));\n    //     console.log(\"maxAmount: \", _data.maxAmount);\n    //     console.logInt(int256(_data.maxAmount));\n\n    //     SD59x18 _initialPrice = sd(int256(_accountLiq)).div(_balance).add(sd(int256(_data.maxAmount))); // per collateral token.\n    //     // console.logInt(SD59x18.unwrap(_initialPrice));\n\n    //     console.log(\"shares: \", totalBorrow.toShares(uint256(SD59x18.unwrap(_initialPrice)), true));\n    //     console.log(\"total.shares: \", totalBorrow.shares);\n    //     console.log(\"total.amount: \", totalBorrow.amount);\n\n    //     SD59x18 _decayConstant = sd(1e17).div(toSD59x18(86400));// decayConstant * deltaTime * initial price = discount.\n    //     SD59x18 _minimumPrice = _initialPrice.div(toSD59x18(4)); // minimum price is 1/4 of initial price.\n        \n    //     // sd(1219450412706); // 10% a day. 1.219450412706322930873853944899453684098615428047153617638... × 10^-6\n    //     // SD59x18 _emissionRate = _balance.div(toSD59x18(86400).div(toSD59x18(2))); // 1/2 balance in a day, tokens per second.\n    //     auctions[_id] = Auction({\n    //         collateral: _collateral.tokenAddress,\n    //         tokenId: _collateral.tokenId,\n    //         borrower: _borrower,\n    //         initialPrice: _initialPrice,\n    //         minimumPrice: _minimumPrice,\n    //         decayConstant: _decayConstant,\n    //         startTime: toSD59x18(int256(block.timestamp)),\n    //         //emissionRate: _emissionRate,\n    //         alive: true\n    //     });\n    \n    //     numAuctions = numAuctions + 1;\n    //     _auctionId = _id;\n    //     userAuctionId[_borrower] = _auctionId;\n\n    //     emit AuctionCreated(_id, _borrower, _collateral.tokenAddress, _collateral.tokenId);\n    // }\n\n    \n    // function closeAuction(address _borrower) public {\n    //     uint256 _id = userAuctionId[_borrower];\n    //     (bool _liquidatable, ) = _isLiquidatable(auctions[_id].borrower);\n    //     require(_id != 0, \"no auction exists\");\n\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //     }\n    // }\n\n    // function _closeAuction(uint256 _id) internal {\n    //     address _borrower = auctions[_id].borrower;\n    //     emit AuctionClosed(_id, _borrower, auctions[_id].collateral, auctions[_id].tokenId);\n    //     delete userAuctionId[_borrower];\n    //     delete auctions[_id];\n    // }\n\n    // function purchaseERC20Collateral(uint256 _id, uint256 _amount) external returns (uint256 _totalCost) {\n    //     Auction memory _auction = auctions[_id];\n\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //         revert(\"auction closed\");\n    //     }\n        \n    //     _totalCost = purchasePriceERC20(_id, _amount);\n    //     console.log(\"totalCost: \", _totalCost);\n\n    //     VaultAccount memory _totalBorrow = totalBorrow;\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\n       \n    //    // will revert if not enough collateral in user collateral balance.\n    //    _removeCollateral(_auction.collateral, _amount, _auction.tokenId, _auction.borrower, msg.sender);\n\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //     }\n    //     if (userCollateralERC20[_auction.collateral][_auction.borrower] == 0) {\n    //         delete userAuctionId[_auction.borrower];\n    //         delete auctions[_id];\n    //     }\n        \n    // }\n\n    // function purchasePriceERC20(uint256 _id, uint256 _numTokens) public view returns (uint256 totalCost) {\n    //     Auction memory _auction = auctions[_id];\n    //     require(_auction.alive, \"auction is not alive\");\n\n    //     uint256 _d = ERC20(_auction.collateral).decimals();\n        \n    //     SD59x18 _quantity = sd(int256(_numTokens * (10 ** (18 - _d))));\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime)).mul(_auction.initialPrice);\n    //     SD59x18 _price = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) // is initial price > minimum price + discount => initial price - discount > minimum price\n    //         ? _auction.initialPrice.sub(_discount) : _auction.minimumPrice;\n    //     totalCost = uint256(SD59x18.unwrap(_price.mul(_quantity)));\n    // }\n\n    // /// @param _id is the auction id to purchase the collateral from\n    // function purchaseERC721Collateral(uint256 _id) external returns (uint256 _totalCost) {\n    //     Auction memory _auction = auctions[_id];\n\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _auction.alive = false;\n    //         auctions[_id] = _auction;\n    //         delete userAuctionId[_auction.borrower];\n    //         revert(\"auction closed\");\n    //     }\n        \n    //     _totalCost = purchasePriceERC721(_id);\n\n    //     VaultAccount memory _totalBorrow = totalBorrow;\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\n       \n    //    // will revert if not enough collateral in user collateral balance.\n    //    _removeCollateral(_auction.collateral, 0, _auction.tokenId, _auction.borrower, msg.sender);\n\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\n    //     if (!_liquidatable) {\n    //         _closeAuction(_id);\n    //     }\n    //     if (userCollateralNFTs[_auction.collateral][_auction.tokenId] == address(0)) {\n    //         delete userAuctionId[_auction.borrower];\n    //         delete auctions[_id];\n    //     }\n    // }\n\n    // function purchasePriceERC721(uint256 _id) public view returns (uint256 totalCost) {\n    //     Auction memory _auction = auctions[_id];\n    //     require(_auction.alive, \"auction is not alive\");\n\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime));\n\n    //     totalCost = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) ? \n    //     uint256(SD59x18.unwrap(_auction.initialPrice.sub(_discount))) : uint256(SD59x18.unwrap(_auction.minimumPrice));\n        \n    // }\n\n    // instrument functions\n    function instrumentApprovalCondition() public override virtual view returns (bool) {\n        return true;\n    }\n\n    function borrowLiquidityAvailable(uint256 _borrowAmount) public view returns (bool){\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            return false;\n        }\n        return true; \n    }\n\n    function totalAssetAvailable() public view returns(uint256){\n        return _totalAssetAvailable(totalAsset, totalBorrow); \n    }\n\n\n    // ERC4626 functions.\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override virtual {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can withdraw\n        // check if there is enough asset to cover the withdraw.\n        uint256 totalAvailableAsset = _totalAssetAvailable(totalAsset, totalBorrow);\n        require(totalAvailableAsset >= assets, \"not enough asset\");\n\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount -= assets.safeCastTo128();\n        _totalAsset.shares -= shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n\n    }\n\n    function afterDeposit(uint256 assets, uint256 shares) internal override virtual {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can deposit\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount += assets.safeCastTo128();\n        _totalAsset.shares += shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n    }\n\n    function getUserSnapshot(address _address)\n        external\n        view\n        returns (\n            uint256 _userAssetShares,\n            uint256 _userAssetAmount,\n            uint256 _userBorrowShares,\n            uint256 _userBorrowAmount,\n            int256 _userAccountLiquidity\n        )\n    {\n        _userAssetShares = balanceOf[_address];\n        _userAssetAmount = totalAsset.toAmount(_userAssetShares, false);\n        _userBorrowShares = userBorrowShares[_address];\n        _userBorrowAmount = totalBorrow.toAmount(_userBorrowShares, false);\n        (, _userAccountLiquidity) = _isLiquidatable(_address);\n    }\n    function isWithdrawAble(address holder, uint256 amount) external view returns(bool){\n        return (previewRedeem(balanceOf[holder])>= amount && totalAssetAvailable() >= amount); \n    }\n\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toShares(_amount, _roundUp);\n    }\n\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalAsset.toShares(_amount, _roundUp);\n    }\n\n    function totalAssets() public view override virtual returns (uint256) {\n        return totalAsset.amount;\n    }\n\n    function convertToShares(uint256 assets) public view override virtual returns (uint256) {\n        return totalAsset.toShares(assets, false);\n    }\n\n    function convertToAssets(uint256 shares) public view override virtual returns (uint256) {\n        return totalAsset.toAmount(shares, false);\n    }\n\n\n    function previewMint(uint256 shares) public view override virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    function previewWithdraw(uint256 assets) public view override virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewRedeem(uint256 shares) public view override virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n}\n\n/**\nnonReentrant\ndeposit asset\nredeem/withdraw\nborrow\nadd collateral,\nremove collateral,\nliquidate,\nrepay,\nrepay behalf,\nupdate exchange rate,\nupdate interest rate,\nonlyVault\nupdate oracle,\nupdate rateCalculator\nminting, redeeming, depositing\n add collateral in batches\n batch liquidation\n update exchange rate + accue interest when *necessary\n virtual function, is approved borrower.\n instrument functions to override: \n function estimatedTotalAssets() public view virtual returns (uint256){}\n prepareWithdraw\n liquidatePosition => protocol liquidation for all outstanding debt.\n */"
    },
    "contracts/instruments/poolConstants.sol": {
      "content": "pragma solidity ^0.8.16;\n\n// taken from https://github.com/FraxFinance/fraxlend\nabstract contract PoolConstants {\n    uint256 internal constant LTV_PRECISION = 1e5; // 5 decimals\n    uint256 internal constant LIQ_PRECISION = 1e5;\n    uint256 internal constant UTIL_PREC = 1e5;\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant EXCHANGE_PRECISION = 1e18;\n    uint64 internal constant DEFAULT_INT = 158049988; // 0.5% annual rate 1e18 precision\n}"
    },
    "contracts/instruments/poolInstrument.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {PoolConstants} from \"./poolConstants.sol\";\nimport {VaultAccount, VaultAccountingLibrary} from \"./VaultAccount.sol\";\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {IRateCalculator} from \"./IRateCalculator.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Pausable} from \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {ERC4626} from \"lib/solmate/src/mixins/ERC4626.sol\";\nimport {ERC721TokenReceiver} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {ReputationManager} from \"../protocol/reputationmanager.sol\";\n// import \"@prb/math/SD59x18.sol\";\n\n// https://github.com/FraxFinance/fraxlend\n/// ****THIS IS A PROOF OF CONCEPT INSTRUMENT.\ncontract PoolInstrument is ERC4626, Instrument, PoolConstants, ReentrancyGuard, Pausable, ERC721TokenReceiver {\n    using SafeTransferLib for ERC20;\n    using VaultAccountingLibrary for VaultAccount;\n    using SafeCastLib for uint256;\n    using FixedPointMathLib for uint256;\n\n\n    /// @param lastBlock last block number\n    /// @param lastTimestamp last block.timestamp\n    /// @param ratePerSec rate per second of interest accrual\n    struct CurrentRateInfo {\n        uint64 lastBlock;\n        uint64 lastTimestamp;\n        uint64 ratePerSec;\n    }\n\n    /// @param tokenAddress collateral token address\n    /// @param tokenId collateral tokenId, 0 for ERC20.\n    struct CollateralLabel {\n        address tokenAddress;\n        uint256 tokenId;\n    }\n\n    /// @param totalCollateral total amount of collateral for a given ERC20 asset, will be zero for NFTs\n    /// @param maxAmount max amount in underlying that a user can \"owe\" per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    /// should always be more than the maxBorrowAmount, acts as buffer for protocol and borrower. this is the value to determine whether\n    /// a borrower is liquidatable\n    /// @param maxBorrowAmount max amount in underlying that a user can borrow per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\n    struct Config {\n        uint256 totalCollateral; \n        uint256 maxAmount;\n        uint256 maxBorrowAmount;\n        bool isERC20;\n    \n        // auction parameters\n        uint256 tau; // seconds after auction start when the price reaches zero -> linearDecrease\n        uint256 cusp; // percentage price drop that can occur before an auction must be reset.\n        uint256 tail; // seconds that can elapse before an auction must be reset. \n        uint256 buf; // auction start price = buf * maxAmount\n    }\n\n    /// @notice dutch auction\n    struct Auction { // linearDecrease for beta only.\n        address borrower;\n        address collateral;\n        uint256 tokenId;\n        uint256 creationTimestamp; // auction start\n        bool alive; // delete auction.\n    }\n\n    /// @notice amount: asset token borrowed, shares = total shares outstanding\n    VaultAccount public totalBorrow;\n    /// @notice amount: total asset supplied + interest earned, shares = total shares outstanding\n    VaultAccount public totalAsset;\n\n    mapping(bytes32 => Config) public collateralConfigs; // collateral address => tokenId (0 for erc20) => collateral data.\n    mapping(bytes32=>bool) public approvedCollateral;\n    mapping(bytes32=>mapping(address => uint256)) public userERC20s; // per collateral, user balance of collateral. id -> user -> balance.\n    mapping(bytes32=> address) public userERC721s; // nft addr => tokenId => owner.\n    mapping(address=>uint256) public userBorrowShares; // user -> shares, this should be equivalent to balanceOf(user), since pool is vault.\n    \n    // mapping(address=>uint256) private baseUnits; // equivalent to 10**decimals for ERC20s, 1 for NFTs.\n    mapping(address=>mapping(bytes32=>bool)) public enabledCollateral; // user -> collateral -> enabled.\n    mapping(address=> CollateralLabel[]) public userCollateral;\n\n    // *** id for collateral = keccak256(abi.encodePacked(collateral, tokenId))\n\n    IRateCalculator public rateContract;\n\n    /// @dev depends on rateCalculator used\n    bytes public rateInitCallData;\n    \n    CurrentRateInfo public currentRateInfo;\n    CollateralLabel[] private collaterals; //approved collaterals.\n    ReputationManager private reputationManager;\n    uint256 public r; // reputation score for this instrument.\n    \n    \n    constructor (\n        address _vault,\n        address _reputationManager,\n        uint256 _r,\n        address _utilizer,\n        string memory _name,\n        string memory _symbol,\n        address _rateCalculator,\n        bytes memory _rateInitCallData,\n        CollateralLabel[] memory _collaterals,\n        Config[] memory _collateralData\n    ) Instrument(_vault, _utilizer) ERC4626(Vault(_vault).UNDERLYING(), _name, _symbol) {\n        rateContract = IRateCalculator(_rateCalculator);\n        rateInitCallData = _rateInitCallData;\n        rateContract.requireValidInitData(_rateInitCallData);\n\n        // need to check for added collateral that erc20 is erc20. ability to add or remove accepted collateral.\n\n        reputationManager = ReputationManager(_reputationManager);\n        r = _r;\n\n        for (uint i = 0; i < _collaterals.length; i ++) {\n            _addAcceptedCollateral(_collaterals[i].tokenAddress, _collaterals[i].tokenId, _collateralData[i]);\n        }\n    }\n\n    /**\n     helper fxn for computing id for collateral, tokenId == 0 for ERC20s.\n     */\n    function computeId(address _addr, uint256 _tokenId) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_addr, _tokenId));\n    }\n\n    function getAcceptedCollaterals() view public returns (CollateralLabel[] memory) {\n        return collaterals;\n    }\n\n    // event NewCollateralAdded(address collateral, uint256 tokenId, uint256 maxAmount, uint256 maxBorrowAmount, bool isERC20);\n    // legacy for tests, remove later.\n\n    function addAcceptedCollateral(address _collateral, uint256 _tokenId, Config calldata _config) public {\n        require(msg.sender == vault.owner(), \"only owner\");\n        _addAcceptedCollateral(_collateral, _tokenId, _config);\n    }\n\n    /**\n     @notice adds a new collateral to the instrument\n     */\n    function _addAcceptedCollateral(address _collateral, uint256 _tokenId, Config memory _config) internal {\n        // need to ensure that _config isERC20 is correct.\n        // max borrow must be less than max amount.\n        bytes32 id = computeId(_collateral, _tokenId);\n        require(!approvedCollateral[id], \"already approved\");\n        require(_config.maxBorrowAmount < _config.maxAmount, \"maxBorrowAmount must be less than maxAmount\");\n        if (_config.isERC20) {\n            require(_tokenId == 0, \"tokenId must be 0 for ERC20\");\n        }\n        _config.totalCollateral = 0;\n        collateralConfigs[id] = _config;\n        collaterals.push(CollateralLabel(_collateral, _tokenId));\n        approvedCollateral[id] = true;\n    }\n\n    function updateConfig(CollateralLabel calldata _label, Config calldata _config) public {\n        require(msg.sender == vault.owner(), \"only owner\");\n        bytes32 id = computeId(_label.tokenAddress, _label.tokenId);\n        require(approvedCollateral[id], \"not approved\");\n        collateralConfigs[id] = _config;\n    }\n    // INTERNAL HELPERS\n\n    modifier onlyApprovedCollateral(address _collateral, uint256 _tokenId) {\n        require(approvedCollateral[computeId(_collateral, _tokenId)], \"collateral not approved\");\n        _;\n    }\n\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\n        internal\n        pure\n        returns (uint256)\n    {\n        return _totalAsset.amount - _totalBorrow.amount;\n    }\n\n    // INTEREST RATE LOGIC\n    event InterestAdded(uint256 indexed timestamp, uint256 interestEarned, uint256 feesAmount, uint256 feesShare, uint64 newRate);\n\n    function addInterest()\n        external\n        nonReentrant\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        return _addInterest();\n    }\n\n    function _addInterest() internal\n        returns (\n            uint256 _interestEarned,\n            uint256 _feesAmount,\n            uint256 _feesShare,\n            uint64 _newRate\n        )\n    {\n        // Add interest only once per block\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\n            _newRate = _currentRateInfo.ratePerSec;\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\n        }\n\n        // Pull some data from storage to save gas\n        VaultAccount memory _totalAsset = totalAsset;\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // If there are no borrows or contract is paused, no interest adds and we reset interest rate\n        if (_totalBorrow.shares == 0 || paused()) {\n            if (!paused()) {\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\n            }\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Effects: write to storage\n            currentRateInfo = _currentRateInfo;\n        } else {\n            // We know totalBorrow.shares > 0\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\n\n            // NOTE: Violates Checks-Effects-Interactions pattern\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\n            // Calc new rate\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\n            // console.log(\"_utilizationRate: \", _utilizationRate);\n            bytes memory _rateData = abi.encode(\n                    _currentRateInfo.ratePerSec,\n                    _deltaTime,\n                    _utilizationRate,\n                    block.number - _currentRateInfo.lastBlock\n                );\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\n\n            // Effects: bookkeeping\n            _currentRateInfo.ratePerSec = _newRate;\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\n            _currentRateInfo.lastBlock = uint64(block.number);\n\n            // Calculate interest addd\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\n\n            // Accumulate interest and fees, only if no overflow upon casting\n            if (\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\n                _interestEarned + _totalAsset.amount <= type(uint128).max\n            ) {\n                _totalBorrow.amount += uint128(_interestEarned);\n                _totalAsset.amount += uint128(_interestEarned);\n            }\n\n            // Effects: write to storage\n            totalAsset = _totalAsset;\n            currentRateInfo = _currentRateInfo;\n            totalBorrow = _totalBorrow;\n        }\n        emit InterestAdded(block.timestamp, _interestEarned, _feesAmount, _feesShare, _newRate);\n    }\n\n    // SOLVENCY* LOGIC\n\n    /// @notice Checks if total amount of asset user borrowed is less than max borrow threshold AFTER executing contract code\n    modifier canBorrow(address _borrower) {\n        _;\n        require(_canBorrow(_borrower), \"borrower is insolvent\");\n    }\n\n\n    /// @notice checks if the borrower is can borrow\n    /// @dev collateral value is in asset, summed across all approved collaterals.\n    /// @dev will return true if the borrower has no collateral and also has no borrower shares.\n    /// @dev 0 addr cannot borrow.\n    function _canBorrow(address _borrower) public view returns (bool) {\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\n\n        if (userBorrowShares[_borrower] == 0) {\n            return true;\n        }\n        if (_maxBorrowableAmount == 0) {\n            return false;\n        }\n        return _maxBorrowableAmount >= totalBorrow.toAmount(userBorrowShares[_borrower], false);\n    }\n\n    function getMaxBorrow(address _borrower) public view returns(uint256 _maxBorrowableAmount){\n\n        CollateralLabel[] memory userCollaterals = userCollateral[msg.sender];\n\n        for (uint256 i; i < userCollaterals.length; i++) {\n            CollateralLabel memory _collateral = userCollaterals[i];\n            bytes32 id = computeId(_collateral.tokenAddress, _collateral.tokenId);\n            Config memory _collateralData = collateralConfigs[id];\n            if (_collateralData.isERC20 && userERC20s[id][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxBorrowableAmount += userERC20s[id][_borrower] * _collateralData.maxBorrowAmount / (10**_d); // <= precision of collateral.\n            } else if (userERC721s[id] == _borrower) {\n                _maxBorrowableAmount += _collateralData.maxBorrowAmount;\n            }\n        }\n    }\n\n    /// @notice returns how much collateral can be removed, given the borrower's current debt condition\n    function removeableCollateral(address _borrower, uint256 tokenId, address collateral) public view returns(uint256){\n        //800 borrowable = 800 * 1, 600borrowed (800-x)*1 - 600 = 0 x=? \n        //800*1-x*1-600 , x = (800*1 - 600)/1\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower); \n        bytes32 id = computeId(collateral, tokenId);\n        uint256 perUnitMaxBorrowAmount = collateralConfigs[id].maxBorrowAmount; \n        //check solvency\n        return (_maxBorrowableAmount - totalBorrow.toAmount(userBorrowShares[_borrower], true)) \n            * 1e18/ perUnitMaxBorrowAmount; \n    }  \n\n    // BORROW LOGIC\n    event Borrow(address indexed _borrower, uint256 _amount, uint256 _shares);\n\n    /// @param _borrowAmount amount of asset to borrow\n    /// @param _collateralAmount amount of collateral to add\n    /// @param _collateral address of collateral, \n    /// @param _reciever address of reciever of asset\n    function borrow(\n        uint256 _borrowAmount,\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _reciever,\n        bool _enable\n    ) canBorrow(msg.sender) nonReentrant whenNotPaused external returns (uint256 _shares) {\n        _addInterest();\n\n        if (_collateral != address(0) && (_collateralAmount > 0 || _tokenId > 0)) {\n            bytes32 id = computeId(_collateral, _tokenId);\n            require(approvedCollateral[id], \"unapproved collateral\");\n            if (_enable) {\n                enableCollateral(_collateral, _tokenId);\n            }\n            _addCollateral(msg.sender, _collateral, _collateralAmount, msg.sender, _tokenId);\n        }\n        // borrow asset.\n        _shares = _borrow(_borrowAmount.safeCastTo128(), _reciever);\n    }\n\n    function _borrow(\n        uint128 _borrowAmount,\n        address _receiver\n    ) internal returns (uint256 _shares) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        // Check available capital\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            revert(\"insufficient contract asset balance\");\n        }\n\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\n        _shares = _totalBorrow.toShares(_borrowAmount, true);\n        _totalBorrow.amount += _borrowAmount;\n        _totalBorrow.shares += uint128(_shares);\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\n\n        // Effects: write back to storage\n        totalBorrow = _totalBorrow;\n        userBorrowShares[msg.sender] += _shares;\n\n        emit Borrow(msg.sender, _borrowAmount, _shares);\n\n        // Interactions\n        if (_receiver != address(this)) {\n            asset.safeTransfer(_receiver, _borrowAmount);\n        }\n    }\n\n    // REPAY LOGIC\n    event Repay(address indexed borrower, uint256 amount, uint256 shares);\n\n    function repayWithAmount(\n        uint256 _amount, \n        address _borrower\n        )   external nonReentrant returns (uint256 _sharesToRepay){\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _sharesToRepay = _totalBorrow.toShares(_amount, true); \n        _repay(_totalBorrow, _amount.safeCastTo128(), _sharesToRepay.safeCastTo128(), msg.sender, _borrower);\n    }\n\n    function repay(\n        uint256 _shares,\n        address _borrower\n    ) external nonReentrant returns (uint256 _amountToRepay) {\n        VaultAccount memory _totalBorrow = totalBorrow;\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\n        console.log(\"amount to repay: \", _amountToRepay);\n        _repay(_totalBorrow, _amountToRepay.safeCastTo128(), _shares.safeCastTo128(), msg.sender, _borrower);\n    }\n\n    function _repay(\n        VaultAccount memory _totalBorrow,\n        uint128 _amountToRepay,\n        uint128 _shares,\n        address _payer,\n        address _borrower\n    ) internal {\n        console.log(\"_shares: \", _shares);\n        console.log(\"_amountToRepay: \", _amountToRepay);\n        console.log(\"userBorrowShares[_borrower]: \", userBorrowShares[_borrower]);\n        // Effects: Bookkeeping\n        _totalBorrow.amount -= _amountToRepay;\n        _totalBorrow.shares -= _shares;\n\n        // Effects: write to state\n        userBorrowShares[_borrower] -= _shares;\n        totalBorrow = _totalBorrow;\n\n        emit Repay(_borrower, _amountToRepay, _shares);\n\n        // Interactions\n        if (_payer != address(this)) {\n            asset.safeTransferFrom(_payer, address(this), _amountToRepay);\n        }\n    }\n\n\n    // ADD/REMOVE/ENABLE/DISABLE COLLATERAL LOGIC\n    event AddCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\n    event RemoveCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\n\n    \n    function enableCollateral(address _collateral, uint256 _tokenId) onlyApprovedCollateral(_collateral, _tokenId) public {\n        // if already enabled, then return\n        bytes32 id = computeId(_collateral, _tokenId);\n        if (enabledCollateral[msg.sender][id]) {\n            return;\n        }\n        enabledCollateral[msg.sender][id] = true;\n        userCollateral[msg.sender].push(CollateralLabel(_collateral, _tokenId));\n    }\n\n    /**\n     can only disable collateral if no collateral balance.\n     */\n    function disableCollateral(address _collateral, uint256 _tokenId) onlyApprovedCollateral(_collateral, _tokenId) public {\n        // if already enabled, then return\n        bytes32 id = computeId(_collateral, _tokenId);\n        if (!enabledCollateral[msg.sender][id]) {\n            return;\n        }\n\n        // require zero collateral, maybe this isn't necessary.\n        require(userERC20s[id][msg.sender] == 0 || userERC721s[id] != address(msg.sender), \"must remove all remaining collateral to disable\");\n\n        // switch w/ last and pop\n        CollateralLabel[] memory arr = userCollateral[msg.sender];\n        for (uint256 i; i < arr.length; i++) {\n            if (arr[i].tokenAddress == _collateral && arr[i].tokenId == _tokenId) {\n                userCollateral[msg.sender][i] = userCollateral[msg.sender][userCollateral[msg.sender].length - 1];\n                userCollateral[msg.sender].pop();\n                break;\n            }\n        }\n\n        enabledCollateral[msg.sender][id] = false;\n    }\n    \n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation, or ERC721.approve().\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\n    /// @param _borrower The account to be credited\n    function addCollateral(\n        address _collateral,\n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _borrower,\n        bool _enable\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant {\n        _addInterest();\n\n        if (_enable) {\n            enableCollateral(_collateral, _tokenId);\n        }\n\n        _addCollateral(msg.sender, _collateral, _collateralAmount, _borrower, _tokenId);\n    }\n\n    function _addCollateral(\n        address _sender,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _borrower,\n        uint256 _tokenId\n    ) internal {\n\n        // Interactions\n        bytes32 id = computeId(_collateral, _tokenId);\n        bool _isERC20 = collateralConfigs[id].isERC20;\n    \n        if (_sender != address(this)) {\n            if (_isERC20)  {\n                userERC20s[id][_borrower] += _collateralAmount;\n                collateralConfigs[id].totalCollateral += _collateralAmount;\n                ERC20(_collateral).safeTransferFrom(_sender, address(this), _collateralAmount);\n            } else {\n                userERC721s[id] = _borrower;\n                ERC721(_collateral).safeTransferFrom(_sender, address(this), _tokenId);\n            }\n        }\n        emit AddCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    function removeAvailableCollateral(\n        address _collateral, \n        uint256 _tokenId,\n        address _receiver\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) returns(uint256 removeable){\n        _addInterest();\n\n        removeable = removeableCollateral(msg.sender,  _tokenId,  _collateral); \n\n        _removeCollateral(_collateral, \n            removeable,\n            _tokenId, msg.sender, _receiver);\n    }\n\n    function removeCollateral(\n        address _collateral, \n        uint256 _tokenId,\n        uint256 _collateralAmount,\n        address _receiver,\n        bool _disable\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) {\n        _addInterest();\n\n        if (_disable) {\n            disableCollateral(_collateral, _tokenId);\n        }\n\n        // Note: exchange rate is irrelevant when borrower has no debt shares\n        _removeCollateral(_collateral, _collateralAmount, _tokenId, msg.sender, _receiver);\n    }\n\n    function _removeCollateral(\n        address _collateral,\n        uint256 _collateralAmount,\n        uint256 _tokenId,\n        address _borrower,\n        address _receiver\n    ) internal {\n\n        // Interactions\n        bytes32 id = computeId(_collateral, _tokenId);\n        bool _isERC20 = collateralConfigs[id].isERC20;\n        if (_receiver != address(this)) {\n            if (_isERC20) {\n                // console.log(\"removing erc20 collateral\");\n                // console.log(\"userCollateralerc20: \", userERC20s[id][_borrower] );\n                // console.log(\"collateralAmount: \", _collateralAmount);\n                userERC20s[id][_borrower] -= _collateralAmount;\n                collateralConfigs[id].totalCollateral -= _collateralAmount;\n                ERC20(_collateral).safeTransfer(_receiver, _collateralAmount);\n            } else {\n                require(userERC721s[id] == _borrower, \"not owner of nft\");\n                delete userERC721s[id];\n                ERC721(_collateral).safeTransferFrom(address(this), _receiver, _tokenId);\n            }\n        }\n        emit RemoveCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\n    }\n\n    // liquidation logic\n\n    /// @notice collateral should be auctioned off at a minimum price chosen by the managers\n    /// underlying balance, collateral balance, what do we know about the user?\n    /// if the user's borrow shares are equal to an amount of asset that is greater than the maximum amount they can borrow, \n    /// they are suceptible to liquidation\n    /// how to determine what collateral should be auctioned off?\n    /// maxBorrowAmount\n    function _isLiquidatable(address _borrower) public view returns (bool, int256 accountLiq) {\n        uint256 _maxAmount;\n\n        CollateralLabel[] memory userCollaterals = userCollateral[_borrower];\n        for (uint256 i; i < userCollaterals.length; i++) {\n            CollateralLabel memory _collateral = userCollaterals[i];\n            bytes32 id = computeId(_collateral.tokenAddress, _collateral.tokenId);\n            Config memory _collateralData = collateralConfigs[id];\n            if (_collateralData.isERC20 && userERC20s[id][_borrower] > 0) {\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\n                _maxAmount += userERC20s[id][_borrower] * _collateralData.maxAmount / (10**_d); // <= precision of collateral.\n            } else {\n                if (userERC721s[id] == _borrower) {\n                    _maxAmount += _collateralData.maxAmount;\n                }\n            }\n        }\n\n\n        return (_maxAmount < totalBorrow.toAmount(userBorrowShares[_borrower], false), \n            int256(_maxAmount) - int256(totalBorrow.toAmount(userBorrowShares[_borrower], false))\n        );\n    }\n\n    // AUCTION LOGIC\n    \n    /// @dev auction id || keccak256(abi.encodePacked(_borrower, _collateral, _tokenId)).\n    mapping(bytes32=>Auction) public auctions; // auction id => auction data, auction id is in order of creation.\n    mapping(address=>bytes32[]) public userAuctionIds; // user => auction ids, if 0 then no auction.\n    \n    bytes32[] public activeAuctionIds;\n\n    event AuctionCreated(bytes32 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event AuctionClosed(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\n    event CollateralPurchased(uint256 indexed id, address indexed buyer, address indexed collateral, uint256 tokenId, uint256 amount);\n\n    function computeAuctionId(address _borrower, address _collateral, uint256 _tokenId) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_borrower, _collateral, _tokenId));\n    }\n\n    /**\n     @notice can only be called when user is liquidatable, all auctions are terminated if not the case.\n     */\n    function triggerAuction(\n        address _borrower,\n        address _collateral,\n        uint256 _tokenId\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant returns (bytes32 _auctionId){\n        _addInterest();\n        \n        (bool _liquidatable, ) = _isLiquidatable(_borrower);\n        require(_liquidatable, \"borrower is not liquidatable\");\n        require(!auctions[computeAuctionId(_borrower, _collateral, _tokenId)].alive, \"auction already exists\");\n\n        if (_liquidatable) {\n            _auctionId = _createAuction(_borrower, _collateral, _tokenId);\n        }\n    }\n\n    /// @dev _accountLiq in wad.\n    function _createAuction(address _borrower, address _collateral, uint256 _tokenId) internal returns (bytes32 auctionId) {\n        auctionId = computeAuctionId(_borrower, _collateral, _tokenId);\n\n        auctions[auctionId] = Auction({\n            borrower: _borrower,\n            collateral: _collateral,\n            tokenId: _tokenId,\n            creationTimestamp: block.timestamp,\n            alive: true\n        });\n\n        activeAuctionIds.push(auctionId);\n\n        emit AuctionCreated(auctionId, _borrower, _collateral, _tokenId);\n    }\n\n    function _closeAuction(bytes32 _auctionId) internal {\n\n        require(auctions[_auctionId].alive, \"auction already dead\");\n        auctions[_auctionId].alive = false;\n    }\n\n    /**\n     @param _amount: amount of collateral to purchase w/ collateral decimals.\n     will reset auction if either tau passed or cusp reached and user still insolvent.\n     watch for price increases, maxPrice should be param set by user. mkerdao\n     */\n    function purchaseERC20(address _borrower, CollateralLabel memory _label, uint256 _amount) external returns (uint128 _totalCost){\n        // if (block.timestamp > _deadline) {\n        //     revert(\"past deadline\");\n        // }\n\n        _addInterest();\n\n        bytes32 auctionId = computeAuctionId(_borrower, _label.tokenAddress, _label.tokenId);\n        bytes32 collateralId = computeId(_label.tokenAddress, _label.tokenId);\n\n        Auction memory auction = auctions[auctionId];\n        Config memory config = collateralConfigs[collateralId];\n        \n        require(config.isERC20, \"collateral is not ERC20\");\n        require(auction.alive, \"auction is not alive\");\n\n        (bool liquidatable,) = _isLiquidatable(_borrower);\n\n        if (!liquidatable) {\n            _closeAuction(auctionId);\n            return 0;\n        }\n\n        uint256 currentPrice = _purchasePrice(auctionId, collateralId); // price of collateral in underlying.     \n        \n        // if tau has passed or current price is below cusp, then reset auction.\n        if ((block.timestamp > auction.creationTimestamp + config.tau) || (currentPrice < config.cusp.mulWadDown(config.maxAmount.mulWadDown(config.buf)))) {\n            _resetAuction(auctionId);\n            return 0; \n        }\n\n        // total cost of collateral in asset.\n\n        //TODO need to ensure safe to cast here.\n        _totalCost = uint128(_amount * currentPrice / (10**ERC20(_label.tokenAddress).decimals())); // <= decimals of collateral.\n\n        // uint128 _sharesToRepay = uint128(totalBorrow.toShares(_totalCost, false));\n\n        VaultAccount memory _totalBorrow = totalBorrow;\n        \n        // reverts if not enough shares.\n        _repay(_totalBorrow, _totalCost, uint128(totalBorrow.toShares(_totalCost, false)), msg.sender, _borrower);\n\n        // reverts if not enough collateral\n        _removeCollateral(_label.tokenAddress, _amount, _label.tokenId, _borrower, msg.sender);\n    }\n\n    function purchaseERC721(address _borrower, CollateralLabel memory _label) external returns (bool) {\n        // if (block.timestamp > _deadline) {\n        //     revert(\"past deadline\");\n        // }\n\n        _addInterest();\n\n        bytes32 auctionId = computeAuctionId(_borrower, _label.tokenAddress, _label.tokenId);\n        bytes32 collateralId = computeId(_label.tokenAddress, _label.tokenId);\n\n        Auction memory auction = auctions[auctionId];\n        Config memory config = collateralConfigs[collateralId];\n        \n        require(config.isERC20, \"collateral is not ERC20\");\n        require(auction.alive, \"auction is not alive\");\n\n        (bool liquidatable,) = _isLiquidatable(_borrower);\n\n        if (!liquidatable) {\n            _closeAuction(auctionId);\n            return false;\n        }\n\n        uint128 currentPrice = uint128(_purchasePrice(auctionId, collateralId)); // price of collateral in underlying.     \n        \n        if ((block.timestamp > auction.creationTimestamp + config.tau) || (currentPrice < config.cusp.mulWadDown(config.maxAmount.mulWadDown(config.buf)))) {\n            _resetAuction(auctionId);\n            return false; \n        }\n\n        // convert collateral nft price to borrow shares\n        // uint128 _sharesToRepay = uint128(totalBorrow.toShares(currentPrice, false));\n\n        // what if not enough shares?\n        _repay(totalBorrow, currentPrice, uint128(totalBorrow.toShares(currentPrice, false)), msg.sender, _borrower);\n\n        _removeCollateral(_label.tokenAddress, 1, _label.tokenId, _borrower, msg.sender);\n        return true;\n    }\n\n    function _resetAuction(bytes32 _auctionId) internal {\n        auctions[_auctionId].creationTimestamp = block.timestamp;\n    }\n\n    /**\n     doesn't check whether tau has passed.\n     */\n    function _purchasePrice(bytes32 auctionId, bytes32 collateralId) internal view returns (uint256 currentPrice) {\n        Auction memory auction = auctions[auctionId];\n        Config memory config = collateralConfigs[collateralId];\n        require(auction.alive, \"auction is not alive\");\n\n        /**\n         slope is (top - 0) / (0 - tau), pf = pi + slope * (t - ti)\n         */\n        uint256 top = config.buf.mulWadDown(config.maxAmount);\n        uint256 t = block.timestamp - auction.creationTimestamp;\n\n        if (t > config.tau) {\n            currentPrice = 0;\n        } else {\n            currentPrice = top  - (top / config.tau) * t;\n        }\n    }\n\n    /**\n     @notice returns cost of purchasing _numTokens of collateral in pool underlying.\n     */\n    function purchasePrice(address _borrower, address _collateral, uint256 _tokenId) public view returns (uint256 currentPrice) {\n        bytes32 auctionId = computeAuctionId(_borrower, _collateral, _tokenId);\n        bytes32 collateralId = computeId(_collateral, _tokenId);\n        currentPrice = _purchasePrice(auctionId, collateralId);\n    }\n\n    // instrument functions\n    function instrumentApprovalCondition() public override virtual view returns (bool) {\n        return true;\n    }\n\n    function borrowLiquidityAvailable(uint256 _borrowAmount) public view returns (bool){\n        VaultAccount memory _totalBorrow = totalBorrow;\n\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\n        if (_assetsAvailable < _borrowAmount) {\n            return false;\n        }\n        return true; \n    }\n\n    function totalAssetAvailable() public view returns(uint256){\n        return _totalAssetAvailable(totalAsset, totalBorrow); \n    }\n\n\n    // ERC4626 functions.\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override virtual {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can withdraw\n        // check if there is enough asset to cover the withdraw.\n        uint256 totalAvailableAsset = _totalAssetAvailable(totalAsset, totalBorrow);\n        require(totalAvailableAsset >= assets, \"not enough asset\");\n\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount -= assets.safeCastTo128();\n        _totalAsset.shares -= shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n\n    }\n\n    function afterDeposit(uint256 assets, uint256 shares) internal override virtual {\n        // require(msg.sender == address(vault) || msg.sender == controller, \"!Vault/Controller\"); // only the vault can deposit\n        VaultAccount memory _totalAsset = totalAsset;\n\n        _totalAsset.amount += assets.safeCastTo128();\n        _totalAsset.shares += shares.safeCastTo128();\n\n        totalAsset = _totalAsset;\n    }\n\n    function getUserSnapshot(address _address)\n        external\n        view\n        returns (\n            uint256 _userAssetShares,\n            uint256 _userAssetAmount,\n            uint256 _userBorrowShares,\n            uint256 _userBorrowAmount,\n            int256 _userAccountLiquidity,\n            CollateralLabel[] memory _userCollaterals\n        )\n    {\n        _userAssetShares = balanceOf[_address];\n        _userAssetAmount = totalAsset.toAmount(_userAssetShares, false);\n        _userBorrowShares = userBorrowShares[_address];\n        _userBorrowAmount = totalBorrow.toAmount(_userBorrowShares, false);\n        (, _userAccountLiquidity) = _isLiquidatable(_address);\n        _userCollaterals = userCollateral[_address];\n    }\n    function isWithdrawAble(address holder, uint256 amount) external view returns(bool){\n        return (previewRedeem(balanceOf[holder])>= amount && totalAssetAvailable() >= amount); \n    }\n\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toShares(_amount, _roundUp);\n    }\n\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalBorrow.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\n        return totalAsset.toAmount(_shares, _roundUp);\n    }\n\n    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\n        return totalAsset.toShares(_amount, _roundUp);\n    }\n\n    function totalAssets() public view override virtual returns (uint256) {\n        return totalAsset.amount;\n    }\n\n    function convertToShares(uint256 assets) public view override virtual returns (uint256) {\n        return totalAsset.toShares(assets, false);\n    }\n\n    function convertToAssets(uint256 shares) public view override virtual returns (uint256) {\n        return totalAsset.toAmount(shares, false);\n    }\n\n\n    function previewMint(uint256 shares) public view override virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    function previewWithdraw(uint256 assets) public view override virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewRedeem(uint256 shares) public view override virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    function assetOracle(uint256 totalSupply) public view override virtual returns(uint256){\n      // Default balance oracle \n      return totalSupply.mulWadDown(previewMint(1e18)); \n      //TODO custom oracle \n    }\n\n\n}\n\n/**\nnonReentrant\ndeposit asset\nredeem/withdraw\nborrow\nadd collateral,\nremove collateral,\nliquidate,\nrepay,\nrepay behalf,\nupdate exchange rate,\nupdate interest rate,\nonlyVault\nupdate oracle,\nupdate rateCalculator\n\nminting, redeeming, depositing\n\n add collateral in batches\n batch liquidation\n update exchange rate + accue interest when *necessary\n\n virtual function, is approved borrower.\n\n instrument functions to override: \n function estimatedTotalAssets() public view virtual returns (uint256){}\n prepareWithdraw\n liquidatePosition => protocol liquidation for all outstanding debt.\n */"
    },
    "contracts/instruments/prbtest.sol": {
      "content": "pragma solidity ^0.8.16;\nimport \"lib/prb-math/src/SD59x18.sol\";\n\ncontract PRBTest {\n\n    function test() public pure returns (int256) {\n        return SD59x18.unwrap(toSD59x18(1));\n    }\n}"
    },
    "contracts/instruments/priceCalculator.sol": {
      "content": ""
    },
    "contracts/instruments/VariableInterestRate.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.16;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ====================== VariableInterestRate ========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n\n// Reviewers\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n// Travis Moore: https://github.com/FortisFortuna\n// Jack Corddry: https://github.com/corddry\n// Rich Gee: https://github.com/zer0blockchain\n\n// ====================================================================\n\nimport \"./IRateCalculator.sol\";\n\n/// @title A formula for calculating interest rates as a function of utilization and time\n/// @author Drake Evans github.com/drakeevans\n/// @notice A Contract for calculating interest rates as a function of utilization and time\ncontract VariableInterestRate is IRateCalculator {\n    // Utilization Rate Settings\n    uint32 private constant MIN_UTIL = 75000; // 75%\n    uint32 private constant MAX_UTIL = 85000; // 85%\n    uint32 private constant UTIL_PREC = 1e5; // 5 decimals\n\n    // Interest Rate Settings (all rates are per second), 365.24 days per year\n    uint64 private constant MIN_INT = 79123523; // 0.25% annual rate\n    uint64 private constant MAX_INT = 146248476607; // 10,000% annual rate\n    uint256 private constant INT_HALF_LIFE = 43200e36; // given in seconds, equal to 12 hours, additional 1e36 to make math simpler\n\n    /// @notice The ```name``` function returns the name of the rate contract\n    /// @return memory name of contract\n    function name() external pure returns (string memory) {\n        return \"Variable Time-Weighted Interest Rate\";\n    }\n\n    /// @notice The ```getConstants``` function returns abi encoded constants\n    /// @return _calldata abi.encode(uint32 MIN_UTIL, uint32 MAX_UTIL, uint32 UTIL_PREC, uint64 MIN_INT, uint64 MAX_INT, uint256 INT_HALF_LIFE)\n    function getConstants() external pure returns (bytes memory _calldata) {\n        return abi.encode(MIN_UTIL, MAX_UTIL, UTIL_PREC, MIN_INT, MAX_INT, INT_HALF_LIFE);\n    }\n\n    /// @notice The ```requireValidInitData``` function No-op as this contract has no init data\n    function requireValidInitData(bytes calldata _initData) external pure {}\n\n    /// @notice The ```getNewRate``` function calculates the new interest rate as a function of time and utilization\n    /// @param _data abi.encode(uint64 _currentRatePerSec, uint256 _deltaTime, uint256 _utilization, uint256 _deltaBlocks)\n    /// @param _initData empty for this Rate Calculator\n    /// @return _newRatePerSec The new interest rate per second, 1e18 precision\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec) {\n        (uint64 _currentRatePerSec, uint256 _deltaTime, uint256 _utilization, ) = abi.decode(\n            _data,\n            (uint64, uint256, uint256, uint256)\n        );\n        if (_utilization < MIN_UTIL) {\n            uint256 _deltaUtilization = ((MIN_UTIL - _utilization) * 1e18) / MIN_UTIL;\n            uint256 _decayGrowth = INT_HALF_LIFE + (_deltaUtilization * _deltaUtilization * _deltaTime);\n            _newRatePerSec = uint64((_currentRatePerSec * INT_HALF_LIFE) / _decayGrowth);\n            if (_newRatePerSec < MIN_INT) {\n                _newRatePerSec = MIN_INT;\n            }\n        } else if (_utilization > MAX_UTIL) {\n            uint256 _deltaUtilization = ((_utilization - MAX_UTIL) * 1e18) / (UTIL_PREC - MAX_UTIL);\n            uint256 _decayGrowth = INT_HALF_LIFE + (_deltaUtilization * _deltaUtilization * _deltaTime);\n            _newRatePerSec = uint64((_currentRatePerSec * _decayGrowth) / INT_HALF_LIFE);\n            if (_newRatePerSec > MAX_INT) {\n                _newRatePerSec = MAX_INT;\n            }\n        } else {\n            _newRatePerSec = _currentRatePerSec;\n        }\n    }\n}\n"
    },
    "contracts/instruments/VaultAccount.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity ^0.8.16;\n\nstruct VaultAccount {\n    uint128 amount; // Total amount, analogous to market cap\n    uint128 shares; // Total shares, analogous to shares outstanding\n}\n\n/// @title VaultAccount Library\n/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto\n/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations\n/// @dev Uses uint128 to save on storage\nlibrary VaultAccountingLibrary {\n    /// @notice Calculates the shares value in relationship to `amount` and `total`\n    /// @dev Given an amount, return the appropriate number of shares\n    function toShares(\n        VaultAccount memory total,\n        uint256 amount,\n        bool roundUp\n    ) internal pure returns (uint256 shares) {\n        if (total.amount == 0) {\n            shares = amount;\n        } else {\n            shares = (amount * total.shares) / total.amount;\n            if (roundUp && (shares * total.amount) / total.shares < amount) {\n                shares = shares + 1;\n            }\n        }\n    }\n\n    /// @notice Calculates the amount value in relationship to `shares` and `total`\n    /// @dev Given a number of shares, returns the appropriate amount\n    function toAmount(\n        VaultAccount memory total,\n        uint256 shares,\n        bool roundUp\n    ) internal pure returns (uint256 amount) {\n        if (total.shares == 0) {\n            amount = shares;\n        } else {\n            amount = (shares * total.amount) / total.shares;\n            if (roundUp && (amount * total.shares) / total.amount < shares) {\n                amount = amount + 1;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/pricerLib.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Controller} from \"../protocol/controller.sol\"; \nimport {Vault} from \"../vaults/vault.sol\"; \nimport  \"../global/types.sol\"; \nimport {Instrument} from \"../vaults/instrument.sol\"; \n\nlibrary PerpTranchePricer{\n    using FixedPointMathLib for uint256;\n    using PerpTranchePricer for PricingInfo; \n    uint256 constant BASE_UNIT = 1e18; \n\tuint256 constant BASE_MULTIPLIER = 5284965330; //10% at 60% util rate \n\n\tfunction setNewPrices(\n\t\tPricingInfo storage _self, \n\t\tuint256 psu,\n\t\tuint256 multiplier, \n\t\tuint256 id, \n\t\tbool constantRF\n\t\t) internal {\n\t\t_self.psu = psu; \n\t\t_self.URATE_MULTIPLIER = multiplier;  \n\t\t_self.ID = id; \n\t\t_self.constantRF = constantRF; \n\t}\n\n\t/// @notice needs to be updated whenver utilization rate is updated \n \tfunction storeNewPSU(\n \t\tPricingInfo storage _self, \n \t\tuint256 uRate\n \t\t) internal {\n\t    \n\t    // 1.00000003 ** x seconds\n\t    uint256 accruedPSU = (BASE_UNIT + _self.prevIntervalRp).rpow(block.timestamp - _self.prevAccrueTime, BASE_UNIT); \n\n\t    _self.psu = _self.psu.mulWadDown(accruedPSU); \n\t    _self.prevAccrueTime = block.timestamp; \n\t    _self.prevIntervalRp = uRateRpLinear(uRate, _self.URATE_MULTIPLIER); \n\t}\n\n\t/// @notice Get Promised return as function of uRate, 0<= uRate<= 1e18\n\tfunction uRateRpLinear(uint256 uRate, uint256 multiplier) internal pure returns(uint256){\n\t\treturn multiplier > 0? uRate.mulWadDown(multiplier) : uRate.mulWadDown(BASE_MULTIPLIER); \n\t}\n\n\tfunction refreshViewCurrentPricing(\n\t\tPricingInfo storage _self, \n\t\taddress instrument, \n\t\tuint256 uRate, \n\t\tuint256 juniorSupply, \n\t\tPoolData memory perp\n\t\t) public returns(uint256 psu, uint256 pju, uint256 levFactor){\n\t\t_self.storeNewPSU(uRate); \n\t\treturn viewCurrentPricing(_self, instrument, perp,juniorSupply ); \n\t}\n\n\tfunction viewCurrentPricing(\n\t\tPricingInfo memory _self,\n\t\taddress instrument, \n\t\tPoolData memory perp, \n\t\tuint256 juniorSupply\n\t\t) public view returns(uint256 psu, uint256 pju, uint256 levFactor){\n\t    //TODO should not tick during assessment \n\t    localVars memory vars; \n\t    uint256 marketId = _self.ID; \n\t    levFactor = perp.leverageFactor; \n\n\t    require(perp.inceptionPrice > 0, \"0 price\"); \n\n\t    vars.seniorSupply = vars.juniorSupply.mulWadDown(perp.leverageFactor); \n\t    vars.totalAssetsHeldScaled = Instrument(instrument).assetOracle(vars.juniorSupply + vars.seniorSupply)\n\t    \t .mulWadDown(perp.inceptionPrice); \n\n\t    if (vars.seniorSupply == 0) return(psu, psu,levFactor); \n\n\t\tif(_self.constantRF){\n\t\t\tpsu = perp.inceptionPrice.mulWadDown((BASE_UNIT+ perp.promisedReturn)\n    \t\t .rpow(block.timestamp - perp.inceptionTime, BASE_UNIT));\n\t\t} else {\n\t\t\tpsu = _self.psu; \n\t\t}\n\n\t\t// Check if all seniors can redeem\n\t    if (vars.totalAssetsHeldScaled < psu.mulWadDown(vars.seniorSupply)){\n\t    \tpsu = vars.totalAssetsHeldScaled.divWadDown(vars.seniorSupply); \n\t    \tvars.belowThreshold = true; \n\t    }\n\n\t    // should be 0 otherwise \n\t    if(!vars.belowThreshold) pju = (vars.totalAssetsHeldScaled \n\t      - psu.mulWadDown(vars.seniorSupply)).divWadDown(vars.juniorSupply); \n\t}\n\n  \n\n\tstruct localVars{\n\n\t    uint256 totalAssetsHeldScaled; \n\t    uint256 juniorSupply;\n\t    uint256 seniorSupply; \n\n\t    bool belowThreshold; \n\t}\n\n}\n\n"
    },
    "contracts/libraries/tradeLib.sol": {
      "content": "\n\n// library TradeLib{\n//   function buyBond(\n\n//     ) external returns(uint256 amountIn, uint256 amountOut){\n    \n//   }\n\n//  event BondBuy(uint256 indexed marketId, address indexed trader, uint256 amountIn, uint256 amountOut);\n//   /// @notice main entry point for longZCB buys \n//   /// @param _amountIn is negative if specified in zcb quantity\n//   function buyBond(\n//     uint256 _marketId, \n//     int256 _amountIn, \n//     uint256 _priceLimit, \n//     bytes calldata _tradeRequestData \n//     ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\n//     require(!restriction_data[_marketId].resolved, \"!resolved\");\n//     _canBuy(msg.sender, _amountIn, _marketId);\n//     //TODO return readable error on why it reverts\n//     CoreMarketData memory marketData = markets[_marketId]; \n//     SyntheticZCBPool bondPool = marketData.bondPool; \n    \n\n//     // During assessment, real bonds are issued from utilizer, they are the sole LP \n//     if (restriction_data[_marketId].duringAssessment){\n//       // TODO fix pricelimit  \n\n//       (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender)); \n\n//       // uint256 upperBound = bondPool.upperBound(); \n//       if( bondPool.upperBound() !=0 &&  bondPool.upperBound() < bondPool.getCurPrice()) revert(\"Exceeds Price Bound\"); \n\n//       //Need to log assessment trades for updating reputation scores or returning collateral when market denied \n//       _logTrades(_marketId, msg.sender, amountIn, 0, true, true);\n\n//       // Get implied probability estimates by summing up all this manager bought for this market \n//       reputationManager.recordPull(msg.sender, _marketId, amountOut,\n//         amountIn, getTraderBudget(_marketId, msg.sender), marketData.isPool); \n\n//       // assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\n//       //     getZCB(_marketId).balanceOf(msg.sender) + leveragePosition[_marketId][msg.sender].amount, \n//       //     longTrades[_marketId][msg.sender], \n//       //     getTraderBudget(_marketId, msg.sender) \n//       // ); \n\n//       // Phase Transitions when conditions met\n//       if(restriction_data[_marketId].onlyReputable){\n//         uint256 total_bought = loggedCollaterals[_marketId];\n\n//         if (total_bought >= parameters[_marketId].omega.mulWadDown(\n//               controller\n//               .getVault(_marketId)\n//               .fetchInstrumentData(_marketId)\n//               .principal)\n//         ) {\n//           restriction_data[_marketId].onlyReputable = false;\n//           emit MarketPhaseSet(_marketId, restriction_data[_marketId]);\n//         }\n//       }\n//     }\n\n//     // Synthetic bonds are issued (liquidity provision are amortized as counterparties)\n//     else{\n//       (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender));\n\n//       // TODO check if valid slippage \n//       // TODO check liquidity, revert if not\n//       // TODO reputation while trading post assessment? \n//       // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\n//       // if(isTaker)\n\n//       //   (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender));\n//       // else{\n//       //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), true, msg.sender); \n//       // }\n//     }\n\n//     uint amountIn_ = _amountIn> 0? uint256(_amountIn) : uint256(-_amountIn); \n//     if(_amountIn> 0)require(amountIn_ == amountIn , \"AMM not enough Liq\") ; \n//     else require(amountIn_==amountOut, \"AMM not enough Liq\"); \n\n//     emit BondBuy(_marketId, msg.sender, amountIn, amountOut); // get current price as well.\n// }"
    },
    "contracts/protocol/controller.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {MarketManager} from \"./marketmanager.sol\";\n// import {ReputationNFT} from \"./reputationtoken.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {Strings} from \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {VaultFactory} from \"./factories.sol\";\nimport \"lib/forge-std/src/console.sol\";\n// import \"@interep/contracts/IInterep.sol\";\nimport {config} from \"../utils/helpers.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\";\nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\n// import \"@interep/contracts/IInterep.sol\";\nimport {SyntheticZCBPoolFactory} from \"../bonds/synthetic.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ReputationManager} from \"./reputationmanager.sol\";\nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\";\nimport {LinearCurve} from \"../bonds/GBC.sol\"; \nimport {LeverageManager} from \"./leveragemanager.sol\"; \nimport {ValidatorManager} from \"./validatorManager.sol\";\n\nimport \"../global/GlobalStorage.sol\"; \nimport \"../global/types.sol\"; \nimport {PerpTranchePricer} from \"../libraries/pricerLib.sol\"; \n\ncontract Controller {\n    using SafeMath for uint256;\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n    using PerpTranchePricer for PricingInfo; \n\n\n    ValidatorManager validatorManager;\n\n\n\n    mapping(uint256 => ApprovalData) approvalDatas;\n\n    function getApprovalData(uint256 marketId)\n        public\n        view\n        returns (ApprovalData memory data)\n    {\n        data = approvalDatas[marketId];\n    }\n\n    mapping(address => bool) public verified;\n    mapping(uint256 => MarketData) public market_data; // id => recipient\n    mapping(address => uint256) public ad_to_id; //utilizer address to marketId\n    mapping(uint256 => Vault) public vaults; // vault id to Vault contract\n    mapping(uint256 => uint256) public id_parent; //marketId-> vaultId\n    mapping(uint256 => uint256[]) public vault_to_marketIds;\n\n    address creator_address;\n\n    // IInterep interep;\n    // TrustedMarketFactoryV3 marketFactory;\n    MarketManager public marketManager;\n    // ReputationNFT repNFT;\n    VaultFactory public vaultFactory;\n    SyntheticZCBPoolFactory public poolFactory;\n    ReputationManager public reputationManager;\n    LeverageManager public leverageManager; \n    StorageHandler public Data; \n\n    /* ========== MODIFIERS ========== */\n    modifier onlyValidator(uint256 marketId) {\n        require(\n            isValidator(marketId, msg.sender) || msg.sender == creator_address,\n            \"!Val\"\n        );\n        _;\n    }\n\n    modifier onlyManager() {\n        require(\n            msg.sender == address(marketManager) || msg.sender == address(leverageManager)|| \n                msg.sender == creator_address,\n            \"!manager\"\n        );\n        _;\n    }\n\n    constructor(\n        address _creator_address,\n        address _interep_address //TODO\n    ) {\n        creator_address = _creator_address;\n    }\n\n    /*----Setup Functions----*/\n\n    function setMarketManager(address _marketManager) public onlyManager {\n        require(_marketManager != address(0));\n        marketManager = MarketManager(_marketManager);\n    }\n\n    function setReputationManager(address _reputationManager)\n        public\n        onlyManager\n    {   require(address(marketManager)!= address(0), \"0mm\"); \n        reputationManager = ReputationManager(_reputationManager);\n        marketManager.setReputationManager(_reputationManager); \n    }\n\n    function setValidatorManager(address _validatorManager) public onlyManager {\n        validatorManager = ValidatorManager(_validatorManager);\n    }\n\n    function setLeverageManager(address _leverageManager) public onlyManager{\n        leverageManager = LeverageManager(_leverageManager); \n        marketManager.setLeverageManager(_leverageManager); \n    }\n\n    function setVaultFactory(address _vaultFactory) public onlyManager {\n        vaultFactory = VaultFactory(_vaultFactory);\n    }\n\n    function setPoolFactory(address _poolFactory) public onlyManager {\n        poolFactory = SyntheticZCBPoolFactory(_poolFactory);\n    }\n    function setDataStore(address _dataStore) public onlyManager{\n        Data = StorageHandler(_dataStore); \n        marketManager.setDataStore( _dataStore); \n\n        reputationManager.setDataStore( _dataStore);\n\n        leverageManager.setDataStore(_dataStore);\n\n    }\n\n    // function storeNewPrices(uint256 marketId, uint256 multiplier, uint256 initPrice) public {\n\n    //     Data.setNewPricingInfo( marketId,  initPrice,  multiplier); \n\n    //     // data.PriceInfos(marketId).setNewPrices(initPrice, multiplier, marketId); \n    // }\n\n\n    // function verifyAddress(\n    //     uint256 nullifier_hash,\n    //     uint256 external_nullifier,\n    //     uint256[8] calldata proof\n    // ) external  {\n    //     require(!verified[msg.sender], \"address already verified\");\n    //     interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\n    //     verified[msg.sender] = true;\n    // }\n    // bool public selfVerify = true; \n    // function canSelfVerify() external {\n    //     require(msg.sender == creator_address, \"!auth\"); \n    //     selfVerify = !selfVerify; \n    // }\n\n    function verifyAddress(address who) external{\n        require(msg.sender == creator_address, \"!auth\"); \n        verified[who] = true;\n        reputationManager.setTraderScore(who, 1e18); \n    }\n\n\n    // function testVerifyAddress() external {\n    //     require(selfVerify, \"!selfVerify\"); \n    //     verified[msg.sender] = true;\n    //     reputationManager.setTraderScore(msg.sender, 1e18); \n    // }\n\n    event RedeemTransfer(uint256 indexed marketId, uint256 amount, address to);\n    /// @notice called only when redeeming, transfer funds from vault\n    function redeem_transfer(\n        uint256 amount,\n        address to,\n        uint256 marketId\n    ) external onlyManager {\n        vaults[id_parent[marketId]].trusted_transfer(amount, to);\n\n        emit RedeemTransfer(marketId, amount, to);\n    }\n\n    event VaultCreated(address indexed vault, uint256 vaultId, address underlying, bool onlyVerified, uint256 r, uint256 assetLimit, uint256 totalAssetLimit, MarketParameters defaultParams);\n    /// @notice creates vault\n    /// @param underlying: underlying asset for vault\n    /// @param _onlyVerified: only verified users can mint shares\n    /// @param _r: minimum reputation score to mint shares\n    /// @param _asset_limit: max number of shares for a single address\n    /// @param _total_asset_limit: max number of shares for entire vault\n    /// @param default_params: default params for markets created by vault\n    function createVault(\n        address underlying,\n        bool _onlyVerified,\n        uint256 _r,\n        uint256 _asset_limit,\n        uint256 _total_asset_limit,\n        MarketParameters memory default_params,\n        string calldata _description\n    ) public {\n        (Vault newVault, uint256 vaultId) = vaultFactory.newVault(\n            underlying,\n            address(this),\n            abi.encode(_onlyVerified, _r, _asset_limit, _total_asset_limit,_description),\n            default_params  \n        );\n\n        vaults[vaultId] = newVault;\n\n        emit VaultCreated(address(newVault), vaultId, underlying, _onlyVerified, _r, _asset_limit, _total_asset_limit, default_params);\n    }\n\n    function getInstrumentSnapShot(uint256 marketId) view public returns (uint256 managerStake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) {\n        CoreMarketData memory data = marketManager.getMarket(marketId); \n        ApprovalData memory approvalData = getApprovalData(marketId); \n        InstrumentData memory instrumentData = getVault(marketId).fetchInstrumentData(marketId);\n        managerStake = approvalData.managers_stake;\n        exposurePercentage = (approvalData.approved_principal- approvalData.managers_stake).divWadDown(getVault(marketId).totalAssets()+1);\n        seniorAPR = instrumentData.poolData.promisedReturn; \n        approvalPrice = instrumentData.poolData.inceptionPrice; \n\n        if(!instrumentData.isPool){\n            uint256 amountDelta;\n            uint256 resultPrice;\n\n            if(approvalData.managers_stake>0){\n                ( amountDelta,  resultPrice) = LinearCurve.amountOutGivenIn(\n                approvalData.managers_stake,\n                0, \n                data.bondPool.a_initial(), \n                data.bondPool.b(), \n                true \n                );\n            }\n            \n            uint256 seniorYield = instrumentData.faceValue -amountDelta\n                - (instrumentData.principal - approvalData.managers_stake); \n\n            seniorAPR = approvalData.approved_principal>0\n                ? seniorYield.divWadDown(1+instrumentData.principal - approvalData.managers_stake)\n                : 0; \n            approvalPrice = resultPrice; \n        }\n    }\n\n    function getVaultSnapShot(uint256 vaultId) view external returns (uint256 totalProtection, uint256 totalEstimatedAPR, uint256 goalAPR, uint256 exchangeRate) {\n        uint256[] memory marketIds = vault_to_marketIds[vaultId];\n        for (uint256 i = 0; i < marketIds.length; i++) {\n            (,uint256 exposurePercentage, uint256 seniorAPR,) = getInstrumentSnapShot(marketIds[i]);\n            totalEstimatedAPR += exposurePercentage.mulWadDown(seniorAPR);\n            totalProtection += marketManager.loggedCollaterals(marketIds[i]);\n        }\n\n        Vault vault = vaults[vaultId];\n\n        uint256 goalUtilizationRate = 9e17; //90% utilization goal? \n        if(vault.utilizationRate() <= goalUtilizationRate)\n         goalAPR = (goalUtilizationRate.divWadDown(1+vault.utilizationRate())).mulWadDown(totalEstimatedAPR); \n        else goalAPR = totalEstimatedAPR;\n\n        exchangeRate = vault.previewDeposit(1e18);\n    }\n\n    event MarketInitiated(uint256 indexed marketId, address indexed vault, address indexed recipient, address pool, address longZCB, address shortZCB, InstrumentData instrumentData);\n\n    /// @notice initiates market, called by frontend loan proposal or instrument form submit button.\n    /// @dev Instrument should already be deployed\n    /// @param recipient: utilizer for the associated instrument\n    /// @param instrumentData: instrument arguments\n    /// @param vaultId: vault identifier\n    function initiateMarket(\n        address recipient,\n        InstrumentData memory instrumentData,\n        uint256 vaultId\n    ) external {\n        require(recipient != address(0), \"address0R\");\n        require(instrumentData.instrument_address != address(0), \"address0I\");\n        require(address(vaults[vaultId]) != address(0), \"address0V\");\n\n        Vault vault = vaults[vaultId];\n        uint256 marketId = marketManager.marketCount();\n        id_parent[marketId] = vaultId;\n        vault_to_marketIds[vaultId].push(marketId);\n        market_data[marketId] = MarketData(\n            instrumentData.instrument_address,\n            recipient\n        );\n        marketManager.setParameters(\n            vault.get_vault_params(),\n            vault.utilizationRate(),\n            marketId\n        ); //TODO non-default\n\n        // Create new pool and bonds and store initial price and liquidity for the pool\n        (address longZCB, address shortZCB, SyntheticZCBPool pool) = poolFactory\n            .newPool(\n                address(vaults[vaultId].UNDERLYING()),\n                address(marketManager)\n            );\n\n        CoreMarketData memory marketData; \n        if (instrumentData.isPool) {\n          require(instrumentData.poolData.initPrice<= 1e18 \n            && instrumentData.poolData.initPrice< instrumentData.poolData.inceptionPrice, \"PRICE ERR\"); \n          require(instrumentData.poolData.promisedReturn>0, \"RETURN ERR\"); \n          instrumentData.poolData.inceptionTime = block.timestamp;\n\n          instrumentData.poolData.managementFee = pool\n            .calculateInitCurveParamsPool(\n                instrumentData.poolData.saleAmount,\n                instrumentData.poolData.initPrice,\n                instrumentData.poolData.inceptionPrice,\n                marketManager.getParameters(marketId).sigma\n            );\n\n            marketManager.newMarket(\n            marketId,\n            pool,\n            longZCB,\n            shortZCB,\n            instrumentData.description,\n            true\n            );\n            marketData = CoreMarketData(\n                pool,\n                ERC20(longZCB),\n                ERC20(shortZCB),\n                instrumentData.description,\n                block.timestamp, \n                0, \n                true\n            ); \n\n          // set validators\n          validatorManager.validatorSetup(\n            marketId,\n            instrumentData.poolData.saleAmount,\n            instrumentData.isPool\n        );\n        } else {\n            MarketParameters memory params = marketManager.getParameters(marketId); \n            pool.calculateInitCurveParams(\n                instrumentData.principal,\n                instrumentData.expectedYield,\n                params.sigma, \n                params.alpha, \n                params.delta\n            );\n\n            marketManager.newMarket(\n                marketId,\n                pool,\n                longZCB,\n                shortZCB,\n                instrumentData.description,\n                false\n            );         \n            marketData = CoreMarketData(\n                pool,\n                ERC20(longZCB),\n                ERC20(shortZCB),\n                instrumentData.description,\n                block.timestamp, \n                0, \n                false\n            ); \n\n            // set validators\n            validatorManager.validatorSetup(\n                marketId,\n                instrumentData.principal,\n                instrumentData.isPool\n            );\n        }\n\n        Data.setNewInstrument(\n         marketId, \n         instrumentData.poolData.inceptionPrice, \n         0, //TODO configurable \n         false, \n         instrumentData, \n         marketData); // TODO more params \n\n        // add vault proposal\n        instrumentData.marketId = marketId;\n        vault.addProposal(instrumentData);\n\n        emit MarketInitiated(marketId, address(vaults[vaultId]), recipient, address(pool), longZCB, shortZCB, instrumentData);\n\n        ad_to_id[recipient] = marketId; //only for testing purposes, one utilizer should be able to create multiple markets\n    }\n\n    /// @notice Resolve function 1\n    /// @dev Prepare market/instrument for closing, called separately before resolveMarket\n    /// this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest\n    /// or, in the event of a default, by validators who deem the principal recouperation is finished\n    /// and need to collect remaining funds by redeeming ZCB\n    function beforeResolve(uint256 marketId) external //onlyValidator(marketId)\n    {\n        (bool duringMarketAssessment, , , bool alive, , ) = marketManager\n            .restriction_data(marketId);\n        require(!duringMarketAssessment && alive, \"market conditions not met\");\n        require(\n            resolveCondition(marketId),\n            \"not enough validators have voted to resolve\"\n        );\n        vaults[id_parent[marketId]].beforeResolve(marketId);\n    }\n\n    // function testBeforeResolve(uint256 marketId) external {\n    //   (bool duringMarketAssessment, , , bool alive, , ) = marketManager\n    //         .restriction_data(marketId);\n    //     require(!duringMarketAssessment && alive, \"market conditions not met\");\n    //     vaults[id_parent[marketId]].beforeResolve(marketId);\n    // }\n\n    function testResolveMarket(uint256 marketId) external {\n      vaults[id_parent[marketId]].beforeResolve(marketId);\n      (\n            bool atLoss,\n            uint256 extra_gain,\n            uint256 principal_loss,\n            bool premature\n        ) = vaults[id_parent[marketId]].resolveInstrument(marketId);\n\n        updateRedemptionPrice(\n            marketId,\n            atLoss,\n            extra_gain,\n            principal_loss,\n            premature\n        );\n        validatorManager.updateValidatorStake(\n            marketId,\n            approvalDatas[marketId].approved_principal,\n            principal_loss\n        );\n        cleanUpDust(marketId);\n        emit MarketResolved(marketId, atLoss, extra_gain, principal_loss, premature);\n    }\n\n    event MarketResolved(uint256 indexed marketId, bool atLoss, uint256 extraGain, uint256 principalLoss, bool premature);\n\n    /// Resolve function 2\n    /// @notice main function called at maturity OR premature resolve of instrument(from early default)\n    /// @dev validators call this function from market manager\n    /// any funds left for the instrument, irrespective of whether it is in profit or inloss.\n    function resolveMarket(uint256 marketId) external onlyValidator(marketId) {\n        (\n            bool atLoss,\n            uint256 extra_gain,\n            uint256 principal_loss,\n            bool premature\n        ) = vaults[id_parent[marketId]].resolveInstrument(marketId);\n        // TODO updating if only market is pool. \n        updateRedemptionPrice(\n            marketId,\n            atLoss,\n            extra_gain,\n            principal_loss,\n            premature\n        );\n        validatorManager.updateValidatorStake(\n            marketId,\n            approvalDatas[marketId].approved_principal,\n            principal_loss\n        );\n        cleanUpDust(marketId);\n\n        emit MarketResolved(marketId, atLoss, extra_gain, principal_loss, premature);\n    }\n\n    /// @dev Redemption price, as calculated (only once) at maturity,\n    /// depends on total_repayed/(principal + predetermined yield)\n    /// If total_repayed = 0, redemption price is 0\n    /// @param atLoss: defines circumstances where expected returns are higher than actual\n    /// @param loss: facevalue - returned amount => non-negative always?\n    /// @param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\n    function updateRedemptionPrice(\n        uint256 marketId,\n        bool atLoss,\n        uint256 extra_gain,\n        uint256 loss,\n        bool premature\n    ) internal {\n  \n        if (atLoss) assert(extra_gain == 0);\n\n        uint256 total_supply = marketManager.getZCB(marketId).totalSupply();\n        uint256 total_shorts = (extra_gain > 0)\n            ? marketManager.getShortZCB(marketId).totalSupply()\n            : 0;\n        uint256 redemption_price;\n        if(premature && extra_gain>0){\n            redemption_price = calcIncompleteReturns(marketId, extra_gain); \n        } else{\n            console.log('updating rp', extra_gain, loss); \n            if (!atLoss)\n                redemption_price =\n                    config.WAD +\n                    extra_gain.divWadDown(total_supply + total_shorts);\n            else {\n                if (config.WAD <= loss.divWadDown(total_supply)) {\n                    redemption_price = 0;\n                } else {\n                    redemption_price = config.WAD - loss.divWadDown(total_supply);\n                }\n            }\n        }\n\n        marketManager.deactivateMarket(\n            marketId,\n            atLoss,\n            !premature,\n            redemption_price\n        );\n        // TODO edgecase redemption price calculations\n    }\n\n    uint256 constant leverageFactor = 3e18; \n    /// @notice redeeming function for fixed instruements that did not pay off at maturity\n    function calcIncompleteReturns(\n        uint256 marketId, \n        uint256 incompleteReturns\n        ) public view returns(uint256 seniorReturn){\n        uint256 totalJuniorCollateral = marketManager.loggedCollaterals(marketId); \n        uint256 principal = getVault(marketId).fetchInstrumentData(marketId).principal; \n\n        seniorReturn = principal.mulWadDown(incompleteReturns).divWadDown(\n          leverageFactor.mulWadDown(totalJuniorCollateral) + principal - totalJuniorCollateral); \n    }\n    // uint256 public constant riskTransferPenalty = 1e17;\n\n    // /// @notice deduce fees for non vault stakers, should go down as maturity time approach 0\n    // function deduct_selling_fee(uint256 marketId)\n    //     public\n    //     view\n    //     returns (uint256)\n    // {\n    //     // Linearly decreasing fee\n    //     uint256 normalizedTime = ((getVault(marketId)\n    //         .fetchInstrumentData(marketId)\n    //         .maturityDate - block.timestamp) * config.WAD) /\n    //         getVault(marketId).fetchInstrumentData(marketId).duration;\n    //     return normalizedTime.mulWadDown(riskTransferPenalty);\n    // }\n\n    /// @notice When market resolves, should collect remaining liquidity and/or dust from\n    /// the pool and send them back to the vault\n    /// @dev should be called before redeem_transfer is allowed\n    function cleanUpDust(uint256 marketId) internal {\n        marketManager.getPool(marketId).flush(\n            getVaultAd(marketId),\n            type(uint256).max\n        );\n    }\n\n    // /// @notice when market is resolved(maturity/early default), calculates score\n    // /// and update each assessment phase trader's reputation, called by individual traders when redeeming\n    // function updateReputation(\n    //     uint256 marketId,\n    //     address trader,\n    //     bool increment\n    // ) external onlyManager {\n    //     uint256 implied_probs = marketManager.assessment_probs(\n    //         marketId,\n    //         trader\n    //     );\n    //     // int256 scoreToUpdate = increment ? int256(implied_probs.mulDivDown(implied_probs, config.WAD)) //experiment\n    //     //                                  : -int256(implied_probs.mulDivDown(implied_probs, config.WAD));\n    //     uint256 change = implied_probs.mulDivDown(implied_probs, config.WAD);\n\n    //     if (increment) {\n    //         reputationManager.incrementScore(trader, change);\n    //     } else {\n    //         reputationManager.decrementScore(trader, change);\n    //     }\n    // }\n\n    /// @notice function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast\n    /// or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc.\n    /// After, the resolveMarket function should be called in a new block\n    /// @dev withdraws all balance from the instrument.\n    /// If assets in instrument is not in underlying, need all balances to be divested to underlying\n    /// Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\n    /// @param emergency ascribes cases where the instrument should be forcefully liquidated back to the vault\n    function forceCloseInstrument(uint256 marketId, bool emergency)\n        external\n        returns (bool)\n    {\n        Vault vault = vaults[id_parent[marketId]];\n\n        // Prepare for close\n        vault.closeInstrument(marketId);\n\n        // Harvests/records all profit & losses\n        vault.beforeResolve(marketId);\n        return true;\n    }\n\n    /// @notice returns true if amount bought is greater than the insurance threshold\n    function marketCondition(uint256 marketId) public view returns (bool) {\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\n\n        // TODO add vault balances as well \n        if (isPool) {\n            return (marketManager.loggedCollaterals(marketId) >=\n                getVault(marketId)\n                    .fetchInstrumentData(marketId)\n                    .poolData\n                    .saleAmount);\n            console.log('marketcondition', marketManager.loggedCollaterals(marketId), \n               getVault(marketId)\n                    .fetchInstrumentData(marketId)\n                    .poolData\n                    .saleAmount); \n        } else {\n            uint256 principal = getVault(marketId)\n                .fetchInstrumentData(marketId)\n                .principal;\n                console.log('marketcondition', marketManager.loggedCollaterals(marketId), \n                principal.mulWadDown(\n                    marketManager.getParameters(marketId).alpha\n                )); \n            return (marketManager.loggedCollaterals(marketId) >=\n                principal.mulWadDown(\n                    marketManager.getParameters(marketId).alpha\n                ));\n        }\n    }\n\n    /// GOD FUNCTION\n    function testApproveMarket(uint256 marketId) external {\n        require(msg.sender == creator_address, \"!owner\");\n        require(marketCondition(marketId), \"market condition not met\");\n        approveMarket(marketId);\n    }\n\n    event MarketApproved(uint256 indexed marketId, ApprovalData data);\n\n    /// @notice called by the validator from validatorApprove when market conditions are met\n    /// need to move the collateral in the wCollateral to\n    function approveMarket(uint256 marketId) public {\n        require(msg.sender == address(validatorManager) || msg.sender == creator_address, \"!validator\");\n        Vault vault = vaults[id_parent[marketId]];\n        SyntheticZCBPool pool = marketManager.getPool(marketId);\n\n\n        require(\n            marketManager.getCurrentMarketPhase(marketId) == 3,\n            \"!marketCondition\"\n        );\n        require(\n            vault.instrumentApprovalCondition(marketId),\n            \"!instrumentCondition\"\n        );\n        marketManager.approveMarket(marketId);\n\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\n        uint256 managerCollateral = marketManager.loggedCollaterals(marketId);\n\n        // console.log(\"managerCollateral: \", managerCollateral);\n\n\n        pool.flush(address(this), managerCollateral); \n        address instrument = address(vault.fetchInstrument(marketId)); \n        vault.UNDERLYING().approve(instrument, managerCollateral); \n\n        if (isPool) {\n            poolApproval(\n                marketId,\n                marketManager.getZCB(marketId).totalSupply(),\n                vault.fetchInstrumentData(marketId).poolData\n            );\n          require(ERC4626(instrument).deposit(managerCollateral, address(vault))>0, \"DEPOSIT_FAILED\");\n        } else {\n            if (vault.getInstrumentType(marketId) == 0)\n                creditApproval(marketId, pool);\n            else generalApproval(marketId);\n            vault.UNDERLYING().transfer(instrument, managerCollateral); \n        }\n\n        approvalDatas[marketId].managers_stake = managerCollateral;\n\n        // TODO vault exchange rate should not change\n        // pull from pool to vault, which will be used to fund the instrument\n\n        // Trust and deposit to the instrument contract\n        vault.trustInstrument(marketId, approvalDatas[marketId], isPool);\n\n        // Since funds are transfered from pool to vault, set default liquidity in pool to 0\n        pool.resetLiq();\n\n        // console.log(\"approval 1: \", approvalDatas[marketId].approved_principal);\n        // console.log(\"approval 2: \", approvalDatas[marketId].approved_yield);\n        // console.log(\"approval 3: \", approvalDatas[marketId].managers_stake);\n        \n        emit MarketApproved(marketId, approvalDatas[marketId]);\n    }\n\n    function poolApproval(\n        uint256 marketId,\n        uint256 juniorSupply,\n        PoolData memory data\n    ) internal {\n        require(data.leverageFactor > 0, \"0 LEV_FACTOR\");\n        approvalDatas[marketId] = ApprovalData(\n            0,\n            juniorSupply\n                .mulWadDown(config.WAD + data.leverageFactor)\n                .mulWadDown(data.inceptionPrice),\n            0\n        );\n\n    }\n\n    /// @notice receives necessary market information. Only applicable for creditlines\n    /// required for market approval such as max principal, quoted interest rate\n    function creditApproval(uint256 marketId, SyntheticZCBPool pool) internal {\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\n            id_parent[marketId]\n        ].viewPrincipalAndYield(marketId);\n\n        // get max_principal which is (s+1) * total long bought for creditline, or just be\n        // proposed principal for other instruments\n        uint256 max_principal = min(\n            (marketManager.getParameters(marketId).s + config.WAD).mulWadDown(\n                marketManager.loggedCollaterals(marketId)\n            ),\n            proposed_principal\n        );\n\n        // Required notional yield amount denominated in underlying  given credit determined by managers\n        uint256 quoted_interest = min(\n            pool.areaBetweenCurveAndMax(max_principal),\n            proposed_yield\n        );\n\n        approvalDatas[marketId] = ApprovalData(\n            0,\n            max_principal,\n            quoted_interest\n        );\n    }\n\n    function generalApproval(uint256 marketId) internal {\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\n            id_parent[marketId]\n        ].viewPrincipalAndYield(marketId);\n        approvalDatas[marketId] = ApprovalData(\n            0,\n            proposed_principal,\n            proposed_yield\n        );\n    }\n\n    event MarketDenied(uint256 indexed marketId);\n    /**\n   @dev called by validator denial of market.\n   */\n    function denyMarket(uint256 marketId) external onlyValidator(marketId) {\n        vaults[id_parent[marketId]].denyInstrument(marketId);\n        cleanUpDust(marketId);\n        marketManager.denyMarket(marketId);\n        emit MarketDenied(marketId);\n    }\n\n    /*----Validator Logic----*/\n    // struct ValidatorData {\n    //     mapping(address => uint256) sales; // amount of zcb bought per validator\n    //     mapping(address => bool) staked; // true if address has staked vt (approved)\n    //     mapping(address => bool) resolved; // true if address has voted to resolve the market\n    //     address[] validators;\n    //     uint256 val_cap; // total zcb validators can buy at a discount\n    //     uint256 avg_price; //price the validators can buy zcb at a discount\n    //     bool requested; // true if already requested random numbers from array.\n    //     uint256 totalSales; // total amount of zcb bought;\n    //     uint256 totalStaked; // total amount of vault token staked.\n    //     uint256 numApproved;\n    //     uint256 initialStake; // amount staked\n    //     uint256 finalStake; // amount of stake recoverable post resolve\n    //     uint256 numResolved; // number of validators calling resolve on early resolution.\n    // }\n\n    // mapping(uint256 => uint256) requestToMarketId;\n    // mapping(uint256 => ValidatorData) public validator_data;\n\n    /// @notice sets the validator cap + valdiator amount\n    /// param prinicipal is saleAmount for pool based instruments\n    /// @dev called by controller to setup the validator scheme\n    // function _validatorSetup(\n    //     uint256 marketId,\n    //     uint256 principal,\n    //     bool isPool\n    // ) internal {\n    //     require(principal != 0, \"0 principal\");\n    //     _getValidators(marketId);\n    //     _setValidatorCap(marketId, principal, isPool);\n    //     _setValidatorStake(marketId, principal);\n    // }\n\n    function getValidatorPrice(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getValidatorPrice(marketId);\n        //return validator_data[marketId].avg_price;\n    }\n\n    function getValidatorCap(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getValidatorCap(marketId);\n        //return validator_data[marketId].val_cap;\n    }\n\n    function viewValidators(uint256 marketId)\n        public\n        view\n        returns (address[] memory)\n    {\n        return validatorManager.viewValidators(marketId);\n        //return validator_data[marketId].validators;\n    }\n\n    function getNumApproved(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getNumApproved(marketId);\n        //return validator_data[marketId].numApproved;\n    }\n\n    function getNumResolved(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getNumResolved(marketId);\n        //return validator_data[marketId].numResolved;\n    }\n\n    function getTotalStaked(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getTotalStaked(marketId);\n        //return validator_data[marketId].totalStaked;\n    }\n\n    function getTotalValidatorSales(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        return validatorManager.getTotalValidatorSales(marketId);\n        //return validator_data[marketId].totalSales;\n    }\n\n    function getInitialStake(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getInitialStake(marketId);\n        //return validator_data[marketId].initialStake;\n    }\n\n    function getFinalStake(uint256 marketId) public view returns (uint256) {\n        return validatorManager.getFinalStake(marketId);\n        //return validator_data[marketId].finalStake;\n    }\n\n    /**\n   @notice randomly choose validators for market approval, async operation => fulfillRandomness is the callback function.\n   @dev for now called on market initialization\n   */\n    // function _getValidators(uint256 marketId) public {\n    //     // retrieve traders that meet requirement.\n    //     // address instrument = market_data[marketId].instrument_address;\n    //     address utilizer = market_data[marketId].utilizer;\n    //     (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n    //     address[] memory selected = reputationManager.filterTraders(\n    //         r,\n    //         utilizer\n    //     );\n\n    //     // if there are not enough traders, set validators to all selected traders.\n    //     if (selected.length <= N) {\n    //         validator_data[marketId].validators = selected;\n\n    //         if (selected.length < N) {\n    //             revert(\"not enough rated traders\");\n    //         }\n\n    //         return;\n    //     }\n\n    //     validator_data[marketId].requested = true;\n\n    //     uint256 _requestId = 1;\n    //     // uint256 _requestId = COORDINATOR.requestRandomWords(\n    //     //   keyHash,\n    //     //   subscriptionId,\n    //     //   requestConfirmations,\n    //     //   callbackGasLimit,\n    //     //   uint32(parameters[marketId].N)\n    //     // );\n\n    //     requestToMarketId[_requestId] = marketId;\n    // }\n\n    /**\n   @notice chainlink callback function, sets validators.\n   @dev TODO => can be called by anyone?\n   */\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords //internal\n    ) public //override\n    {\n        validatorManager.fulfillRandomWords(requestId, randomWords);\n        // uint256 marketId = requestToMarketId[requestId];\n        // (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n\n        // assert(randomWords.length == N);\n\n        // // address instrument = market_data[marketId].instrument_address;\n        // address utilizer = market_data[marketId].utilizer;\n\n        // address[] memory temp = reputationManager.filterTraders(r, utilizer);\n        // uint256 length = temp.length;\n\n        // // get validators\n        // for (uint8 i = 0; i < N; i++) {\n        //     uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\n        //     validator_data[marketId].validators.push(temp[j]);\n        //     temp[j] = temp[length - 1];\n        //     length--;\n        // }\n    }\n\n    // function _weightedRetrieve(\n    //     address[] memory group,\n    //     uint256 length,\n    //     uint256 randomWord\n    // ) internal view returns (uint256) {\n    //     uint256 sum_weights;\n\n    //     for (uint8 i = 0; i < length; i++) {\n    //         sum_weights += getTraderScore(group[i]); //repToken.getReputationScore(group[i]);\n    //     }\n\n    //     uint256 tmp = randomWord % sum_weights;\n\n    //     for (uint8 i = 0; i < length; i++) {\n    //         uint256 wt = getTraderScore(group[i]);\n    //         if (tmp < wt) {\n    //             return i;\n    //         }\n    //         unchecked {\n    //             tmp -= wt;\n    //         }\n    //     }\n    // }\n\n    /// @notice allows validators to buy at a discount + automatically stake a percentage of the principal\n    /// They can only buy a fixed amount of ZCB, usually a at lot larger amount\n    /// @dev get val_cap, the total amount of zcb for sale and each validators should buy\n    /// val_cap/num validators zcb\n    /// They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly\n    /// correlated instruments triggers controller.approveMarket\n    function validatorApprove(uint256 marketId) external returns (uint256) {\n        \n        (uint256 collateral_required, uint256 zcb_for_sale) = validatorManager.validatorApprove(marketId, msg.sender);\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\n        marketManager.validatorApprove(\n            marketId,\n            collateral_required,\n            zcb_for_sale,\n            msg.sender\n        );\n\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\n        if (approvalCondition(marketId)) {\n            approveMarket(marketId);\n            marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\n        }\n\n        return collateral_required;\n    }\n\n    /**\n   @notice conditions for approval => validator zcb stake fulfilled + validators have all approved\n   */\n    function approvalCondition(uint256 marketId) public view returns (bool) {\n        return validatorManager.approvalCondition(marketId);\n        // return (validator_data[marketId].totalSales >=\n        //     validator_data[marketId].val_cap &&\n        //     validator_data[marketId].validators.length ==\n        //     validator_data[marketId].numApproved);\n    }\n\n    /**\n   @notice returns true if user is validator for corresponding market\n   */\n    function isValidator(uint256 marketId, address user)\n        public\n        view\n        returns (bool)\n    {\n        return validatorManager.isValidator(marketId, user);\n    }\n\n    /**\n   @notice condition for resolving market, met when all the validators chosen for the market\n   have voted to resolve.\n   */\n    function resolveCondition(uint256 marketId) public view returns (bool) {\n        return validatorManager.resolveCondition(marketId);\n        // return (validator_data[marketId].numResolved ==\n        //     validator_data[marketId].validators.length);\n    }\n\n    /**\n   @notice updates the validator stake, burned in proportion to loss.\n   principal and principal loss are in the underlying asset of the vault => must be converted to vault shares.\n   @dev called by resolveMarket\n   */\n    // function _updateValidatorStake(\n    //     uint256 marketId,\n    //     uint256 principal,\n    //     uint256 principal_loss\n    // ) internal {\n    //     if (principal_loss == 0) {\n    //         validator_data[marketId].finalStake = validator_data[marketId]\n    //             .initialStake;\n    //         return;\n    //     }\n\n    //     ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\n    //     uint256 p_shares = vault.convertToShares(principal);\n    //     uint256 p_loss_shares = vault.convertToShares(principal_loss);\n\n    //     uint256 totalStaked = validator_data[marketId].totalStaked;\n    //     uint256 newTotal = totalStaked /\n    //         2 +\n    //         (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(\n    //             totalStaked / 2\n    //         );\n\n    //     ERC4626(getVaultAd(marketId)).burn(totalStaked - newTotal);\n    //     validator_data[marketId].totalStaked = newTotal;\n\n    //     validator_data[marketId].finalStake =\n    //         newTotal /\n    //         validator_data[marketId].validators.length;\n    // }\n\n    /**\n   @notice called by validators to approve resolving the market, after approval.\n   */\n    function validatorResolve(uint256 marketId) external {\n        validatorManager.validatorResolve(marketId, msg.sender);\n        // require(isValidator(marketId, msg.sender), \"!val\");\n        // require(!validator_data[marketId].resolved[msg.sender], \"voted\");\n\n        // validator_data[marketId].resolved[msg.sender] = true;\n        // validator_data[marketId].numResolved++;\n    }\n\n    /**\n   @notice called by validators when the market is resolved or denied to retrieve their stake.\n   */\n    function unlockValidatorStake(uint256 marketId) external {\n        validatorManager.unlockValidatorStake(marketId, msg.sender);\n        // require(isValidator(marketId, msg.sender), \"!validator\");\n        // require(validator_data[marketId].staked[msg.sender], \"!stake\");\n        // (bool duringMarketAssessment, , , , , ) = marketManager\n        //     .restriction_data(marketId);\n\n        // // market early denial, no loss.\n        // ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\n        // if (duringMarketAssessment) {\n        //     ERC20(getVaultAd(marketId)).safeTransfer(\n        //         msg.sender,\n        //         validator_data[marketId].initialStake\n        //     );\n        //     validator_data[marketId].totalStaked -= validator_data[marketId]\n        //         .initialStake;\n        // } else {\n        //     // market resolved.\n        //     ERC20(getVaultAd(marketId)).safeTransfer(\n        //         msg.sender,\n        //         validator_data[marketId].finalStake\n        //     );\n        //     validator_data[marketId].totalStaked -= validator_data[marketId]\n        //         .finalStake;\n        // }\n\n        // validator_data[marketId].staked[msg.sender] = false;\n    }\n\n    /// @notice called when market initialized, calculates the average price and quantities of zcb\n    /// validators will buy at a discount when approving\n    /// valcap = sigma * princpal.\n    // function _setValidatorCap(\n    //     uint256 marketId,\n    //     uint256 principal,\n    //     bool isPool //??\n    // ) internal {\n    //     SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\n    //     (, uint256 sigma, , , , , , ) = marketManager.parameters(marketId);\n    //     require(config.isInWad(sigma) && config.isInWad(principal), \"paramERR\");\n    //     ValidatorData storage valdata = validator_data[marketId];\n\n    //     uint256 valColCap = (sigma.mulWadDown(principal));\n\n    //     // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved\n    //     uint256 discount_cap = bondingPool.discount_cap();\n    //     uint256 avgPrice = valColCap.divWadDown(discount_cap);\n\n    //     valdata.val_cap = discount_cap;\n    //     valdata.avg_price = avgPrice;\n    // }\n\n    /**\n   @notice sets the amount of vt staked by a single validator for a specific market\n   @dev steak should be between 1-0 wad.\n   */\n    // function _setValidatorStake(uint256 marketId, uint256 principal) internal {\n    //     //get vault\n    //     ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\n    //     uint256 shares = vault.convertToShares(principal);\n    //     (, , , , , , , uint256 steak) = marketManager.parameters(marketId);\n    //     validator_data[marketId].initialStake = steak.mulWadDown(shares);\n    // }\n\n    function hasApproved(uint256 marketId, address validator)\n        public\n        view\n        returns (bool)\n    {\n        return validatorManager.hasApproved(marketId, validator);\n        // return validator_data[marketId].staked[validator];\n    }\n\n    /**\n   @notice called by marketManager.redeemDeniedMarket, redeems the discounted ZCB\n   */\n    function deniedValidator(uint256 marketId, address validator)\n        external\n        onlyManager\n        returns (uint256 collateral_amount)\n    {\n        collateral_amount = validatorManager.deniedValidator(\n            marketId,\n            validator\n        );\n        //??? is this correct\n        // collateral_amount = validator_data[marketId]\n        //     .sales[validator]\n        //     .mulWadDown(validator_data[marketId].avg_price);\n        // delete validator_data[marketId].sales[validator];\n    }\n\n    function redeemValidator(uint256 marketId, address validator)\n        external\n        onlyManager\n    {\n        validatorManager.redeemValidator(\n            marketId,\n            validator\n        );\n        //delete validator_data[marketId].sales[validator];\n    }\n\n    function getValidatorRequiredCollateral(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        return validatorManager.getValidatorRequiredCollateral(marketId);\n        // uint256 val_cap = validator_data[marketId].val_cap;\n        // (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\n        // uint256 zcb_for_sale = val_cap / N;\n        // return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\n    }\n\n    function getTraderScore(address trader) public view returns (uint256) {\n        return reputationManager.trader_scores(trader);\n    }\n\n    function isReputable(address trader, uint256 r) public view returns (bool) {\n      return reputationManager.isReputable(trader, r);\n    }\n\n\n    /// @notice pool instrument\n    /// @notice called by utilizer during assessment\n    // function addAcceptedCollateral(\n    //     uint256 _marketId,\n    //     address _tokenAddress,\n    //     uint256 _tokenId,\n    //     uint256 _maxAmount,\n    //     uint256 _borrowAmount,\n    //     bool _isERC20\n    // ) external {\n    //     require(\n    //         msg.sender == address(market_data[_marketId].utilizer),\n    //         \"only utilizer can call this function\"\n    //     );\n    //     require(marketManager.getCurrentMarketPhase(_marketId) == 1, \"is during assessment\");\n        \n    //     Vault.InstrumentData memory _data = getVault(_marketId).fetchInstrumentData(_marketId);\n    //     require(_data.isPool, \"instrument is not pool\");\n        \n    //     PoolInstrument(address(getVault(_marketId).fetchInstrument(_marketId))).addAcceptedCollateral(\n    //         _tokenAddress,\n    //         _tokenId,\n    //         _maxAmount,\n    //         _borrowAmount,\n    //         _isERC20\n    //     );\n\n\n    //     // Instrument instrument = fetchInstrument(_marketId);\n    //     // instrument.addAcceptedCollateral(\n    //     //     _tokenAddress,\n    //     //     _tokenId,\n    //     //     _maxAmount,\n    //     //     _borrowAmount\n    //     // );\n    // }\n\n    function pullLeverage(uint256 marketId, uint256 amount)\n        external\n        onlyManager\n    {\n        getVault(marketId).trusted_transfer(amount, msg.sender);\n    }\n\n\n    function getTotalSupply(uint256 marketId) external view returns (uint256) {\n        return marketManager.getZCB(marketId).totalSupply();\n    }\n\n    function getMarketId(address recipient) public view returns (uint256) {\n        return ad_to_id[recipient];\n    }\n\n    function getVault(uint256 marketId) public view returns (Vault) {\n        return vaults[id_parent[marketId]];\n    }\n\n    function getVaultAd(uint256 marketId) public view returns (address) {\n        return address(vaults[id_parent[marketId]]);\n    }\n\n    function isVerified(address addr) public view returns (bool) {\n        return verified[addr];\n    }\n\n    function getVaultfromId(uint256 vaultId) public view returns (address) {\n        return address(vaults[vaultId]);\n    }\n\n    function marketId_to_vaultId(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        return id_parent[marketId];\n    }\n\n    function marketIdToVaultId(uint256 marketId) public view returns (uint256) {\n        return id_parent[marketId];\n    }\n\n    function getMarketIds(uint256 vaultId)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        return vault_to_marketIds[vaultId];\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n"
    },
    "contracts/protocol/factories.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {Vault} from \"../vaults/vault.sol\";\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {Controller} from \"./controller.sol\";\nimport \"../global/types.sol\"; \n\n/// @notice Anyone can create a vault. These can be users who  \n/// a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans)\n/// b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers)\n/// c) a vault for any long-tailed assets \n/// d) managers who wants leverage for yield opportunities on a specific asset \n/// e) uncollateralized lending platforms that wants to delegate the risk underwriting \n/// etc\n/// They need to specify \n/// 1. Vault mint conditions-> such as verified LPs(managers) only, \n/// 2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers)\n/// 3. Vault underlying \n/// @dev only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\n\ncontract VaultFactory{\n\n  address owner; \n  mapping(address=>bool) private _isVault; \n\n  uint256 public numVaults; \n  Controller controller; \n\n  constructor(address _controller){\n    owner = msg.sender; \n    controller = Controller(_controller);\n  }\n\n  function isVault(address v) external view returns(bool){\n    return _isVault[v]; \n  }\n\n  modifier onlyController(){\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \"is not controller\"); \n      _;\n  }\n\n  /**\n   @notice creates vault\n   @param underlying: underlying asset for vault\n   @param _controller: protocol controller\n   @param default_params: default params for markets created by vault\n   */\n  function newVault(\n    address underlying,\n    address _controller,\n    bytes memory _configData,\n    MarketParameters memory default_params\n  ) external onlyController returns(Vault, uint256) {\n    require(default_params.alpha >= 1e16, \"Alpha too small\"); \n    \n    Vault vault = new Vault(\n      underlying,\n       _controller,\n       owner, \n       //Params \n       _configData,\n       default_params\n       ); \n    _isVault[address(vault)] = true; \n    numVaults++;\n\n    return (vault, numVaults); \n    // vaultId is numVaults after new creation of the vault.\n\n  }\n}"
    },
    "contracts/protocol/leveragemanager.sol": {
      "content": "pragma solidity ^0.8.4; \n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\nimport  \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol\"; \nimport {Controller} from \"./controller.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\"; \n// import {PoolInstrument} from \"../instruments/oldpoolInstrument.sol\";\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {MarketManager} from \"./marketmanager.sol\"; \nimport {ReputationManager} from \"./reputationmanager.sol\"; \nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\"; \nimport {StorageHandler} from \"../global/GlobalStorage.sol\"; \nimport \"../global/types.sol\"; \n\n/// @notice borrow from leverageVault to leverage mint vaults\ncontract LeverageManager is ERC721Enumerable{\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n\n    uint256 constant precision =1e18; \n    Controller controller; \n    MarketManager marketManager; \n    ReputationManager reputationManager; \n  modifier _lock_() {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n    bool private _mutex; \n    constructor(\n        address controller_ad, \n        address marketManager_ad, \n        address reputationManager_ad\n        )ERC721Enumerable() ERC721(\"RAMM lv\", \"RammLV\") {\n        controller = Controller(controller_ad); \n        marketManager = MarketManager(marketManager_ad); \n        reputationManager = ReputationManager(reputationManager_ad); \n    }\n  modifier onlyController(){\n    require(address(controller) == msg.sender , \"!controller\"); \n    _;\n  }\n\n  StorageHandler public Data; \n  function setDataStore(address dataStore) public onlyController{\n    Data = StorageHandler(dataStore); \n  }\n    mapping(uint256=>mapping(address=> LeveredBond)) public leveragePosition; \n    struct LeveredBond{\n        uint256 debt; //how much collateral borrowed from vault \n        uint256 amount; // how much bonds were bought with the given leverage\n    }\n\n    struct LocalVars{\n        uint256 psu; \n        uint256 pju; \n        uint256 levFactor; \n        uint256 seniorAmount; \n        uint256 budget; \n\n        Vault vault; \n    }\n\n    function getPosition(uint256 marketId, address trader) public view returns(LeveredBond memory){\n        return leveragePosition[marketId][trader]; \n    }\n\n    /// @notice issue longzcb to this contract, create note to for trader \n    function issuePerpBondLevered(\n        uint256 _marketId, \n        uint256 _amountIn, \n        uint256 _leverage\n        ) external returns(uint256 issueQTY){\n        require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= precision, \"!leverage\");\n\n        marketManager._canIssue(msg.sender, int256(_amountIn), _marketId); \n        CoreMarketData memory market = marketManager.getMarket(_marketId); \n        ERC20 underlying = ERC20(address(market.bondPool.BaseToken())); \n\n        // stack collateral from trader and loan from vault \n        uint256 amountPulled = _amountIn.divWadDown(_leverage); \n        marketManager.transferTraderCap(address(underlying), msg.sender, address(this), amountPulled); \n        // underlying.transferFrom(msg.sender, address(this), amountPulled); \n        controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n        underlying.approve(address(marketManager), _amountIn); \n        issueQTY = marketManager.issueBond(_marketId, _amountIn, address(this), msg.sender); \n\n        leveragePosition[_marketId][msg.sender].debt += (_amountIn - amountPulled); \n        leveragePosition[_marketId][msg.sender].amount += (issueQTY); \n    }\n\n    /// @notice redeem longzcb in this contract, send redeemed amount to vault\n    /// and if debt fully repaid, send remaining to trader \n    /// param redeemAmount is in longZCB \n    function redeemLeveredPerpLongZCB(\n        uint256 marketId, \n        uint256 redeemAmount\n        ) external  returns(\n            uint256 collateral_redeem_amount, \n            uint256 postRepayLeftOver, \n            uint256 paidDebt){\n        LocalVars memory vars; \n        vars.vault = controller.getVault(marketId); \n        LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n        require(position.amount>=redeemAmount, \"Amount ERR\"); \n\n        // Redeem longZCB in this address and get back collateral_redeem_amount to this address\n        /// Get back collateral, need to send repaid capital back to the vault \n        (collateral_redeem_amount, ) = \n            marketManager.redeemPerpLongZCB(marketId, redeemAmount, address(this), msg.sender); \n        vars.vault.UNDERLYING().transfer(address(vars.vault), collateral_redeem_amount); \n\n        // Need to first pay all of debt \n        if(position.debt > collateral_redeem_amount){\n            paidDebt = collateral_redeem_amount; \n            position.debt -= collateral_redeem_amount; \n        } else{\n            paidDebt = position.debt; \n            position.debt = 0 ; \n        }\n\n        unchecked{position.amount -= redeemAmount;}\n\n        // If debt is fully paid, can send unlocked funds \n        if (position.debt==0) {//100-70 = 30 send me back 30!!\n            postRepayLeftOver = collateral_redeem_amount - paidDebt; \n            controller.redeem_transfer(postRepayLeftOver, msg.sender, marketId);\n        }\n\n        leveragePosition[marketId][msg.sender] = position; \n    }\n\n    /// @notice for managers that are a) meet certain reputation threshold and b) choose to be more\n    /// capital efficient with their zcb purchase. \n    /// @param _amountIn (in collateral) already accounts for the leverage, so the actual amount manager is transferring\n    /// is _amountIn/_leverage \n    /// @dev the marketmanager should take custody of the quantity bought with leverage\n    /// and instead return notes of the levered position \n    function buyBondLevered(\n        uint256 _marketId, \n        uint256 _amountIn, \n        uint256 _priceLimit, \n        uint256 _leverage //in 18 dec \n        ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\n        require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= precision, \"!leverage\");\n        CoreMarketData memory market = marketManager.getMarket(_marketId); \n        ERC20 underlying = ERC20(address(market.bondPool.BaseToken())); \n\n        // stack collateral from trader and borrowing from vault \n        uint256 amountPulled = _amountIn.divWadDown(_leverage); \n        marketManager.transferTraderCap(address(underlying), msg.sender, address(this), amountPulled); \n        controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n        // Buy bond to this address \n        bytes memory emptyByte; \n        underlying.approve(address(marketManager), _amountIn); \n        (amountIn, amountOut) = marketManager.buylongZCB(_marketId, int256(_amountIn),\n            _priceLimit, emptyByte, address(this), msg.sender);  \n   \n        // create note to trader \n        leveragePosition[_marketId][msg.sender].debt += (_amountIn - amountPulled); \n        leveragePosition[_marketId][msg.sender].amount += amountOut; \n    }\n\n    mapping(uint256=>mapping(address=> bool)) redeemed; \n\n    /// @notice redeem all zcb at maturity \n    function redeemLeveredBond(uint256 marketId) public{\n        require(marketManager.isMarketResolved( marketId), \"!resolved\"); \n        require(!redeemed[marketId][msg.sender], \"Redeemed\");\n        redeemed[marketId][msg.sender] = true; \n\n        if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender); \n\n        LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n        require(position.amount>0, \"0 Amount\"); \n\n        uint256 redemption_price = marketManager.redemption_prices(marketId); \n        uint256 collateral_back = redemption_price.mulWadDown(position.amount) ; \n        uint256 collateral_redeem_amount = collateral_back >= uint256(position.debt)  \n            ? collateral_back - uint256(position.debt) : 0; \n\n        if (!controller.isValidator(marketId, msg.sender)) {\n          // bool increment = redemption_price >= config.WAD? true: false;\n          // controller.updateReputation(marketId, msg.sender, increment);\n          // reputationManager.recordPush(msg.sender, marketId, redemption_price, false, zcb_redeem_amount); \n        }\n        marketManager.burnAndTransfer(marketId, address(this), position.amount, msg.sender, collateral_redeem_amount); \n\n        position.amount = 0; \n        position.debt = 0; \n        leveragePosition[marketId][msg.sender] = position;  \n    }\n\n\n    function redeemDeniedLeveredBond(uint256 marketId) public returns(uint collateral_amount){\n        LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n        require(position.amount>0, \"ERR\"); \n        leveragePosition[marketId][msg.sender].amount = 0; \n\n        // TODO this means if trader's loss will be refunded if loss was realized before denied market\n        if (controller.isValidator(marketId, msg.sender)) {\n          collateral_amount = controller.deniedValidator(marketId, msg.sender);\n        }else{\n          collateral_amount = marketManager.longTrades(marketId, msg.sender);  \n          // delete longTrades[marketId][msg.sender]; \n        }\n\n        marketManager.burnAndTransfer(marketId, address(this), position.amount, msg.sender, collateral_amount); \n    }\n\n    /// @notice returns the manager's maximum leverage \n    function getMaxLeverage(address manager) public view returns(uint256){\n        //TODO experiment \n        return 5e18 ;//min((controller.getTraderScore(manager) * 1e18).sqrt(), 5e18);\n    }\n    /// @notice called by pool when buying, transfers funds from trader to pool \n    function tradeCallBack(uint256 amount, bytes calldata data) external{\n        SyntheticZCBPool(msg.sender).BaseToken().transferFrom(abi.decode(data, (address)), msg.sender, amount); \n    }\n\n\n\n\n    mapping(uint256=> Position) public positions; \n    mapping(uint256=> address)  leveragePools; \n\n    struct Position{\n        address vaultAd; \n        uint256 totalShares; \n\n        uint256 suppliedCapital; \n        uint256 borrowedCapital; \n\n        uint256 borrowTimeStamp;\n        uint256 endStateBalance; \n    }\n\n    function getPosition(uint256 tokenId) public view returns (Position memory position){\n        return positions[tokenId]; \n    }\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint176 private _nextId = 1;\n    /// @dev The ID of the next pool that is used for the first time. Skips 0\n    uint80 private _nextPoolId = 1;\n\n    function addLeveragePool(uint256 vaultId, address pool) public \n    //onlyowner\n    {\n        leveragePools[vaultId] = pool; \n    }\n    /// @notice Allow people to borrow from leverageVault and use that to\n    /// create leveraged Vault positions \n    /// @dev steps\n    // 0. transfer to this address\n    // 1. mint vault to this address\n    // 2. borrow to this address,\n    // 3. mint new vault to this address \n    // 4. borrow new vault to this \n    function _mintWithLeverage(\n        uint256 vaultId, \n        uint256 availableLiquidity, \n        uint256 borrowAmount, \n        uint256 collateralAmount, \n        MintLocalVars memory vars) \n        internal{\n\n        // Check collateral specific borrowable \n        uint256 maxBorrowableAmount = min(borrowAmount, vars.collateralPower.mulWadDown(collateralAmount)); \n\n        // Check if liquidity available\n        vars.maxBorrowableAmount = min(maxBorrowableAmount, availableLiquidity); \n\n        // Depleted lendingpool if availableLiquidity < maxBorrowableAmount\n        vars.noMoreLiq = (vars.maxBorrowableAmount < maxBorrowableAmount); \n\n        vars.vault.approve(address(vars.leveragePool), collateralAmount); \n\n        vars.leveragePool.borrow(\n            vars.maxBorrowableAmount, address(vars.vault), \n            0, collateralAmount, address(this),\n            true\n            ); \n\n        console.log('new collateral amount', collateralAmount); \n        console.log('maxBorrowableAmount', vars.maxBorrowableAmount); \n\n        vars.shares = vars.vault.deposit(vars.maxBorrowableAmount, address(this));      \n    }\n\n    struct MintLocalVars{\n        Vault vault; \n        PoolInstrument leveragePool; \n\n        uint256 totalBorrowAmount; \n        uint256 maxBorrowAmount; \n        bool noMoreLiq; \n        uint256 shares; \n        uint256 mintedShares; \n        uint256 borrowedAmount; \n\n        uint256 availableLiquidity; \n        uint256 maxBorrowableAmount; \n        uint256 collateralPower; \n\n    }\n\n    function mintLev() public {\n        //1. borrow from child pool, \n        //2. if child pool has not enough liq, go to parent pool \n        //3. debt: 10 to child pool, 5 to parent pool or 15 to child pool\n        // or 15 to parent pool. First pay off parent pool, \n        // \n    }\n    /// @notice Implements a leverage loop \n    // TODO implement with flash minting, maybe more gas efficient \n    function mintWithLeverage(\n        uint256 vaultId, \n        uint256 suppliedCapital, \n        uint256 leverageFactor) public returns(uint256 tokenId, Position memory newPosition) {\n        MintLocalVars memory vars; \n        vars.vault = controller.vaults(vaultId); \n\n        ERC20 underlying = ERC20(address(vars.vault.UNDERLYING()));\n        underlying.transferFrom(msg.sender, address(this), suppliedCapital); \n        underlying.approve(address(vars.vault), suppliedCapital.mulWadDown(precision + leverageFactor)); \n\n        vars.leveragePool = PoolInstrument(leveragePools[vaultId]); \n        vars.availableLiquidity = vars.leveragePool.totalAssetAvailable(); \n\n        if(vars.availableLiquidity == 0) revert(\"Not Enough Liq\"); \n        (,,vars.collateralPower,,,,,) = vars.leveragePool.collateralConfigs(vars.leveragePool.computeId(address(vars.vault),0)); \n\n        // Initial minting \n        vars.shares = vars.vault.deposit(suppliedCapital, address(this));\n\n        // borrow until leverage is met, \n        vars.totalBorrowAmount = suppliedCapital.mulWadDown(leverageFactor); \n\n        while(true){\n            vars.mintedShares += vars.shares; \n            console.log('___NEW___'); \n            console.log('totalBorrowAmount', vars.borrowedAmount); \n            console.log('borrowedAmount Left', vars.totalBorrowAmount); \n            _mintWithLeverage( \n                vaultId, \n                vars.availableLiquidity, \n                vars.totalBorrowAmount, \n                vars.shares,\n                vars \n            ); \n\n            vars.borrowedAmount += vars.maxBorrowableAmount; \n\n            if(vars.totalBorrowAmount>= vars.maxBorrowableAmount)\n                (vars.totalBorrowAmount) -= vars.maxBorrowableAmount;\n\n            else vars.totalBorrowAmount = 0; \n\n            if(vars.totalBorrowAmount == 0 || vars.noMoreLiq) break; \n        }\n        vars.mintedShares += vars.shares; \n\n        _mint(msg.sender,  (tokenId = _nextId++)); \n\n        newPosition = Position(\n            address(vars.vault),\n            vars.mintedShares, \n            suppliedCapital, \n            vars.borrowedAmount, \n            block.timestamp, \n            vars.shares\n        );\n\n        positions[tokenId] = newPosition; \n\n\n\n    }\n\n    struct RewindLocalVars{\n        uint256 assetReturned; \n\n        uint256 withdrawAmount; \n        uint256 removed; \n        uint256 totalAssetReturned;\n        uint256 sharesRedeemed; \n\n    }\n\n    /// @notice Allows leverage minters to close their positions, and share profit with the leverageVault\n    /// @dev step goes 1. repay to instrument,  \n    function rewindPartialLeverage(\n        uint256 vaultId, \n        uint256 tokenId, \n        uint256 withdrawAmount) public{\n        //0. redeem \n        //1. repay to leverage pool\n        //2. get vault collateral back \n        //3. redeem\n        //4. repay to leverage pool \n        RewindLocalVars memory vars; \n\n        Position memory position = positions[tokenId]; \n        require(position.totalShares >= withdrawAmount, \"larger than position\"); \n\n        Vault vault = controller.vaults(vaultId); \n\n        ERC20 underlying = ERC20(address(vault.UNDERLYING())); \n        PoolInstrument leveragePool = PoolInstrument(leveragePools[vaultId]); \n        underlying.approve(address(leveragePool), vault.previewMint(withdrawAmount)); //TODO \n\n        vars.withdrawAmount = withdrawAmount; \n\n        // Begin with initial redeem \n\n\n        // vars.redeemedShares = position.endStateBalance; \n\n        while(vars.withdrawAmount!=0 ){\n            vars.sharesRedeemed = min(position.endStateBalance, vars.withdrawAmount); \n            vars.assetReturned = vault.redeem(\n                vars.sharesRedeemed, \n                address(this),\n                address(this)//70, 100=70, 80,30= 30\n                ); \n            leveragePool.repayWithAmount(vars.assetReturned, address(this)); //70->80\n            // get 70 collateral in, 30 collateral in, \n            vars.removed = leveragePool.removeAvailableCollateral(address(vault), 0, address(this)); \n            // get 80 collateral out , 34 collateral out\n            console.log('___NEW___'); \n            console.log('withdraw left', vars.withdrawAmount); \n            console.log('redeemed shares',min(position.endStateBalance, vars.withdrawAmount) ); \n            console.log('redeemed/repayed', vars.assetReturned); \n            console.log('removed', vars.removed); \n\n            // Revert if err\n            vars.withdrawAmount -= vars.sharesRedeemed; \n\n            vars.totalAssetReturned += vars.assetReturned; \n\n            position.endStateBalance = position.endStateBalance >= vars.withdrawAmount\n                                        ? position.endStateBalance - vars.withdrawAmount + vars.removed \n                                        : vars.removed; \n            console.log('totalAssetReturned', vars.totalAssetReturned);                             \n            console.log('endStateBalance', position.endStateBalance); \n\n        }// how does this take care of losses? how does interest accrue? \n        position.totalShares -= withdrawAmount; \n\n        if(position.borrowedCapital >= vars.totalAssetReturned)\n            position.borrowedCapital -= vars.totalAssetReturned;\n\n        else {\n            position.borrowedCapital = 0; \n            // revert if withdraw amount was too large \n            position.suppliedCapital -= vars.totalAssetReturned - position.borrowedCapital; \n        }\n\n        positions[tokenId] = position; \n\n    }\n\n    function getTokenIds(address _owner) public view returns (uint[] memory) {\n        uint[] memory _tokensOfOwner = new uint[](balanceOf(_owner));\n        uint i;\n\n        for (i=0;i<balanceOf(_owner);i++){\n            _tokensOfOwner[i] =tokenOfOwnerByIndex(_owner, i);\n        }\n        return (_tokensOfOwner);\n    }\n\n    function getPositions(address _owner) public view returns(Position[] memory){\n        uint[] memory ids = getTokenIds(_owner); \n        Position[] memory openpositions = new Position[](ids.length); \n        for(uint i=0; i<ids.length; i++){\n            openpositions[i] = positions[ids[i]]; \n        }\n        return openpositions; \n    }\n\n// 60 c repay-> 70 v remove -> 70 v redeem-> 70c repay-> 80v remove -> 80v redeem \n// 70 + \n    /// @notice when debt is 0, user can claim their endstate balance \n    function deletePosition() public {\n\n    }\n\n\n    function viewPNL () public {}\n\n\n    function rewindFull()public{}\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n    function tokenURI(uint256 id) public view override returns (string memory){}\n\n\n}\n\n// function redeemLeveredPoolLongZCB(\n//         uint256 marketId, \n//         uint256 redeemAmount\n//         ) external  returns(\n//             uint256 collateral_redeem_amount, \n//             uint256 postRepayLeftOver, \n//             uint256 paidDebt){\n//         LocalVars memory vars; \n//         LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n//         require(position.amount>redeemAmount, \"Amount ERR\"); \n\n//         Vault vault = controller.getVault(marketId); \n//         MarketManager.CoreMarketData memory market = marketManager.getMarket(marketId); \n//         require(market.isPool, \"!pool\"); \n\n//         (vars.psu, vars.pju, vars.levFactor) = vault.poolZCBValue(marketId);\n//         collateral_redeem_amount = vars.pju.mulWadDown(redeemAmount); \n//         vars.seniorAmount= redeemAmount.mulWadDown(vars.levFactor).mulWadDown(vars.psu); \n\n//         // Need to check if redeemAmount*levFactor can be withdrawn from the pool. If so, do so. \n//         vault.withdrawFromPoolInstrument(marketId, collateral_redeem_amount, address(this), vars.seniorAmount); \n\n//         // Need to first pay all of debt \n//         if(position.debt > collateral_redeem_amount){\n//             paidDebt = position.debt - collateral_redeem_amount; \n//             position.debt -= collateral_redeem_amount; \n//         } else{\n//             paidDebt = position.debt; \n//             position.debt = 0 ; \n//         }\n\n//         position.amount -= redeemAmount; \n//         market.bondPool.trustedBurn(address(this), redeemAmount, true); \n\n//         if (position.debt==0) {\n//             postRepayLeftOver = collateral_redeem_amount - paidDebt; \n//             controller.redeem_transfer(postRepayLeftOver, msg.sender, marketId);\n//         }\n        \n//         // Update reputation \n//         reputationManager.recordPush(msg.sender, marketId, vars.pju, false, redeemAmount); \n//         leveragePosition[marketId][msg.sender] = position; \n//     }\n\n    // /// @notice issue bond to this address, and give trader note\n    // function issuePoolBondLevered(\n    //     uint256 _marketId, \n    //     uint256 _amountIn, \n    //     uint256 _leverage\n    //     ) external  returns(uint256 issueQTY){\n    //     LocalVars memory vars; \n    //     require(marketManager.isMarketApproved(_marketId), \"Pre Approval\"); \n    //     marketManager._canIssue(msg.sender, int256(_amountIn), _marketId); \n    //     MarketManager.CoreMarketData memory market = marketManager.getMarket(_marketId); \n\n    //     Vault vault = controller.getVault(_marketId); \n    //     ERC20 underlying = ERC20(address(market.bondPool.BaseToken())); \n    //     address instrument = address(vault.Instruments(_marketId)); \n\n    //     // stack collateral from trader and borrowing from vault \n    //     uint256 amountPulled = _amountIn.divWadDown(_leverage); \n    //     underlying.transferFrom(msg.sender, address(this), amountPulled); \n    //     controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n    //     // Get price and sell longZCB with this price\n    //     (vars.psu, vars.pju, vars.levFactor) = vault.poolZCBValue(_marketId);\n\n    //     underlying.approve(instrument, _amountIn); \n    //     ERC4626(instrument).deposit(_amountIn, address(vault)); \n\n    //     issueQTY = _amountIn.divWadUp(vars.pju); //TODO rounding errs\n    //     market.bondPool.trustedDiscountedMint(address(this), issueQTY); \n\n    //     // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu  \n    //     vault.depositIntoInstrument(_marketId, issueQTY.mulWadDown(1e18 + vars.levFactor).mulWadDown(vars.psu), true);\n\n    //     //TODO Need totalAssets and exchange rate to remain same assertion \n    //     //TODO vault always has to have more shares, all shares minted goes to vault \n    //     vars.budget = marketManager.getTraderBudget( _marketId, msg.sender); \n    //     reputationManager.recordPull(msg.sender, _marketId, issueQTY, _amountIn, vars.budget, true); \n    //     leveragePosition[_marketId][msg.sender] = LeveredBond(_amountIn - amountPulled , issueQTY) ;\n    // }\n\n\n"
    },
    "contracts/protocol/marketmanager.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport \"./reputationtoken.sol\"; \nimport {Controller} from \"./controller.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {VRFConsumerBaseV2} from \"../chainlink/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"../chainlink/VRFCoordinatorV2Interface.sol\";\nimport {config} from \"../utils/helpers.sol\";\nimport {SyntheticZCBPool} from \"../bonds/synthetic.sol\"; \nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\";\nimport {Vault} from \"../vaults/vault.sol\"; \nimport {ReputationManager} from \"./reputationmanager.sol\"; \nimport {StorageHandler} from \"../global/GlobalStorage.sol\"; \nimport {PerpTranchePricer} from \"../libraries/pricerLib.sol\"; \n\nimport \"../global/types.sol\"; \n\ncontract MarketManager {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n  using PerpTranchePricer for PricingInfo; \n\n  // Chainlink state variables\n  // VRFCoordinatorV2Interface COORDINATOR;\n  // uint64 private immutable subscriptionId;\n  // bytes32 private keyHash;\n  // uint32 private callbackGasLimit = 100000;\n  // uint16 private requestConfirmations = 3;\n  // uint256 total_validator_bought; // should be a mapping no?\n  bool private _mutex;\n\n  // ReputationNFT repToken;\n  Controller controller;\n  ReputationManager reputationManager; \n  CoreMarketData[] public markets;\n  address public owner; \n\n  // mapping(uint256 => uint256) requestToMarketId; // chainlink request id to marketId\n  // mapping(uint256 => ValidatorData) validator_data;\n  mapping(uint256=>uint256) public redemption_prices; //redemption price for each market, set when market resolves \n  // mapping(uint256=>mapping(address=>uint256)) private assessment_prices; \n  // mapping(uint256=>mapping(address=>bool)) private assessment_trader;\n  // mapping(uint256=>mapping(address=>uint256) ) public assessment_probs; \n  mapping(uint256=> MarketPhaseData) public restriction_data; // market ID => restriction data\n  mapping(uint256=> MarketParameters) public parameters; //marketId-> params\n  mapping(uint256=> mapping(address=>bool)) private redeemed; \n  mapping(uint256=> mapping(address=>uint256)) public longTrades; \n  mapping(uint256=> mapping(address=>uint256)) public shortTrades;\n  mapping(uint256=> uint256) public loggedCollaterals;\n\n\n  modifier onlyController(){\n    require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \"!controller\"); \n    _;\n  }\n\n\n  modifier _lock_() {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n\n  constructor(\n    address _creator_address,\n    address _controllerAddress,\n    address _vrfCoordinator, // 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\n    bytes32 _keyHash, // 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\n    uint64 _subscriptionId // 1713, \n  ) \n    //VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) \n  {\n    controller = Controller(_controllerAddress);\n    // keyHash = bytes32(0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f);\n    // subscriptionId = 1713;\n    // COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);\n    \n    // push empty market\n    markets.push(\n      makeEmptyMarketData()\n    );\n\n    owner = msg.sender; \n  }\n\n  StorageHandler public Data; \n  function setDataStore(address dataStore) public onlyController{\n    Data = StorageHandler(dataStore); \n  }\n//TODO setcontroller\n  function makeEmptyMarketData() public pure returns (CoreMarketData memory) {\n    return CoreMarketData(\n        SyntheticZCBPool(address(0)),\n        ERC20(address(0)),\n        ERC20(address(0)),\n        \"\",\n        0,\n        0, \n        false\n      );\n  }    \n\n  function marketCount() public view returns (uint256) {\n    return markets.length;\n  }\n\n  function getMarket(uint256 _id) public view returns (CoreMarketData memory) {\n    if (_id >= markets.length) {\n        return makeEmptyMarketData();\n    } else {\n        return markets[_id];\n    }\n  }\n\n  /// @notice parameters have to be set prior \n  // event MarketCreated(uint256 indexed marketId, address bondPool, address longZCB, address shortZCB, string description, bool isPool);\n\n  function newMarket(\n    uint256 marketId,\n    SyntheticZCBPool bondPool,  \n    address _longZCB, \n    address _shortZCB, \n    string calldata _description, \n    // uint256 _duration, \n    bool isPool\n    ) external onlyController {\n    uint256 creationTimestamp = block.timestamp;\n    \n    //emit MarketCreated(marketId, address(bondPool), _longZCB, _shortZCB, _description, isPool);\n\n    markets.push(CoreMarketData(\n      bondPool, \n      ERC20(_longZCB),\n      ERC20(_shortZCB),  \n      _description,\n      creationTimestamp,\n      0, //TODO resolution timestamp, \n      isPool \n    ));\n\n    uint256 base_budget = 1000 * config.WAD; //TODO \n    setMarketPhase(marketId, true, true, base_budget);\n\n   // _validatorSetup(marketId, principal, creationTimestamp, _duration, isPool);\n  }\n\n\n  /*----Phase Functions----*/\n\n  event MarketParametersSet(uint256 indexed marketId, MarketParameters params);\n  /// @notice list of parameters in this system for each market, should vary for each instrument \n  /// @dev calculates market driven s from utilization rate. If u-r high,  then s should be low, as 1) it disincentivizes \n  /// managers to approving as more proportion of the profit goes to the LP, and 2) disincentivizes the borrower \n  /// to borrow as it lowers approved principal and increases interest rate \n  function setParameters(\n    MarketParameters memory param,\n    uint256 utilizationRate,\n    uint256 marketId \n    ) public onlyController{\n\n    require(param.N <= reputationManager.getTraders().length, \"not enough rated traders\");\n    parameters[marketId] = param; \n    parameters[marketId].s = param.s.mulWadDown(config.WAD - utilizationRate); // experiment\n    emit MarketParametersSet(marketId, param);\n  }\n\n  function setReputationManager(address _reputationManager) external onlyController{\n      reputationManager = ReputationManager(_reputationManager);\n  }\n  address leverageManager_ad; \n  function setLeverageManager(address _leverageManager) external onlyController{\n    leverageManager_ad = _leverageManager; \n  }\n\n  /**\n   @dev in the event that the number of traders in X percentile is less than the specified number of validators\n   parameter N is changed to reflect this\n   */\n  // function setN(uint256 marketId, uint256 _N) external onlyController {\n  //   parameters[marketId].N = _N;\n  // }\n\n  event MarketPhaseSet(uint256 indexed marketId, MarketPhaseData data);\n\n  /// @notice sets market phase data\n  /// @dev called on market initialization by controller\n  /// @param base_budget: base budget (amount of vault tokens to spend) as a market manager during the assessment stage\n  function setMarketPhase(\n    uint256 marketId, \n    bool duringAssessment,\n    bool _onlyReputable,\n    uint256 base_budget\n    ) internal {\n    MarketPhaseData storage data = restriction_data[marketId]; \n    data.onlyReputable = _onlyReputable; \n    data.duringAssessment = duringAssessment;\n    // data.min_rep_score = calcMinRepScore(marketId);\n    data.base_budget = base_budget;\n    data.alive = true;\n    emit MarketPhaseSet(marketId, restriction_data[marketId]);\n  }\n\n  // event MarketReputationSet(uint256 indexed marketId, bool onlyReputable);\n\n  /// @notice used to transition from reputationphases \n  // function setReputationPhase(\n  //   uint256 marketId,\n  //   bool _onlyReputable\n  // ) public onlyController {\n  //   restriction_data[marketId].onlyReputable = _onlyReputable;\n  //   emit MarketReputationSet(marketId, _onlyReputable);\n  // }\n\n\nevent DeactivatedMarket(uint256 indexed marketId, bool atLoss, bool resolve, uint256 rp);\n  /// @notice Called when market resolves \n  /// @param resolve is true when instrument does not resolve prematurely\n  function deactivateMarket(\n    uint256 marketId, \n    bool atLoss, \n    bool resolve, \n    uint256 rp) public onlyController{\n    restriction_data[marketId].resolved = resolve; \n    restriction_data[marketId].atLoss = atLoss; \n    restriction_data[marketId].alive = false;\n    redemption_prices[marketId] = rp; \n    emit DeactivatedMarket(marketId, atLoss, resolve, rp);\n  } \n\nevent MarketDenied(uint256 indexed marketId); \n\n  /// @notice called by validator only\n  function denyMarket(\n    uint256 marketId\n  ) external onlyController {\n    //TODO should validators be able to deny even though they've approved.\n    require(restriction_data[marketId].duringAssessment, \"!assessment\");\n    MarketPhaseData storage data = restriction_data[marketId]; \n    data.alive = false;\n    data.resolved = true;\n    emit MarketDenied(marketId);\n  }\n\n  event MarketApproved(uint256 indexed marketId);\n  /// @notice main approval function called by controller\n  /// @dev if market is alive and market is not during assessment, it is approved. \n  function approveMarket(uint256 marketId) onlyController external {\n    restriction_data[marketId].duringAssessment = false;    \n    emit MarketApproved(marketId);\n  }\n\n  function getPhaseData(\n    uint256 marketId\n  ) public view returns (MarketPhaseData memory)  {\n    return restriction_data[marketId];\n  }\n\n  \n  function isMarketResolved(uint256 marketId) public view returns(bool){\n      return( !restriction_data[marketId].alive && restriction_data[marketId].resolved); \n  }\n  function isMarketApproved(uint256 marketId) public view returns(bool){\n    return(!restriction_data[marketId].duringAssessment && restriction_data[marketId].alive);  \n  }\n\n\n\n  /// @notice returns whether current market is in phase \n  /// 1: onlyReputable, which also means market is in assessment\n  /// 2: not onlyReputable but in asseessment \n  /// 3: in assessment but canbeapproved \n  /// 4: post assessment(accepted or denied), amortized liquidity \n  function getCurrentMarketPhase(uint256 marketId) public view returns(uint256){\n    if (restriction_data[marketId].onlyReputable){\n      // assert(!controller.marketCondition(marketId) && !isMarketApproved(marketId) && restriction_data[marketId].duringAssessment ); \n      return 1; \n    }\n\n    else if (restriction_data[marketId].duringAssessment && !restriction_data[marketId].onlyReputable){\n      // assert(!isMarketApproved(marketId)); \n      if (controller.marketCondition(marketId)) return 3; \n      return 2; \n    }\n\n    else if (isMarketApproved( marketId)){\n      // assert (!restriction_data[marketId].duringAssessment && controller.marketCondition(marketId)); \n      return 4; \n    }\n  }\n\n  /// @notice get trade budget = f(reputation), returns in collateral_dec\n  /// sqrt for now\n  function getTraderBudget(uint256 marketId, address trader) public view returns(uint256){\n    uint256 repscore = reputationManager.trader_scores(trader);\n    if (repscore==0) return 0;\n    return restriction_data[marketId].base_budget + (repscore*config.WAD).sqrt();\n  }\n\n  function getParameters(uint256 marketId) public view returns(MarketParameters memory){\n    return parameters[marketId]; \n  }\n\n  function getPool(uint256 marketId) public view returns(SyntheticZCBPool){\n    return markets[marketId].bondPool; \n  }\n\n  function getZCB(uint256 marketId) public view returns (ERC20) {\n    return markets[marketId].longZCB;\n  }\n\n  function getShortZCB(uint256 marketId) public view returns (ERC20) {\n    return markets[marketId].shortZCB;\n  }\n  \n\n  /// @notice whether new longZCB can be issued \n  function _canIssue(\n    address trader,\n    int256 amount,\n    uint256 marketId\n    ) public view {\n    //TODO per market queue \n    //if(queuedRepUpdates[trader] > queuedRepThreshold)\n    //  revert(\"rep queue\"); \n\n    // if (!controller.isVerified(trader)) \n    //   revert(\"!verified\");\n\n    if (getTraderBudget(marketId, trader) <= uint256(amount))\n      revert(\"budget\");\n\n    if (controller.getTraderScore(trader) == 0)\n      revert(\"!rep\"); \n  }\n\n  /// @notice performs checks for buy function\n  /// @param amount: collateral used to buy ZCB.\n  function _canBuy(\n    address trader,\n    int256 amount,\n    uint256 marketId\n  ) public view {\n    //If after assessment there is a set buy threshold, people can't buy above this threshold\n    require(restriction_data[marketId].alive, \"!Active\");\n    // TODO: upper bound \n    // TODO: check if this is correct\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \"market maturity reached\");\n    // TODO: check if enough liquidity \n    bool _duringMarketAssessment = restriction_data[marketId].duringAssessment;\n    bool _onlyReputable =  restriction_data[marketId].onlyReputable;\n\n    if(amount>0){\n      if (_duringMarketAssessment){\n        _canIssue(trader, amount, marketId); \n      }\n    }\n\n    //During the early risk assessment phase only reputable can buy \n    if (_onlyReputable){\n      if (!controller.isReputable(trader, parameters[marketId].r)){\n        revert(\"insufficient rep\");\n      }\n    }\n  }\n\n  /// @notice amount is in zcb_amount_in TODO \n  function _canSell(\n    address trader,\n    uint256 amount, \n    uint256 marketId\n  ) public view returns(bool) {\n    require(restriction_data[marketId].alive, \"!Active\");\n    // TODO need to check amount is capped, and trader has enough vault locked \n    //TODO: check if this is correct\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \"market maturity reached\");\n\n    // if(restriction_data[marketId].duringAssessment) {\n    //   // restrict attacking via disapproving the utilizer by just shorting a bunch\n    //  // if(amount>= hedgeAmount) return false; \n\n    //   //else return true;\n    // }\n    // else{\n    //   // restrict naked CDS amount\n      \n    //   // \n    // } \n\n    return true; \n  }\n\n  // VALIDATOR FUNCTIONS\n\n  /**\n   @notice called when the validator votes to approve the market => stakes vt + recieves discounted ZCB\n   the staked amount goes to the controller while the discounted ZCB goes to the market manager.\n   */\n  function validatorApprove(\n    uint256 marketId, \n    uint256 collateral_required,\n    uint256 zcb_for_sale,\n    address validator\n  ) external onlyController {\n    loggedCollaterals[marketId] += collateral_required;\n    SyntheticZCBPool bondPool = getPool(marketId); \n    bondPool.BaseToken().transferFrom(validator, address(bondPool), collateral_required); \n    bondPool.trustedDiscountedMint(validator, zcb_for_sale);\n  }\n\n\n  event MarketCollateralUpdate(uint256 marketId, uint256 totalCollateral);\n  event TraderCollateralUpdate(uint256 marketId, address manager, uint256 totalCollateral, bool isLong);\n\n  /// @notice log how much collateral trader has at stake, \n  /// to be used for redeeming, restricting trades\n  function _logTrades(\n    uint256 marketId,\n    address trader, \n    uint256 collateral,\n    uint256 shortCollateral,  \n    bool isBuy, \n    bool isLong\n    ) internal {\n\n    if (isLong){\n      // TODO queuerep needs to be per market \n      // If buying bond during assessment, trader is manager, so should update \n      if (isBuy) {\n        longTrades[marketId][trader] += collateral; \n        loggedCollaterals[marketId] += collateral; \n        queuedRepUpdates[trader] += 1; \n        } else {\n        longTrades[marketId][trader] -= collateral;\n        loggedCollaterals[marketId] -= collateral; \n        }\n      } else {\n      if (isBuy) {\n        // shortCollateral is amount trader pays to buy shortZCB\n        shortTrades[marketId][trader] += shortCollateral;\n        // collateral is the area under the curve that is subtracted due to the (short)selling\n        loggedCollaterals[marketId] -= collateral; \n        } else {\n        // revert if underflow, which means trader sold short at a profit, which is not allowed during assessment \n        shortTrades[marketId][trader] -= shortCollateral; \n        loggedCollaterals[marketId] += collateral;\n      } \n    }\n\n    emit TraderCollateralUpdate(marketId, trader, shortTrades[marketId][trader], isLong);\n    emit MarketCollateralUpdate(marketId, loggedCollaterals[marketId]);\n  }\n\n  /// @notice general limitorder claim + liquidity provision funnels used post-assessment, \n  /// which will be recorded if necessary \n  /// param type: 1 if open long, 2 if close long, 3 if open short, 4 if close short\n  /// type 5: partially claim , TODO do all possible trading functions \n  function claimFunnel(\n    uint256 marketId, \n    uint16 point, \n    uint256 funnel\n    ) external returns(uint256 claimedAmount){\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \n\n    // if (funnel == 1) claimedAmount = bondPool.makerClaimOpen(point,true, msg.sender); \n    // else if (funnel == 2) claimedAmount = bondPool.makerClaimClose(point,true, msg.sender);\n    // else if (funnel == 3) claimedAmount = bondPool.makerClaimOpen(point,false, msg.sender); \n    // else if (funnel == 4) claimedAmount = bondPool.makerClaimClose(point,false, msg.sender); \n  }\n\n  /// @notice called by pool when buying, transfers funds from trader to pool \n  function tradeCallBack(uint256 amount, bytes calldata data) external{\n    SyntheticZCBPool(msg.sender).BaseToken().transferFrom(abi.decode(data, (address)), msg.sender, amount); \n  }\n\n  function issueBond(\n    uint256 _marketId, \n    uint256 _amountIn, \n    address _caller,\n    address trader\n    ) external returns(uint256 issueQTY){\n    LocarVars memory vars; \n    require(msg.sender == address(this) || msg.sender == leverageManager_ad, \"invalid entry\"); \n\n    vars.vault = controller.getVault(_marketId); \n    vars.underlying = ERC20(address(markets[_marketId].bondPool.BaseToken())); \n    vars.instrument = address(vars.vault.Instruments(_marketId)); \n\n    // Get price a_lock_nd sell longZCB with this price\n    // (vars.psu, vars.pju, vars.levFactor) = Data.viewCurrentPricing(_marketId); \n    (vars.psu, vars.pju, vars.levFactor ) = vars.vault.poolZCBValue(_marketId);\n\n    vars.underlying.transferFrom(_caller, address(this), _amountIn);\n    vars.underlying.approve(vars.instrument, _amountIn); \n    ERC4626(vars.instrument).deposit(_amountIn, address(vars.vault)); \n\n    issueQTY = _amountIn.divWadUp(vars.pju); //TODO rounding errs\n    markets[_marketId].bondPool.trustedDiscountedMint(_caller, issueQTY); \n\n    // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu  \n    vars.vault.depositIntoInstrument(_marketId, issueQTY.mulWadDown(config.WAD + vars.levFactor).mulWadDown(vars.psu), true); \n\n    reputationManager.recordPull(trader, _marketId, issueQTY, _amountIn, getTraderBudget( _marketId, trader), true); \n  }\n\n  /// @notice after assessment, let managers buy newly issued longZCB if the instrument is pool based \n  /// funds + funds * levFactor will be directed to the instrument \n  function issuePoolBond(\n    uint256 _marketId, \n    uint256 _amountIn\n    ) external _lock_ returns(uint256 issueQTY){\n    require(!restriction_data[_marketId].duringAssessment, \"Pre Approval\"); \n\n    _canIssue(msg.sender, int256(_amountIn), _marketId);  \n\n    issueQTY = this.issueBond(_marketId, _amountIn, msg.sender, msg.sender); \n    //TODO Need totalAssets and exchange rate to remain same assertion \n    //TODO vault always has to have more shares, all shares minted goes to vault \n    /** \n    total apr from deposit = (totalAssets of the pool - psu * senior supply)/junior supply\n    */\n    // reputationManager.recordPull(msg.sender, _marketId, issueQTY, _amountIn, getTraderBudget( _marketId, msg.sender), true); \n  }\n\n  function redeemPerpLongZCB(\n    uint256 marketId,\n    uint256 redeemAmount, \n    address caller, \n    address trader \n    ) external returns(uint256 collateral_redeem_amount, uint256 seniorAmount){\n    require(msg.sender == address(this) || msg.sender == leverageManager_ad, \"invalid entry\"); \n    Vault vault = controller.getVault(marketId); \n    CoreMarketData memory market = markets[marketId]; \n\n    require(market.isPool, \"!pool\"); \n\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(marketId);\n    collateral_redeem_amount = pju.mulWadDown(redeemAmount); \n    seniorAmount = redeemAmount.mulWadDown(levFactor).mulWadDown(psu); \n\n    // Need to check if redeemAmount*levFactor can be withdrawn from the pool and do so\n    vault.withdrawFromPoolInstrument(marketId, collateral_redeem_amount, caller, seniorAmount); \n\n    // This means that the sender is a manager\n    if (queuedRepUpdates[trader] > 0){\n     unchecked{queuedRepUpdates[trader] -= 1;} \n    }\n    market.bondPool.trustedBurn(caller, redeemAmount, true); \n\n    reputationManager.recordPush(trader, marketId, pju, false, redeemAmount);\n\n    // TODO assert pju stays same \n    // TODO assert need totalAssets and exchange rate to remain same \n    }\n\n   function redeemPoolLongZCB(\n    uint256 marketId, \n    uint256 redeemAmount\n    ) external _lock_ returns(uint256 collateral_redeem_amount, uint256 seniorAmount){\n\n    (collateral_redeem_amount, seniorAmount) = \n      this.redeemPerpLongZCB(marketId, redeemAmount, msg.sender, msg.sender); \n   }\n \n\n  mapping(address => uint8) public queuedRepUpdates; \n  uint8 public constant queuedRepThreshold = 3; // at most 3 simultaneous assessment per manager\n\n  event BondBuy(uint256 indexed marketId, address indexed trader, uint256 amountIn, uint256 amountOut);\n\n  struct LocarVars{\n    uint256 upperBound; \n    uint256 budget; \n    uint256 repThreshold; \n\n    uint256 pju; \n    uint256 psu; \n    uint256 levFactor; \n    Vault vault; \n    ERC20 underlying; \n    address instrument; \n    MarketPhaseData phaseData; \n  }\n  /// @notice main entry point for longZCB buys (during assessment for now)\n  /// @param _amountIn is negative if specified in zcb quantity\n  function buyBond(\n    uint256 _marketId, \n    int256 _amountIn, \n    uint256 _priceLimit, \n    bytes calldata _tradeRequestData \n    ) external  returns(uint256 amountIn, uint256 amountOut){\n\n    (amountIn, amountOut) = this.buylongZCB(_marketId, _amountIn, _priceLimit, _tradeRequestData, msg.sender, msg.sender); \n\n    emit BondBuy(_marketId, msg.sender, amountIn, amountOut); // get current price as well.\n  }\n\n  function buylongZCB(\n    uint256 _marketId, \n    int256 _amountIn, \n    uint256 _priceLimit, \n    bytes calldata _tradeRequestData, \n    address caller, \n    address trader \n    ) external _lock_  returns(uint256 amountIn, uint256 amountOut){\n    require(msg.sender == address(this) || msg.sender == leverageManager_ad, \"invalid entry\"); \n\n    LocarVars memory vars; \n    vars.phaseData = restriction_data[_marketId]; \n\n    require(!vars.phaseData.resolved, \"not resolved\");\n    require(vars.phaseData.duringAssessment, \"only assessment\"); \n\n    _canBuy(trader, _amountIn, _marketId);\n\n    //TODO return readable error on why it reverts\n    CoreMarketData memory marketData = markets[_marketId]; \n    SyntheticZCBPool bondPool = marketData.bondPool; \n    \n    // TODO fix pricelimit  \n    (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(caller)); \n\n    // Revert if cross bound\n    vars.upperBound =  bondPool.upperBound(); \n    if(vars.upperBound !=0 &&  vars.upperBound < bondPool.getCurPrice()) revert(\"exceed bound\"); \n\n    //Need to log assessment trades for updating reputation scores or returning collateral when market denied \n    _logTrades(_marketId, trader, amountIn, 0, true, true);\n\n    // Get implied probability estimates by summing up all this manager bought for this market \n    vars.budget = getTraderBudget(_marketId, trader); \n    reputationManager.recordPull(trader, _marketId, amountOut, amountIn, vars.budget, marketData.isPool); \n\n    // Phase Transitions when conditions met\n    if(vars.phaseData.onlyReputable){\n      vars.repThreshold = parameters[_marketId].omega.mulWadDown(\n          controller.getVault(_marketId).fetchInstrumentData(_marketId).principal); \n\n      if (loggedCollaterals[_marketId] >= vars.repThreshold) {\n        restriction_data[_marketId].onlyReputable = false;\n        emit MarketPhaseSet(_marketId, restriction_data[_marketId]);\n      }\n    }\n  }\n\n  /// @param _amountIn: amount of short trader is willing to buy\n  /// @param _priceLimit: slippage tolerance on trade\n  function shortBond(\n    uint256 _marketId,\n    uint256 _amountIn, \n    uint256 _priceLimit,\n    bytes calldata _tradeRequestData \n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\n    require(!markets[_marketId].isPool, \"only fixed instrument\"); \n    require(restriction_data[_marketId].duringAssessment, \"only assessment\"); \n    // require(_canSell(msg.sender, _amountIn, _marketId),\"Restricted\");\n\n      // amountOut is base collateral down the curve, amountIn is collateral used to buy shortZCB \n    (amountOut, amountIn) = markets[_marketId].bondPool.takerOpen(false, int256(_amountIn),\n       _priceLimit, abi.encode(msg.sender));\n    _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false);\n  }\n\n\n  event RedeemDenied(uint256 marketId, address trader, bool isLong);\n\n  /// @notice called by traders when market is denied before approval TODO\n  /// ??? if the market is denied, this function is called and everything is redeemed \n  /// validator will need to call this on denial + isLong = true to redeem their collateral.\n  function redeemDeniedMarket(\n    uint256 marketId, \n    bool isLong\n  ) external _lock_ {\n    require(!restriction_data[marketId].alive, \"Market Still During Assessment\"); // TODO\n    require(restriction_data[marketId].duringAssessment, \"Market has been approved\");\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \n\n    uint256 collateral_amount;\n    uint256 balance; \n    // Get collateral at stake in shorts, which will be directly given back to traders\n    if(!isLong){\n      balance = markets[marketId].shortZCB.balanceOf(msg.sender); \n      require(balance >= 0, \"Empty\");\n\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\n      collateral_amount = shortTrades[marketId][msg.sender]; \n      delete shortTrades[marketId][msg.sender]; \n      emit RedeemDenied(marketId, msg.sender, false);\n\n      //Burn all their balance\n      bondPool.trustedBurn(msg.sender, balance, false);\n    } \n\n    // Get collateral at stake in longs, which will be directly given back to traders\n    else {\n      balance = markets[marketId].longZCB.balanceOf(msg.sender); \n      require(balance >= 0, \"Empty\");\n\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\n      if (controller.isValidator(marketId, msg.sender) && controller.hasApproved(marketId, msg.sender)) {\n        collateral_amount = controller.deniedValidator(marketId, msg.sender);\n      }\n      else{\n        collateral_amount = longTrades[marketId][msg.sender]; \n        delete longTrades[marketId][msg.sender]; \n        emit RedeemDenied(marketId, msg.sender, true);\n      }\n\n      // Burn all their balance \n      bondPool.trustedBurn(msg.sender, balance, true); \n      \n      // This means that the sender is a manager\n      if (queuedRepUpdates[msg.sender] > 0){\n        unchecked{queuedRepUpdates[msg.sender] -= 1;} \n      }    \n    }\n\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\n    controller.redeem_transfer(collateral_amount, msg.sender, marketId);\n    //TODO need to check if last redeemer, so can kill market.\n  }\n\n\n  /// @notice trader will redeem entire balance of ZCB\n  /// Needs to be called at maturity, market needs to be resolved first(from controller)\n  function redeem(\n    uint256 marketId\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\n    require(!restriction_data[marketId].alive, \"!Active\"); \n    require(restriction_data[marketId].resolved, \"!resolved\"); \n    require(!redeemed[marketId][msg.sender], \"Redeemed\");\n    redeemed[marketId][msg.sender] = true; \n\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \n\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender);\n\n    uint256 zcb_redeem_amount = markets[marketId].longZCB.balanceOf(msg.sender); \n    uint256 redemption_price = redemption_prices[marketId]; \n    collateral_redeem_amount = redemption_price.mulWadDown(zcb_redeem_amount); \n\n    if (!controller.isValidator(marketId, msg.sender)) { // TODO should validators get reputation if they do ok.\n      reputationManager.recordPush(msg.sender, marketId, redemption_price, false, zcb_redeem_amount); \n    }\n\n    // This means that the sender is a manager\n    if (queuedRepUpdates[msg.sender] > 0){\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \n   }\n\n    bondPool.trustedBurn(msg.sender, zcb_redeem_amount, true); \n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId);\n  }\n\n  /// @notice called by short buyers when market is resolved for fixed term instruments \n  function redeemShortZCB(\n    uint256 marketId \n    ) external _lock_ returns(uint256 collateral_redeem_amount){\n    require(!restriction_data[marketId].alive, \"Active\"); \n    require(restriction_data[marketId].resolved, \"!resolved\"); \n    require(!redeemed[marketId][msg.sender], \"Redeemed\");\n    require(!markets[marketId].isPool, \"pool\");\n\n    redeemed[marketId][msg.sender] = true; \n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \n\n    uint256 shortZCB_redeem_amount = markets[marketId].shortZCB.balanceOf(msg.sender); \n    uint256 long_redemption_price = redemption_prices[marketId];\n    uint256 redemption_price = long_redemption_price >= config.WAD \n                               ? 0 \n                               : config.WAD - long_redemption_price; \n    collateral_redeem_amount = redemption_price.mulWadDown(shortZCB_redeem_amount);\n\n    bondPool.trustedBurn(msg.sender, shortZCB_redeem_amount, false); \n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \n  }\n\n  function burnAndTransfer(\n    uint256 marketId, \n    address burnWho, \n    uint256 burnAmount, \n    address sendWho, \n    uint256 sendAmount) external{\n    require(msg.sender == leverageManager_ad, \"unauthorized\");\n\n    markets[marketId].bondPool.trustedBurn(burnWho, burnAmount, true); \n    controller.redeem_transfer(sendAmount, sendWho, marketId); \n\n  }\n\n  /// @notice marketmanager is the only approved contract\n  function transferTraderCap(\n    address token, \n    address trader, \n    address to, \n    uint256 amount) external {\n    require(msg.sender == leverageManager_ad, \"unauthorized\");\n    ERC20(token).transferFrom(trader, to, amount); \n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n\n\n\n\n  // /// @notice returns the manager's maximum leverage \n  // function getMaxLeverage(address manager) public view returns(uint256){\n  //   //return (repToken.getReputationScore(manager) * config.WAD).sqrt(); //TODO experiment \n  //   return (controller.getTraderScore(manager) * config.WAD).sqrt();\n  // }\n\n  // mapping(uint256=>mapping(address=> LeveredBond)) public leveragePosition; \n  // struct LeveredBond{\n  //   uint128 debt; //how much collateral borrowed from vault \n  //   uint128 amount; // how much bonds were bought with the given leverage\n  // }\n\n  // /// @notice for managers that are a) meet certain reputation threshold and b) choose to be more\n  // /// capital efficient with their zcb purchase. \n  // /// @param _amountIn (in collateral) already accounts for the leverage, so the actual amount manager is transferring\n  // /// is _amountIn/_leverage \n  // /// @dev the marketmanager should take custody of the quantity bought with leverage\n  // /// and instead return notes of the levered position \n  // /// TODO do + instead of creating new positions and implied prob cumulative \n  // function buyBondLevered(\n  //   uint256 _marketId, \n  //   uint256 _amountIn, \n  //   uint256 _priceLimit, \n  //   uint256 _leverage //in 18 dec \n  //   ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\n  //   require(restriction_data[_marketId].duringAssessment, \"PhaseERR\"); \n  //   require(!restriction_data[_marketId].resolved, \"!resolved\");\n  //   require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= config.WAD, \"!leverage\");\n  //   _canBuy(msg.sender, int256(_amountIn), _marketId);\n  //   SyntheticZCBPool bondPool = markets[_marketId].bondPool; \n\n  //   // stack collateral from trader and borrowing from vault \n  //   uint256 amountPulled = _amountIn.divWadDown(_leverage); \n  //   bondPool.BaseToken().transferFrom(msg.sender, address(this), amountPulled); \n  //   controller.pullLeverage(_marketId, _amountIn - amountPulled); \n\n  //   // Buy with leverage, zcb transferred here\n  //   bondPool.BaseToken().approve(address(this), _amountIn); \n  //   (amountIn, amountOut) = bondPool.takerOpen(true, int256(_amountIn), _priceLimit, abi.encode(address(this))); \n\n  //   //Need to log assessment trades for updating reputation scores or returning collateral when market denied \n  //   _logTrades(_marketId, msg.sender, _amountIn, 0, true, true);\n\n  //   // Phase Transitions when conditions met\n  //   if(restriction_data[_marketId].onlyReputable){\n  //     uint256 total_bought = loggedCollaterals[_marketId];\n\n  //     if (total_bought >= parameters[_marketId].omega.mulWadDown(\n  //           controller\n  //           .getVault(_marketId)\n  //           .fetchInstrumentData(_marketId)\n  //           .principal)\n  //     ) {\n  //       restriction_data[_marketId].onlyReputable = false;\n  //       emit MarketPhaseSet(_marketId, restriction_data[_marketId]);\n  //     }\n  //   }\n  //   // create note to trader \n  //   leveragePosition[_marketId][msg.sender] = LeveredBond(uint128(_amountIn - amountPulled ),uint128(amountOut)) ; \n  // }\n\n  // function redeemLeveredBond(uint256 marketId) public{\n  //   require(!restriction_data[marketId].alive, \"!Active\"); \n  //   require(restriction_data[marketId].resolved, \"!resolved\"); \n  //   require(!redeemed[marketId][msg.sender], \"Redeemed\");\n  //   redeemed[marketId][msg.sender] = true; \n\n  //   if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender); \n\n  //   LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n  //   require(position.amount>0, \"ERR\"); \n\n  //   uint256 redemption_price = redemption_prices[marketId]; \n  //   uint256 collateral_back = redemption_price.mulWadDown(position.amount) ; \n  //   uint256 collateral_redeem_amount = collateral_back >= uint256(position.debt)  \n  //       ? collateral_back - uint256(position.debt) : 0; \n\n  //   if (!controller.isValidator(marketId, msg.sender)) {\n  //     // bool increment = redemption_price >= config.WAD? true: false;\n  //     // controller.updateReputation(marketId, msg.sender, increment);\n  //     // reputationManager.recordPush(msg.sender, marketId, redemption_price, false, zcb_redeem_amount); \n\n  //   }\n\n  //   // This means that the sender is a manager\n  //   if (queuedRepUpdates[msg.sender] > 0){\n  //    unchecked{queuedRepUpdates[msg.sender] -= 1;} \n  //   }\n\n  //   leveragePosition[marketId][msg.sender].amount = 0; \n  //   markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \n  //   controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId);\n  // }\n\n  // function redeemDeniedLeveredBond(uint256 marketId) public returns(uint collateral_amount){\n  //   LeveredBond memory position = leveragePosition[marketId][msg.sender]; \n  //   require(position.amount>0, \"ERR\"); \n  //   leveragePosition[marketId][msg.sender].amount = 0; \n\n  //   // TODO this means if trader's loss will be refunded if loss was realized before denied market\n  //   if (controller.isValidator(marketId, msg.sender)) {\n  //     collateral_amount = controller.deniedValidator(marketId, msg.sender);\n  //   }\n  //   else{\n  //     collateral_amount = longTrades[marketId][msg.sender]; \n  //     delete longTrades[marketId][msg.sender]; \n  //   }\n\n  //   // Burn all their position, \n  //   markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \n\n  //   // This means that the sender is a manager\n  //   if (queuedRepUpdates[msg.sender] > 0){\n  //     unchecked{queuedRepUpdates[msg.sender] -= 1;} \n  //   }    \n\n  //   // Before redeem_transfer is called all funds for this instrument should be back in the vault\n  //   controller.redeem_transfer(collateral_amount - uint256(position.debt), msg.sender, marketId);\n  // }\n //  /// @notice longZCB sells  \n //  /// @param _amountIn quantity in longZCB \n //  function sellBond(\n //      uint256 _marketId,\n //      uint256 _amountIn, \n //      uint256 _priceLimit, \n //      bytes calldata _tradeRequestData \n //    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\n //    require(!restriction_data[_marketId].duringAssessment, \"not during assessment\"); \n //    require(!markets[_marketId].isPool, \"ispool\"); \n\n //    // if (duringMarketAssessment(_marketId)) revert(\"can't close during assessment\"); \n //    require(!restriction_data[_marketId].resolved, \"!resolved\");\n //    // require(_canSell(msg.sender, _amountIn, _marketId),\"Restricted\");\n //    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \n\n //    if (restriction_data[_marketId].duringAssessment){\n\n //      (amountIn, amountOut) = bondPool.takerClose(\n //                                    true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\n\n //      _logTrades(_marketId, msg.sender, amountIn, 0, false, true );                                          \n\n //    }\n //    else{\n //      // controller.deduct_selling_fee( _marketId ); //TODO, if validator or manager, deduct reputation \n\n //      // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\n //      // if(isTaker) \n //      (amountIn, amountOut) = bondPool.takerClose(\n //              true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\n //      // else {\n //      //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, uint256(_amountIn), true, msg.sender);        \n //      // }\n //    }\n\n //    reputationManager.recordPush(msg.sender, _marketId, bondPool.getCurPrice(), true, amountIn); \n\n //  } \n // /// @param _amountIn is amount of short trader is willing to cover \n //  function coverBondShort(\n //    uint256 _marketId, \n //    uint256 _amountIn, \n //    uint256 _priceLimit,\n //    bytes calldata _tradeRequestData \n //    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\n //    require(!restriction_data[_marketId].duringAssessment, \"not during assessment\"); \n\n //    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \n\n //    if (restriction_data[_marketId].duringAssessment){\n\n //      // amountOut is collateral up the curve, amountIn is collateral returned from closing  \n //      (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\n\n //      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false); \n //     // deduct_selling_fee(); \n //    }\n //    else{\n //      // (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\n //      // if (isTaker)\n //        (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\n      \n //      // else{\n //      //   (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, _amountIn, false, msg.sender);\n //      // }\n //    }\n //  }"
    },
    "contracts/protocol/reputationmanager.sol": {
      "content": "pragma solidity ^0.8.16;\nimport \"lib/forge-std/src/console.sol\";\n\nimport {config} from \"../utils/helpers.sol\"; \nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {Controller} from \"./controller.sol\"; \nimport {StorageHandler} from \"../global/GlobalStorage.sol\"; \n\ncontract ReputationManager {\n    using FixedPointMathLib for uint256;\n\n    mapping(address=>uint256) public trader_scores; // trader address => score\n    mapping(address=>bool) public isRated;\n    address[] public traders;\n\n    address controller;\n    address marketManager;\n\n    address deployer;\n\n    modifier onlyProtocol() {\n        require(msg.sender == controller || msg.sender == marketManager || msg.sender == deployer, \"ReputationManager: !protocol\");\n        _;\n    }\n    // event pullLogged(uint256 marketId, address recipient, );\n    event reputationUpdated(uint256 marketId, address recipient);\n\n    constructor(\n        address _controller,\n        address _marketManager\n    ) {\n       controller = _controller;\n       marketManager = _marketManager;\n       deployer = msg.sender;\n    }\n  StorageHandler public Data; \n  function setDataStore(address dataStore) public onlyProtocol{\n    Data = StorageHandler(dataStore); \n  }\n    struct RepLog{\n        uint256 collateralAmount; \n        uint256 bondAmount; \n        uint256 budget; \n        bool perpetual; \n        //TODO place this info elsewhere or do packing\n    }\n\n    mapping(address=> mapping(uint256=> RepLog)) public repLogs; //trader=> marketid=>replog \n\n    function getRepLog(address trader, uint256 marketId) external view returns(RepLog memory){\n        return repLogs[trader][marketId]; \n    }\n\n    /// @notice record for reputation updates whenever trader buys longZCB\n    function recordPull(\n        address trader, \n        uint256 marketId, \n        uint256 bondAmount, \n        uint256 collateral_amount, \n        uint256 budget,\n        bool perpetual\n        ) external onlyProtocol{\n        RepLog memory newLog = repLogs[trader][marketId]; \n        newLog.collateralAmount += collateral_amount; \n        newLog.bondAmount += bondAmount; \n        newLog.perpetual = perpetual; \n        newLog.budget = budget; \n\n        repLogs[trader][marketId] = newLog;   \n    }\n\n    /// @notice updates reputation whenever trader redeems \n    /// param premature is true if trader redeems/sells before maturity \n    /// param redeemAmount is 0 if !perpetual, since for those traders will redeem all at once \n    function recordPush(\n        address trader, \n        uint256 marketId, \n        uint256 bondPrice, \n        bool premature, \n        uint256 redeemAmount//in bonds \n        ) external onlyProtocol {\n        RepLog memory newLog = repLogs[trader][marketId]; \n\n        uint256 avgPrice = newLog.collateralAmount.divWadDown(newLog.bondAmount); \n\n        // Penalize premature sells \n        if(premature){\n            _updateReputation(marketId, trader, false, 1e18, newLog); \n            delete repLogs[trader][marketId]; \n        }\n        // What about when trader buys during assessment at discount?  \n        // if instrument is perpetual, increment if exit price > avgPrice by \n        // proportional to the diff in price  \n        if(newLog.perpetual){\n            if (bondPrice >= avgPrice) \n                _updateReputation(marketId, trader, true,  bondPrice-avgPrice, newLog); \n            else \n                _updateReputation(marketId, trader, false,  avgPrice - bondPrice, newLog); \n\n            require(newLog.collateralAmount >= redeemAmount.mulWadDown(avgPrice), \"logERR1\");\n            require(newLog.bondAmount>= redeemAmount, \"logERR2\"); \n            unchecked{\n                newLog.collateralAmount -= redeemAmount.mulWadDown(avgPrice);\n                newLog.bondAmount -= redeemAmount; \n                repLogs[trader][marketId] = newLog; \n            }\n        }\n\n        // if instrument is fixed term, increment if redemptionprice >= 1, \n        // no change if 1>= redemption price >= avgPrice and decrement otherwise \n        else{\n            //bondPrice is redemptionprice for fixed term instruments\n            if(bondPrice>= 1e18)\n                _updateReputation(marketId, trader, true, bondPrice-avgPrice, newLog); \n            \n            else if(bondPrice <= avgPrice && bondPrice < 1e18)\n                _updateReputation(marketId, trader, false, avgPrice-bondPrice, newLog);  \n            // Redeeming everything at maturity \n            delete repLogs[trader][marketId];             \n        }\n\n\n    }\n\n    /// @notice given a hypoethetical bond price, calculate how much reputation one will gain\n    function expectedRepGain(\n        address trader, \n        uint256 marketId, \n        uint256 bondPrice, \n        uint256 incremntalAmount, \n        uint256 incrementalBondAmount) external view returns(int256 expectedGain){\n        RepLog memory log = repLogs[trader][marketId]; \n\n        uint256 avgPrice = (log.collateralAmount+incremntalAmount)\n            .divWadDown(log.bondAmount + incrementalBondAmount); \n        uint256 priceChange = bondPrice- avgPrice; \n        uint256 implied_probs; \n\n        if(log.perpetual){\n            implied_probs = log.collateralAmount.divWadDown(log.budget); \n            expectedGain = (bondPrice >= avgPrice)\n                ? int256(priceChange.mulWadDown(implied_probs))\n                : -int256(priceChange.mulWadDown(implied_probs)); \n        } else {\n            implied_probs = calcImpliedProbability(\n                log.bondAmount, \n                log.collateralAmount, \n                log.budget\n                ); \n            if(bondPrice>= 1e18)\n                expectedGain = int256(priceChange.mulWadDown(implied_probs)); \n            else if(bondPrice <= avgPrice && bondPrice < 1e18)\n                expectedGain = -int256(priceChange.mulWadDown(implied_probs)); \n        }\n    }\n\n    /// @notice when market is resolved(maturity/early default), calculates score\n    /// and update each assessment phase trader's reputation, called by individual traders when redeeming\n    function _updateReputation(\n        uint256 marketId,\n        address trader,\n        bool increment, \n        uint256 priceChange, \n        RepLog memory log\n    ) internal {\n\n        uint256 implied_probs = log.perpetual\n            ? log.collateralAmount.divWadDown(log.budget)\n            : calcImpliedProbability(\n                log.bondAmount, \n                log.collateralAmount, \n                log.budget\n                ); \n\n        uint256 change = priceChange.mulWadDown(implied_probs); \n                        // log.perpetual\n                        // ? priceChange.mulWadDown(implied_probs) * \n                        // : implied_probs.mulDivDown(implied_probs, config.WAD);\n\n        if (increment) {\n            incrementScore(trader, change);\n        } else {\n            decrementScore(trader, change);\n        }\n    }\n\n    //function expectedRepGain()\n\n\n    /// @notice calculates implied probability of the trader, used to\n    /// update the reputation score by brier scoring mechanism\n    /// @param budget of trader in collateral decimals\n    function calcImpliedProbability(\n        uint256 bondAmount,\n        uint256 collateral_amount,\n        uint256 budget\n    ) public pure returns (uint256) {\n        require(bondAmount > 0 && collateral_amount > 0, \"0div\"); \n      // TODO underflows when avgprice bigger than wad\n        uint256 avg_price = collateral_amount.divWadDown(bondAmount);\n        uint256 b = avg_price.mulWadDown(config.WAD - avg_price);\n        uint256 ratio = bondAmount.divWadDown(budget);\n\n        return ratio.mulWadDown(b) + avg_price;\n    }\n\n    function calculateMinScore(uint256 percentile) view external returns (uint256) {\n        uint256 l = traders.length * config.WAD;\n        if (percentile / 1e2 == 0) {\n        return 0;\n        }\n        uint256 x = l.mulWadDown(percentile / 1e2);\n        x /= config.WAD;\n        return trader_scores[traders[x - 1]];\n    }\n\n    // change visiblity, external only for testing.\n    function setTraderScore(address trader, uint256 score) external {\n        uint256 prev_score = trader_scores[trader];\n        if (score > prev_score) {\n        incrementScore(trader, score - prev_score);\n        } else if (score < prev_score) {\n        decrementScore(trader, prev_score - score);\n        }\n    }\n    \n    function isReputable(address trader, uint256 percentile) view external returns (bool) {\n        uint256 k = findTrader(trader);\n        uint256 n = (traders.length - (k+1))*config.WAD;\n        uint256 N = traders.length*config.WAD;\n        uint256 p = uint256(n).divWadDown(N)*10**2;\n\n        if (p >= percentile) {\n        return true;\n        } else {\n        return false;\n        }\n    }\n\n    // TODO \n    function expectedIncrement(address manager) public view returns(uint256){\n\n    }\n\n    /**\n    @dev percentile is is wad 0-100\n    @notice returns a list of top X percentile traders excluding the utilizer. \n    */\n    function filterTraders(uint256 percentile, address utilizer) view public returns (address[] memory) {\n        uint256 l = traders.length * config.WAD;\n        \n        // if below minimum percentile, return all traders excluding the utilizer\n        if (percentile / 1e2 == 0) {\n        if (isRated[utilizer]) {\n            address[] memory result = new address[](traders.length - 1);\n\n            uint256 j = 0;\n            for (uint256 i=0; i<traders.length; i++) {\n            if (utilizer == traders[i]) {\n                j = 1;\n                continue;\n            }\n            result[i - j] = traders[i];\n            }\n            return result;\n        } else {\n            return traders;\n        }\n        }\n\n        uint256 x = l.mulWadDown((config.WAD*100 - percentile) / 1e2);\n        x /= config.WAD;\n\n        address[] memory selected; \n        if (utilizer == address(0) || !isRated[utilizer]) {\n        selected = new address[](x);\n        for (uint256 i=0; i<x; i++) {\n            selected[i] = traders[i];\n        }\n        } else {\n        selected = new address[](x - 1);\n        uint256 j=0;\n        for (uint256 i = 0; i<x; i++) {\n            if (traders[i] == utilizer) {\n            j = 1;\n            continue;\n            }\n            selected[i - j] = traders[i];\n        }\n        }\n\n        return selected;\n    }\n\n    function getTraders() view public returns (address[] memory) {\n        return traders;\n    }\n\n    event ScoreUpdated(address trader, uint256 score);\n    /**\n    @notice increments trader's score\n    @dev score >= 0, update > 0\n    */\n    function incrementScore(address trader, uint256 update) onlyProtocol public {\n        trader_scores[trader] += update;\n        _updateRanking(trader, true);\n        emit ScoreUpdated(trader, trader_scores[trader]);\n    }\n\n    function testIncrementScore(uint256 update) public {\n        trader_scores[msg.sender] += update;\n        _updateRanking(msg.sender, true);\n        emit ScoreUpdated(msg.sender, trader_scores[msg.sender]);\n    }\n\n    /**\n    @notice decrements trader's score\n    @dev score >= 0, update > 0\n    */\n    function decrementScore(address trader, uint256 update) onlyProtocol public {\n        if (update >= trader_scores[trader]) {\n        trader_scores[trader] = 0;\n        } else {\n        trader_scores[trader] -= update;\n        }\n        _updateRanking(trader, false);\n        emit ScoreUpdated(trader, trader_scores[trader]);\n    }\n\n    /**\n    @notice updates top trader array\n    @dev holy moly is this ugly\n    */\n    function _updateRanking(address trader, bool increase) internal {\n        uint256 score = trader_scores[trader];\n\n        if (!isRated[trader]) {\n        isRated[trader] = true;\n        if (traders.length == 0) {\n            traders.push(trader);\n            return;\n        }\n        for (uint256 i=0; i<traders.length; i++) {\n            if (score > trader_scores[traders[i]]) {\n            traders.push(address(0));\n            _shiftRight(i, traders.length-1);\n            traders[i] = trader;\n            return;\n            }\n            if (i == traders.length - 1) {\n            traders.push(trader);\n            return;\n            }\n        }\n        } else {\n        uint256 k = findTrader(trader);\n        //swap places with someone.\n        if ((k == 0 && increase)\n        || (k == traders.length - 1 && !increase)) {\n            return;\n        }\n\n        if (increase) {\n            for (uint256 i=0; i<k; i++) {\n            if (score > trader_scores[traders[i]]) {\n                _shiftRight(i,k);\n                traders[i] = trader;\n                return;\n            }\n            }\n        } else {\n            for (uint256 i=traders.length - 1; i>k; i--) {\n            if (score < trader_scores[traders[i]]) {\n                _shiftLeft(k, i);\n                traders[i] = trader;\n                return;\n            }\n            }\n        }\n        }\n    }\n\n    function findTrader(address trader) public view returns (uint256) {\n    for (uint256 i=0; i<traders.length; i++) {\n        if (trader == traders[i]) {\n            return i;\n        }\n        }\n    }\n\n    /**\n    @notice helpers\n    */\n    function _shiftRight(uint256 pos, uint256 end) internal {\n        for (uint256 i=end; i>pos; i--) {\n        traders[i] = traders[i-1];\n        }\n    }\n\n    function _shiftLeft(uint256 pos, uint256 end) internal {\n        for (uint256 i=pos; i<end; i++) {\n        traders[i] = traders[i+1];\n        }\n    }\n    \n}"
    },
    "contracts/protocol/reputationtoken.sol": {
      "content": "pragma solidity ^0.8.16; \n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {Controller} from \"./controller.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\n\n\ncontract ReputationNFT is ERC721 {\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\n  mapping(address => uint256) internal _ownerToId;\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\n\n  uint256 private nonce = 1;\n  Controller controller;\n  uint256 SCALE = 1e18;\n\n\n  struct ReputationData {\n    uint256 n; // number of markets participated in => regular uint256\n    uint256 score; \n  }\n\n  struct TraderData { // for each market\n    address trader;\n    uint256 tokensBought;\n  }\n\n  struct TopReputation{\n    address trader; \n    uint256 score; \n  }\n\n  uint256 private constant topRep = 100; \n  TopReputation[topRep] topReputations; \n\n  mapping(uint256=>mapping(address=>bool)) canTrade; //marketID-> address-> cantrade\n  mapping(uint256=>bool) allowAll; \n  mapping(address=>bool) isUnique; \n  address[] unique_traders; \n  mapping(uint256=>mapping(address=>uint256)) public balances; // marketId => market manager address => how much collateral already bought.\n\n  modifier onlyController() {\n    require(msg.sender == address(controller));\n    _;\n  }\n\n  constructor (\n    address _controller\n  ) ERC721(\"Debita Reputation Token\", \"DRT\") {\n    controller = Controller(_controller);\n  }\n\n  /**\n   @notice incrementBalance\n   */\n  function incrementBalance(uint256 marketId, address trader, uint256 amount) external onlyController {\n    balances[marketId][trader] += amount;\n  }\n\n  /**\n   @notice called post reputation update\n   */\n  function removeBalance(uint256 marketId, address trader) external onlyController {\n    delete balances[marketId][trader];\n  }\n\n  function _baseURI() internal pure returns (string memory baseURI) {\n    baseURI = \"\";\n  }\n\n  function tokenURI(uint256 id) public view override returns (string memory) {\n    require(_ownerOf[id] != address(0), \"Invalid Identifier\");\n\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \"\";\n  }\n\n  function mint(address to) external {\n    require(_ownerToId[to] == uint256(0), \"can only mint one reputation token\");\n    super._mint(to, nonce);\n    _ownerToId[to] = nonce;\n\n    // Set default score, if this goes to 0 cannot trade\n    _reputation[_ownerToId[to]].score = 1e18; \n\n    nonce++;\n  }\n\n  function getReputationScore(address owner) view external returns (uint256){\n    require(_ownerToId[owner] != uint256(0), \"No Id found\");\n    return _reputation[_ownerToId[owner]].score;\n  }\n\n  function setReputationScore(address owner, uint256 score) external returns (uint256) \n  //onlyOwner\n  {\n    require(_ownerToId[owner] != uint256(0), \"No Id found\");\n    return _reputation[_ownerToId[owner]].score = score;\n  }\n\n\n  function updateScore(address to, int256 score) external onlyController{\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    if (score > 0) data.score = data.score + uint256(score);\n    else{\n        if (data.score <= uint256(-score)) data.score = 0; \n        else data.score = data.score - uint256(-score);\n      } \n\n    storeTopX(data.score, to); \n  }\n\n\n  function addScore(address to, uint256 score) external onlyController\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    data.score = data.score + score; \n\n    storeTopX(data.score, to); \n  }\n\n  function decrementScore(address to, uint256 score) external onlyController\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    if (data.score <= score) data.score = 0; \n    else data.score = data.score - score; \n\n    storeTopX(data.score, to); \n  }\n\n  function addAverageScore(address to, uint256 score) external onlyController\n\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    \n    if (data.n == 0) {\n      data.score = score;\n    } else {\n      data.score = (data.score / data.n + score) / (data.n + 1);\n    }\n\n    data.n++;\n  }\n\n  /**\n   @notice reset scores\n   */\n  function resetScore(address to) external {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n    delete _reputation[_ownerToId[to]];\n  }\n\n  /// @notice called by controller when initiating market,\n  function storeTopReputation(uint256 topX, uint256 marketId) external onlyController{\n    if (getAvailableTopX() < topX) {\n      allowAll[marketId] =true; \n      return; \n    }\n\n    for (uint256 i; i<topX; i++){\n      canTrade[marketId][topReputations[i].trader] = true;\n    }\n\n  }\n\n  /// @notice gets the x's ranked score from all reputation scores \n  /// @dev returns 0 if topX is greater then avaiable nonzero rep scores-> everyone is allowed\n  /// during reputation constraint periods \n  function getMinRepScore(uint256 topX) public view returns(uint256) {\n    if (getAvailableTopX() < topX) {\n      return 0; \n    }\n    return topReputations[topX].score;\n  }\n\n  function getAvailableTopX() public view returns(uint256){\n    return unique_traders.length; \n  }\n\n  function getAvailableTraderNum() public view returns(uint256){\n    return nonce -1; \n  }\n\n  /// @notice whether trader is above reputation threshold \n  function traderCanTrade(uint256 marketId, address trader) external returns(bool){\n    return allowAll[marketId]? true : canTrade[marketId][trader]; \n  }\n\n  /// @notice called whenever a score is incremented   \n  function storeTopX(uint256 score, address trader) internal {\n    uint256 i = 0;\n\n    for(i; i < topReputations.length; i++) {\n      if(topReputations[i].score < score) {\n        break;\n      }\n    }\n    // shifting the array of position (getting rid of the last element) \n    for(uint j = topReputations.length - 1; j > i; j--) {\n        topReputations[j].score = topReputations[j - 1].score;\n        topReputations[j].trader = topReputations[j - 1].trader;\n    }\n    // update the new max element \n    topReputations[i].score = score;\n    topReputations[i].trader = trader;\n\n    if (isUnique[trader]) return; \n    isUnique[trader] = true; \n    unique_traders.push(trader);\n\n  }\n\n  function testStore() public view {\n    for (uint i=0; i<10; i++){\n      console.log('score', topReputations[i].score); \n    }\n  }  \n}"
    },
    "contracts/protocol/validatorManager.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {Controller} from \"./controller.sol\";\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {ReputationManager} from \"./reputationmanager.sol\";\nimport {SyntheticZCBPool} from \"../bonds/synthetic.sol\";\nimport {config} from \"../utils/helpers.sol\";\nimport {ERC4626} from \"../vaults/mixins/ERC4626.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\n\ncontract ValidatorManager {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    Controller private controller;\n    ReputationManager private reputationManager;\n    MarketManager private marketManager;\n\n    modifier onlyController () {\n        require(msg.sender == address(controller), \"not controller\");\n        _;\n    }\n\n     /*----Validator Logic----*/\n    struct ValidatorData {\n        mapping(address => uint256) sales; // amount of zcb bought per validator\n        mapping(address => bool) staked; // true if address has staked vt (approved)\n        mapping(address => bool) resolved; // true if address has voted to resolve the market\n        address[] validators;\n        uint256 val_cap; // total zcb validators can buy at a discount\n        uint256 avg_price; //price the validators can buy zcb at a discount\n        bool requested; // true if already requested random numbers from array.\n        uint256 totalSales; // total amount of zcb bought;\n        uint256 totalStaked; // total amount of vault token staked.\n        uint256 numApproved;\n        uint256 initialStake; // amount staked\n        uint256 finalStake; // amount of stake recoverable post resolve\n        uint256 numResolved; // number of validators calling resolve on early resolution.\n    }\n\n    mapping(uint256 => uint256) requestToMarketId;\n    mapping(uint256 => ValidatorData) public validator_data;\n    \n    constructor (\n        address _controller,\n        address _marketManager,\n        address _reputationManager\n        ) {\n        controller = Controller(_controller);\n        reputationManager = ReputationManager(_reputationManager);\n        marketManager = MarketManager(_marketManager);\n    }\n\n    function validatorSetup(\n        uint256 marketId,\n        uint256 principal,\n        bool isPool\n    ) external onlyController {\n        require(principal != 0, \"0 principal\");\n\n\n        _getValidators(marketId);\n\n        _setValidatorCap(marketId, principal, isPool);\n\n        _setValidatorStake(marketId, principal);\n    }\n\n    function _getValidators(uint256 marketId) public {\n        // retrieve traders that meet requirement.\n        // address instrument = market_data[marketId].instrument_address;\n        (,address utilizer) = controller.market_data(marketId);\n\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n        address[] memory selected = reputationManager.filterTraders(\n            r,\n            utilizer\n        );\n\n        // if there are not enough traders, set validators to all selected traders.\n        if (selected.length <= N) {\n            validator_data[marketId].validators = selected;\n\n            if (selected.length < N) {\n                revert(\"not enough rated traders\");\n            }\n\n            return;\n        }\n\n        validator_data[marketId].requested = true;\n\n        uint256 _requestId = 1;\n        // uint256 _requestId = COORDINATOR.requestRandomWords(\n        //   keyHash,\n        //   subscriptionId,\n        //   requestConfirmations,\n        //   callbackGasLimit,\n        //   uint32(parameters[marketId].N)\n        // );\n\n        requestToMarketId[_requestId] = marketId;\n    }\n\n    function _setValidatorCap(\n        uint256 marketId,\n        uint256 principal,\n        bool isPool //??\n    ) internal {\n        SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\n        (, uint256 sigma, , , , , , ) = marketManager.parameters(marketId);\n        require(config.isInWad(sigma) && config.isInWad(principal), \"paramERR\");\n        ValidatorData storage valdata = validator_data[marketId];\n\n        uint256 valColCap = (sigma.mulWadDown(principal));\n\n        // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved\n        uint256 discount_cap = bondingPool.discount_cap();\n        uint256 avgPrice = valColCap.divWadDown(discount_cap);\n\n        valdata.val_cap = discount_cap;\n        valdata.avg_price = avgPrice;\n    }\n\n     /**\n   @notice sets the amount of vt staked by a single validator for a specific market\n   @dev steak should be between 1-0 wad.\n   */\n    function _setValidatorStake(uint256 marketId, uint256 principal) internal {\n        //get vault\n        uint256 vaultId = controller.id_parent(marketId);\n        Vault vault = controller.vaults(vaultId);\n        // ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\n        uint256 shares = vault.convertToShares(principal);\n        (, , , , , , , uint256 steak) = marketManager.parameters(marketId);\n        validator_data[marketId].initialStake = steak.mulWadDown(shares);\n    }\n\n    function deniedValidator(uint256 marketId, address validator)\n        external\n        onlyController\n        returns (uint256 collateral_amount)\n    {\n        //??? is this correct\n        collateral_amount = validator_data[marketId]\n            .sales[validator]\n            .mulWadDown(validator_data[marketId].avg_price);\n        delete validator_data[marketId].sales[validator];\n    }\n\n    function redeemValidator(uint256 marketId, address validator)\n        external\n        onlyController\n    {\n        delete validator_data[marketId].sales[validator];\n    }\n\n    function getValidatorRequiredCollateral(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 val_cap = validator_data[marketId].val_cap;\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\n        uint256 zcb_for_sale = val_cap / N;\n        return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\n    }\n\n    function unlockValidatorStake(uint256 marketId, address validator) onlyController external {\n        require(isValidator(marketId, validator), \"!validator\");\n        require(validator_data[marketId].staked[validator], \"!stake\");\n        (bool duringMarketAssessment, , , , , ) = marketManager\n            .restriction_data(marketId);\n\n        // market early denial, no loss.\n        uint256 vaultId = controller.id_parent(marketId);\n        Vault vault = controller.vaults(vaultId);\n        if (duringMarketAssessment) {\n            ERC20(controller.getVaultAd(marketId)).safeTransfer(\n                validator,\n                validator_data[marketId].initialStake\n            );\n            validator_data[marketId].totalStaked -= validator_data[marketId]\n                .initialStake;\n        } else {\n            // market resolved.\n            ERC20(controller.getVaultAd(marketId)).safeTransfer(\n                validator,\n                validator_data[marketId].finalStake\n            );\n            validator_data[marketId].totalStaked -= validator_data[marketId]\n                .finalStake;\n        }\n\n        validator_data[marketId].staked[validator] = false;\n    }\n\n     function updateValidatorStake(\n        uint256 marketId,\n        uint256 principal,\n        uint256 principal_loss\n    ) public onlyController {\n        if (principal_loss == 0) {\n            validator_data[marketId].finalStake = validator_data[marketId]\n                .initialStake;\n            return;\n        }\n\n        uint256 vaultId = controller.id_parent(marketId);\n        Vault vault = controller.vaults(vaultId);\n        uint256 p_shares = vault.convertToShares(principal);\n        uint256 p_loss_shares = vault.convertToShares(principal_loss);\n\n        uint256 totalStaked = validator_data[marketId].totalStaked;\n        uint256 newTotal = totalStaked /\n            2 +\n            (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(\n                totalStaked / 2\n            );\n\n        ERC4626(controller.getVaultAd(marketId)).burn(totalStaked - newTotal);\n        validator_data[marketId].totalStaked = newTotal;\n\n        validator_data[marketId].finalStake =\n            newTotal /\n            validator_data[marketId].validators.length;\n    }\n\n    function validatorResolve(uint256 marketId, address validator) onlyController external {\n        require(isValidator(marketId, validator), \"!val\");\n        require(!validator_data[marketId].resolved[validator], \"voted\");\n\n        validator_data[marketId].resolved[validator] = true;\n        validator_data[marketId].numResolved++;\n    }\n\n    function isValidator(uint256 marketId, address user)\n        public\n        view\n        returns (bool)\n    {\n        address[] storage _validators = validator_data[marketId].validators;\n        for (uint256 i = 0; i < _validators.length; i++) {\n            if (_validators[i] == user) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function validatorApprove(uint256 marketId, address validator) external returns (uint256 collateral_required, uint256 zcb_for_sale) {\n        require(isValidator(marketId, validator), \"!Val\");\n        require(controller.marketCondition(marketId), \"!condition\");\n\n        ValidatorData storage valdata = validator_data[marketId];\n        require(!valdata.staked[validator], \"!staked\");\n\n        // staking logic, TODO optional since will throw error on transfer.\n        // require(ERC20(getVaultAd(marketId)).balanceOf(validator) >= valdata.initialStake, \"not enough tokens to stake\");\n\n        // staked vault tokens go to controller\n        ERC20(controller.getVaultAd(marketId)).safeTransferFrom(\n            validator,\n            address(this),\n            valdata.initialStake\n        );\n\n        valdata.totalStaked += valdata.initialStake;\n        valdata.staked[validator] = true;\n\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\n        zcb_for_sale = valdata.val_cap / N;\n        collateral_required = zcb_for_sale.mulWadDown(\n            valdata.avg_price\n        );\n\n        require(valdata.sales[validator] <= zcb_for_sale, \"approved\");\n\n        valdata.sales[validator] += zcb_for_sale;\n        valdata.totalSales += (zcb_for_sale + 1); //since division rounds down ??\n        valdata.numApproved += 1;\n\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\n        // marketManager.validatorApprove(\n        //     marketId,\n        //     collateral_required,\n        //     zcb_for_sale,\n        //     validator\n        // );\n\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\n        if (controller.approvalCondition(marketId)) {\n            controller.approveMarket(marketId);\n            // marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\n        }\n    }\n\n    function approvalCondition(uint256 marketId) public view returns (bool) {\n        return (validator_data[marketId].totalSales >=\n            validator_data[marketId].val_cap &&\n            validator_data[marketId].validators.length ==\n            validator_data[marketId].numApproved);\n    }\n\n\n    function getValidatorPrice(uint256 marketId) public view returns (uint256) {\n        return validator_data[marketId].avg_price;\n    }\n\n    function getValidatorCap(uint256 marketId) public view returns (uint256) {\n        return validator_data[marketId].val_cap;\n    }\n\n    function viewValidators(uint256 marketId)\n        public\n        view\n        returns (address[] memory)\n    {\n        return validator_data[marketId].validators;\n    }\n\n    function fulfillRandomWords(\n        uint256 requestId,\n        uint256[] memory randomWords //internal\n    ) external onlyController\n    {\n        uint256 marketId = requestToMarketId[requestId];\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\n\n        assert(randomWords.length == N);\n\n        // address instrument = market_data[marketId].instrument_address;\n        (,address utilizer) = controller.market_data(marketId);\n\n        address[] memory temp = reputationManager.filterTraders(r, utilizer);\n        uint256 length = temp.length;\n\n        // get validators\n        for (uint8 i = 0; i < N; i++) {\n            uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\n            validator_data[marketId].validators.push(temp[j]);\n            temp[j] = temp[length - 1];\n            length--;\n        }\n    }\n\n    function _weightedRetrieve(\n        address[] memory group,\n        uint256 length,\n        uint256 randomWord\n    ) internal view returns (uint256) {\n        uint256 sum_weights;\n\n        for (uint8 i = 0; i < length; i++) {\n            sum_weights += controller.getTraderScore(group[i]); //repToken.getReputationScore(group[i]);\n        }\n\n        uint256 tmp = randomWord % sum_weights;\n\n        for (uint8 i = 0; i < length; i++) {\n            uint256 wt = controller.getTraderScore(group[i]);\n            if (tmp < wt) {\n                return i;\n            }\n            unchecked {\n                tmp -= wt;\n            }\n        }\n    }\n\n    function resolveCondition(uint256 marketId) public view returns (bool) {\n        return (validator_data[marketId].numResolved ==\n            validator_data[marketId].validators.length);\n    }\n\n    function hasApproved(uint256 marketId, address validator)\n        public\n        view\n        returns (bool)\n    {\n        return validator_data[marketId].staked[validator];\n    }\n\n    function getNumApproved(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getNumApproved(marketId);\n        return validator_data[marketId].numApproved;\n    }\n\n    function getNumResolved(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getNumResolved(marketId);\n        return validator_data[marketId].numResolved;\n    }\n\n    function getTotalStaked(uint256 marketId) public view returns (uint256) {\n        // return validatorManager.getTotalStaked(marketId);\n        return validator_data[marketId].totalStaked;\n    }\n\n    function getTotalValidatorSales(uint256 marketId)\n        public\n        view\n        returns (uint256)\n    {\n        // return validatorManager.getTotalValidatorSales(marketId);\n        return validator_data[marketId].totalSales;\n    }\n\n    function getInitialStake(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getInitialStake(marketId);\n        return validator_data[marketId].initialStake;\n    }\n\n    function getFinalStake(uint256 marketId) public view returns (uint256) {\n        //return validatorManager.getFinalStake(marketId);\n        return validator_data[marketId].finalStake;\n    }\n}"
    },
    "contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n    // function isContract(address account) internal view returns (bool) {\n    //     // This method relies on extcodesize, which returns 0 for contracts in\n    //     // construction, since the code is only stored at the end of the\n    //     // constructor execution.\n\n    //     uint256 size;\n    //     // solhint-disable-next-line no-inline-assembly\n    //     assembly { size := extcodesize(account) }\n    //     return size > 0;\n    // }\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}"
    },
    "contracts/utils/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}"
    },
    "contracts/utils/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "contracts/utils/common/Uint.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.4;\n\nuint256 constant MAX_VAL = type(uint256).max;\n\n// reverts on overflow\nfunction safeAdd(uint256 x, uint256 y) pure returns (uint256) {\n    return x + y;\n}\n\n// does not revert on overflow\nfunction unsafeAdd(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return x + y;\n}}\n\n// does not revert on overflow\nfunction unsafeSub(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return x - y;\n}}\n\n// does not revert on overflow\nfunction unsafeMul(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return x * y;\n}}\n\n// does not overflow\nfunction mulModMax(uint256 x, uint256 y) pure returns (uint256) { unchecked {\n    return mulmod(x, y, MAX_VAL);\n}}\n\n// does not overflow\nfunction mulMod(uint256 x, uint256 y, uint256 z) pure returns (uint256) { unchecked {\n    return mulmod(x, y, z);\n}}\n"
    },
    "contracts/utils/fetcher.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {MarketManager} from \"../protocol/marketmanager.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {VaultFactory} from \"../protocol/factories.sol\";\nimport {Controller} from \"../protocol/controller.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\nimport {SyntheticZCBPool} from \"../bonds/synthetic.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport {LinearCurve} from \"../bonds/GBC.sol\"; \nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\";\n// import {PoolInstrument } from \"../instruments/oldpoolInstrument.sol\";\n\nimport \"lib/forge-std/src/console.sol\";\nimport {CoveredCallOTC} from \"../vaults/dov.sol\";\nimport { CreditLine } from \"../vaults/instrument.sol\";\n\nimport \"../global/types.sol\"; \n\ncontract Fetcher {\n    using FixedPointMathLib for uint256;\n\n    /**\n        static => only called on creation of vault or market.\n        dynamic => called continuously.\n     */\n    struct AssetBundle {\n        address addr;\n        string symbol;\n        uint256 decimals;\n        string name;\n    }\n\n    struct CollateralBundle {\n        address tokenAddress;\n        uint256 tokenId;\n        uint256 decimals;\n        uint256 maxAmount;\n        uint256 borrowAmount;\n        uint256 totalCollateral; //only for ERC20.\n        string symbol;\n        string name;\n        bool isERC20;\n        address owner; // only for ERC721.\n    }\n\n    struct ValidatorBundle {\n        address[] validators;\n        uint256 val_cap;\n        uint256 avg_price;\n        uint256 totalSales;\n        uint256 totalStaked;\n        uint256 numApproved;\n        uint256 initialStake;\n        uint256 finalStake;\n        uint256 numResolved;\n    }\n\n    // change types\n    struct VaultBundle {\n        string name;\n        string symbol;\n        string description;\n        uint256 vaultId;\n        uint256[] marketIds;\n        MarketParameters default_params;\n        bool onlyVerified; \n        uint256 r; //reputation ranking  \n        uint256 asset_limit; \n        uint256 total_asset_limit;\n        AssetBundle want;\n        uint256 totalShares;\n        uint256 totalAssets;\n        address vault_address;\n        uint256 exchangeRate;\n        uint256 utilizationRate;\n        uint256 totalEstimatedAPR; \n        uint256 goalAPR; \n        uint256 totalProtection;\n        uint256 totalInstrumentHoldings;\n    }\n\n    struct MarketBundle {\n        uint256 marketId;\n        uint256 vaultId;\n        uint256 creationTimestamp;\n        uint256 resolutionTimestamp;\n\n        bool marketConditionMet;\n        uint256 approvedPrincipal;\n        uint256 approvedYield;\n        uint256 managerStake;\n        uint256 totalCollateral; // loggedCollateral\n        uint256 redemptionPrice;\n\n        // bond pool data\n        address bondPool;\n        address longZCB;\n        uint256 longZCBSupply;\n        address shortZCB;\n        uint256 shortZCBSupply;\n        uint256 longZCBPrice;\n        uint256 a_initial;\n        uint256 b_initial;\n        uint256 b;\n        uint256 discountCap;\n        uint256 discountedReserves;\n\n        MarketParameters parameters;\n        MarketPhaseData phase;\n        ValidatorBundle validatorData;\n    }\n\n    struct PoolBundle {\n        uint256 saleAmount;\n        uint256 initPrice; // init price of longZCB in the amm \n        uint256 promisedReturn; //per unit time \n        uint256 inceptionTime;\n        uint256 inceptionPrice; // init price of longZCB after assessment \n        uint256 leverageFactor; //leverageFactor * manager collateral = capital from vault to instrument\n        uint256 managementFee; // sum of discounts for high reputation managers/validators\n        uint256 pju;\n        uint256 psu;\n        // lending pool data\n        uint128 totalBorrowedAssets;\n        uint128 totalSuppliedAssets;\n        uint256 totalAvailableAssets;\n        \n        // rates\n        uint256 ratePerSec;\n        uint256 lastUpdate;\n        uint256 utilizationRate;\n        address rateContract;\n        string rateName;\n        uint256 exchangeRate;\n        // constants\n        CollateralBundle[] collaterals;\n    }\n\n    struct OptionsBundle {\n        uint256 strikePrice;\n        uint256 pricePerContract;\n        uint256 shortCollateral;\n        uint256 longCollateral;\n        uint256 maturityDate;\n        uint256 tradeTime;\n        address oracle;\n        bool approvalStatus;\n    }\n\n    struct CreditlineBundle {\n        address collateral;\n        address oracle;\n        // tenor === instrument duration.\n        uint256 collateralBalance;\n        uint256 principalRepayed;\n        uint256 interestRepayed;\n        uint256 totalOwed;\n        CreditLine.CollateralType collateralType;\n        CreditLine.LoanStatus loanStatus;\n    }\n\n    struct InstrumentBundle {\n        uint256 marketId;\n        uint256 vaultId;\n        address utilizer;\n        bool trusted;\n        bool isPool;\n        uint256 balance;\n        uint256 faceValue;\n\n        // proposed\n        uint256 principal;\n        uint256 expectedYield;\n\n        uint256 duration;\n        string description;\n        address instrument_address;\n        InstrumentType instrument_type;\n        uint256 maturityDate;\n        bytes32 name;\n        uint256 seniorAPR; \n        uint256 exposurePercentage;\n        uint256 managers_stake; \n        uint256 approvalPrice;\n        PoolBundle poolData;\n        OptionsBundle optionsData;\n        CreditlineBundle creditlineData;\n    }\n\n    function buildAssetBundle(ERC20 _asset) internal view returns (AssetBundle memory _bundle) {\n        _bundle.addr = address(_asset);\n        _bundle.symbol = _asset.symbol();\n        _bundle.decimals = _asset.decimals();\n        _bundle.name = _asset.name();\n    }\n\n    /**\n     @dev vaultId retrieved from vaultIds public array in controller.\n     @notice retrieves all the static data associated with a vaultId.\n     */\n    function fetchInitial(\n        Controller _controller,\n        MarketManager _marketManager,\n        uint256 vaultId\n    ) \n    public \n    view \n    returns (\n        VaultBundle memory vaultBundle,\n        MarketBundle[] memory marketBundle,\n        InstrumentBundle[] memory instrumentBundle,\n        uint256 timestamp\n    )\n    {\n        timestamp = block.timestamp;\n        // vault bundle\n        Vault vault = _controller.vaults(vaultId);\n\n        if (address(vault) == address(0)) {\n            return (makeEmptyVaultBundle(), new MarketBundle[](0), new InstrumentBundle[](0), timestamp);\n        }\n\n        vaultBundle.name = vault.name();\n        vaultBundle.symbol = vault.symbol();\n        vaultBundle.vaultId = vaultId;\n        vaultBundle.marketIds = _controller.getMarketIds(vaultId);\n        vaultBundle.default_params = vault.get_vault_params();\n        vaultBundle.onlyVerified = vault.onlyVerified();\n        vaultBundle.want = buildAssetBundle(vault.asset());\n        vaultBundle.r = vault.r();\n        vaultBundle.asset_limit = vault.asset_limit();\n        vaultBundle.total_asset_limit = vault.total_asset_limit();\n        vaultBundle.totalShares = vault.totalSupply();\n        vaultBundle.totalAssets = vault.totalAssets(); \n        vaultBundle.vault_address = address(vault);\n        vaultBundle.utilizationRate = vault.utilizationRate();\n        vaultBundle.totalInstrumentHoldings = vault.totalInstrumentHoldings();\n        // vaultBundle.description = vault.description();\n     \n        (uint256 totalProtection, uint256 totalEstimatedAPR, uint256 goalAPR, uint256 exchangeRate) = _controller.getVaultSnapShot(vaultId);\n        vaultBundle.totalProtection = totalProtection;\n        vaultBundle.totalEstimatedAPR = totalEstimatedAPR;\n        vaultBundle.goalAPR = goalAPR;\n        vaultBundle.exchangeRate = exchangeRate;\n\n        if (vaultBundle.marketIds.length == 0) {\n            return (vaultBundle, new MarketBundle[](0), new InstrumentBundle[](0), timestamp);\n        }\n\n        // associated markets\n        // (_marketIds, _lowestMarketIndex) = listOfInterestingMarkets(_marketFactory, _offset, _total);\n        marketBundle = new MarketBundle[](vaultBundle.marketIds.length);\n        instrumentBundle = new InstrumentBundle[](vaultBundle.marketIds.length);\n\n        for (uint256 i; i < vaultBundle.marketIds.length; i++) {\n            marketBundle[i] = buildMarketBundle(vaultBundle.marketIds[i], vaultId, _controller, _marketManager);\n            // (uint256 managers_stake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) = \n            instrumentBundle[i] = buildInstrumentBundle(vaultBundle.marketIds[i], vaultId, _controller, _marketManager);\n        }\n    }\n\n\n    function buildInstrumentBundle(uint256 mid, uint256 vid, Controller controller, MarketManager marketManager) internal view returns (InstrumentBundle memory bundle) {\n        Vault vault = controller.vaults(vid);\n        (,address utilizer) = controller.market_data(mid);\n        InstrumentData memory data = vault.fetchInstrumentData(mid);\n\n\n        (uint256 managerStake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice) = controller.getInstrumentSnapShot(mid);\n        bundle.managers_stake = managerStake;\n        bundle.exposurePercentage = exposurePercentage;\n        bundle.seniorAPR = seniorAPR;\n        bundle.approvalPrice = approvalPrice;\n\n        bundle.marketId = mid;\n        bundle.vaultId = vid;\n        bundle.isPool = data.isPool;\n        bundle.trusted = data.trusted;\n        bundle.balance = vault.asset().balanceOf(address(data.instrument_address));\n        bundle.principal = data.principal;\n        bundle.expectedYield = data.expectedYield;\n        bundle.duration = data.duration;\n        bundle.description = data.description;\n        bundle.instrument_type = data.instrument_type;\n        bundle.maturityDate = data.maturityDate;\n        bundle.instrument_address = address(data.instrument_address);\n        bundle.utilizer = utilizer;\n        bundle.name = data.name;\n        if (data.instrument_type == InstrumentType.LendingPool) {\n            bundle.poolData = buildPoolBundle(mid, vid, controller, marketManager);\n        } else if (data.instrument_type == InstrumentType.CoveredCallShort) {\n            bundle.optionsData = buildCoveredCallBundle(bundle.instrument_address);\n        } else if (data.instrument_type == InstrumentType.CreditLine) {\n            bundle.creditlineData = buildCreditlineBundle(bundle.instrument_address);\n        }\n    }\n\n    function buildCreditlineBundle(address instrument) internal view returns (CreditlineBundle memory bundle) {\n        CreditLine creditline = CreditLine(instrument);\n        bundle.collateral = creditline.collateral();\n        bundle.collateralBalance = creditline.collateral_balance();\n        bundle.collateralType = creditline.collateral_type();\n        bundle.oracle = creditline.oracle();\n        bundle.loanStatus = creditline.loanStatus();\n        bundle.principalRepayed = creditline.principalRepayed();\n        bundle.totalOwed = creditline.totalOwed();\n        bundle.interestRepayed = creditline.interestRepayed();\n    }\n\n    function buildCoveredCallBundle(address instrument) internal view returns (OptionsBundle memory bundle) {\n        CoveredCallOTC instrumentContract = CoveredCallOTC(instrument);\n        // (uint256 _strikePrice, uint256 _pricePerContract, uint256 _shortCollateral, uint256 _longCollateral, uint256 _maturityDate, uint256 _tradeTime, address _oracle) = instrumentContract.instrumentStaticSnapshot();\n        uint256 _strikePrice = instrumentContract.strikePrice();\n        uint256 _pricePerContract = instrumentContract.pricePerContract();\n        uint256 _shortCollateral = instrumentContract.shortCollateral();\n        uint256 _longCollateral = instrumentContract.longCollateral();\n        uint256 _maturityDate = instrumentContract.maturityTime();\n        uint256 _tradeTime = instrumentContract.tradeTime();\n        address _oracle = instrumentContract.oracle();\n\n        bundle.strikePrice = _strikePrice;\n        bundle.pricePerContract = _pricePerContract;\n        bundle.shortCollateral = _shortCollateral;\n        bundle.longCollateral = _longCollateral;\n        bundle.maturityDate = _maturityDate;\n        bundle.tradeTime = _tradeTime;\n        bundle.oracle = _oracle;\n        bundle.approvalStatus = instrumentContract.instrumentApprovalCondition();\n    }\n\n    function buildPoolBundle(uint256 mid, uint256 vid, Controller controller, MarketManager marketManager) internal view returns (PoolBundle memory bundle) {\n        Vault vault = controller.vaults(vid);\n        address instrument = address(vault.Instruments(mid));\n        InstrumentData memory instrumentData = vault.fetchInstrumentData(mid);\n\n        bundle.saleAmount = instrumentData.poolData.saleAmount;\n        bundle.initPrice = instrumentData.poolData.initPrice;\n        bundle.promisedReturn = instrumentData.poolData.promisedReturn;\n        bundle.inceptionTime = instrumentData.poolData.inceptionTime;\n        bundle.inceptionPrice = instrumentData.poolData.inceptionPrice;\n        bundle.leverageFactor = instrumentData.poolData.leverageFactor;\n        bundle.managementFee = instrumentData.poolData.managementFee;\n        (uint256 psu, uint256 pju, ) = vault.poolZCBValue(mid);\n        bundle.psu = psu;\n        bundle.pju = pju;\n\n        PoolInstrument.CollateralLabel[] memory labels = PoolInstrument(instrument).getAcceptedCollaterals();\n        uint256 l = labels.length;\n        bundle.collaterals = new CollateralBundle[](l);\n        for (uint256 i; i < l; i++) {\n            (uint256 totalCollateral,\n            uint256 maxAmount,\n            uint256 maxBorrowAmount,\n            bool isERC20, , , ,) = PoolInstrument(instrument).collateralConfigs(PoolInstrument(instrument).computeId(labels[i].tokenAddress, labels[i].tokenId));\n            bundle.collaterals[i] = buildCollateralBundle(labels[i].tokenAddress, labels[i].tokenId, maxAmount, maxBorrowAmount, isERC20, totalCollateral);\n            bundle.collaterals[i].owner = PoolInstrument(instrument).userERC721s(PoolInstrument(instrument).computeId(labels[i].tokenAddress, labels[i].tokenId));\n        }\n        \n        \n        (,uint64 lastTimestamp,uint64 ratePerSec) = PoolInstrument(instrument).currentRateInfo();\n        bundle.ratePerSec = ratePerSec;\n        bundle.lastUpdate = lastTimestamp;\n\n        (uint128 borrowAmount,) = PoolInstrument(instrument).totalBorrow();\n        (uint128 assetAmount,) = PoolInstrument(instrument).totalAsset();\n\n        bundle.utilizationRate = assetAmount == 0 ? 0 : borrowAmount * 1e18 / assetAmount;\n        bundle.rateContract = address(PoolInstrument(instrument).rateContract());\n        bundle.rateName = PoolInstrument(instrument).rateContract().name();\n        bundle.exchangeRate = PoolInstrument(instrument).previewMint(1e18);\n\n        bundle.totalBorrowedAssets = borrowAmount;\n        bundle.totalSuppliedAssets = assetAmount;\n        bundle.totalAvailableAssets = PoolInstrument(instrument).totalAssetAvailable();\n    }\n\n    function buildCollateralBundle(address tokenAddress, uint256 tokenId, uint256 maxAmount, uint256 borrowAmount, bool isERC20, uint256 totalCollateral) internal view returns (CollateralBundle memory bundle) {\n        bundle.tokenAddress = tokenAddress;\n        bundle.tokenId = tokenId;\n        bundle.maxAmount = maxAmount;\n        bundle.borrowAmount = borrowAmount;\n        bundle.isERC20 = isERC20;\n        bundle.totalCollateral = totalCollateral;\n        if (isERC20) {\n            bundle.name = ERC20(tokenAddress).name();\n            bundle.symbol = ERC20(tokenAddress).symbol();\n            bundle.decimals = ERC20(tokenAddress).decimals();\n        } else {\n            bundle.name = ERC721(tokenAddress).name();\n            bundle.symbol = ERC721(tokenAddress).symbol();\n        }\n    }\n\n    function buildMarketBundle(uint256 mid, uint256 vid, Controller controller, MarketManager marketManager) internal view returns (MarketBundle memory bundle) {\n        bundle.marketId = mid;\n        bundle.vaultId = vid;\n        CoreMarketData memory data = marketManager.getMarket(mid);\n        bundle.creationTimestamp = data.creationTimestamp;\n        bundle.resolutionTimestamp = data.resolutionTimestamp;\n        bundle.marketConditionMet = controller.marketCondition(mid);\n\n        ApprovalData memory approvalData = controller.getApprovalData(mid);\n        bundle.approvedPrincipal = approvalData.approved_principal;\n        bundle.approvedYield = approvalData.approved_yield;\n        bundle.managerStake = approvalData.managers_stake;\n\n        bundle.totalCollateral = marketManager.loggedCollaterals(mid);\n        bundle.redemptionPrice = marketManager.redemption_prices(mid);\n\n        bundle.phase = marketManager.getPhaseData(mid);\n        bundle.parameters = marketManager.getParameters(mid);\n\n        bundle.bondPool = address(data.bondPool);\n        bundle.longZCB = address(data.longZCB);\n        bundle.shortZCB = address(data.shortZCB);\n        bundle.shortZCBSupply = data.shortZCB.totalSupply();\n        bundle.longZCBSupply = data.longZCB.totalSupply();\n        bundle.longZCBPrice = data.bondPool.getCurPrice();\n        bundle.a_initial = data.bondPool.a_initial();\n        bundle.b_initial = data.bondPool.b_initial();\n        bundle.b = data.bondPool.b();\n        bundle.discountCap = data.bondPool.discount_cap();\n        bundle.discountedReserves = data.bondPool.discountedReserves();\n        \n        bundle.validatorData = buildValidatorBundle(mid, controller);\n\n    }\n\n    function buildValidatorBundle(uint256 mid, Controller controller) view internal returns (ValidatorBundle memory bundle)  {\n        bundle.avg_price = controller.getValidatorPrice(mid);\n        bundle.validators = controller.viewValidators(mid);\n        bundle.totalSales = controller.getTotalValidatorSales(mid);\n        bundle.totalStaked = controller.getTotalStaked(mid);\n        bundle.numApproved = controller.getNumApproved(mid);\n        bundle.initialStake = controller.getInitialStake(mid);\n        bundle.finalStake = controller.getFinalStake(mid);\n        bundle.numResolved = controller.getNumResolved(mid);\n        bundle.val_cap = controller.getValidatorCap(mid);\n    }\n\n// (uint256 managers_stake, uint256 exposurePercentage, uint256 seniorAPR, uint256 approvalPrice)\n    // function computeInstrumentProfile(\n    //     uint256 mid, \n    //     InstrumentBundle memory bundle, \n    //     Controller controller, \n    //     MarketManager marketmanager\n    //     ) internal view {\n    //     // get senior instrument apr, approval price, manager's stake, \n    //     MarketManager.CoreMarketData memory data = marketmanager.getMarket(mid); \n    //     Controller.ApprovalData memory approvalData = controller.getApprovalData(mid); \n    //     bundle.managers_stake = approvalData.managers_stake;\n\n    //     bundle.exposurePercentage = (bundle.balance).divWadDown(\n    //         controller.getVault(mid).totalAssets()+1);\n    //     bundle.seniorAPR = bundle.poolData.promisedReturn; \n    //     bundle.approvalPrice = bundle.poolData.inceptionPrice; \n\n    //     if(!bundle.isPool){\n    //         uint256 amountDelta;\n    //         uint256 resultPrice;\n\n    //         if(approvalData.managers_stake>0){\n    //             ( amountDelta,  resultPrice) = LinearCurve.amountOutGivenIn(\n    //             approvalData.managers_stake,\n    //             0, \n    //             data.bondPool.a_initial(), \n    //             data.bondPool.b(), \n    //             true \n    //             );\n    //         }\n            \n    //         uint256 seniorYield = bundle.faceValue -amountDelta\n    //             - (bundle.principal - approvalData.managers_stake); \n\n    //         bundle.seniorAPR = approvalData.approved_principal>0\n    //             ? seniorYield.divWadDown(1+bundle.principal - approvalData.managers_stake)\n    //             : 0; \n    //         bundle.approvalPrice = resultPrice; \n    //     }\n\n    // }\n\n    function makeEmptyVaultBundle() pure internal returns (VaultBundle memory bundle) {\n        return VaultBundle(\n            \"\",\n            \"\",\n            \"\",\n            0,\n            new uint256[](0),\n           MarketParameters(0,0,0,0,0,0,0,0),\n            false,\n            0,\n            0,\n            0,\n            AssetBundle(address(0), \"\", 0, \"\"),\n            0,\n            0,\n            address(0),\n            0,\n            0,\n            0, \n            0,0,\n            0\n        );\n    }\n}"
    },
    "contracts/utils/helpers.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nlibrary config{\n\n  uint256 public constant WAD_PRECISION = 18; \n  uint256 public constant WAD = 1e18; \n  uint256 public constant USDC_dec = 1e6; \n  uint256 public constant roundLimit = 1e14; //0.0001 \n\n  //Max amount in one transaction \n  uint256 private constant max_amount = 1e8 * WAD; \n\n  //Min amount in one transaction \n  uint256 private constant min_amount = WAD/1e4; \n\n  function convertToWad(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\n    //number should not be 18 dec, but in collateral_dec\n    new_number = number * (10 ** (WAD_PRECISION - dec));\n    assert(new_number <= max_amount); \n  }\n\n  function wadToDec(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\n    // number should be 18 dec \n    assert(isInWad(number)); \n    new_number = number/(10 ** (WAD_PRECISION - dec)); \n\n  }\n\n  function isInWad(uint256 number) internal pure returns(bool){\n    return (number >= min_amount); \n  }\n\n\n\n\n}"
    },
    "contracts/utils/Multicall.sol": {
      "content": ""
    },
    "contracts/utils/owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor (address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}"
    },
    "contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.4;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}"
    },
    "contracts/utils/TestNFT.sol": {
      "content": "pragma solidity ^0.8.16;\nimport {ERC721} from \"lib/solmate/src/tokens/ERC721.sol\";\n\n\ncontract TestNFT is ERC721 {\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n    }\n\n    function freeMint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    function tokenURI(uint256 id) public view override virtual returns (string memory) {\n        return \"tokenURI\";\n    }\n}"
    },
    "contracts/utils/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/vaults/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n    mapping(address=>bool) Authorized; \n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(msg.sender, _owner);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return(user == owner || Authorized[user]);\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setNewAuthority(address newAuthority) public {\n        require(msg.sender == owner );\n        Authorized[newAuthority] = true; \n\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/vaults/auth/authorities/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    },
    "contracts/vaults/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "contracts/vaults/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "contracts/vaults/dov.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport \"./vault.sol\";\n// import {ERC20} from \"./tokens/ERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\n// import {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {Vault} from \"./vault.sol\"; \n\n/// @notice This contract acts as an OTC option platform\n/// Utilizer will \"propose\" a strike price to buy\n/// At maturity, premiums from utilizer will be collected by the vault when expires\n/// below strike price \ncontract CoveredCallOTC is Instrument{\n    using FixedPointMathLib for uint256; \n\n    address public immutable utilizer;\n    uint256 public immutable strikePrice;\n    uint256 public immutable pricePerContract; \n    uint256 public immutable shortCollateral; \n    uint256 public immutable longCollateral;\n    address public immutable cash; \n    uint256 public immutable maturityTime; \n    uint256 public immutable tradeTime; \n\n    address public oracle ;\n    uint256 public profit; \n    uint256 public constant timeThreshold = 10; \n    bool utilizerClaimed; \n\n    /// @param _shortCollateral depends on how much underlyingAsset is in the vault. \n    /// @param _pricePerContract is the price that the utilizer is willing to buy \n    /// the call option. Usually implied vol here is lower than external implied vol values \n    constructor(address _vault,\n        address _utilizer,\n        uint256 _strikePrice, \n        uint256 _pricePerContract, // depends on IV, price per contract denominated in underlying  \n        uint256 _shortCollateral, // collateral for the sold options-> this is in underlyingAsset i.e weth \n        uint256 _longCollateral, // collateral amount in underlying for long to pay. (price*quantity)\n        address _cash,\n        uint256 duration,\n        uint256 _tradeTime// when the trade will occur \n        ) Instrument(_vault, _utilizer){\n        // TODO shortcollateral must equal principal \n        require(_longCollateral == _shortCollateral.mulWadDown(_pricePerContract), \"incorrect setting\"); \n        utilizer = _utilizer;\n        strikePrice = _strikePrice; \n        pricePerContract = _pricePerContract; \n        shortCollateral = _shortCollateral; \n        longCollateral = _longCollateral; \n        cash = _cash;\n        tradeTime = block.timestamp+ _tradeTime; \n        maturityTime = block.timestamp + duration;\n    }\n\n    function setOracle(address _oracle) public {\n        require(msg.sender ==Vault(vault).owner(), \"not owner\"); \n        oracle = _oracle; \n    }\n\n    function returnCollateral() public onlyUtilizer{\n        // can't return when approved, only can return when denied.  \n        require(block.timestamp<= tradeTime, \"redeem window passed\"); \n        underlying.transfer(msg.sender, longCollateral); \n    }\n\n    /// @notice returns true if the instrument can be approved\n    /// and funds can be directed from vault. Utilizer must have escrowed\n    /// to this contract before  \n    function instrumentApprovalCondition() public override view returns(bool){\n        return underlying.balanceOf(address(this)) >= longCollateral;\n    }\n    uint256 public testqueriedPrice=1e18; \n    /// @notice queries oracle for the latest price of the underlying \n    function queryPrice() public view returns(uint256 price){\n        //return testqueriedPrice; \n        return strikePrice;  \n    }\n\n    /// @notice for a given queriedPrice(usually the spot chainlink price at maturity)\n    /// what is the profit returned to the utilizer \n    /// @dev utillizers can call this function at maturity so they can realize profit it is positive \n    /// if they miss the window(timethreshold), they can't realize profit. \n    /// param queriedPrice must be the exact price at which option is exercised, at maturity\n    function profitForUtilizer() internal{\n        // require(block.timestamp <= maturityTime + timeThreshold  && \n        //     block.timestamp >= maturityTime- timeThreshold , \"Time window err\"); \n        require(profit == 0, \"profit already set\"); \n        uint256 queriedPrice = queryPrice(); \n\n        // Under strike price \n        if (queriedPrice <= strikePrice) profit = 0; \n\n        // Profit denominated in the base asset for the underlyingAsset, normally a stablecoin \n        else {\n            uint256 profitInCash = (queriedPrice - strikePrice).mulWadDown(shortCollateral); \n\n            // profit in underlying should be divided by the price \n            profit = profitInCash.divWadDown(queriedPrice); \n        }\n    }\n\n    /// @notice either option buyers(utilizers) or sellers(protocol)\n    /// can claim their proportion of the winnings \n    function claim() external onlyUtilizer{\n        require(maturityTime < block.timestamp, \"not matured\");\n        profitForUtilizer(); \n\n        if (profit==0) return; \n        // require(profit> 0, \"0profit\"); \n\n        underlying.transfer(msg.sender, profit); \n        profit = 0; \n        utilizerClaimed = true; \n        vault.pingMaturity(address(this), false); \n    }\n\n    /// @notice called at maturity\n    function readyForWithdrawal() public view override returns(bool){\n        return ( (block.timestamp >= maturityTime + timeThreshold && profit == 0)\n                || utilizerClaimed); \n    }\n\n    /**\n    deposit for the utilizer\n     */\n    function deposit() public onlyUtilizer {\n        transfer_liq_from(msg.sender, address(this), longCollateral);\n    }\n\n    function instrumentStaticSnapshot() public view returns (uint256 _strikePrice, uint256 _pricePerContract, uint256 _shortCollateral, uint256 _longCollateral, uint256 _maturityTime, uint256 _tradeTime, address _oracle){\n        return (strikePrice, pricePerContract, shortCollateral, longCollateral, maturityTime, tradeTime, oracle);\n    }\n}\n\n// TODO extra gains redemption price effects \n\n// Vault supplies to this instrument, validators can manually do twaps. If price deviates too much \n// between assessment period start to end, validators can pull out, and create new proposals. \n\n// everytime a manager buys, the same amount needs to be deposited into lyra. lyra wil\n// 0.97 buy-> \n// issue poollongzcb-> supply to instrument from vault-> triggers and open position  to lyra\n// redeem poollongzcb-> withdraw from instrument to vault -> triggers and close position -> realize profit back to vault \n// pool zcb value is derived from options price using it as an exchange rate. \n// contract CoveredCallLyra is Instrument{\n//     using FixedPointMathLib for uint256; \n\n//     address public immutable utilizer;\n//     uint256 public immutable strikePrice;\n//     uint256 public immutable pricePerContract; \n//     uint256 public immutable shortCollateral; \n//     uint256 public immutable longCollateral;\n//     address public immutable cash; \n//     uint256 public immutable maturityTime; \n//     uint256 public immutable tradeTime; \n\n//     address public oracle ;\n//     uint256 public profit; \n//     uint256 public constant timeThreshold = 10; \n//     bool utilizerClaimed; \n\n//     /// @param _shortCollateral depends on how much underlyingAsset is in the vault. \n//     /// @param _pricePerContract is the price that the utilizer is willing to buy \n//     /// the call option. Usually implied vol here is lower than external implied vol values \n//     constructor(address _vault,\n//         address _utilizer,\n//         uint256 _strikePrice, \n//         uint256 _pricePerContract, // depends on IV, price per contract denominated in underlying  \n//         uint256 _shortCollateral, // collateral for the sold options-> this is in underlyingAsset i.e weth \n//         uint256 _longCollateral, // collateral amount in underlying for long to pay. (price*quantity)\n//         address _cash,\n//         uint256 duration,\n//         uint256 _tradeTime// when the trade will occur \n//         ) Instrument(_vault, _utilizer){\n//         // TODO shortcollateral must equal principal \n//         require(_longCollateral == _shortCollateral.mulWadDown(_pricePerContract), \"incorrect setting\"); \n//         utilizer = _utilizer;\n//         strikePrice = _strikePrice; \n//         pricePerContract = _pricePerContract; \n//         shortCollateral = _shortCollateral; \n//         longCollateral = _longCollateral; \n//         cash = _cash;\n//         tradeTime = block.timestamp+ _tradeTime; \n//         maturityTime = block.timestamp + duration;\n//     }\n\n//     // @notice when buyer buys longZCB, funds are directed to here  triggers the contract to supply to lyra \n//     function deposit() public onlyVault{\n\n//     }\n\n//     /// @notice returns true if the instrument can be approved\n//     /// and funds can be directed from vault. Utilizer must have escrowed\n//     /// to this contract before  \n//     function instrumentApprovalCondition() public override view returns(bool){\n//         return underlying.balanceOf(address(this)) >= longCollateral;\n//     }\n\n//     /// @notice short sell a single batch of call options in lyra \n//     function performsSingleTrade() public \n//    // onlyValidator \n//     {\n//         lyraOp.openPosition(TradeInputParameters memory params)\n//     }\n\n\n//     /// @notice pull out funds back to vault when price deviation exceeds threshold \n//     function invalidateInstrument() public \n//     //onlyValidator\n//     {\n\n//     }\n\n\n\n\n\n\n\n// }\n//If you are indeed a scammer, not difficult to make bots that terrorize your account. I really don't deal well with liars and those who rip people off. \n"
    },
    "contracts/vaults/instrument.sol": {
      "content": "\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.16;\n\nimport \"./vault.sol\";\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport \"../global/types.sol\"; \n\n/// @notice Minimal interface for Vault compatible strategies.\nabstract contract Instrument {\n\n    modifier onlyUtilizer() {\n        require(msg.sender == Utilizer, \"!Utilizer\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == vault.owner() || isValidator[msg.sender], \"!authorized\");\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == address(vault), \"caller must be vault\");\n        _;\n    }\n\n    modifier notLocked() {\n        require(!locked); \n        _; \n    }\n\n    constructor (\n        address _vault,\n        address _Utilizer\n    ) {\n        vault = Vault(_vault);\n        underlying =vault.UNDERLYING();\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \n        Utilizer = _Utilizer;\n    }\n\n\n    ERC20 public underlying;\n    Vault public vault; \n    bool locked; \n    uint256 private constant MAX_UINT = 2**256 - 1;\n    uint256 private maturity_balance; \n    uint256 rawFunds; \n\n    /// @notice address of user who submits the liquidity proposal \n    address public Utilizer; \n    address[] public validators; //set when deployed, but can't be ch\n    mapping(address=>bool) isValidator;\n\n    /**\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\n     */\n    function onMarketApproval(uint256 principal, uint256 yield) virtual external {}\n\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\n        require(_Utilizer != address(0));\n        Utilizer = _Utilizer;\n    }\n\n    // function setValidator(address _validator) external {\n    //     require(msg.sender == vault.owner(), \"Not owner\"); \n    //     validators.push(_validator); \n    //     isValidator[_validator] = true;     \n    // }\n    function setVault(address newVault) external onlyAuthorized {\n        vault = Vault(newVault); \n    }\n\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\n    /// @param amount The amount of underlying tokens to withdraw.\n    /// @return An error code, or 0 if the withdrawal was successful.\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\n        //TODO if this is pool redeemig to vault, need to redeem pool shares \n        return underlying.transfer(address(vault), amount); \n    }\n\n    /// @notice Returns a user's Instrument balance in underlying tokens.\n    /// @param user The user to get the underlying balance of.\n    /// @return The user's Instrument balance in underlying tokens.\n    /// @dev May mutate the state of the Instrument by accruing interest.\n    /// TODO need to incorporate the capital supplied by pool bond issuers\n    function balanceOfUnderlying(address user) public view virtual returns (uint256){\n        if(user == address(this)) return underlying.balanceOf(user) - rawFunds;\n        return underlying.balanceOf(user); \n    }\n\n    /// @notice raw funds should not be harvested by the vault\n    function pullRawFunds(uint256 amount) public {\n        underlying.transferFrom(msg.sender,address(this), amount); \n        rawFunds += amount; \n    }\n\n\n\n    function estimatedTotalAssets() public view virtual returns (uint256){}\n\n\n    /// @notice Free up returns for vault to pull,  checks if the instrument is ready to be withdrawed, i.e all \n    /// loans have been paid, all non-underlying have been liquidated, etc\n    function readyForWithdrawal() public view virtual returns(bool){\n        return true; \n    }\n\n    /// @notice checks whether the vault can withdraw and record profit from this instrument \n    /// for this instrument to resolve \n    /// For creditlines, all debts should be repaid\n    /// for strategies, all assets should be divested + converted to Underlying\n    /// this function is important in preventing manipulations, \n    /// @dev prepareWithdraw->vault.beforeResolve->vault.resolveInstrument in separate txs\n    function prepareWithdraw()\n        external \n        onlyVault \n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        ){\n            require(readyForWithdrawal(), \"not ready to withdraw\"); \n\n            // Lock additional drawdowns or usage of instrument balance \n            lockLiquidityFlow();    \n\n        }\n\n\n    function liquidatePosition(uint256 _amountNeeded) public  virtual returns (uint256 _liquidatedAmount, uint256 _loss){}\n\n\n    function liquidateAllPositions() public  virtual returns (uint256 _amountFreed){}\n\n    function lockLiquidityFlow() internal{\n        locked = true; \n    }\n\n    function isLocked() public view returns(bool){\n        return locked; \n    }\n\n    event LiquidityTransfer(address indexed from ,address indexed to, uint256 amount);\n    function transfer_liq(address to, uint256 amount) internal notLocked {\n        underlying.transfer(to, amount);\n        emit LiquidityTransfer(address(this), to, amount);\n    }\n\n    function transfer_liq_from(address from, address to, uint256 amount) internal notLocked {\n        underlying.transferFrom(from, to, amount);\n        emit LiquidityTransfer(from, to, amount);\n    }\n\n    /// @notice called before resolve, to avoid calculating redemption price based on manipulations \n    function store_internal_balance() external onlyVault{\n\n        maturity_balance = balanceOfUnderlying(address(this)); \n\n    }\n\n    function getMaturityBalance() public view returns(uint256){\n        return maturity_balance; \n    }\n\n    function isLiquid(uint256 amount) public virtual view returns(bool){\n        //TODO \n        console.log('isliquid', balanceOfUnderlying(address(this)), amount); \n        return balanceOfUnderlying(address(this)) >= amount; \n    }\n\n    // function beforeApprove(Vault.InstrumentData memory _instrumentData) onlyVault virtual external  {}\n\n\n    /// @notice Before supplying liquidity from the vault to this instrument,\n    /// which is done automatically when instrument is trusted, \n    /// need to check if certain conditions that are required to this specific \n    /// instrument is met. For example, for a creditline with a collateral \n    /// requirement need to check if this address has the specific amount of collateral\n    /// @dev called to be checked at the approve phase from controller  \n    function instrumentApprovalCondition() public virtual view returns(bool); \n\n    /// @notice fetches how much asset the instrument has in underlying for the given share supply \n    function assetOracle(uint256 supply) public view virtual returns(uint256){}\n}\n\n\n\n \n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\n/// approved borrowers will interact with this contract to borrow, repay. \n/// and vault will supply principal and harvest principal/interest \ncontract CreditLine is Instrument {\n    using FixedPointMathLib for uint256;\n    address public immutable borrower; \n\n    //  variables initiated at creation\n    uint256 principal;\n    uint256 notionalInterest; \n    uint256 faceValue; //total amount due, i.e principal+interest\n    uint256 duration; // normalized to a year 1 means 1 year, 0.5 means 6 month \n    uint256 interestAPR; \n\n    // Modify-able Global Variables during repayments, borrow\n    uint256 public totalOwed; \n    uint256 public principalOwed; \n    uint256 public interestOwed;\n    uint256 public accumulated_interest; \n    uint256 public principalRepayed;\n    uint256 public interestRepayed; \n\n    // Collateral Info \n    enum CollateralType{\n        liquidatable, \n        nonLiquid, \n        ownership,        \n        none\n    }\n    address public collateral; \n    address public oracle; \n    uint256 public collateral_balance; \n    CollateralType public collateral_type; \n\n    uint256 drawdown_block; \n    bool didDrawdown; \n\n    uint256 gracePeriod; \n    uint256 resolveBlock; \n    uint256 constant DUST = 1e18; //1usd\n\n    enum LoanStatus{\n        notApproved,\n        approvedNotDrawdowned,\n        drawdowned, \n        partially_repayed,\n        prepayment_fulfilled, \n        matured, \n        grace_period, \n        isDefault\n    }\n\n    LoanStatus public loanStatus; \n\n    uint256 lastRepaymentTime; \n    uint256 gracePeriodStart; \n    Proxy proxy; \n\n    /// @notice both _collateral and _oracle could be 0\n    /// address if fully uncollateralized or does not have a price oracle \n    /// param _notionalInterest and _principal is initialized as desired variables\n    constructor(\n        address vault,\n        address _borrower, \n        uint256 _principal,\n        uint256 _notionalInterest, \n        uint256 _duration,\n        uint256 _faceValue,\n        address _collateral, //collateral for the dao, could be their own native token or some tokenized revenue \n        address _oracle, // oracle for price of collateral \n        uint256 _collateral_balance, //promised collateral balance\n        uint256 _collateral_type\n    )  Instrument(vault, _borrower) {\n        borrower = _borrower; \n        principal = DUST* _principal; \n        notionalInterest =DUST* _notionalInterest; \n        duration = _duration;   \n        faceValue = DUST*_faceValue;\n\n        collateral = _collateral; \n        oracle = _oracle; \n        collateral_balance = DUST*_collateral_balance; \n        collateral_type = CollateralType(_collateral_type); \n\n        loanStatus = LoanStatus.notApproved; \n\n        proxy = new Proxy(address(this), _borrower); \n    }\n\n    function getCurrentTime() internal view returns(uint256){\n        return block.timestamp + 31536000/2; \n    }\n    function getProxy() public view returns(address){\n        return address(proxy); \n    }\n\n    /// @notice checks if the creditline is ready to be withdrawed, i.e all \n    /// loans have been paid, all non-underlying have been liquidated, etc\n    function readyForWithdrawal() public view override returns(bool){\n        if (loanStatus == LoanStatus.matured || loanStatus == LoanStatus.isDefault\n            || loanStatus == LoanStatus.prepayment_fulfilled) return true; \n        return true; \n        //return false  \n    }\n\n    function getApprovedBorrowConditions() public view returns(uint256, uint256){\n        if (vault.isTrusted(this)) return(principal, notionalInterest) ;\n\n        return (0,0); \n    }\n\n    /// @notice if possible, and borrower defaults, liquidates given collateral to underlying\n    /// and push back to vault. If not possible, push the collateral back to\n    function liquidateAndPushToVault() internal  {}\n    function auctionAndPushToVault() internal {} \n    function isLiquidatable(address collateral) public view returns(bool){}\n\n    /// @notice if collateral is liquidateable and has oracle, fetch value of collateral \n    /// and return ratio to principal \n    function getCollateralRatio() public view returns(uint256){\n\n    }\n    /// @notice After grace period auction off ownership to some other party and transfer the funds back to vault \n    /// @dev assumes collateral has already been transferred to vault, needs to be checked by the caller \n    function liquidateOwnership(address buyer) public virtual onlyAuthorized{\n        // TODO implement auction \n        proxy.changeOwnership(buyer);\n    }\n\n    /// @notice transfers collateral back to vault when default \n    function pushCollateralToVault(uint256 amount, address to) public virtual onlyAuthorized{\n        require(loanStatus == LoanStatus.isDefault); \n        ERC20(collateral).transfer(to, amount); \n    }\n\n\n\n    /// @notice validators have to check these conditions at a human level too before approving \n    function instrumentApprovalCondition() public override view returns(bool){\n        // check if borrower has correct identity \n\n        // check if enough collateral has been added as agreed   \n        if (collateral_type == CollateralType.liquidatable || collateral_type == CollateralType.nonLiquid){\n            require(ERC20(collateral).balanceOf(address(this)) >= collateral_balance, \"Insufficient collateral\"); \n        }\n\n        // // check if validator(s) are set \n        // if (validators.length == 0) {revert(\"No validators\"); }\n\n        // Check if proxy has been given ownership\n        if (collateral_type == CollateralType.ownership && proxy.numContracts() == 0) revert(\"Ownership \"); \n\n        return true; \n    } \n\n    event DepositCollateral(uint256 amount);\n    /// @notice borrower deposit promised collateral  \n    function depositCollateral(uint256 amount) external onlyUtilizer {\n        require(collateral!= address(0)); \n        ERC20(collateral).transferFrom(msg.sender, address(this), amount); \n        emit DepositCollateral(amount);\n    }\n\n    /// @notice can only redeem collateral when debt is fully paid \n    function releaseAllCollateral() internal {\n        require(loanStatus == LoanStatus.matured || loanStatus == LoanStatus.prepayment_fulfilled, \"Loan status err\"); \n\n        ERC20(collateral).transfer(msg.sender,collateral_balance); \n    }\n\n\n\n    /// @notice should only be called when (portion of) principal is repayed\n    function adjustInterestOwed() internal {\n\n        uint256 remainingDuration = (drawdown_block + toSeconds(duration)) - getCurrentTime();\n\n        interestOwed = interestAPR.mulWadDown(toYear(remainingDuration).mulWadDown(principalOwed)); \n    }\n\n    /// @param quoted_yield is in notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \n    /// where area under curve is max_principal \n    function onMarketApproval(uint256 max_principal, uint256 quoted_yield) external override onlyVault {\n        principal = max_principal; \n        notionalInterest = quoted_yield; //this accounts for duration as well\n        interestAPR = quoted_yield.divWadDown(duration.mulWadDown(principal)); \n\n        loanStatus = LoanStatus.approvedNotDrawdowned;\n    }\n\n    function onMaturity() external onlyUtilizer {\n        require(loanStatus == LoanStatus.prepayment_fulfilled || loanStatus == LoanStatus.matured,\"Not matured\"); \n        require(block.number > resolveBlock, \"Block equal\"); \n\n        if (collateral_type == CollateralType.liquidatable || collateral_type == CollateralType.nonLiquid ){\n            releaseAllCollateral(); \n        }\n\n        else proxy.changeOwnership(borrower);\n        \n        bool isPrepaid = loanStatus == LoanStatus.prepayment_fulfilled? true:false;\n        // Write to storage resolve details (principal+interest repaid, is prepaid, etc) \n        vault.pingMaturity(address(this), isPrepaid); \n\n    }\n\n    /// @notice borrower can see how much to repay now starting from last repayment time, also used to calculated\n    /// how much interest to repay for the current principalOwed, which can be changed \n    function interestToRepay() public view returns(uint256){\n\n        // Normalized to year\n        uint256 elapsedTime = toYear(getCurrentTime() - lastRepaymentTime);\n        // Owed interest from last timestamp till now  + any unpaid interest that has accumulated\n        return elapsedTime.mulWadDown(interestAPR.mulWadDown(principalOwed)) + accumulated_interest ; \n    }\n\n    event Drawdown(uint256 amount);\n    /// @notice Allows a borrower to borrow on their creditline.\n    /// This creditline allows only lump sum drawdowns, all approved principal needs to be borrowed\n    /// which would start the interest timer \n    function drawdown() external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n        require(loanStatus == LoanStatus.approvedNotDrawdowned, \"Already borrowed\"); \n        loanStatus = LoanStatus.drawdowned; \n\n        drawdown_block = block.timestamp; \n        lastRepaymentTime = block.timestamp;//-31536000/2; \n\n        totalOwed = principal + notionalInterest; \n        principalOwed = principal; \n        interestOwed = notionalInterest;\n\n        transfer_liq(msg.sender, principal); \n\n        emit Drawdown(principal);\n    }\n\n    event Repay(uint256 amount);\n    /// @notice allows a borrower to repay their loan\n    /// Standard repayment structure is repaying interest for the owed principal periodically and\n    /// whenever principal is repayed interest owed is decreased proportionally \n    function repay( uint256 _repay_amount) external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n\n        uint256 owedInterest = interestToRepay(); \n        uint256 repay_principal; \n        uint256 repay_interest = _repay_amount; \n\n        // Push remaineder to repaying principal \n        if (_repay_amount >= owedInterest){\n            repay_principal += (_repay_amount - owedInterest);  \n            repay_interest = owedInterest; \n            accumulated_interest = 0; \n        }\n\n        //else repay_amount is less than owed interest, accumulate the debt \n        else accumulated_interest = owedInterest - repay_interest;\n\n        if(handleRepay(repay_principal, repay_interest)){\n\n            // Save resolve block, so that onMaturity can be called later\n            resolveBlock = block.number; \n\n            // Prepayment //TODO cases where repayed a significant portion at the start but paid rest at maturity date\n            if (isPaymentPremature()) loanStatus = LoanStatus.prepayment_fulfilled; \n\n            // Repayed at full maturity \n            else loanStatus = LoanStatus.matured; \n\n        }\n\n        lastRepaymentTime = getCurrentTime();  \n\n        transfer_liq_from(msg.sender, address(this), _repay_amount);\n\n        emit Repay(_repay_amount);\n\n    }   \n\n    /// @notice updates balances after repayment\n    /// need to remove min.\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal returns(bool){\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \n        principalOwed -= Math.min(repay_principal, principalOwed);\n        interestOwed -= Math.min(repay_interest, interestOwed);\n\n        principalRepayed += repay_principal;\n        interestRepayed += repay_interest; \n        if (repay_principal > 0) adjustInterestOwed(); \n\n        bool fullyRepayed = (principalOwed == 0 && interestOwed == 0)? true : false; \n        return fullyRepayed; \n    }\n\n    function setGracePeriod() external {}\n\n    /// @notice callable by anyone \n    function beginGracePeriod() external {\n       // require(block.timestamp >= drawdown_block + toSeconds(duration), \"time err\"); \n        require(principalOwed > 0 && interestOwed > 0, \"repaid\"); \n        gracePeriodStart = block.timestamp; \n        loanStatus = LoanStatus.grace_period; \n    }\n\n    function declareDefault() external onlyAuthorized {\n       // require(gracePeriodStart + gracePeriod >= block.timestamp);\n        require(loanStatus == LoanStatus.grace_period); \n\n        loanStatus = LoanStatus.isDefault; \n    }\n\n    /// @notice should be called  at default by validators\n    /// calling this function will go thorugh the necessary process\n    /// to recoup bad debt, and will push the remaining funds to vault\n    function onDefault() external onlyAuthorized{\n        require(loanStatus == LoanStatus.isDefault); \n\n        // If collateral is liquidateable, liquidate at dex and push to vault\n        if (isLiquidatable(collateral)) {\n            liquidateAndPushToVault(); //TODO get pool \n        }\n\n        // Else for non liquid governance tokens or ownership, should auction off \n        else {\n            auctionAndPushToVault(); \n        }\n\n        //Testing purposes only \n        underlying.transferFrom(msg.sender, address(this), principal/2); \n\n    }\n\n    /// @notice when principal/interest owed becomes 0, need to find out if this is prepaid\n    function isPaymentPremature() internal returns(bool){\n        // bool timeCondition = getCurrentTime() <= drawdown_block + toSeconds(duration); \n        bool amountCondition = (principal+notionalInterest) > (principalRepayed + interestRepayed) + DUST; \n\n        // timeCondition implies amountCondition, but not the other way around \n        return amountCondition; \n    }\n\n\n    function toYear(uint256 sec) internal pure returns(uint256){\n        return (sec*1e18)/uint256(31536000); \n    }\n\n    function toSeconds(uint256 y) internal pure returns(uint256){\n        return uint256(31536000).mulWadDown(y); \n    }\n\n    function getRemainingOwed() public view returns(uint256, uint256){\n        return(principalOwed, interestOwed); \n    }\n\n    function getCurrentLoanStatus() public view returns(uint256){}\n\n\n\n\n\n}\n\n\ncontract Proxy{\n    address owner; \n    address delegator; \n\n    address[] public ownedContracts;\n    mapping(address=>bytes4) public ownerTransferFunctions; \n    mapping(address=>bool) public isValidContract; \n\n    /// @notice owner is first set to be the instrument contract\n    /// and is meant to be changed back to the borrower or whoever is\n    /// buying the ownership \n    constructor(address _owner, address _delegator){\n        owner = _owner; \n        delegator = _delegator; \n\n    }\n\n    function changeOwnership(address newOwner) external {\n        require(msg.sender == owner, \"Not owner\"); \n        owner = newOwner; \n    }\n\n    function numContracts() public view returns(uint256){\n        return ownedContracts.length; \n    }\n\n    /// @notice temporarily delegate ownership of relevant contract \n    /// to this address, and stores the ownership transfering function\n    /// called when initialized\n    /// @param ownershipFunction is selector of the functions that transfers\n    /// ownership \n    /// @dev called by the borrower during assessment, after they had given ownership \n    /// of the contract to this address first, \n    /// but ownerTransferfunction/contract needs to be checked before approval by the validators\n    /// Validators are responsible for checking if there isn't any other ownership transferring functions \n    /// and check that the contract is legit, and think ways that the borrower can game the system. \n    function delegateOwnership(\n        address _contract, \n        bytes4 ownershipFunction) external \n    {\n        ownedContracts.push(_contract); \n        isValidContract[_contract] = true; \n        ownerTransferFunctions[_contract] = ownershipFunction; \n\n    }\n\n    /// @notice transfers ownership to borrower or any other party if necessary\n    function grantOwnership(\n        address _contract, \n        address newOwner,\n        bytes calldata data, \n        bool isSingleArgument) external{   \n        require(msg.sender == owner);\n        require(isValidContract[_contract]);\n        if(newOwner != address(this)) isValidContract[_contract] = false; \n\n        if(isSingleArgument){\n            (bool success, ) = _contract.call(\n                abi.encodeWithSelector(\n                    ownerTransferFunctions[_contract], \n                    newOwner\n                )\n            );  \n            require(success, \"!success\"); \n        }\n\n        else{\n            require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \"func not allowed\"); \n            (bool success, ) = _contract.call(data);\n            require(success, \"!success\"); \n\n        }\n    }\n\n    /// @notice function that ownership delegators use to call functions \n    /// in their contract other than the transferFunction contract \n    function proxyFunc(address _contract, bytes calldata data) external{\n        require(msg.sender == delegator); \n        require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \"func not allowed\"); \n\n        (bool success, ) = _contract.call(data); \n        require(success, \"!success\"); \n\n    }\n\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\n        if (inBytes.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            outBytes4 := mload(add(inBytes, 4))\n        }\n    }\n\n    function getOwner() public view returns(address){\n        return owner; \n    }\n}\n\n\ncontract MockBorrowerContract{\n\n    address public owner; \n    constructor(){\n        owner = msg.sender;  \n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == owner, \"notowner\"); \n        owner = newOwner; \n    } \n\n    function onlyOwnerFunction(uint256 a) public {\n        console.log('msgsender', msg.sender, owner); \n        require(msg.sender == owner, \"notowner\"); \n        console.log('hello', a); \n    }\n\n    function autoDelegate(address proxyad) public {\n        Proxy(proxyad).delegateOwnership(address(this), this.changeOwner.selector); \n    }\n    fallback () external {\n        console.log('hi?'); \n    }\n}\n"
    },
    "contracts/vaults/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\n// import {ERC20} from \"../../ERC20/ERC20.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    uint immutable underlying_decimals; \n    uint8 constant default_decimals = 18; \n    bool public decimal_mismatch; \n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, default_decimals) {\n        asset = _asset;\n\n        underlying_decimals = _asset.decimals(); \n        decimal_mismatch = (_asset.decimals() != default_decimals);\n        if(decimal_mismatch) assert(_asset.decimals() < default_decimals);  \n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function burn(uint256 shares) public virtual {\n        _burn(msg.sender, shares);\n    }\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \n                : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if(decimal_mismatch) shares = decSharesToAssets(shares); \n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \n                : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \n                : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \n\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \n                : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    function decAssetsToShares(uint256 assets) public view virtual returns(uint256) {\n        return assets * (10 ** (default_decimals - underlying_decimals)); \n    }\n\n    function decSharesToAssets(uint256 shares) public view virtual returns(uint256){\n        return shares / (10**(default_decimals - underlying_decimals)); \n    }\n}\n"
    },
    "contracts/vaults/nftLending.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport \"./vault.sol\";\n// import {ERC20} from \"./tokens/ERC20.sol\";\n// import {ERC4626} from \"./mixins/ERC4626.sol\"; \nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\n// import {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"lib/forge-std/src/console.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {ERC721} from \"./tokens/ERC721.sol\"; \n\n// Need to be \n// 1. quick to borrow\n// 2. can add new nft to borrow through longZCB governance \n// 3. managers underwrite and absorb loss \n// 4. liquidatation thorugh auctions or managers buy \n// 5. \n// THINK of a system where managers approve a criterion and profit\n// from all investment from these criterion. \n// Instance generated for a new ERC721 \n\n/// @notice people can submit an NFT collateral\n/// from a predtermined set\ncontract SimpleNFTPool is Instrument, ERC4626{\n\n    using FixedPointMathLib for uint256; \n\n    constructor(\n        address _vault,\n        address _utilizer, \n        address _underlying \n        \n        ) Instrument(_vault, _utilizer) ERC4626(ERC20(_underlying),\"Mock\", \"Mock\" ){\n        utilizer = _utilizer; \n        underlying = ERC20(_underlying); // already specified \n        \n    }\n\n    mapping(bytes32=> bool )public  accepted; \n    bytes32[] acceptedList; \n    address public utilizer;  \n\n    function borrowAllowed() public returns(bool){\n        return true; \n    }\n    function totalAssets() public view override returns (uint256){\n        return asset.balanceOf(address(this)); \n    }\n    function borrow(\n        address tokenAddress,\n        uint256 tokenId, \n        uint256 borrowAmount) external{\n        borrowAllowed();\n        require(accepted[keccak256(abi.encodePacked(tokenAddress, tokenId))], \"Unaccepted\"); \n\n        ERC721(tokenAddress).transferFrom(msg.sender, address(this), tokenId); \n        ERC20(underlying).transfer(msg.sender, borrowAmount ); \n\n    }\n\n    function repay(\n        address tokenAddress,\n        uint256 tokenId, \n        uint256 repayAmount\n        ) external{\n        require(accepted[keccak256(abi.encodePacked(tokenAddress, tokenId))], \"Unaccepted\"); \n        ERC20(underlying).transferFrom(msg.sender, address(this), repayAmount); \n        ERC721(tokenAddress).transferFrom(address(this), msg.sender, tokenId); \n    }\n\n    function addAcceptableCollateral(address tokenAddress, uint256 tokenId) external{\n        bytes32 key = keccak256(abi.encodePacked(tokenAddress, tokenId)); \n        accepted[key] = true;\n        acceptedList.push(key); \n    }\n\n    function instrumentApprovalCondition() public override view returns(bool){\n        return true; \n    }\n\n\n    \n\n}  \n\n\n\n\n\n\n\n\n\n\n"
    },
    "contracts/vaults/pvault.sol": {
      "content": "pragma solidity ^0.8.4;\n\n    struct ResolveVar{\n        uint256 endBlock; \n        bool isPrepared; \n    }\n// import {Auth} from \"./auth/Auth.sol\";\n// import {ERC4626} from \"./mixins/ERC4626.sol\";\n\n// import {SafeCastLib} from \"./utils/SafeCastLib.sol\";\n// import {SafeTransferLib} from \"./utils/SafeTransferLib.sol\";\n// import {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\n\n// import {ERC20} from \"./tokens/ERC20.sol\";\n// import {Instrument} from \"./instrument.sol\";\n// import {Controller} from \"../protocol/controller.sol\";\n// import {MarketManager} from \"../protocol/marketmanager.sol\"; \n// import \"openzeppelin-contracts/utils/math/Math.sol\";\n// import \"forge-std/console.sol\";\n\n// /// @notice Vault where its instrument is lending for investors to mint\n// /// vaults with leverage. No l\n// contract LeverageVault is ERC4626{\n//     using SafeCastLib for uint256; \n//     using SafeTransferLib for ERC20;\n//     using FixedPointMathLib for uint256;\n\n//     uint256 internal BASE_UNIT;\n//     uin\n// }\n// contract LeverageVault is ERC4626, Auth{\n//     using SafeCastLib for uint256; \n//     using SafeTransferLib for ERC20;\n//     using FixedPointMathLib for uint256;\n\n\n//     event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n//     event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n//     event InstrumentTrusted(address indexed user, Instrument indexed instrument);\n//     event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\n//     event InstrumentHarvest(address indexed instrument, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\n\n//     /*///////////////////////////////////////////////////////////////\n//                                  CONSTANTS\n//     //////////////////////////////////////////////////////////////*/\n\n//     uint256 internal BASE_UNIT;\n//     uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\n//     ERC20 public immutable UNDERLYING;\n//     Controller private controller;\n//     MarketManager.MarketParameters default_params; \n\n//     ///// For Factory\n//     bool public onlyVerified; \n//     uint256 public r; //reputation ranking  \n//     uint256 public asset_limit; \n//     uint256 public total_asset_limit; \n\n//     mapping(Instrument => InstrumentData) public instrument_data;\n//     mapping(address => uint256) public  num_proposals;\n//     mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\n//     mapping(uint256 => bool) resolveBeforeMaturity;\n//     mapping(uint256=>ResolveVar) prepareResolveBlock;\n\n//     enum InstrumentType {\n//         CreditLine,\n//         CoveredCall,\n//         Other\n//     }\n\n//     /// @param trusted Whether the Instrument is trusted.\n//     /// @param balance The amount of underlying tokens held in the Instrument.\n//     struct InstrumentData {\n//         // Used to determine if the Vault will operate on a Instrument.\n//         bool trusted;\n//         // Balance of the contract denominated in Underlying, \n//         // used to determine profit and loss during harvests of the Instrument.  \n//         // represents the amount of debt the Instrument has incurred from this vault   \n//         uint256 balance; // in underlying\n//         uint256 faceValue; // in underlying\n//         uint256 marketId;\n//         uint256 principal; //this is total available allowance in underlying\n//         uint256 expectedYield; // total interest paid over duration in underlying\n//         uint256 duration;\n//         string description;\n//         address Instrument_address;\n//         InstrumentType instrument_type;\n//         uint256 maturityDate;\n//     }\n\n//     struct ResolveVar{\n//         uint256 endBlock; \n//         bool isPrepared; \n//     }\n\n//     constructor(\n//         address _UNDERLYING,\n//         address _controller, \n//         address owner, \n\n//         bool _onlyVerified, //\n//         uint256 _r, //reputation ranking\n//         uint256 _asset_limit, \n//         uint256 _total_asset_limit,\n\n//         MarketManager.MarketParameters memory _default_params\n\n//     )\n//         ERC4626(\n//             ERC20(_UNDERLYING),\n//             string(abi.encodePacked(\"debita \", ERC20(_UNDERLYING).name(), \" Vault\")),\n//             string(abi.encodePacked(\"db\", ERC20(_UNDERLYING).symbol()))\n//         )  Auth(owner)\n\n//     {\n//         UNDERLYING = ERC20(_UNDERLYING);\n//         //BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\n//         BASE_UNIT = 10**18; \n//         controller = Controller(_controller);\n//         set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \n//         default_params = _default_params; \n//         //totalSupply = type(uint256).max;\n//     }\n\n//     function getInstrumentType(uint256 marketId) public view returns(uint256){\n//         // return 0 if credit line //TODO \n//         return 0; \n//     }\n\n//     function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\n//         return instrument_data[_instrument];\n//     }\n    \n//     modifier onlyController(){\n//         require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \"is not controller\"); \n//         _;\n//     }\n\n//     /// @notice called by controller at maturity \n//     function controller_burn(uint256 amount, address bc_address) external onlyController {\n//         _burn(bc_address,amount); \n//     }\n//     /// @notice called by controller at maturity, since redeem amount > balance in bc\n//     function controller_mint(uint256 amount, address to) external onlyController {\n//         _mint(to , amount); \n//     }\n//     /// @notice amount is always in WAD, so need to convert if decimals mismatch\n//     function trusted_transfer(uint256 amount, address to) external onlyController{\n//         if (decimal_mismatch) amount = decSharesToAssets(amount); \n//         UNDERLYING.transfer(to, amount); \n//     }\n\n//     function balanceInUnderlying(address ad) external view returns(uint256){\n//         return previewRedeem(balanceOf[ad]); \n//     }\n\n//     /// @notice burns all balance of address \n//     function burnAll(address to) private{\n//       _burn(to, balanceOf[to]); \n//     }\n\n//     /// @notice Harvest a trusted Instrument, records profit/loss \n//     function harvest(address instrument) public {\n//         require(instrument_data[Instrument(instrument)].trusted, \"UNTRUSTED_Instrument\");\n//         InstrumentData storage data = instrument_data[Instrument(instrument)]; \n\n//         uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n        \n//         uint256 balanceLastHarvest = data.balance;\n        \n//         uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\n        \n//         if (balanceLastHarvest == balanceThisHarvest) {\n//             return;\n//         }\n        \n//         data.balance = balanceThisHarvest;\n\n//         uint256 delta;\n       \n//         bool net_positive = balanceThisHarvest >= balanceLastHarvest;\n        \n//         delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\n\n//         totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\n\n//         emit InstrumentHarvest(instrument, balanceThisHarvest, delta, net_positive);\n//     }\n\n//     /// @notice Deposit a specific amount of float into a trusted Instrument.\n//     /// Called when market is approved. \n//     /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n//     function depositIntoInstrument(uint256 marketId, uint256 underlyingAmount) internal{\n//       Instrument instrument = fetchInstrument(marketId); \n//       require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n\n//       if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n//       if (underlyingAmount > UNDERLYING.balanceOf(address(this))) revert(\"Not enough bal in vault\"); \n//       console.log('deposit amount and current balance', underlyingAmount, UNDERLYING.balanceOf(address(this)));\n\n//       totalInstrumentHoldings += underlyingAmount; \n\n//       instrument_data[instrument].balance += underlyingAmount;\n\n//       require(UNDERLYING.transfer(address(instrument), underlyingAmount), \"DEPOSIT_FAILED\");\n\n//       emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\n//     }\n\n//     /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n//     function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) internal {\n//       require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n      \n//       if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n//       instrument_data[instrument].balance -= underlyingAmount;\n      \n//       totalInstrumentHoldings -= underlyingAmount;\n      \n//       require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n      \n//       emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\n\n//     }\n\n//     /// @notice Stores a Instrument as trusted when its approved\n//     function trustInstrument(uint256 marketId, Controller.ApprovalData memory data) external onlyController{\n//       instrument_data[fetchInstrument(marketId)].trusted = true;\n\n//       //Write to storage \n//       InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \n//       instrumentData.principal = data.approved_principal; \n//       instrumentData.expectedYield = data.approved_yield;\n//       instrumentData.faceValue = data.approved_principal + data.approved_yield; \n\n//       depositIntoInstrument(marketId, data.approved_principal);\n    \n//       setMaturityDate(marketId);\n\n//       fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \n//     }\n\n//     /// @notice Stores a Instrument as untrusted\n//     function distrustInstrument(Instrument instrument) external onlyController {\n//       instrument_data[instrument].trusted = false; \n//     }\n\n\n//     /// @notice returns true if Instrument is approved\n//     function isTrusted(Instrument instrument) public view returns(bool){\n//       return instrument_data[instrument].trusted; \n//     }\n\n//     /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n//     function totalAssets() public view override returns(uint256){\n//       return totalInstrumentHoldings + totalFloat();\n//     }\n\n//     function utilizationRate() public view returns(uint256){\n\n//         if (totalInstrumentHoldings==0) return 0;  \n//         return totalInstrumentHoldings.divWadDown(totalAssets()); \n\n//     }\n//     function totalFloat() public view returns (uint256) {\n//         return UNDERLYING.balanceOf(address(this));\n//     }\n\n//     function fetchInstrument(uint256 marketId) public view returns(Instrument){\n//       return Instruments[marketId]; \n//     }\n\n//     function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n//         return instrument_data[Instruments[marketId]];\n//     }\n//     /**\n//      called on market denial + removal, maybe no chekcs?\n//      */\n//     function removeInstrument(uint256 marketId) internal {\n//         InstrumentData storage data = instrument_data[Instruments[marketId]];\n//         require(data.marketId > 0, \"instrument doesn't exist\");\n//         delete instrument_data[Instruments[marketId]];\n//         delete Instruments[marketId];\n//         // emit event here;\n//     }\n\n\n\n//     /// @notice add instrument proposal created by the Utilizer \n//     /// @dev Instrument instance should be created before this is called\n//     /// need to add authorization\n//     function addProposal(\n//         InstrumentData memory data\n//     ) external onlyController {\n//         require(data.principal > 0, \"principal must be greater than 0\");\n//         require(data.duration > 0, \"duration must be greater than 0\");\n//         require(data.faceValue > 0, \"faceValue must be greater than 0\");\n//         require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); \n//         require(data.marketId > 0, \"must be valid instrument\");\n\n//         num_proposals[msg.sender] ++; \n\n//         instrument_data[Instrument(data.Instrument_address)] = (\n//           InstrumentData(\n//             false, \n//                 0, \n//                 data.faceValue, \n//                 data.marketId, \n//                 data.principal, \n//                 data.expectedYield, \n//                 data.duration, \n//                 data.description, \n//                 data.Instrument_address,\n//                 data.instrument_type,\n//                 0\n//             )\n//         ); \n\n//         Instruments[data.marketId] = Instrument(data.Instrument_address);\n//         assert(data.marketId !=0); \n//     }\n\n//     /**\n//      @notice called by controller on approveMarket.\n//      */\n//     function setMaturityDate(uint256 marketId) internal {\n\n//         instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n//     }\n\n//     /// @notice function called when instrument resolves from within\n//     function pingMaturity(address instrument, bool premature) external {\n//         require(msg.sender == instrument || isTrusted(Instrument(instrument))); \n//         uint256 marketId = instrument_data[Instrument(instrument)].marketId; \n//         beforeResolve(marketId); \n//         resolveBeforeMaturity[marketId] = premature; \n//     }\n\n\n//     /// @notice RESOLVE FUNCTION #1\n//     /// Checks if instrument is ready to be resolved and locks capital.\n//     /// records blocknumber such that resolveInstrument is called after this function \n//     /// records balances+PnL of instrument\n//     /// @dev need to store internal balance that is used to calculate the redemption price \n//     function beforeResolve(uint256 marketId) public {\n//         Instrument _instrument = Instruments[marketId]; \n\n//         require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n//         require(isTrusted( _instrument), \"Not trusted\"); \n\n//         // Should revert if can't be resolved \n//         _instrument.prepareWithdraw(); \n\n//         // Record profit/loss used for calculation of redemption price \n//         harvest(address(_instrument));\n\n//         _instrument.store_internal_balance(); \n//         prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \n//       }\n\n//     /// @notice RESOLVE FUNCTION #2\n//     /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \n//     /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\n//     function resolveInstrument(\n//         uint256 marketId\n//     ) external onlyController\n//     returns(bool, uint256, uint256, bool) {\n//         Instrument _instrument = Instruments[marketId];\n//         ResolveVar memory rvar = prepareResolveBlock[marketId]; \n//         require(_instrument.isLocked(), \"Not Locked\");\n//         require(rvar.isPrepared && rvar.endBlock < block.number, \"can't resolve\"); \n\n//         uint256 bal = UNDERLYING.balanceOf(address(this)); \n//         uint256 instrument_balance = _instrument.getMaturityBalance(); \n\n//         InstrumentData memory data = instrument_data[_instrument];\n\n//         bool prematureResolve = resolveBeforeMaturity[marketId]; \n//         bool atLoss; \n//         uint256 total_loss; \n//         uint256 extra_gain; \n\n//         // If resolved at predetermined maturity date, loss is defined by\n//         // the event the instrument has paid out all its yield + principal \n//         if (!prematureResolve){\n//             atLoss = instrument_balance < data.faceValue;\n//             total_loss = atLoss ? data.faceValue - instrument_balance : 0;\n//             extra_gain = !atLoss ? instrument_balance - data.faceValue : 0;\n//             console.log(data.faceValue);  \n//         }\n\n//         // If resolved before predetermined maturity date, loss is defined by \n//         // the event the instrument has balance less then principal \n//         else {\n//             atLoss = instrument_balance < data.principal; \n//             total_loss = atLoss? data.principal - instrument_balance :0; \n//         }\n\n//         withdrawFromInstrument(_instrument, instrument_balance);\n//         removeInstrument(data.marketId);\n\n//         return(atLoss, extra_gain, total_loss, prematureResolve); \n//     }\n\n//     /// @notice when market resolves, send back pulled collateral from managers \n//     function repayDebt(address to, uint256 amount) external onlyController{\n//         UNDERLYING.transfer(to, amount); \n//     }\n\n//     /**\n//      called on market denial by controller.\n//      */\n//     function denyInstrument(uint256 marketId) external onlyController {\n//         InstrumentData storage data = instrument_data[Instruments[marketId]];\n\n//         require(marketId > 0 && data.Instrument_address != address(0), \"invalid instrument\");\n\n//         require(!data.trusted, \"can't deny approved instrument\");\n        \n//         removeInstrument(marketId);\n//     }\n\n\n//     function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\n//       return Instruments[marketId].instrumentApprovalCondition(); \n//     }\n\n\n//     /// TODO \n//     function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\n//       return amount; \n//     }\n\n\n//     /// @notice types of restrictions are: \n//     /// a) verified address b) reputation scores \n//     function receiver_conditions(address receiver) public view returns(bool){\n//         return true; \n//     }\n\n//     /// @notice called when constructed, params set by the creater of the vault \n//     function set_minting_conditions(\n//       bool _onlyVerified, \n//       uint256 _r, \n//       uint256 _asset_limit,\n//       uint256 _total_asset_limit) internal{\n//         onlyVerified = _onlyVerified; \n//         r = _r; \n//         asset_limit = _asset_limit; \n//         total_asset_limit = _total_asset_limit; \n//     } \n\n\n//     function get_vault_params() public view returns(MarketManager.MarketParameters memory){\n//       return default_params; \n//     }\n\n\n//     function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n//       require(enoughLiqudity(assets), \"Not enough liqudity in vault\"); \n\n//     }\n\n//     /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\n//     /// (excluding those supplied to existing instruments)\n//     /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\n//     /// should be (soft)maxed and tunable by a parameter \n//     function enoughLiqudity(uint256 amounts) public view returns(bool){\n//         return (UNDERLYING.balanceOf(address(this)) >= amounts); \n//     }\n\n\n//     /// @notice function that closes instrument prematurely \n//     function closeInstrument(uint256 marketId) external onlyController{\n//       Instrument instrument = fetchInstrument( marketId); \n\n//       // If instrument has non-underlying tokens, liquidate them first. \n//       instrument.liquidateAllPositions(); \n\n//     }\n\n//     function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\n//         InstrumentData memory data = instrument_data[Instruments[marketId]];\n//         return (data.principal, data.expectedYield); \n//     }\n\n//     /// @notice a minting restrictor is set for different vaults \n//     function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\n//         if (!receiver_conditions(receiver)) revert(\"Minting Restricted\"); \n//         assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n//         // Need to transfer before minting or ERC777s could reenter.\n//         asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n//         _mint(receiver, shares);\n\n//         emit Deposit(msg.sender, receiver, assets, shares);\n\n//         afterDeposit(assets, shares);\n//     }\n\n\n//     /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \n//      function redeem(\n//         uint256 shares,\n//         address receiver,\n//         address owner\n//     ) public virtual override returns (uint256 assets) {\n//         if (msg.sender != owner) {\n//             uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n//             if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n//         }\n\n//         // Check for rounding error since we round down in previewRedeem.\n//         require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n//         beforeWithdraw(assets, shares);\n\n//         assets = deduct_withdrawal_fees(assets); \n\n//         _burn(owner, shares);\n\n//         emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n//         asset.safeTransfer(receiver, assets);\n//     }\n\n\n\n// //deprecated\n//     /// @notice RESOLVE FUNCTION #1\n//     /// checks if instrument is ready to be resolved\n//     /// and locks capital inside the instrument \n//     /// @dev resolving is separated into three tx \n//     /// prepareResolve->beforeResolve->resolveinstrument\n//     function prepareResolve(uint256 marketId) public {\n//         Instrument _instrument = Instruments[marketId]; \n\n//         require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n//         require(isTrusted( _instrument), \"Not trusted\"); \n\n//         // This will check if instrument is ready to be resolved (i.e all debts payed, investments liquidated, etc)\n//         // and lock further drawdowns or usage of capital \n//         _instrument.prepareWithdraw(); \n//     }\n\n// }"
    },
    "contracts/vaults/tokens/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/vaults/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/vaults/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/vaults/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "contracts/vaults/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "contracts/vaults/utils/CREATE3.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Bytes32AddressLib} from \"./Bytes32AddressLib.sol\";\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    using Bytes32AddressLib for bytes32;\n\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\n    //--------------------------------------------------------------------------------//\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\n    //--------------------------------------------------------------------------------//\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\n    // 0x52       |  0x52                 | MSTORE           |                        //\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\n    // 0xf3       |  0xf3                 | RETURN           |                        //\n    //--------------------------------------------------------------------------------//\n    bytes internal constant PROXY_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\n\n    function deploy(\n        bytes32 salt,\n        bytes memory creationCode,\n        uint256 value\n    ) internal returns (address deployed) {\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\n\n        address proxy;\n        assembly {\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\n        }\n        require(proxy != address(0), \"DEPLOYMENT_FAILED\");\n\n        deployed = getDeployed(salt);\n        (bool success, ) = proxy.call{value: value}(creationCode);\n        require(success && deployed.code.length != 0, \"INITIALIZATION_FAILED\");\n    }\n\n    function getDeployed(bytes32 salt) internal view returns (address) {\n        address proxy = keccak256(\n            abi.encodePacked(\n                // Prefix:\n                bytes1(0xFF),\n                // Creator:\n                address(this),\n                // Salt:\n                salt,\n                // Bytecode hash:\n                PROXY_BYTECODE_HASH\n            )\n        ).fromLast20Bytes();\n\n        return\n            keccak256(\n                abi.encodePacked(\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n                    hex\"d6_94\",\n                    proxy,\n                    hex\"01\" // Nonce of the proxy contract (1)\n                )\n            ).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/vaults/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/vaults/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "contracts/vaults/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/vaults/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/vaults/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    },
    "contracts/vaults/vault.sol": {
      "content": "pragma solidity ^0.8.16;\n\nimport {Auth} from \"./auth/Auth.sol\";\nimport {ERC4626} from \"lib/solmate/src/mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"lib/solmate/src/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"lib/solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"lib/solmate/src/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {PoolInstrument} from \"../instruments/poolInstrument.sol\";\nimport {Controller} from \"../protocol/controller.sol\";\nimport {MarketManager} from \"../protocol/marketmanager.sol\"; \nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"lib/forge-std/src/console.sol\";\n\nimport \"../global/types.sol\"; \n\n\ncontract Vault is ERC4626{\n    using SafeCastLib for uint256; \n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n\n    /*///////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal BASE_UNIT;\n    uint256 public totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\n    ERC20 public immutable UNDERLYING;\n    Controller private controller;\n    MarketParameters default_params; \n    string public description;\n\n    ///// For Factory\n    bool public onlyVerified; \n    uint256 public r; //reputation ranking  \n    uint256 public asset_limit; \n    uint256 public total_asset_limit; \n\n    mapping(Instrument => InstrumentData) public instrument_data;\n    // mapping(address => uint256) public  num_proposals;\n    mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\n    mapping(uint256 => bool) resolveBeforeMaturity;\n    mapping(uint256=>ResolveVar) prepareResolveBlock;\n\n    enum InstrumentType {\n        CreditLine,\n        CoveredCallShort,\n        LendingPool, \n        StraddleBuy,\n        LiquidityProvision, \n        Other\n    }\n\n    address public owner; \n\n    constructor(\n        address _UNDERLYING,\n        address _controller, \n        address _owner,\n        bytes memory _configData,\n        MarketParameters memory _default_params\n    )\n        ERC4626(\n            ERC20(_UNDERLYING),\n            string(abi.encodePacked(\"Ramm \", ERC20(_UNDERLYING).name(), \" Vault\")),\n            string(abi.encodePacked(\"RAMM\", ERC20(_UNDERLYING).symbol()))\n        )  \n\n    {\n          \n        (\n            bool _onlyVerified, \n            uint256 _r, \n            uint256 _asset_limit, \n            uint256 _total_asset_limit,\n            string memory _description\n        ) = abi.decode(_configData, (bool, uint256, uint256, uint256, string));\n        description = _description;\n        owner = _owner; \n        UNDERLYING = ERC20(_UNDERLYING);\n        require(UNDERLYING.decimals() == 18, \"decimals\"); \n        BASE_UNIT = 1e18; \n        controller = Controller(_controller);\n        //set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \n        onlyVerified = _onlyVerified; \n        r = _r; \n        asset_limit = _asset_limit; \n        total_asset_limit = _total_asset_limit; \n        default_params = _default_params; \n    }\n\n    function getInstrumentType(uint256 marketId) public view returns(uint256){\n        // return 0 if credit line //TODO \n        return 0; \n    }\n\n    function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\n        return instrument_data[_instrument];\n    }\n    \n    function _onlyController() view internal {\n        require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \"is not controller\"); \n    }\n\n    modifier onlyController(){\n        _onlyController();\n        _;\n    }\n\n    /// @notice called by controller at maturity \n    // function controller_burn(uint256 amount, address bc_address) external onlyController {\n    //     _burn(bc_address,amount); \n    // }\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\n    // function controller_mint(uint256 amount, address to) external onlyController {\n    //     _mint(to , amount); \n    // }\n    /// @notice amount is always in WAD, so need to convert if decimals mismatch\n    function trusted_transfer(uint256 amount, address to) external onlyController{\n        UNDERLYING.transfer(to, amount); \n    }\n\n    function balanceInUnderlying(address ad) external view returns(uint256){\n        return previewRedeem(balanceOf[ad]); \n    }\n\n    /// @notice burns all balance of address \n    // function burnAll(address to) private{\n    //   _burn(to, balanceOf[to]); \n    // }\n\n  struct localVars{\n    uint256 promised_return; \n    uint256 inceptionTime; \n    uint256 inceptionPrice; \n    uint256 leverageFactor; \n    uint256 managementFee; \n\n    uint256 srpPlusOne; \n    uint256 totalAssetsHeldScaled; \n    uint256 juniorSupply;\n    uint256 seniorSupply; \n\n    bool belowThreshold; \n  }\n\n  \n\n\n  /// @notice get programmatic pricing of a pool based longZCB \n  /// returns psu: price of senior(VT's share of investment) vs underlying \n  /// returns pju: price of junior(longZCB) vs underlying\n  // TODO inception price needs to be modifyable for changing senior returns \n  function poolZCBValue(uint256 marketId) \n    public \n    view\n    returns(uint256 psu, uint256 pju, uint256 levFactor){\n      //TODO should not tick during assessment \n    localVars memory vars; \n\n    (vars.promised_return, vars.inceptionTime, vars.inceptionPrice, vars.leverageFactor, \n      vars.managementFee) = fetchPoolTrancheData(marketId); \n    levFactor = vars.leverageFactor; \n\n    require(vars.inceptionPrice > 0, \"0\"); \n\n    // Get senior redemption price that increments per unit time \n    vars.srpPlusOne = vars.inceptionPrice.mulWadDown((BASE_UNIT+ vars.promised_return)\n      .rpow(block.timestamp - vars.inceptionTime, BASE_UNIT));\n\n    // Get total assets held by the instrument \n    vars.juniorSupply = controller.getTotalSupply(marketId); \n    vars.seniorSupply = vars.juniorSupply.mulWadDown(vars.leverageFactor); \n    vars.totalAssetsHeldScaled = instrumentAssetOracle(marketId, vars.juniorSupply, vars.seniorSupply)\n      .mulWadDown(vars.inceptionPrice); \n\n    if (vars.seniorSupply == 0) return(vars.srpPlusOne,vars.srpPlusOne,levFactor); \n    \n    // Check if all seniors can redeem\n    if (vars.totalAssetsHeldScaled >= vars.srpPlusOne.mulWadDown(vars.seniorSupply))\n      psu = vars.srpPlusOne; \n    else{\n      psu = vars.totalAssetsHeldScaled.divWadDown(vars.seniorSupply);\n      vars.belowThreshold = true;  \n    }\n    // should be 0 otherwise \n    if(!vars.belowThreshold) pju = (vars.totalAssetsHeldScaled \n      - vars.srpPlusOne.mulWadDown(vars.seniorSupply)).divWadDown(vars.juniorSupply); \n    uint pju_ = (BASE_UNIT+ vars.leverageFactor).mulWadDown(previewMint(BASE_UNIT.mulWadDown(vars.inceptionPrice))) \n      -  vars.srpPlusOne.mulWadDown(vars.leverageFactor);\n\n    // assert(pju_ >= pju-10 || pju_ <= pju+10); \n        // console.log('ok????'); \n\n    }\n\n    event InstrumentHarvest(address indexed instrument, uint256 totalInstrumentHoldings, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\n\n    /// @notice Harvest a trusted Instrument, records profit/loss \n    function harvest(address instrument) public {\n      require(instrument_data[Instrument(instrument)].trusted, \"UNTRUSTED_Instrument\");\n      InstrumentData storage data = instrument_data[Instrument(instrument)]; \n\n      uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n      uint256 balanceLastHarvest = data.balance;\n      uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\n      \n      if (balanceLastHarvest == balanceThisHarvest) {\n          return;\n      }\n\n      data.balance = balanceThisHarvest;\n\n      uint256 delta;\n      bool net_positive = balanceThisHarvest >= balanceLastHarvest;\n      delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\n      totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\n\n      emit InstrumentHarvest(instrument, totalInstrumentHoldings, balanceThisHarvest, delta, net_positive);\n    }\n\n    event InstrumentDeposit(uint256 indexed marketId, address indexed instrument, uint256 amount, bool isPool);\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\n    /// Called when market is approved. \n    /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n    function depositIntoInstrument(\n      uint256 marketId, \n      uint256 underlyingAmount,\n      bool isPool) onlyTrustedInstrument(fetchInstrument(marketId)) public virtual\n  //onlyManager\n    {\n      Instrument instrument = fetchInstrument(marketId); \n      // require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n\n      // if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n      uint256 curBalance = UNDERLYING.balanceOf(address(this)); \n      if (underlyingAmount > curBalance) {\n\n        // check if can be pulled from lending pool, if yes do it\n        uint256 required = underlyingAmount - curBalance; \n        if(PoolInstrument(address(Instruments[0])).isWithdrawAble( address(this), required))  \n          pullFromLM( required); \n        else revert(\"!vaultbal\"); \n      }\n\n      totalInstrumentHoldings += underlyingAmount; \n      instrument_data[instrument].balance += underlyingAmount;\n\n      if(!isPool)\n        require(UNDERLYING.transfer(address(instrument), underlyingAmount), \"DEPOSIT_FAILED\");\n      else{\n        // TODO keep track of all this \n        UNDERLYING.approve(address(instrument), underlyingAmount); \n        require(ERC4626(address(instrument)).deposit(underlyingAmount, address(this))>0, \"DEPOSIT_FAILED\");\n\n      }\n\n      emit InstrumentDeposit(marketId, address(instrument), underlyingAmount, isPool);\n    }\n\n    modifier onlyTrustedInstrument(Instrument instrument) {\n      _onlyTrustedInstrument(instrument);\n      _;\n    }\n\n    function _onlyTrustedInstrument(Instrument instrument) internal view {\n      require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n    }\n\n    event InstrumentWithdrawal(uint256 indexed marketId, address indexed instrument, uint256 amount);\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n    function withdrawFromInstrument(\n      Instrument instrument, \n      uint256 underlyingAmount, \n      bool redeem) onlyTrustedInstrument(instrument) internal virtual {\n      // require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n      \n      // if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n      instrument_data[instrument].balance -= underlyingAmount;\n      \n      totalInstrumentHoldings -= underlyingAmount;\n      \n      if (redeem) require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n\n      emit InstrumentWithdrawal(instrument_data[instrument].marketId, address(instrument), underlyingAmount);\n    }\n\n    function withdrawFromPoolInstrument(\n      uint256 marketId, \n      uint256 instrumentPullAmount, \n      address pushTo, \n      uint256 underlyingAmount\n      ) public virtual \n    //onlyManager\n    { \n      // Send to withdrawer \n      Instrument instrument = fetchInstrument( marketId); \n      require(instrument.isLiquid(underlyingAmount + instrumentPullAmount), \"!liq\");\n\n      ERC4626(address(instrument)).withdraw(underlyingAmount + instrumentPullAmount, address(this), address(this)); \n      UNDERLYING.transfer(pushTo, instrumentPullAmount); \n\n      //TODO instrument balance should decrease to 0 and stay solvent  \n      //TODO can everyone redeem? does vault's instument share balance change when\n      // mint-> redeem at different pjus? \n      withdrawFromInstrument(fetchInstrument(marketId), underlyingAmount, false);\n    }\n\n    event InstrumentTrusted(uint256 indexed marketId, address indexed instrument, uint256 principal, uint256 expectedYield, uint256 maturityDate);\n    /// @notice Stores a Instrument as trusted when its approved\n    function trustInstrument(\n      uint256 marketId,\n      ApprovalData memory data, \n      bool isPool\n      ) external virtual onlyController{\n      instrument_data[fetchInstrument(marketId)].trusted = true;\n\n      //Write to storage \n      if(!isPool){\n        InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \n        instrumentData.principal = data.approved_principal; \n        instrumentData.expectedYield = data.approved_yield;\n        instrumentData.faceValue = data.approved_principal + data.approved_yield; \n\n        depositIntoInstrument(marketId, data.approved_principal - data.managers_stake, false);\n        \n        // setMaturityDate(marketId);\n        instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n\n        fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \n\n      } else{\n        instrument_data[Instruments[marketId]].poolData.inceptionTime = block.timestamp; \n        depositIntoInstrument(marketId, data.approved_principal - data.managers_stake, true);\n      }\n      emit InstrumentTrusted(marketId, address(Instruments[marketId]), data.approved_principal, data.approved_yield, instrument_data[fetchInstrument(marketId)].maturityDate);\n    }\n\n    /// @notice fetches how much asset the instrument has in underlying. \n    function instrumentAssetOracle(\n      uint256 marketId, \n      uint256 juniorSupply, \n      uint256 seniorSupply) public view returns(uint256){\n      // Default balance oracle \n      ERC4626 instrument = ERC4626(address(Instruments[marketId])); \n      return (juniorSupply + seniorSupply).mulWadDown(instrument.previewMint(BASE_UNIT)); \n      //TODO custom oracle \n    }\n\n    /// @notice Stores a Instrument as untrusted\n    // not needed?\n    function distrustInstrument(Instrument instrument) external onlyController {\n      instrument_data[instrument].trusted = false; \n    }\n\n    function addLendingModule(address lv) external\n    //onlyOwner\n    { \n      // The 0th instrument is always the lending module \n      Instruments[0] = Instrument(lv);\n      instrument_data[Instruments[0]].trusted = true; \n      UNDERLYING.approve(lv, type(uint256).max); \n    }\n\n    /// @notice push unutilized capital to leverage vault \n    function pushToLM(uint256 amount) external \n    //onlyOwner \n    { \n      // if amount=0, push everything this vault have \n      uint256 bal = UNDERLYING.balanceOf(address(this)); \n      require(amount<= bal, \"push exceeds liq\"); \n      uint256 depositAmount = amount==0 ? bal : amount; \n\n      depositIntoInstrument(0, depositAmount, true); \n    }\n\n    function pullFromLM(uint256 amount) public\n    //onlyowner or internal \n    {\n      // check if amount is available liquidity, and is appropriate for the given\n      // shares this vault has of it. \n      Instrument instrument = fetchInstrument(0); \n      uint256 shares = ERC4626(address(instrument)).balanceOf(address(this)); \n      require(amount <= ERC4626(address(instrument)).previewMint(shares), \"!!liq1\" ); \n      require(instrument.isLiquid(amount), \"!liq2\");\n\n      ERC4626(address(instrument)).withdraw(amount, address(this), address(this)); \n\n      withdrawFromInstrument(instrument, amount, false);\n    }\n\n    /// @notice returns true if Instrument is approved\n    function isTrusted(Instrument instrument) public view returns(bool){\n      return instrument_data[instrument].trusted; \n    }\n\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n    function totalAssets() public view override returns(uint256){\n      return totalInstrumentHoldings + totalFloat();\n    }\n\n    function utilizationRate() public view returns(uint256){\n\n        if (totalInstrumentHoldings==0) return 0;  \n        return totalInstrumentHoldings.divWadDown(totalAssets()); \n\n    }\n    function totalFloat() public view returns (uint256) {\n        return UNDERLYING.balanceOf(address(this));\n    }\n\n    function fetchInstrument(uint256 marketId) public view returns(Instrument){\n      return Instruments[marketId]; \n    }\n\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n      return instrument_data[Instruments[marketId]];\n    }\n\n    function fetchPoolTrancheData(uint256 marketId) public view returns(uint256, uint256, uint256, uint256, uint256){\n      // InstrumentData memory data = instrument_data[Instruments[marketId]]; \n      return (instrument_data[Instruments[marketId]].poolData.promisedReturn, instrument_data[Instruments[marketId]].poolData.inceptionTime, \n            instrument_data[Instruments[marketId]].poolData.inceptionPrice, instrument_data[Instruments[marketId]].poolData.leverageFactor, instrument_data[Instruments[marketId]].poolData.managementFee); \n    }\n  \n    event InstrumentRemoved(uint256 indexed marketId, address indexed instrumentAddress);\n    /**\n     called on market denial + removal, maybe no chekcs?\n     */\n    function removeInstrument(uint256 marketId) internal {\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\n        require(data.marketId > 0, \"instrument doesn't exist\");\n        delete instrument_data[Instruments[marketId]];\n        delete Instruments[marketId];\n        // emit event here;\n        emit InstrumentRemoved(marketId, address(Instruments[marketId]));\n    }\n\n    // event PoolAdded(\n    //   uint256 indexed marketId,\n    //   address indexed instrumentAddress,\n    //   bytes32 indexed name,\n    //   uint256 saleAmount, \n    //   uint256 initPrice, // init price of longZCB in the amm \n    //   uint256 promisedReturn, //per unit time \n    //   uint256 inceptionTime,\n    //   uint256 inceptionPrice, // init price of longZCB after assessment \n    //   uint256 leverageFactor, //leverageFactor * manager collateral = capital from vault to instrument\n    //   uint256 managementFee\n    // );\n\n    // event InstrumentAdded(\n    //   uint256 indexed marketId,\n    //   address indexed instrumentAddress,\n    //   bytes32 indexed name,\n    //   uint256 faceValue,\n    //   uint256 principal,\n    //   uint256 expectedYield,\n    //   uint256 duration,\n    //   uint256 maturityDate,\n    //   InstrumentType instrumentType,\n    //   bool isPool\n    // );\n\n    // event ProposalAdded(InstrumentData data);\n    /// @notice add instrument proposal created by the Utilizer \n    /// @dev Instrument instance should be created before this is called\n    /// need to add authorization\n    function addProposal(\n        InstrumentData memory data\n    ) external onlyController {\n      if(!data.isPool){\n        require(data.principal > 0, \"principal must be greater than 0\");\n        require(data.duration > 0, \"duration must be greater than 0\");\n        require(data.faceValue > 0, \"faceValue must be greater than 0\");\n        require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); \n        require(data.marketId > 0, \"must be valid instrument\");\n      }\n        // num_proposals[msg.sender] ++; \n        // TODO indexed by id\n        instrument_data[Instrument(data.instrument_address)] = data;  \n\n        Instruments[data.marketId] = Instrument(data.instrument_address);\n        // emit ProposalAdded(data);\n    }\n\n    //event MaturityDateSet(uint256 indexed marketId, address indexed instrument, uint256 maturityDate);\n  \n    // function setMaturityDate(uint256 marketId) internal {\n\n    //     instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n    //     emit MaturityDateSet(marketId, address(fetchInstrument(marketId)), instrument_data[fetchInstrument(marketId)].maturityDate);\n    // }\n\n    /// @notice function called when instrument resolves from within\n    function pingMaturity(address instrument, bool premature) external {\n        require(msg.sender == instrument || isTrusted(Instrument(instrument))); \n        uint256 marketId = instrument_data[Instrument(instrument)].marketId; \n        beforeResolve(marketId); \n        resolveBeforeMaturity[marketId] = premature; \n    }\n\n    /// @notice RESOLVE FUNCTION #1\n    /// Checks if instrument is ready to be resolved and locks capital.\n    /// records blocknumber such that resolveInstrument is called after this function \n    /// records balances+PnL of instrument\n    /// @dev need to store internal balance that is used to calculate the redemption price \n    function beforeResolve(uint256 marketId) public {\n        Instrument _instrument = Instruments[marketId]; \n\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n        require(isTrusted( _instrument), \"Not trusted\"); \n\n        // Should revert if can't be resolved \n        _instrument.prepareWithdraw();\n\n        // Record profit/loss used for calculation of redemption price \n        harvest(address(_instrument));\n\n        _instrument.store_internal_balance(); \n        prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \n      }\n\n\n    //event InstrumentResolve(uint256 indexed marketId, uint256 instrumentBalance, bool atLoss, uint256 extraGain, uint256 totalLoss, bool prematureResolve);\n    /// @notice RESOLVE FUNCTION #2\n    /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \n    /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\n    function resolveInstrument(\n        uint256 marketId\n    ) external onlyController\n    returns(bool, uint256, uint256, bool) {\n        Instrument _instrument = Instruments[marketId];\n        ResolveVar memory rvar = prepareResolveBlock[marketId]; \n        require(_instrument.isLocked(), \"Not Locked\");\n        // require(rvar.isPrepared && rvar.endBlock < block.number, \"can't resolve\"); \n\n        // uint256 bal = UNDERLYING.balanceOf(address(this)); \n        uint256 instrument_balance = _instrument.getMaturityBalance(); \n\n        // InstrumentData memory data = instrument_data[_instrument];\n\n        bool prematureResolve = resolveBeforeMaturity[marketId]; \n        bool atLoss; \n        uint256 total_loss; \n        uint256 extra_gain; \n\n        // If resolved at predetermined maturity date, loss is defined by\n        // the event the instrument has paid out all its yield + principal \n        if (!prematureResolve){\n            atLoss = instrument_balance < instrument_data[_instrument].faceValue;\n            total_loss = atLoss ? instrument_data[_instrument].faceValue - instrument_balance : 0;\n            extra_gain = !atLoss ? instrument_balance - instrument_data[_instrument].faceValue : 0;\n        }\n\n        // If resolved before predetermined maturity date, loss is defined by \n        // the event the instrument has balance less then principal \n        else {\n            atLoss = instrument_balance < instrument_data[_instrument].principal; \n            total_loss = atLoss? instrument_data[_instrument].principal - instrument_balance :0; \n            extra_gain = !atLoss? instrument_balance - instrument_data[_instrument].principal: 0; \n        }\n\n        withdrawFromInstrument(_instrument, instrument_balance, true);\n        removeInstrument(instrument_data[_instrument].marketId);\n\n        //emit InstrumentResolve(marketId, instrument_balance, atLoss, extra_gain, total_loss, prematureResolve);\n\n        return(atLoss, extra_gain, total_loss, prematureResolve); \n    }\n\n    /// @notice when market resolves, send back pulled collateral from managers \n    function repayDebt(address to, uint256 amount) external onlyController{\n        UNDERLYING.transfer(to, amount); \n    }\n\n    event InstrumentDeny(uint256 indexed marketId);\n    /**\n     called on market denial by controller => denied before approval\n     */\n    function denyInstrument(uint256 marketId) external onlyController {\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\n\n        require(marketId > 0 && data.instrument_address != address(0), \"invalid instrument\");\n\n        require(!data.trusted, \"can't deny approved instrument\");\n        emit InstrumentDeny(marketId);\n        removeInstrument(marketId);\n    }\n\n\n    function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\n      return Instruments[marketId].instrumentApprovalCondition(); \n    }\n\n    /// TODO \n    function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\n      return amount; \n    }\n\n\n    /// @notice types of restrictions are: \n    /// a) verified address b) reputation scores \n    function receiver_conditions(address receiver) public view returns(bool){\n        return true; \n    }\n\n    /// @notice called when constructed, params set by the creater of the vault \n    // function set_minting_conditions(\n    //   bool _onlyVerified, \n    //   uint256 _r, \n    //   uint256 _asset_limit,\n    //   uint256 _total_asset_limit) internal{\n    //     onlyVerified = _onlyVerified; \n    //     r = _r; \n    //     asset_limit = _asset_limit; \n    //     total_asset_limit = _total_asset_limit; \n    // } \n\n\n    function get_vault_params() public view returns(MarketParameters memory){\n      return default_params; \n    }\n\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n      require(enoughLiqudity(assets), \"Not enough liqudity in vault\"); \n\n    }\n\n    /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\n    /// (excluding those supplied to existing instruments)\n    /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\n    /// should be (soft)maxed and tunable by a parameter \n    function enoughLiqudity(uint256 amounts) public view returns(bool){\n        return (UNDERLYING.balanceOf(address(this)) >= amounts); \n    }\n\n\n    /// @notice function that closes instrument prematurely \n    function closeInstrument(uint256 marketId) external onlyController{\n      Instrument instrument = fetchInstrument( marketId); \n\n      // If instrument has non-underlying tokens, liquidate them first. \n      instrument.liquidateAllPositions(); \n\n    }\n\n    function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\n        // InstrumentData memory data = instrument_data[Instruments[marketId]];\n        return (instrument_data[Instruments[marketId]].principal, instrument_data[Instruments[marketId]].expectedYield); \n    }\n\n    /// @notice a minting restrictor is set for different vaults \n    function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\n        if (!receiver_conditions(receiver)) revert(\"Minting Restricted\"); \n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.transferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n\n    /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \n     function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        assets = deduct_withdrawal_fees(assets); \n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.transfer(receiver, assets);\n    }\n}"
    },
    "lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "lib/openzeppelin-contracts/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* firstTokenId */,\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "lib/prb-math/src/Core.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\n/// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n/// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Emitted when the ending result in the fixed-point version of `mulDiv` would overflow uint256.\nerror PRBMath__MulDiv18Overflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the ending result in `mulDiv` would overflow uint256.\nerror PRBMath__MulDivOverflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Emitted when attempting to run `mulDiv` with one of the inputs `type(int256).min`.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the ending result in the signed version of `mulDiv` would overflow int256.\nerror PRBMath__MulDivSignedOverflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev How many trailing decimals can be represented.\nuint256 constant UNIT = 1e18;\n\n/// @dev Largest power of two that is a divisor of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/// @dev The `UNIT` number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\n/// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each of the steps in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is swapped with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/paulrberg/f932f8693f2733e30c4d479e8e980948\n///\n/// A list of the Yul instructions used below:\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as an uint256.\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates floor(x*y÷denominator) with full precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Requirements:\n/// - The denominator cannot be zero.\n/// - The result must fit within uint256.\n///\n/// Caveats:\n/// - This function does not work with fixed-point numbers.\n///\n/// @param x The multiplicand as an uint256.\n/// @param y The multiplier as an uint256.\n/// @param denominator The divisor as an uint256.\n/// @return result The result as an uint256.\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath__MulDivOverflow(x, y, denominator);\n    }\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512 bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n    unchecked {\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        assembly {\n            // Divide denominator by lpotdod.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * lpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates floor(x*y÷1e18) with full precision.\n///\n/// @dev Variant of `mulDiv` with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n/// final result, we add 1 if `(x * y) % UNIT >= HALF_UNIT`. Without this adjustment, 6.6e-19 would be truncated to 0\n/// instead of being rounded to 1e-18. See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n///\n/// Requirements:\n/// - The result must fit within uint256.\n///\n/// Caveats:\n/// - The body is purposely left uncommented; to understand how this works, see the NatSpec comments in `mulDiv`.\n/// - It is assumed that the result can never be `type(uint256).max` when x and y solve the following two equations:\n///     1. x * y = type(uint256).max * UNIT\n///     2. (x * y) % UNIT >= UNIT / 2\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath__MulDiv18Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly {\n        remainder := mulmod(x, y, UNIT)\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    assembly {\n        result := mul(\n            or(\n                div(sub(prod0, remainder), UNIT_LPOTD),\n                mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n            ),\n            UNIT_INVERSE\n        )\n    }\n}\n\n/// @notice Calculates floor(x*y÷denominator) with full precision.\n///\n/// @dev An extension of `mulDiv` for signed numbers. Works by computing the signs and the absolute values separately.\n///\n/// Requirements:\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit within int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath__MulDivSignedInputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 absX;\n    uint256 absY;\n    uint256 absD;\n    unchecked {\n        absX = x < 0 ? uint256(-x) : uint256(x);\n        absY = y < 0 ? uint256(-y) : uint256(y);\n        absD = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n    uint256 rAbs = mulDiv(absX, absY, absD);\n    if (rAbs > uint256(type(int256).max)) {\n        revert PRBMath__MulDivSignedOverflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly {\n        // This works thanks to two's complement.\n        // \"sgt\" stands for \"signed greater than\" and \"sub(0,1)\" is max uint256.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers.\n/// See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\nfunction prbExp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // We're doing two things at the same time:\n        //\n        //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n        //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n        //      rather than 192.\n        //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n        //\n        // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Calculates the square root of x, rounding down if x is not a perfect square.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n/// Credits to OpenZeppelin for the explanations in code comments below.\n///\n/// Caveats:\n/// - This function does not work with fixed-point numbers.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as an uint256.\nfunction prbSqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$ and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2}` is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since  it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // Round down the result in case x is not a perfect square.\n        uint256 roundedDownResult = x / result;\n        if (result >= roundedDownResult) {\n            result = roundedDownResult;\n        }\n    }\n}\n"
    },
    "lib/prb-math/src/SD59x18.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.13;\n\nimport { msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \"./Core.sol\";\n\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18 decimals.\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int256.\ntype SD59x18 is int256;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Emitted when taking the absolute value of `MIN_SD59x18`.\nerror PRBMathSD59x18__AbsMinSD59x18();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(SD59x18 x);\n\n/// @notice Emitted when dividing two numbers and one of them is `MIN_SD59x18`.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(SD59x18 x);\n\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(SD59x18 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(SD59x18 x);\n\n/// @notice Emitted when taking the geometric mean of two numbers and their product is negative.\nerror PRBMathSD59x18__GmNegativeProduct(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when taking the logarithm of a number less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(SD59x18 x);\n\n/// @notice Emitted when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when multiplying two numbers and the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(SD59x18 x, SD59x18 y);\n\n/// @notice Emitted when raising a number to a power and hte intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(SD59x18 x, uint256 y);\n\n/// @notice Emitted when taking the square root of a negative number.\nerror PRBMathSD59x18__SqrtNegativeInput(SD59x18 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(SD59x18 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__ToSD59x18Overflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__ToSD59x18Underflow(int256 x);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// NOTICE: the \"u\" prefix stands for \"unwrapped\".\n\n/// @dev Euler's number as an SD59x18 number.\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\n\n/// @dev Half the UNIT number.\nint256 constant uHALF_UNIT = 0.5e18;\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\n\n/// @dev log2(10) as an SD59x18 number.\nint256 constant uLOG2_10 = 3_321928094887362347;\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\n\n/// @dev log2(e) as an SD59x18 number.\nint256 constant uLOG2_E = 1_442695040888963407;\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\n\n/// @dev The maximum value an SD59x18 number can have.\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\n\n/// @dev The maximum whole value an SD59x18 number can have.\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\n\n/// @dev The minimum value an SD59x18 number can have.\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\n\n/// @dev The minimum whole value an SD59x18 number can have.\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\n\n/// @dev PI as an SD59x18 number.\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\n\n/// @dev The unit amount which implies how many trailing decimals can be represented.\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\nint256 constant uUNIT = 1e18;\n\n/// @dev Zero as an SD59x18 number.\nSD59x18 constant ZERO = SD59x18.wrap(0);\n\n/*//////////////////////////////////////////////////////////////////////////\n                            MATHEMATICAL FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { abs, avg, ceil, div, exp, exp2, floor, frac, gm, inv, log10, log2, ln, mul, pow, powu, sqrt } for SD59x18 global;\n\n/// @notice Calculate the absolute value of x.\n///\n/// @dev Requirements:\n/// - x must be greater than `MIN_SD59x18`.\n///\n/// @param x The SD59x18 number for which to calculate the absolute value.\n/// @param result The absolute value of x as an SD59x18 number.\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt == uMIN_SD59x18) {\n        revert PRBMathSD59x18__AbsMinSD59x18();\n    }\n    result = xInt < 0 ? wrap(-xInt) : x;\n}\n\n/// @notice Calculates the arithmetic average of x and y, rounding towards zero.\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The arithmetic average as an SD59x18 number.\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n\n    unchecked {\n        // This is equivalent to \"x / 2 +  y / 2\" but faster.\n        // This operation can never overflow.\n        int256 sum = (xInt >> 1) + (yInt >> 1);\n\n        if (sum < 0) {\n            // If at least one of x and y is odd, we add 1 to the result, since shifting negative numbers to the right rounds\n            // down to infinity. The right part is equivalent to \"sum + (x % 2 == 1 || y % 2 == 1)\" but faster.\n            assembly {\n                result := add(sum, and(or(xInt, yInt), 1))\n            }\n        } else {\n            // We need to add 1 if both x and y are odd to account for the double 0.5 remainder that is truncated after shifting.\n            result = wrap(sum + (xInt & yInt & 1));\n        }\n    }\n}\n\n/// @notice Yields the smallest whole SD59x18 number greater than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to ceil.\n/// @param result The least number greater than or equal to x, as an SD59x18 number.\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt > uMAX_WHOLE_SD59x18) {\n        revert PRBMathSD59x18__CeilOverflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt > 0) {\n                resultInt += uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number. Rounds towards zero.\n///\n/// @dev This is a variant of `mulDiv` that works with signed numbers. Works by computing the signs and the absolute values\n/// separately.\n///\n/// Requirements:\n/// - All from `Core/mulDiv`.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The denominator cannot be zero.\n/// - The result must fit within int256.\n///\n/// Caveats:\n/// - All from `Core/mulDiv`.\n///\n/// @param x The numerator as an SD59x18 number.\n/// @param y The denominator as an SD59x18 number.\n/// @param result The quotient as an SD59x18 number.\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert PRBMathSD59x18__DivInputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    // Compute the absolute value (x*UNIT)÷y. The resulting value must fit within int256.\n    uint256 resultAbs = mulDiv(xAbs, uint256(uUNIT), yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMathSD59x18__DivOverflow(x, y);\n    }\n\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs don't have the same sign, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Calculates the natural exponent of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// e^x = 2^{x * log_2{e}}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n/// - x must be less than 133.084258667509499441.\n///\n/// Caveats:\n/// - All from `exp2`.\n/// - For any x less than -41.446531673892822322, the result is zero.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    // Without this check, the value passed to `exp2` would be less than -59.794705707972522261.\n    if (xInt < -41_446531673892822322) {\n        return ZERO;\n    }\n\n    // Without this check, the value passed to `exp2` would be greater than 192.\n    if (xInt >= 133_084258667509499441) {\n        revert PRBMathSD59x18__ExpInputTooBig(x);\n    }\n\n    unchecked {\n        // Do the fixed-point multiplication inline to save gas.\n        int256 doubleUnitProduct = xInt * uLOG2_E;\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\n    }\n}\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// 2^{-x} = \\frac{1}{2^x}\n/// $$\n///\n/// See https://ethereum.stackexchange.com/q/79903/24693.\n///\n/// Requirements:\n/// - x must be 192 or less.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - For any x less than -59.794705707972522261, the result is zero.\n///\n/// @param x The exponent as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n        if (xInt < -59_794705707972522261) {\n            return ZERO;\n        }\n\n        unchecked {\n            // Do the fixed-point inversion $1/2^x$ inline to save gas. 1e36 is UNIT * UNIT.\n            result = wrap(1e36 / unwrap(exp2(wrap(-xInt))));\n        }\n    } else {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (xInt >= 192e18) {\n            revert PRBMathSD59x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\n\n            // It is safe to convert the result to int256 with no checks because the maximum input allowed in this function is 192.\n            result = wrap(int256(prbExp2(x_192x64)));\n        }\n    }\n}\n\n/// @notice Yields the greatest whole SD59x18 number less than or equal to x.\n///\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n///\n/// Requirements:\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\n///\n/// @param x The SD59x18 number to floor.\n/// @param result The greatest integer less than or equal to x, as an SD59x18 number.\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < uMIN_WHOLE_SD59x18) {\n        revert PRBMathSD59x18__FloorUnderflow(x);\n    }\n\n    int256 remainder = xInt % uUNIT;\n    if (remainder == 0) {\n        result = x;\n    } else {\n        unchecked {\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n            int256 resultInt = xInt - remainder;\n            if (xInt < 0) {\n                resultInt -= uUNIT;\n            }\n            result = wrap(resultInt);\n        }\n    }\n}\n\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\n/// of the radix point for negative numbers.\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n/// @param x The SD59x18 number to get the fractional part of.\n/// @param result The fractional part of x as an SD59x18 number.\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) % uUNIT);\n}\n\n/// @notice Calculates the geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n///\n/// @dev Requirements:\n/// - x * y must fit within `MAX_SD59x18`, lest it overflows.\n/// - x * y must not be negative, since this library does not handle complex numbers.\n///\n/// @param x The first operand as an SD59x18 number.\n/// @param y The second operand as an SD59x18 number.\n/// @return result The result as an SD59x18 number.\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == 0 || yInt == 0) {\n        return ZERO;\n    }\n\n    unchecked {\n        // Equivalent to \"xy / x != y\". Checking for overflow this way is faster than letting Solidity do it.\n        int256 xyInt = xInt * yInt;\n        if (xyInt / xInt != yInt) {\n            revert PRBMathSD59x18__GmOverflow(x, y);\n        }\n\n        // The product must not be negative, since this library does not handle complex numbers.\n        if (xyInt < 0) {\n            revert PRBMathSD59x18__GmNegativeProduct(x, y);\n        }\n\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\n        // during multiplication. See the comments within the `prbSqrt` function.\n        uint256 resultUint = prbSqrt(uint256(xyInt));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/// @notice Calculates 1 / x, rounding toward zero.\n///\n/// @dev Requirements:\n/// - x cannot be zero.\n///\n/// @param x The SD59x18 number for which to calculate the inverse.\n/// @return result The inverse as an SD59x18 number.\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\n    // 1e36 is UNIT * UNIT.\n    result = wrap(1e36 / unwrap(x));\n}\n\n/// @notice Calculates the natural logarithm of x.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// ln{x} = log_2{x} / log_2{e}$$.\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\n///\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\n/// @return result The natural logarithm as an SD59x18 number.\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\n    // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n    // can return is 195.205294292027477728.\n    result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\n}\n\n/// @notice Calculates the common logarithm of x.\n///\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n/// logarithm based on the formula:\n///\n/// $$\n/// log_{10}{x} = log_2{x} / log_2{10}\n/// $$\n///\n/// Requirements:\n/// - All from `log2`.\n///\n/// Caveats:\n/// - All from `log2`.\n///\n/// @param x The SD59x18 number for which to calculate the common logarithm.\n/// @return result The common logarithm as an SD59x18 number.\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        revert PRBMathSD59x18__LogInputTooSmall(x);\n    }\n\n    // Note that the `mul` in this block is the assembly mul operation, not the SD59x18 `mul`.\n    // prettier-ignore\n    assembly {\n        switch x\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\n        case 1000000000000000000 { result := 0 }\n        case 10000000000000000000 { result := uUNIT }\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\n        default {\n            result := uMAX_SD59x18\n        }\n    }\n\n    if (unwrap(result) == uMAX_SD59x18) {\n        unchecked {\n            // Do the fixed-point division inline to save gas.\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\n        }\n    }\n}\n\n/// @notice Calculates the binary logarithm of x.\n///\n/// @dev Based on the iterative approximation algorithm.\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n///\n/// Requirements:\n/// - x must be greater than zero.\n///\n/// Caveats:\n/// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n///\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\n/// @return result The binary logarithm as an SD59x18 number.\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt <= 0) {\n        revert PRBMathSD59x18__LogInputTooSmall(x);\n    }\n\n    unchecked {\n        // This works because of:\n        //\n        // $$\n        // log_2{x} = -log_2{\\frac{1}{x}}\n        // $$\n        int256 sign;\n        if (xInt >= uUNIT) {\n            sign = 1;\n        } else {\n            sign = -1;\n            // Do the fixed-point inversion inline to save gas. The numerator is UNIT * UNIT.\n            xInt = 1e36 / xInt;\n        }\n\n        // Calculate the integer part of the logarithm and add it to the result and finally calculate $y = x * 2^(-n)$.\n        uint256 n = msb(uint256(xInt / uUNIT));\n\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\n        // because n is maximum 255, UNIT is 1e18 and sign is either 1 or -1.\n        int256 resultInt = int256(n) * uUNIT;\n\n        // This is $y = x * 2^{-n}$.\n        int256 y = xInt >> n;\n\n        // If y is 1, the fractional part is zero.\n        if (y == uUNIT) {\n            return wrap(resultInt * sign);\n        }\n\n        // Calculate the fractional part via the iterative approximation.\n        // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n        int256 DOUBLE_UNIT = 2e18;\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\n            y = (y * y) / uUNIT;\n\n            // Is $y^2 > 2$ and so in the range [2,4)?\n            if (y >= DOUBLE_UNIT) {\n                // Add the 2^{-m} factor to the logarithm.\n                resultInt = resultInt + delta;\n\n                // Corresponds to z/2 on Wikipedia.\n                y >>= 1;\n            }\n        }\n        resultInt *= sign;\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\n///\n/// @dev This is a variant of `mulDiv` that works with signed numbers and employs constant folding, i.e. the denominator\n/// is always 1e18.\n///\n/// Requirements:\n/// - All from `Core/mulDiv18`.\n/// - None of the inputs can be `MIN_SD59x18`.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - To understand how this works in detail, see the NatSpec comments in `Core/mulDivSigned`.\n///\n/// @param x The multiplicand as an SD59x18 number.\n/// @param y The multiplier as an SD59x18 number.\n/// @return result The product as an SD59x18 number.\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\n        revert PRBMathSD59x18__MulInputTooSmall();\n    }\n\n    // Get hold of the absolute values of x and y.\n    uint256 xAbs;\n    uint256 yAbs;\n    unchecked {\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\n    }\n\n    uint256 resultAbs = mulDiv18(xAbs, yAbs);\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMathSD59x18__MulOverflow(x, y);\n    }\n\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\n    bool sameSign = (xInt ^ yInt) > -1;\n\n    // If the inputs have the same sign, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\n    }\n}\n\n/// @notice Raises x to the power of y.\n///\n/// @dev Based on the formula:\n///\n/// $$\n/// x^y = 2^{log_2{x} * y}\n/// $$\n///\n/// Requirements:\n/// - All from `exp2`, `log2` and `mul`.\n/// - x cannot be zero.\n///\n/// Caveats:\n/// - All from `exp2`, `log2` and `mul`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x Number to raise to given power y, as an SD59x18 number.\n/// @param y Exponent to raise x to, as an SD59x18 number\n/// @return result x raised to power y, as an SD59x18 number.\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    int256 yInt = unwrap(y);\n\n    if (xInt == 0) {\n        result = yInt == 0 ? UNIT : ZERO;\n    } else {\n        if (yInt == uUNIT) {\n            result = x;\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n}\n\n/// @notice Raises x (an SD59x18 number) to the power y (unsigned basic integer) using the famous algorithm\n/// algorithm \"exponentiation by squaring\".\n///\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n///\n/// Requirements:\n/// - All from `abs` and `Core/mulDiv18`.\n/// - The result must fit within `MAX_SD59x18`.\n///\n/// Caveats:\n/// - All from `Core/mulDiv18`.\n/// - Assumes 0^0 is 1.\n///\n/// @param x The base as an SD59x18 number.\n/// @param y The exponent as an uint256.\n/// @return result The result as an SD59x18 number.\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\n    uint256 xAbs = uint256(unwrap(abs(x)));\n\n    // Calculate the first iteration of the loop in advance.\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\n\n    // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n    uint256 yAux = y;\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\n        xAbs = mulDiv18(xAbs, xAbs);\n\n        // Equivalent to \"y % 2 == 1\" but faster.\n        if (yAux & 1 > 0) {\n            resultAbs = mulDiv18(resultAbs, xAbs);\n        }\n    }\n\n    // The result must fit within `MAX_SD59x18`.\n    if (resultAbs > uint256(uMAX_SD59x18)) {\n        revert PRBMathSD59x18__PowuOverflow(x, y);\n    }\n\n    unchecked {\n        // Is the base negative and the exponent an odd number?\n        int256 resultInt = int256(resultAbs);\n        bool isNegative = unwrap(x) < 0 && y & 1 == 1;\n        if (isNegative) {\n            resultInt = -resultInt;\n        }\n        result = wrap(resultInt);\n    }\n}\n\n/// @notice Calculates the square root of x, rounding down. Only the positive root is returned.\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Requirements:\n/// - x cannot be negative, since this library does not handle complex numbers.\n/// - x must be less than `MAX_SD59x18` divided by `UNIT`.\n///\n/// @param x The SD59x18 number for which to calculate the square root.\n/// @return result The result as an SD59x18 number.\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\n    int256 xInt = unwrap(x);\n    if (xInt < 0) {\n        revert PRBMathSD59x18__SqrtNegativeInput(x);\n    }\n    if (xInt > uMAX_SD59x18 / uUNIT) {\n        revert PRBMathSD59x18__SqrtOverflow(x);\n    }\n\n    unchecked {\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two SD59x18\n        // numbers together (in this case, the two numbers are both the square root).\n        uint256 resultUint = prbSqrt(uint256(xInt * uUNIT));\n        result = wrap(int256(resultUint));\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                            CONVERSION FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Converts an SD59x18 number to a simple integer by dividing it by `UNIT`. Rounds towards zero in the process.\n/// @param x The SD59x18 number to convert.\n/// @return result The same number as a simple integer.\nfunction fromSD59x18(SD59x18 x) pure returns (int256 result) {\n    result = unwrap(x) / uUNIT;\n}\n\n/// @notice Wraps a signed integer into the SD59x18 type.\nfunction sd(int256 x) pure returns (SD59x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Wraps a signed integer into the SD59x18 type.\n/// @dev Alias for the \"sd\" function defined above.\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\n    result = wrap(x);\n}\n\n/// @notice Converts a simple integer to SD59x18 by multiplying it by `UNIT`.\n///\n/// @dev Requirements:\n/// - x must be greater than or equal to `MIN_SD59x18` divided by `UNIT`.\n/// - x must be less than or equal to `MAX_SD59x18` divided by `UNIT`.\n///\n/// @param x The basic integer to convert.\n/// @param result The same number converted to SD59x18.\nfunction toSD59x18(int256 x) pure returns (SD59x18 result) {\n    if (x < uMIN_SD59x18 / uUNIT) {\n        revert PRBMathSD59x18__ToSD59x18Underflow(x);\n    }\n    if (x > uMAX_SD59x18 / uUNIT) {\n        revert PRBMathSD59x18__ToSD59x18Overflow(x);\n    }\n    unchecked {\n        result = wrap(x * uUNIT);\n    }\n}\n\n/// @notice Unwraps an SD59x18 number into the underlying signed integer.\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\n    result = SD59x18.unwrap(x);\n}\n\n/// @notice Wraps a signed integer into the SD59x18 type.\nfunction wrap(int256 x) pure returns (SD59x18 result) {\n    result = SD59x18.wrap(x);\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                        GLOBAL-SCOPED HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing {\n    add,\n    and,\n    eq,\n    gt,\n    gte,\n    isZero,\n    lshift,\n    lt,\n    lte,\n    mod,\n    neq,\n    or,\n    rshift,\n    sub,\n    uncheckedAdd,\n    uncheckedSub,\n    uncheckedUnary,\n    xor\n} for SD59x18 global;\n\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    return wrap(unwrap(x) + unwrap(y));\n}\n\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\n    return wrap(unwrap(x) & bits);\n}\n\n/// @notice Implements the equal (=) operation in the SD59x18 type.\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) == unwrap(y);\n}\n\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) > unwrap(y);\n}\n\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) >= unwrap(y);\n}\n\n/// @notice Implements a zero comparison check function in the SD59x18 type.\nfunction isZero(SD59x18 x) pure returns (bool result) {\n    result = unwrap(x) == 0;\n}\n\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) << bits);\n}\n\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) < unwrap(y);\n}\n\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) <= unwrap(y);\n}\n\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) % unwrap(y));\n}\n\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\n    result = unwrap(x) != unwrap(y);\n}\n\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) | unwrap(y));\n}\n\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) >> bits);\n}\n\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) - unwrap(y));\n}\n\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) + unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) - unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(-unwrap(x));\n    }\n}\n\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    result = wrap(unwrap(x) ^ unwrap(y));\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                        FILE-SCOPED HELPER FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\nusing { uncheckedDiv, uncheckedMul } for SD59x18;\n\n/// @notice Implements the unchecked standard division operation in the SD59x18 type.\nfunction uncheckedDiv(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) / unwrap(y));\n    }\n}\n\n/// @notice Implements the unchecked standard multiplication operation in the SD59x18 type.\nfunction uncheckedMul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\n    unchecked {\n        result = wrap(unwrap(x) * unwrap(y));\n    }\n}\n"
    },
    "lib/solmate/src/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "lib/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() virtual {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\n        require(x < 1 << 16);\n\n        y = uint16(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x0000000000000031363735323330393338363235"
      }
    }
  }
}