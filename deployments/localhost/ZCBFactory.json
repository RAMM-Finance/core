{
  "address": "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "description",
          "type": "string"
        }
      ],
      "name": "newBond",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x9dca5cbd2e3bc6b02cbbf9e4888e0f47b5f365134e80d05a964eaa8f3022ab8a",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xa513E6E4b8f2a923D98304ec87F64353C4D5C853",
    "transactionIndex": 0,
    "gasUsed": "1076564",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x68ade5365ddaa48e62444f705dc94e7952434ef117153d6cee5197df159d5f7b",
    "transactionHash": "0x9dca5cbd2e3bc6b02cbbf9e4888e0f47b5f365134e80d05a964eaa8f3022ab8a",
    "logs": [],
    "blockNumber": 8,
    "cumulativeGasUsed": "1076564",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "00672e6cd73d9950581fa64d570c9dfd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"newBond\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/bonds/synthetic.sol\":\"ZCBFactory\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363735323330393338363235\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/bonds/GBC.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\n// import {ERC20} from \\\"./aave/Libraries.sol\\\"; \\nimport {SafeCast, FixedPointMath, ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \\n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \\n/// @dev all funds will be handled in the child contract \\ncontract GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using Tick for mapping(uint16 => Tick.Info);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n    using SafeCast for uint256; \\n\\n\\n    modifier onlyEntry(){\\n        require(entry == msg.sender  ,\\\"Not Entry\\\"); \\n        _;\\n    }\\n    \\n    bool private _mutex;\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    constructor(\\n        address _baseToken,\\n        address _tradeToken\\n        //uint256 _priceDelta\\n        ) {\\n        tradeToken = _tradeToken; \\n        baseToken = _baseToken; \\n        //priceDelta = _priceDelta; \\n        fee =0; \\n        factory = address(0); \\n        tickSpacing = 0; \\n        //Start liquidity \\n        liquidity = 100 * uint128(PRECISION); \\n\\n        owner = msg.sender; \\n    }\\n\\n    address public immutable owner; \\n    uint24 public immutable  fee;\\n    Slot0 public slot0; // global state?\\n    address public immutable  factory;\\n    address public immutable  tradeToken;\\n    address public immutable  baseToken;\\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\\n\\n    uint128 public liquidity;\\n\\n    mapping(uint16 => Tick.Info) public  ticks;\\n\\n    mapping(bytes32 => Position.Info) public  positions;\\n\\n    // mapping(uint16=> PricePoint) Points; \\n\\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\\n    uint256 public constant ROUNDLIMIT = 1e4; \\n    uint256 public constant PRECISION = 1e18; \\n    address public entry; \\n\\n    /// @notice previliged function called by the market maker \\n    /// if he is the one providing all the liquidity \\n    function setLiquidity(uint128 liq) internal  \\n    //onlyEntry\\n    {\\n        liquidity = liq; \\n    }\\n\\n    function setEntry(address _entry) external onlyEntry{\\n        entry = _entry; \\n    }\\n    function lock() external onlyEntry{\\n        slot0.unlocked = !slot0.unlocked; \\n    }\\n\\n    function positionIsFilled(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk\\n    ) \\n        public view returns(bool){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        return (liq>0 && numCross > crossId); \\n    }\\n\\n    function setPriceAndPoint(uint256 price) internal  \\n    //onlyOwner\\n    {\\n        slot0.point = priceToPoint(price);         \\n        slot0.curPrice = price.toUint160(); \\n    }\\n\\n    function getCurPrice() external view returns(uint256){\\n        return slot0.curPrice; \\n    }\\n\\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\\n        return uint256(ticks.oneTimeLiquidity(point)); \\n    }    \\n\\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\\n        return ticks.getNumCross(point, moveUp); \\n    }\\n\\n\\n    struct Slot0 {\\n        // the current price\\n        uint160 curPrice;\\n        // the current tick\\n        uint16 point;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n\\n        // Whether liquidity provision is amortized \\n        bool amortized; \\n\\n        // Where to modify liquidity \\n        uint16 modifyLiqPoint; \\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        uint256 amountCalculated;\\n        // current sqrt(price)\\n        uint256 curPrice;\\n        // the tick associated with the current price\\n        uint16 point;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobal;\\n        // amount of input token paid as protocol fee\\n        uint128 protocolFee;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n        uint128 liquidityStart; \\n\\n\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint256 priceStart;\\n        // the next tick to swap to from the current tick in the swap direction\\n        uint16 pointNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // price for the next tick (1/0)\\n        uint256 priceNextLimit;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n\\n        uint128 liqDir; \\n    }\\n\\n    struct swapVars{\\n        uint256 a;\\n        uint256 s; \\n        uint256 b; \\n    }\\n\\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\\n    /// -amountSpecified is in trade if moveUp, else is in base \\n    /// returns amountIn if moveUp, cash, else token\\n    /// returns amountOut if moveUp, token, else cash \\n    function trade(\\n        address recipient, \\n        bool moveUp, \\n        int256 amountSpecified, \\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\\n        console.logString('---New Trade---'); \\n\\n        Slot0 memory slot0Start = slot0; \\n        uint256 pDelta = priceDelta; \\n\\n        SwapState memory state = SwapState({\\n            amountSpecifiedRemaining: amountSpecified, \\n            amountCalculated: 0, \\n            curPrice: uint256(slot0Start.curPrice),\\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\\n            protocolFee: 0, \\n            liquidity: liquidity, \\n            liquidityStart: liquidity,\\n            point: slot0.point\\n            }); \\n        swapVars memory vars = swapVars({\\n            a:0,\\n            b:0,\\n            s:0\\n            });\\n\\n        bool exactInput = amountSpecified > 0;\\n\\n        // increment price by 1/1e18 if at boundary, and go back up a point,\\n        // should be negligible compared to fees TODO \\n        if (mod0(state.curPrice, pDelta) && !moveUp) {\\n            state.curPrice += 1; \\n            state.point = priceToPoint(state.curPrice);\\n            slot0.point = state.point; \\n            slot0Start.point = state.point; \\n        }\\n        \\n        require(moveUp? priceLimit>= state.curPrice : priceLimit<= state.curPrice, \\\"plimitERR\\\" ); \\n        priceLimit = pointToPrice(priceToPoint(priceLimit)); \\n\\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\\n            StepComputations memory step; \\n            step.priceStart = state.curPrice; \\n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \\n\\n            step.pointNext = moveUp? state.point + 1 : state.point-1; \\n\\n            // Need liquidity for both move up and move down for path independence within a \\n            // given point range. Either one of them should be 0 \\n            step.liqDir = ticks.oneTimeLiquidity(state.point);\\n            vars.a = exactInput \\n                ? inv(state.liquidity + step.liqDir)\\n                : invRoundUp(state.liquidity + step.liqDir); \\n            vars.b = yInt(state.curPrice, moveUp); \\n            vars.s = xMax(state.curPrice, vars.b, vars.a); \\n \\n            //If moveup, amountIn is in cash, amountOut is token and vice versa \\n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\\n                state.curPrice, \\n                step.priceNextLimit,    \\n                state.amountSpecifiedRemaining, \\n                fee, \\n                vars               \\n                ); \\n\\n            {console.log('________'); \\n            console.log('CURPRICE', state.curPrice); \\n            console.log('trading; liquidity, amountleft', state.liquidity); \\n            console.log(uint256(state.amountSpecifiedRemaining));\\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \\n            console.log('a', vars.a); }\\n            console.log('amountinandout', step.amountIn, step.amountOut); \\n            console.log('s,b', vars.s, vars.b); \\n\\n            if (exactInput){\\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \\n            }\\n            else{\\n                state.amountSpecifiedRemaining += int256(step.amountIn); \\n            }\\n            state.amountCalculated += step.amountOut; \\n\\n            if (state.liquidity>0)\\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \\n\\n            // If next limit reached, cross price range and change slope(liquidity)\\n            if (state.curPrice == step.priceNextLimit){\\n\\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\\n                // Else if crossing DOWN, bids are all filled \\n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \\n\\n                int128 liquidityNet = ticks.cross(\\n                    step.pointNext, \\n                    feeGrowthGlobalBase,\\n                    feeGrowthGlobalTrade\\n                    ); \\n\\n                if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint)\\n                    liquidityNet = liquidityNet += dynamicLiq[step.pointNext]; \\n                    console.log('dynamicLiq', uint256(int256(dynamicLiq[step.pointNext])), uint256(int256(liquidityNet))); \\n\\n                if (!moveUp) liquidityNet = -liquidityNet; \\n\\n\\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\\n                state.point = step.pointNext;  \\n            }\\n        }\\n\\n        slot0.curPrice = state.curPrice.toUint160(); \\n        if(state.point != slot0Start.point) slot0.point = state.point; \\n            \\n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\\n\\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \\n            \\n        // (amountIn, amountOut) = exactInput\\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n\\n        (amountIn, amountOut) = exactInput\\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n                    console.log('???', uint256(state.amountSpecifiedRemaining) , uint256(amountSpecified)); \\n\\n    }\\n\\n    function placeLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk  \\n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \\n        //TODO mint NFT \\n        // Should only accept asks for price above the current point range\\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\\\"ask below prie\\\"); \\n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\\\"bids above prie\\\"); \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        numCross = ticks.getNumCross(point, isAsk); \\n        position.updateLimit(int128(amount), isAsk, numCross); \\n\\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \\n\\n        // If placing bids, need to escrow baseAsset, vice versa \\n        address tokenToEscrow = isAsk? tradeToken : baseToken;\\n\\n        amountToEscrow = isAsk\\n                ? tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    )\\n            \\n                : baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    ); \\n\\n        console.log('amountbid', amountToEscrow); \\n\\n    }\\n\\n    function reduceLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \\\"Can't reduce order for current tick\\\"); \\n\\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\\n\\n        position.updateLimit(-int128(amount), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \\n\\n        address tokenToReturn = isAsk? tradeToken : baseToken;\\n        \\n        amountToReturn = isAsk\\n            ? tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                )\\n         \\n            : baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                );\\n    }\\n\\n    /// @notice called when maker wants to claim when the the price is at the \\n    /// point he submitted the order\\n    function claimPartiallyFilledOrder(\\n        address recipient, \\n        uint16 point,\\n        bool isAsk\\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\\n        Slot0 memory _slot0 = slot0; \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n        require(priceToPoint(uint256(_slot0.curPrice)) == point, \\\"Not cur price\\\"); \\n\\n        // Assume trying to withdraw all liquidity provided \\n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \\n       \\n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \\n\\n        // Get total trade filled OR remaining\\n        tradeAmount = tradeGivenLiquidity(\\n            pointToPrice(point+1),\\n            _slot0.curPrice, \\n            liqToWithdraw\\n        ); \\n           \\n        // Get total base filled OR remaining \\n        baseAmount = baseGivenLiquidity(\\n            _slot0.curPrice, \\n            pointToPrice(point), \\n            liqToWithdraw\\n            ); \\n\\n    }\\n\\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \\n    /// or crossDown \\n    function claimFilledOrder(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        require(numCross > crossId, \\\"Position not filled\\\");\\n\\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        // Sold to base when asks are filled\\n        if(isAsk) claimedAmount = baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        // Bought when bids are filled so want tradeTokens\\n        else claimedAmount = tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        position.updateLimit(-int128(liq), isAsk, 0); \\n        \\n        // Need to burn AND \\n\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        uint16 pointLower;\\n        uint16 pointUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n    }\\n\\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\\n    function provide(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount, \\n        bytes calldata data \\n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\\n        require(amount > 0, \\\"0 amount\\\"); \\n\\n        (,  amount0,  amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        //mintCallback\\n\\n    }\\n\\n    function remove(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount\\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\\n\\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: -int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        if(amount0>0 || amount1> 0){\\n            (position.tokensOwed0, position.tokensOwed1) = (\\n                position.tokensOwed0 + amount0,\\n                position.tokensOwed1 + amount1\\n            );\\n        }\\n        return (amount0, amount1); \\n    }\\n\\n    function collect(\\n        address recipient,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\\n\\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\\n\\n        if (amount0 > 0) {\\n            position.tokensOwed0 -= amount0;\\n        }\\n        if (amount1 > 0) {\\n            position.tokensOwed1 -= amount1;\\n        }\\n    }\\n\\n\\n    function _modifyPosition(ModifyPositionParams memory params)\\n    private \\n    returns(\\n        Position.Info storage position, \\n        uint256 baseAmount, \\n        uint256 tradeAmount\\n        )\\n    {\\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\\n\\n        position = _updatePosition(\\n            params.owner,\\n            params.pointLower,\\n            params.pointUpper,\\n            params.liquidityDelta,\\n            _slot0.point\\n        );\\n\\n        if (params.liquidityDelta != 0){\\n            if (_slot0.point < params.pointLower){\\n                // in case where liquidity is just asks waiting to be sold into, \\n                // so need to only provide tradeAsset \\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n            } else if( _slot0.point < params.pointUpper){\\n                uint128 liquidityBefore = liquidity; \\n\\n                // Get total asks to be submitted above current price\\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper),\\n                    _slot0.curPrice, \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Get total bids to be submitted below current price \\n                baseAmount = baseGivenLiquidity(\\n                    _slot0.curPrice, \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Slope changes since current price is in this range \\n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\\n\\n            } else{\\n                // liquidity is just bids waiting to be bought into \\n                baseAmount = baseGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                ); \\n            }\\n        }\\n    }\\n\\n    uint256 public feeGrowthGlobalBase;\\n    uint256 public feeGrowthGlobalTrade;\\n\\n    function _updatePosition(\\n        address owner, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        int128 liquidityDelta, \\n        uint16 point \\n        ) private returns(Position.Info storage position){\\n\\n        position = positions.get(owner, pointLower, pointUpper); \\n\\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \\n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \\n\\n        if(liquidityDelta != 0){\\n\\n            ticks.update(\\n                pointLower, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                false\\n                ); \\n\\n            ticks.update(\\n                pointUpper, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                true\\n                ); \\n        } \\n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \\n    }\\n\\n\\n    mapping(uint16=> int128) dynamicLiq; \\n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\\n        dynamicLiq[point] = liq; \\n    }\\n    function setModifyLiqPoint(uint16 point) internal{\\n        slot0.modifyLiqPoint = point;  \\n    }\\n    function amortizeLiq() internal{\\n        slot0.amortized = true; \\n    }\\n\\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return (p2-p1).mulWadDown(L); \\n    }\\n\\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \\n    }\\n\\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return T.divWadDown(p2-p1); \\n    }\\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \\n    }\\n\\n    function pointToPrice(uint16 point) public pure returns(uint160){\\n        return(uint256(point) * priceDelta).toUint160(); \\n    }\\n\\n    /// @notice will round down to nearest integer \\n    function priceToPoint(uint256 price) public pure returns(uint16){\\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        return (curPrice-b).divWadUp(a); \\n    }\\n\\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\\n    /// the current point\\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\\n        uint16 point = priceToPoint(curPrice); \\n\\n        // If at boundary when moving down, decrement point by one\\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \\n    }\\n\\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\\n        if (moveUp) return uint256(point+1) * pDelta; \\n        else return uint256(point) * pDelta; \\n    }\\n\\n    function inv(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \\n    }\\n    function invRoundUp(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \\n    }\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\\n        return (a%b ==0); \\n    }\\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\\n    /// @param x The liquidity before change\\n    /// @param y The delta by which liquidity should be changed\\n    /// @return z The liquidity delta\\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\\n        return  isAsk\\n                ? positions.get(to, point, point+1).askLiq\\n                : positions.get(to, point, point+1).bidLiq; \\n    }\\n\\n}\\n\\nlibrary LinearCurve{\\n    uint256 public constant PRECISION = 1e18; \\n    using FixedPointMath for uint256; \\n\\n\\n    /// @notice Compute results of swap given amount in and params\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// b is 0 and s is curPrice/a during variable liquidity phase\\n    function swapStep(\\n        uint256 curPrice, \\n        uint256 targetPrice, \\n        int256 amountRemaining, \\n        uint24 feePips,    \\n        GranularBondingCurve.swapVars memory vars       \\n        ) \\n        public \\n        pure \\n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\\n\\n        bool moveUp = targetPrice >= curPrice; \\n        bool exactInput = amountRemaining >= 0; \\n\\n        // If move up and exactInput, amountIn is base, amountOut is trade \\n        if (exactInput){\\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\\n\\n            if (moveUp){\\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \\n\\n                // If overshoot go to next point\\n                if (nextPrice >= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out for a given price range is Pdelta / a \\n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \\n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \\n                }            \\n                else {\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }   \\n            }\\n\\n            // amountIn is trade, amountOut is base \\n            else {\\n                // If amount is greater than s, then need to cap it \\n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \\n                // If undershoot go to previous point \\n                if(nextPrice <= targetPrice && vars.a > 0){//TODO might introduce bugs \\n                    nextPrice = targetPrice; \\n\\n                    // max amount out is area under curve \\n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \\n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \\n\\n                }\\n                else{\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }\\n            }\\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \\n        }\\n\\n        else {\\n            if(moveUp){\\n                uint256 remaining = uint256(-amountRemaining); \\n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \\n\\n                // if overshoot\\n                if(nextPrice>=targetPrice){\\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \\n                    nextPrice = targetPrice; \\n\\n                    // Prevent stuck cases where point is almost filled but not quite \\n                    if(remaining - amountIn<=1e4){\\n                        amountIn = remaining; \\n                    } \\n                }\\n                else amountIn = remaining; \\n\\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\\n\\n            }\\n            else{\\n                //TODO \\n            }\\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\\n            amountOut = amountOut + feeAmount;\\n        }\\n    }\\n\\n\\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\\n    /// @param amount: amount of base in\\n    /// returns amountDelta wanted token returned \\n    function amountOutGivenIn( \\n        uint256 amount,\\n        uint256 s, \\n        uint256 a, \\n        uint256 b, \\n        bool up\\n        ) \\n        public \\n        pure \\n        returns(uint256 amountDelta, uint256 resultPrice) {\\n        \\n        // If liquidity is not infinite \\n        if(a > 0){\\n            if (up){\\n                //TODO overflow on small amount \\n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \\n                uint256 y = 2*( a.mulWadDown(amount)); \\n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\\n                uint256 z = (a.mulWadDown(s) + b); \\n                amountDelta = (x_y_sqrt-z).divWadDown(a);\\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \\n            } else{\\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \\n                amountDelta = amount.mulWadDown(z); \\n                resultPrice = a.mulWadDown(s-amount) + b; \\n            }\\n        }\\n\\n        // When a = 0, infinite liquidity and constant price\\n        else{     \\n            if(up){\\n                amountDelta = amount.divWadDown(b); \\n            } else{\\n                amountDelta = amount.mulWadDown(b); \\n            }\\n            resultPrice = b;             \\n        }\\n    }\\n\\n    /// @notice calculates area under the curve from s to s+amount\\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\\n     /// returned in collateral decimals\\n    function areaUnderCurve(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \\n    }\\n    function areaUnderCurveRoundUp(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        // you want area to be big for a given amount \\n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n\\n}\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    using FixedPointMath for uint256;\\n\\n    // info stored for each user's position\\n    struct Info {\\n        uint128 bidCrossId; \\n        uint128 askCrossId; \\n        uint128 askLiq; \\n        uint128 bidLiq; \\n\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // the fees owed to the position owner in token0/token1\\n        uint256 tokensOwed0;\\n        uint256 tokensOwed1;\\n\\n        \\n    }\\n\\n    function updateLimit(\\n        Info storage self,\\n        int128 limitLiqudityDelta, \\n        bool isAsk, \\n        uint128 crossId\\n        ) internal {\\n\\n        if (isAsk) {\\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \\n        } \\n\\n        else {\\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \\n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \\n        }\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        uint16 tickLower,\\n        uint16 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees\\n        uint128 tokensOwed0 = uint128(\\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n        uint128 tokensOwed1 =uint128(\\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n            \\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\\n            self.tokensOwed0 += tokensOwed0;\\n            self.tokensOwed1 += tokensOwed1;\\n        }\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n}\\n\\n/// @title Tick\\n/// @notice Contains functions for managing tick processes and relevant calculations\\nlibrary Tick {\\n    using FixedPointMath for uint256;\\n\\n    using SafeCast for int256;\\n\\n    // info stored for each initialized individual tick\\n    struct Info {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutsideBase;\\n        uint256 feeGrowthOutsideTrade;\\n        // the cumulative tick value on the other side of the tick\\n        int56 tickCumulativeOutside;\\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint160 secondsPerLiquidityOutsideX128;\\n        // the seconds spent on the other side of the tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint32 secondsOutside;\\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\\n        bool initialized;\\n\\n        uint128 askLiquidityGross; \\n        uint128 bidLiquidityGross;\\n        uint128 askNumCross; \\n        uint128 bidNumCross; \\n    }\\n\\n    function getNumCross(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal view returns(uint128){\\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \\n    }\\n\\n    function oneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick \\n        ) internal view returns(uint128){\\n        Tick.Info memory info = self[tick]; \\n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \\n        return info.askLiquidityGross + info.bidLiquidityGross; \\n    }\\n\\n    function deleteOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal {\\n        Tick.Info storage info = self[tick]; \\n        if(isAsk) {\\n            info.askLiquidityGross = 0;\\n            info.askNumCross++; \\n            console.log('tick??', tick); \\n        }\\n        else {\\n            info.bidLiquidityGross = 0; \\n            info.bidNumCross++; \\n        }\\n    }\\n\\n    function updateOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        int128 oneTimeLiquidityDelta,\\n        bool isAsk\\n        ) internal {\\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \\n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\\n    }\\n\\n    function update(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick,\\n        uint16 tickCurrent,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthGlobalBase, \\n        uint256 feeGrowthGlobalTrade, \\n        bool upper\\n    ) internal returns (bool flipped) {\\n        Tick.Info storage info = self[tick];\\n\\n        uint128 liquidityGrossBefore = info.liquidityGross; \\n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if(liquidityGrossBefore == 0) {\\n            if(tick<=tickCurrent){\\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \\n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \\n            }\\n            info.initialized = true; \\n        }\\n        info.liquidityGross = liquidityGrossAfter;\\n\\n        info.liquidityNet = upper \\n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \\n    }\\n\\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\\n        delete self[tick];\\n    }\\n\\n    function cross(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick, \\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal returns (int128 liquidityNet) {\\n        Tick.Info storage info = self[tick]; \\n\\n        liquidityNet = info.liquidityNet; \\n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \\n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n\\n    function getFeeGrowthInside(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint16 tickCurrent,\\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\\n        Info storage lower = self[tickLower];\\n        Info storage upper = self[tickUpper];\\n\\n        // calculate fee growth below\\n        uint256 feeGrowthBelowBase;\\n        uint256 feeGrowthBelowTrade;\\n        if (tickCurrent >= tickLower) {\\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\\n        }\\n\\n        // calculate fee growth above\\n        uint256 feeGrowthAboveBase;\\n        uint256 feeGrowthAboveTrade;\\n        if (tickCurrent < tickUpper) {\\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\\n        }\\n\\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\\n    }\\n}\\n\\n\\ncontract SpotPool is GranularBondingCurve{\\n\\n    ERC20 BaseToken; //junior\\n    ERC20 TradeToken; //senior \\n    // GranularBondingCurve public pool; \\n\\n    constructor(\\n        address _baseToken, \\n        address _tradeToken\\n        )GranularBondingCurve(_baseToken,_tradeToken){\\n        BaseToken = ERC20(_baseToken); \\n        TradeToken = ERC20(_tradeToken); \\n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \\n    }\\n\\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\\n\\n        if(up){\\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\\n            console.log('togive', amountOut, amountIn); \\n            TradeToken.transfer(recipient, amountOut); \\n            console.log('balofre', BaseToken.balanceOf(recipient));\\n            BaseToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n\\n        else{\\n            BaseToken.transfer(recipient, amountOut); \\n            TradeToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n    }\\n\\n    // function getCurPrice() external view returns(uint256){\\n    //     return uint256(pool.getCurPrice());\\n    // }\\n\\n    /// @notice if buyTradeForBase, move up, and vice versa \\n    function takerTrade(\\n        address recipient, \\n        bool buyTradeForBase, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data        \\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        (poolamountIn, poolamountOut) = this.trade(\\n            recipient, \\n            buyTradeForBase, \\n            amountIn,  \\n            priceLimit, \\n            data\\n        ); \\n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \\n    }\\n\\n    /// @notice specify how much trade trader intends to sell/buy \\n    function makerTrade(\\n        bool buyTradeForBase,\\n        uint256 amountIn,\\n        uint16 point\\n        ) external {\\n        (uint256 toEscrowAmount, uint128 crossId) \\n                = this.placeLimitOrder(msg.sender, \\n                    point, \\n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \\n                    !buyTradeForBase); \\n\\n        // Collateral for bids\\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n\\n        // or asks\\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n    }\\n\\n    function makerClaim(\\n        uint16 point, \\n        bool buyTradeForBase\\n        ) external {\\n        uint256 claimedAmount = this.claimFilledOrder(\\n            msg.sender, \\n            point, \\n            !buyTradeForBase\\n        ); \\n\\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\\n        else BaseToken.transfer(msg.sender, claimedAmount); \\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\",\"keccak256\":\"0x0dbebc2cb6a95e547a45e36907c8f93202dcf4bf655cd94e9fe963653bcdc81d\",\"license\":\"UNLICENSED\"},\"contracts/bonds/boundedDerivatives.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport \\\"./GBC.sol\\\"; \\n// import {BoundedDerivativesPool, LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice Uses AMM as a derivatives market,where the price is bounded between two price\\n/// and mints/burns tradeTokens. \\n/// stores all baseTokens for trading, and also stores tradetokens when providing liquidity, \\n/// @dev Short loss is bounded as the price is bounded, no need to program liquidations logic \\ncontract BoundedDerivativesPool is GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using SafeCast for uint256; \\n    // using Position for Position.Info;\\n    // uint256 constant PRECISION = 1e18; \\n    ERC20 public  BaseToken; \\n    ERC20 public  TradeToken; \\n    ERC20 public  s_tradeToken; \\n    uint256 public constant maxPrice = 1e18; \\n\\n    bool immutable noCallBack; \\n    constructor(\\n        address base, \\n        address trade, \\n        address s_trade, \\n        bool _noCallBack\\n        // address _pool \\n        ) GranularBondingCurve(base, trade){\\n        BaseToken =  ERC20(base);\\n        TradeToken = ERC20(trade);\\n        s_tradeToken = ERC20(s_trade);\\n        noCallBack = _noCallBack; \\n    }\\n\\n    /// @notice recipient recieves amountOut in exchange for giving this contract amountIn (base)\\n    function mintAndPull(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        \\n        // Mint and Pull \\n        if(isLong) TradeToken.mint(recipient, amountOut); \\n        else s_tradeToken.mint(recipient, amountOut); \\n        BaseToken.transferFrom(recipient,address(this), amountIn); \\n    }\\n\\n    function burnAndPush(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        // Burn and Push \\n        if(isLong) TradeToken.burn(recipient, amountIn); \\n        else s_tradeToken.burn(recipient, amountIn); \\n   \\n        BaseToken.transfer(recipient, amountOut); \\n    }\\n\\n    function baseBal() internal view returns(uint256){\\n        return BaseToken.balanceOf(address(this)); \\n    }\\n\\n    /// @notice Long up the curve, or short down the curve \\n    /// @param amountIn is base if long, trade if short\\n    /// @param priceLimit is slippage tolerance\\n    function takerOpen(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external  returns(uint256 poolamountIn, uint256 poolamountOut ){\\n        if(isLong){\\n            // Buy up \\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            if (noCallBack) mintAndPull(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else {\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \\n                require(baseBal() >= poolamountIn + bal, \\\"balERR\\\"); \\n                TradeToken.mint(abi.decode(data, (address)), poolamountOut); \\n            }\\n        }\\n\\n        else{\\n            // just shift pool state\\n            (poolamountIn, poolamountOut) = trade(\\n                address(this), \\n                false, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint b = baseBal(); \\n            console.log('basebal',b , poolamountOut); \\n            require(poolamountOut <= baseBal(), \\\"!ammLiq\\\"); \\n            uint256 cached_poolamountOut = poolamountOut; \\n            // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\\n            poolamountOut = poolamountIn.mulWadDown(maxPrice) - poolamountOut;\\n\\n            // One s_tradeToken is a representation of debt+sell of one tradetoken\\n            // Escrow collateral required for shorting, where price for long + short = maxPrice, \\n            // so (maxPrice-price of trade) * quantity\\n            if (noCallBack) mintAndPull(msg.sender, poolamountIn, poolamountOut, false);\\n\\n            else{\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \\n                require(baseBal() >= poolamountOut + bal, \\\"balERR\\\"); \\n                s_tradeToken.mint(abi.decode(data,(address)), poolamountIn); \\n\\n                // need to send cached poolamountOut(the area under the curve) data for accounting purposes\\n                poolamountIn = cached_poolamountOut; \\n            }\\n\\n            // BaseToken.transferFrom(msg.sender, address(this), poolamountIn.mulWadDown(maxPrice) - poolamountOut); \\n            // s_tradeToken.mint(msg.sender, uint256(amountIn)); \\n        }\\n\\n    }\\n\\n    /// @param amountIn is trade if long, ALSO trade if short, since getting rid of s_trade \\n    function takerClose(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        // Sell down\\n        if(isLong){\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender,\\n                false, \\n                amountIn, //this should be trade tokens\\n                priceLimit, \\n                data\\n            ); \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else burnAndPush(abi.decode(data, (address)), poolamountOut, poolamountIn, true );                             \\n        }\\n\\n        else{            \\n            // buy up with the baseToken that was transferred to this contract when opened, in is base out is trade\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountIn = poolamountIn; \\n\\n            // collateral used to buy short \\n            poolamountIn = poolamountOut.mulWadDown(maxPrice) - poolamountIn; \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountIn,poolamountOut, false);\\n            else {\\n                burnAndPush(abi.decode(data, (address)), poolamountIn, poolamountOut,false ); \\n                poolamountOut = cached_poolamountIn; \\n            }\\n\\n            // s_tradeToken.burn(msg.sender, poolamountOut); \\n            // BaseToken.transfer(msg.sender, poolamountOut.mulWadDown(maxPrice) - poolamountIn);\\n        }\\n    }\\n\\n    /// @notice provides oneTimeliquidity in the range (point,point+1)\\n    /// @param amount is in base if long, trade if in short  \\n    function makerOpen(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong,\\n        address recipient\\n        )external  returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // escrowAmount is base \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient,\\n                point, \\n                uint128(liquidityGivenBase(pointToPrice(point+1), pointToPrice(point), amount)), \\n                false\\n                ); \\n            BaseToken.transferFrom(recipient, address(this), toEscrowAmount); \\n        }\\n\\n        // need to set limit for sells, but claiming process is different then regular sells \\n        else{\\n            // escrowAmount is trade \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)) , \\n                true\\n                ); \\n\\n            // escrow amount is (maxPrice - avgPrice) * quantity \\n            uint256 escrowCollateral = toEscrowAmount - baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) //positive since adding asks, not subtracting \\n                    ); \\n            BaseToken.transferFrom(recipient, address(this), escrowCollateral); \\n            toEscrowAmount = escrowCollateral; \\n        }\\n\\n    }\\n\\n    function makerClaimOpen(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            uint256 claimedAmount = claimFilledOrder(recipient, point, false ); \\n\\n            // user already escrowed funds, so need to send him tradeTokens \\n            TradeToken.mint(recipient, claimedAmount);          \\n        }\\n\\n        else{           \\n            s_tradeToken.mint(recipient, \\n                tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    getLiq(msg.sender, point, true)\\n                    )\\n                ); \\n\\n            // open short is filled sells, check if sells are filled. If it is,\\n            // claimedAmount of basetokens should already be in this contract \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n        }\\n\\n    }\\n    /// @notice amount is trade if long, but ALSO trade if short(since trade quantity also coincides\\n    /// with shortTrade quantity )\\n    function makerClose(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // close long is putting up trades for sells, \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point, \\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                true\\n                ); \\n            //maybe burn it when claiming, and just escrow? \\n            TradeToken.burn(recipient, toEscrowAmount); \\n        }\\n\\n        else{\\n            // Place limit orders for buys \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                false\\n                ); \\n\\n            // burn s_tradeTokens, \\n            s_tradeToken.burn(recipient, amount); \\n\\n        }\\n    }\\n\\n    function makerClaimClose(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        ) external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            // Sell is filled, so need to transfer back base \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n            BaseToken.transfer(recipient, claimedAmount); \\n        }\\n        else{\\n            uint128 liq = getLiq(recipient, point, false); \\n\\n            // Buy is filled, which means somebody burnt trade, so claimedAmount is in trade\\n            claimedAmount = claimFilledOrder(recipient, point, false);\\n            claimedAmount = claimedAmount.mulWadDown(maxPrice) \\n                            - baseGivenLiquidity(\\n                            pointToPrice(point+1), \\n                            pointToPrice(point), \\n                            liq); \\n            BaseToken.transfer(recipient, claimedAmount);\\n        }\\n    }    \\n\\n    function makerPartiallyClaim(\\n        uint16 point, \\n        bool isLong,\\n        bool open, \\n        address recipient\\n        ) external returns(uint256 baseAmount, uint256 tradeAmount){\\n   \\n        if(open){\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true);\\n        }\\n        else{\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false);\\n        }\\n        \\n        BaseToken.transfer(recipient, baseAmount);\\n        TradeToken.mint(recipient, tradeAmount); \\n    }\\n\\n    /// @notice amount is in base if long, trade if short \\n    function makerReduceOpen(\\n        uint16 point, \\n        uint256 amount, \\n        bool isLong, \\n        address recipient\\n        ) external{\\n    \\n        if(isLong){\\n            uint256 returned_amount =reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenBase(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point),\\n                    amount\\n                    ).toUint128(), \\n                false\\n                ); \\n            // need to send base back \\n            BaseToken.transfer(recipient, returned_amount); \\n        }\\n        else {\\n            uint128 liq = liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amount).toUint128(); \\n            // Reduce asks \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liq, \\n                true\\n                ); \\n\\n            // Need to send escrowed basetoken back, which is shortTrade quantity - baseGivenLiquidity \\n            BaseToken.transfer(recipient, \\n                amount - baseGivenLiquidity(pointToPrice(point+1), pointToPrice(point), liq));\\n        }\\n    }\\n\\n    /// @notice amount is in trade if long, ALSO trade if short \\n    function makerReduceClose(      \\n        uint16 point, \\n        uint256 amount, \\n        bool isLong,\\n        address recipient\\n        ) external{\\n\\n        if(isLong){\\n            uint256 returned_amount = reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                true\\n                ); \\n            // need to send trade back \\n            TradeToken.mint(recipient, returned_amount); \\n        }\\n\\n        else{\\n            // reduce limit bids \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                false\\n            ); \\n             \\n            s_tradeToken.mint(recipient, amount); \\n        }\\n    }\\n\\n    // TODO separate contracts \\n    // function provideLiquidity(\\n    //     uint16 pointLower,\\n    //     uint16 pointUpper,\\n    //     uint128 amount, \\n    //     bytes calldata data \\n    //     ) external {\\n\\n    //     (uint256 amount0, uint256 amount1) = provide(\\n    //         msg.sender, \\n    //         pointLower, \\n    //         pointUpper, \\n    //         amount, \\n    //         data \\n    //     ); \\n    //     BaseToken.transferFrom(msg.sender, address(this), amount0); \\n    //     // TradeToken.transferFrom(msg.sender, address(this), amount1);\\n    //     TradeToken.burn(msg.sender, amount1);\\n    // }\\n\\n    // function withdrawLiquidity(\\n    //     uint16 pointLower,\\n    //     uint16 pointUpper,\\n    //     uint128 amount, \\n    //     bytes calldata data \\n    //     )external{\\n\\n    //     (uint256 amountBase, uint256 amountTrade) = remove(\\n    //         msg.sender, \\n    //         pointLower, \\n    //         pointUpper, \\n    //         amount\\n    //     ); \\n      \\n    //     collect(\\n    //         msg.sender, \\n    //         pointLower,\\n    //         pointUpper,\\n    //         type(uint128).max,\\n    //         type(uint128).max\\n    //     ); \\n\\n    //     BaseToken.transfer(msg.sender,  amountBase); \\n    //     TradeToken.mint(msg.sender, amountTrade); \\n    // }\\n\\n    //TODO fees, skipping uninit for gas, below functions\\n    // possible attacks: manipulation of price with no liquidityregions, add a bid/ask and a naive \\n    // trader fills, and immediately submit a ask much higher/lower\\n    // gas scales with number of loops, so need to set ticks apart large, or provide minimal liquidity in each tick\\n\\n}\\n\\ninterface iTradeCallBack{\\n    function tradeCallBack(\\n        uint256 amount0,\\n bytes calldata data    ) external;\\n} \\n\",\"keccak256\":\"0x302284a44be40ac9cdfa964cf3244beefa565008d1b901026caa91ad197bd388\"},\"contracts/bonds/libraries.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMath {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint256(y)) == y);\\n    // }\\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint160(y)) == y);\\n    // }\\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\\n        require((z = uint128(y)) == y);\\n    }\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\\n\\ncontract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n    function mint(address to, uint256 amount) public {\\n      _mint(to, amount); \\n    }\\n    function burn(address to, uint256 amount) public {\\n      _burn(to, amount); \\n    }\\n}\",\"keccak256\":\"0x6f4b41b0a3a677144ec92ae040f756a7af61ffe54f497f92d7f20a729b3cb091\"},\"contracts/bonds/synthetic.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport { LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {BoundedDerivativesPool} from \\\"./boundedDerivatives.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\ncontract ZCBFactory{\\n    function newBond(\\n        string memory name, \\n        string memory description \\n        ) public returns(address) {\\n        ERC20 bondToken = new ERC20(name,description, 18);\\n        return address(bondToken); \\n    }\\n\\n}\\ncontract SyntheticZCBPoolFactory{\\n    address public immutable controller;\\n    address public immutable zcbFactory; \\n    constructor(address _controller, address _zcbFactory){\\n        controller = _controller; \\n        zcbFactory = _zcbFactory; \\n    }\\n\\n    event PoolCreated(address pool, address longZCB, address shortZCB);\\n\\n    /// @notice param base is the collateral used in pool \\n    function newPool(\\n        address base, \\n        address entry\\n        ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\\n        longZCB = ZCBFactory(zcbFactory).newBond(\\\"longZCB\\\", \\\"long\\\");\\n        shortZCB = ZCBFactory(zcbFactory).newBond(\\\"shortZCB\\\", \\\"short\\\");\\n\\n        pool = new SyntheticZCBPool(\\n            base, longZCB, shortZCB, entry, controller\\n        ); \\n        emit PoolCreated(address(pool), longZCB, shortZCB);\\n    }\\n}\\n\\ncontract SyntheticZCBPool is BoundedDerivativesPool{\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 public a_initial;\\n    uint256 public b_initial; // b without discount cap \\n    uint256 public b;\\n    uint256 public discount_cap; \\n    uint256 public discountedReserves; \\n    uint256 public upperBound; \\n    address public immutable controller; \\n    uint256 public constant precision = 1e18; \\n    constructor(address base, \\n        address trade, \\n        address s_trade, \\n        address _entry, \\n        address _controller\\n        )BoundedDerivativesPool(base,trade,s_trade, false){\\n        entry = _entry; \\n        controller = _controller; \\n        }\\n\\n    /// @notice calculate and store initial curve params that takes into account\\n    /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\\n    /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \\n    /// @param sigma is the proportion of P that is going to be bought at a discount  \\n    function calculateInitCurveParams(\\n        uint256 P, \\n        uint256 I, \\n        uint256 sigma,\\n        uint256 alpha, \\n        uint256 delta) external {\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        b_initial = (2*P).divWadDown(P+I) - precision; \\n        a_initial = (precision-b_initial).divWadDown(P+I); \\n\\n        // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\\n        (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\\n        (, upperBound )= LinearCurve.amountOutGivenIn(P.mulWadDown(alpha+delta), 0, a_initial, b_initial,true); \\n\\n        // Set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a_initial))); \\n        setPriceAndPoint(b);\\n    }\\n\\n    /// @notice calculates initparams for pool based instruments \\n    /// param endPrice is the inception Price of longZCB, or its price when there is no discount\\n    function calculateInitCurveParamsPool(\\n        uint256 saleAmount, \\n        uint256 initPrice, \\n        uint256 endPrice, \\n        uint256 sigma\\n        ) external returns(uint256 managementFee){\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        //TODO these fails at some inputs\\n        uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \\n        uint256 a = (endPrice - initPrice).divWadDown(saleAmountQty); \\n        \\n        //Set discount cap as saleAmount * sigma \\n        (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \\n        b = initPrice; \\n\\n        // How much total discounts are validators and managers getting\\n        managementFee = discount_cap.mulWadDown(endPrice) \\n            - saleAmount.mulWadDown(sigma) + saleAmountQty.mulWadDown(endPrice) - saleAmount ; \\n\\n        // set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a))); \\n        setPriceAndPoint(b); \\n        setDynamicLiquidity(priceToPoint(endPrice), type(int128).max); \\n        setModifyLiqPoint(priceToPoint(endPrice)); \\n    }\\n\\n    /// @notice computes area between the curve and max price for given storage parameters\\n    function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\\n        (uint256 amountDelta, ) = LinearCurve.amountOutGivenIn(amount, 0, a_initial, b_initial, true); \\n        return amountDelta.mulWadDown(maxPrice) - amount; \\n    }\\n\\n    /// @notice mints new zcbs \\n    function trustedDiscountedMint(\\n        address receiver, \\n        uint256 amount \\n        ) external{\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        TradeToken.mint(receiver, amount);\\n        discountedReserves += amount;\\n    }\\n\\n\\n    function trustedBurn(\\n        address trader, \\n        uint256 amount, \\n        bool long\\n        ) external {\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n        if (long) TradeToken.burn(trader, amount); \\n        else s_tradeToken.burn(trader, amount);\\n    }\\n\\n    function flush(address flushTo, uint256 amount) external {\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        if (amount == type(uint256).max) BaseToken.transfer(flushTo, baseBal()); \\n        else BaseToken.transfer(flushTo, amount); \\n    }\\n\\n    /// @notice resets AMM liquidity to 0 and make it ready to be liq provisioned \\n    /// by anyone \\n    function resetLiq() external{\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        setLiquidity(0); \\n        amortizeLiq(); \\n    }\\n\\n}\\n\",\"keccak256\":\"0x7d66091c54154e0260d41f7ceac8e2b9ce0193e15304d2776078bb17c4aba8a2\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"},\"lib/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061128e806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c155830214610030575b600080fd5b61004361003e366004610153565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b60008083836012604051610072906100a3565b61007e939291906101fd565b604051809103906000f08015801561009a573d6000803e3d6000fd5b50949350505050565b6110228061023783390190565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126100d757600080fd5b813567ffffffffffffffff808211156100f2576100f26100b0565b604051601f8301601f19908116603f0116810190828211818310171561011a5761011a6100b0565b8160405283815286602085880101111561013357600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806040838503121561016657600080fd5b823567ffffffffffffffff8082111561017e57600080fd5b61018a868387016100c6565b935060208501359150808211156101a057600080fd5b506101ad858286016100c6565b9150509250929050565b6000815180845260005b818110156101dd576020818501810151868301820152016101c1565b506000602082860101526020601f19601f83011685010191505092915050565b60608152600061021060608301866101b7565b828103602084015261022281866101b7565b91505060ff8316604083015294935050505056fe60e06040523480156200001157600080fd5b5060405162001022380380620010228339810160408190526200003491620001d5565b6000620000428482620002e9565b506001620000518382620002e9565b5060ff81166080524660a0526200006762000074565b60c0525062000433915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6000604051620000a89190620003b5565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200013857600080fd5b81516001600160401b038082111562000155576200015562000110565b604051601f8301601f19908116603f0116810190828211818310171562000180576200018062000110565b816040528381526020925086838588010111156200019d57600080fd5b600091505b83821015620001c15785820183015181830184015290820190620001a2565b600093810190920192909252949350505050565b600080600060608486031215620001eb57600080fd5b83516001600160401b03808211156200020357600080fd5b620002118783880162000126565b945060208601519150808211156200022857600080fd5b50620002378682870162000126565b925050604084015160ff811681146200024f57600080fd5b809150509250925092565b600181811c908216806200026f57607f821691505b6020821081036200029057634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620002e457600081815260208120601f850160051c81016020861015620002bf5750805b601f850160051c820191505b81811015620002e057828155600101620002cb565b5050505b505050565b81516001600160401b0381111562000305576200030562000110565b6200031d816200031684546200025a565b8462000296565b602080601f8311600181146200035557600084156200033c5750858301515b600019600386901b1c1916600185901b178555620002e0565b600085815260208120601f198616915b82811015620003865788860151825594840194600190910190840162000365565b5085821015620003a55787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000808354620003c5816200025a565b60018281168015620003e05760018114620003f65762000427565b60ff198416875282151583028701945062000427565b8760005260208060002060005b858110156200041e5781548a82015290840190820162000403565b50505082870194505b50929695505050505050565b60805160a05160c051610bbf6200046360003960006104700152600061043b0152600061015f0152610bbf6000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c806370a082311161008c5780639dc29fac116100665780639dc29fac146101f8578063a9059cbb1461020b578063d505accf1461021e578063dd62ed3e1461023157600080fd5b806370a08231146101b05780637ecebe00146101d057806395d89b41146101f057600080fd5b806323b872dd116100c857806323b872dd14610147578063313ce5671461015a5780633644e5151461019357806340c10f191461019b57600080fd5b806306fdde03146100ef578063095ea7b31461010d57806318160ddd14610130575b600080fd5b6100f761025c565b60405161010491906108bc565b60405180910390f35b61012061011b366004610926565b6102ea565b6040519015158152602001610104565b61013960025481565b604051908152602001610104565b610120610155366004610950565b610357565b6101817f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610104565b610139610437565b6101ae6101a9366004610926565b610492565b005b6101396101be36600461098c565b60036020526000908152604090205481565b6101396101de36600461098c565b60056020526000908152604090205481565b6100f76104a0565b6101ae610206366004610926565b6104ad565b610120610219366004610926565b6104b7565b6101ae61022c3660046109ae565b61051d565b61013961023f366004610a21565b600460209081526000928352604080842090915290825290205481565b6000805461026990610a54565b80601f016020809104026020016040519081016040528092919081815260200182805461029590610a54565b80156102e25780601f106102b7576101008083540402835291602001916102e2565b820191906000526020600020905b8154815290600101906020018083116102c557829003601f168201915b505050505081565b3360008181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906103459086815260200190565b60405180910390a35060015b92915050565b6001600160a01b038316600090815260046020908152604080832033845290915281205460001981146103b35761038e8382610aa4565b6001600160a01b03861660009081526004602090815260408083203384529091529020555b6001600160a01b038516600090815260036020526040812080548592906103db908490610aa4565b90915550506001600160a01b0380851660008181526003602052604090819020805487019055519091871690600080516020610b6a833981519152906104249087815260200190565b60405180910390a3506001949350505050565b60007f0000000000000000000000000000000000000000000000000000000000000000461461046d57610468610766565b905090565b507f000000000000000000000000000000000000000000000000000000000000000090565b61049c8282610800565b5050565b6001805461026990610a54565b61049c828261085a565b336000908152600360205260408120805483919083906104d8908490610aa4565b90915550506001600160a01b03831660008181526003602052604090819020805485019055513390600080516020610b6a833981519152906103459086815260200190565b428410156105725760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f4558504952454400000000000000000060448201526064015b60405180910390fd5b6000600161057e610437565b6001600160a01b038a811660008181526005602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938d166060840152608083018c905260a083019390935260c08083018b90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600084529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa15801561068a573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116158015906106c05750876001600160a01b0316816001600160a01b0316145b6106fd5760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610569565b6001600160a01b0390811660009081526004602090815260408083208a8516808552908352928190208990555188815291928a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60006040516107989190610ab7565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b80600260008282546108129190610b56565b90915550506001600160a01b038216600081815260036020908152604080832080548601905551848152600080516020610b6a83398151915291015b60405180910390a35050565b6001600160a01b03821660009081526003602052604081208054839290610882908490610aa4565b90915550506002805482900390556040518181526000906001600160a01b03841690600080516020610b6a8339815191529060200161084e565b600060208083528351808285015260005b818110156108e9578581018301518582016040015282016108cd565b506000604082860101526040601f19601f8301168501019250505092915050565b80356001600160a01b038116811461092157600080fd5b919050565b6000806040838503121561093957600080fd5b6109428361090a565b946020939093013593505050565b60008060006060848603121561096557600080fd5b61096e8461090a565b925061097c6020850161090a565b9150604084013590509250925092565b60006020828403121561099e57600080fd5b6109a78261090a565b9392505050565b600080600080600080600060e0888a0312156109c957600080fd5b6109d28861090a565b96506109e06020890161090a565b95506040880135945060608801359350608088013560ff81168114610a0457600080fd5b9699959850939692959460a0840135945060c09093013592915050565b60008060408385031215610a3457600080fd5b610a3d8361090a565b9150610a4b6020840161090a565b90509250929050565b600181811c90821680610a6857607f821691505b602082108103610a8857634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561035157610351610a8e565b600080835481600182811c915080831680610ad357607f831692505b60208084108203610af257634e487b7160e01b86526022600452602486fd5b818015610b065760018114610b1b57610b48565b60ff1986168952841515850289019650610b48565b60008a81526020902060005b86811015610b405781548b820152908501908301610b27565b505084890196505b509498975050505050505050565b8082018082111561035157610351610a8e56feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220146f326df5e8aaab16e727f4438a25906cdf309b263c5beb358ce55ea0fd293164736f6c63430008100033a26469706673582212203f5804432f6d1f887a8125d02d798f05515840c81faa43f923c8c3c43a57af0b64736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c155830214610030575b600080fd5b61004361003e366004610153565b61005f565b6040516001600160a01b03909116815260200160405180910390f35b60008083836012604051610072906100a3565b61007e939291906101fd565b604051809103906000f08015801561009a573d6000803e3d6000fd5b50949350505050565b6110228061023783390190565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126100d757600080fd5b813567ffffffffffffffff808211156100f2576100f26100b0565b604051601f8301601f19908116603f0116810190828211818310171561011a5761011a6100b0565b8160405283815286602085880101111561013357600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806040838503121561016657600080fd5b823567ffffffffffffffff8082111561017e57600080fd5b61018a868387016100c6565b935060208501359150808211156101a057600080fd5b506101ad858286016100c6565b9150509250929050565b6000815180845260005b818110156101dd576020818501810151868301820152016101c1565b506000602082860101526020601f19601f83011685010191505092915050565b60608152600061021060608301866101b7565b828103602084015261022281866101b7565b91505060ff8316604083015294935050505056fe60e06040523480156200001157600080fd5b5060405162001022380380620010228339810160408190526200003491620001d5565b6000620000428482620002e9565b506001620000518382620002e9565b5060ff81166080524660a0526200006762000074565b60c0525062000433915050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f6000604051620000a89190620003b5565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126200013857600080fd5b81516001600160401b038082111562000155576200015562000110565b604051601f8301601f19908116603f0116810190828211818310171562000180576200018062000110565b816040528381526020925086838588010111156200019d57600080fd5b600091505b83821015620001c15785820183015181830184015290820190620001a2565b600093810190920192909252949350505050565b600080600060608486031215620001eb57600080fd5b83516001600160401b03808211156200020357600080fd5b620002118783880162000126565b945060208601519150808211156200022857600080fd5b50620002378682870162000126565b925050604084015160ff811681146200024f57600080fd5b809150509250925092565b600181811c908216806200026f57607f821691505b6020821081036200029057634e487b7160e01b600052602260045260246000fd5b50919050565b601f821115620002e457600081815260208120601f850160051c81016020861015620002bf5750805b601f850160051c820191505b81811015620002e057828155600101620002cb565b5050505b505050565b81516001600160401b0381111562000305576200030562000110565b6200031d816200031684546200025a565b8462000296565b602080601f8311600181146200035557600084156200033c5750858301515b600019600386901b1c1916600185901b178555620002e0565b600085815260208120601f198616915b82811015620003865788860151825594840194600190910190840162000365565b5085821015620003a55787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000808354620003c5816200025a565b60018281168015620003e05760018114620003f65762000427565b60ff198416875282151583028701945062000427565b8760005260208060002060005b858110156200041e5781548a82015290840190820162000403565b50505082870194505b50929695505050505050565b60805160a05160c051610bbf6200046360003960006104700152600061043b0152600061015f0152610bbf6000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c806370a082311161008c5780639dc29fac116100665780639dc29fac146101f8578063a9059cbb1461020b578063d505accf1461021e578063dd62ed3e1461023157600080fd5b806370a08231146101b05780637ecebe00146101d057806395d89b41146101f057600080fd5b806323b872dd116100c857806323b872dd14610147578063313ce5671461015a5780633644e5151461019357806340c10f191461019b57600080fd5b806306fdde03146100ef578063095ea7b31461010d57806318160ddd14610130575b600080fd5b6100f761025c565b60405161010491906108bc565b60405180910390f35b61012061011b366004610926565b6102ea565b6040519015158152602001610104565b61013960025481565b604051908152602001610104565b610120610155366004610950565b610357565b6101817f000000000000000000000000000000000000000000000000000000000000000081565b60405160ff9091168152602001610104565b610139610437565b6101ae6101a9366004610926565b610492565b005b6101396101be36600461098c565b60036020526000908152604090205481565b6101396101de36600461098c565b60056020526000908152604090205481565b6100f76104a0565b6101ae610206366004610926565b6104ad565b610120610219366004610926565b6104b7565b6101ae61022c3660046109ae565b61051d565b61013961023f366004610a21565b600460209081526000928352604080842090915290825290205481565b6000805461026990610a54565b80601f016020809104026020016040519081016040528092919081815260200182805461029590610a54565b80156102e25780601f106102b7576101008083540402835291602001916102e2565b820191906000526020600020905b8154815290600101906020018083116102c557829003601f168201915b505050505081565b3360008181526004602090815260408083206001600160a01b038716808552925280832085905551919290917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925906103459086815260200190565b60405180910390a35060015b92915050565b6001600160a01b038316600090815260046020908152604080832033845290915281205460001981146103b35761038e8382610aa4565b6001600160a01b03861660009081526004602090815260408083203384529091529020555b6001600160a01b038516600090815260036020526040812080548592906103db908490610aa4565b90915550506001600160a01b0380851660008181526003602052604090819020805487019055519091871690600080516020610b6a833981519152906104249087815260200190565b60405180910390a3506001949350505050565b60007f0000000000000000000000000000000000000000000000000000000000000000461461046d57610468610766565b905090565b507f000000000000000000000000000000000000000000000000000000000000000090565b61049c8282610800565b5050565b6001805461026990610a54565b61049c828261085a565b336000908152600360205260408120805483919083906104d8908490610aa4565b90915550506001600160a01b03831660008181526003602052604090819020805485019055513390600080516020610b6a833981519152906103459086815260200190565b428410156105725760405162461bcd60e51b815260206004820152601760248201527f5045524d49545f444541444c494e455f4558504952454400000000000000000060448201526064015b60405180910390fd5b6000600161057e610437565b6001600160a01b038a811660008181526005602090815260409182902080546001810190915582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98184015280840194909452938d166060840152608083018c905260a083019390935260c08083018b90528151808403909101815260e08301909152805192019190912061190160f01b6101008301526101028201929092526101228101919091526101420160408051601f198184030181528282528051602091820120600084529083018083525260ff871690820152606081018590526080810184905260a0016020604051602081039080840390855afa15801561068a573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b038116158015906106c05750876001600160a01b0316816001600160a01b0316145b6106fd5760405162461bcd60e51b815260206004820152600e60248201526d24a72b20a624a22fa9a4a3a722a960911b6044820152606401610569565b6001600160a01b0390811660009081526004602090815260408083208a8516808552908352928190208990555188815291928a16917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a350505050505050565b60007f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f60006040516107989190610ab7565b6040805191829003822060208301939093528101919091527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc660608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b80600260008282546108129190610b56565b90915550506001600160a01b038216600081815260036020908152604080832080548601905551848152600080516020610b6a83398151915291015b60405180910390a35050565b6001600160a01b03821660009081526003602052604081208054839290610882908490610aa4565b90915550506002805482900390556040518181526000906001600160a01b03841690600080516020610b6a8339815191529060200161084e565b600060208083528351808285015260005b818110156108e9578581018301518582016040015282016108cd565b506000604082860101526040601f19601f8301168501019250505092915050565b80356001600160a01b038116811461092157600080fd5b919050565b6000806040838503121561093957600080fd5b6109428361090a565b946020939093013593505050565b60008060006060848603121561096557600080fd5b61096e8461090a565b925061097c6020850161090a565b9150604084013590509250925092565b60006020828403121561099e57600080fd5b6109a78261090a565b9392505050565b600080600080600080600060e0888a0312156109c957600080fd5b6109d28861090a565b96506109e06020890161090a565b95506040880135945060608801359350608088013560ff81168114610a0457600080fd5b9699959850939692959460a0840135945060c09093013592915050565b60008060408385031215610a3457600080fd5b610a3d8361090a565b9150610a4b6020840161090a565b90509250929050565b600181811c90821680610a6857607f821691505b602082108103610a8857634e487b7160e01b600052602260045260246000fd5b50919050565b634e487b7160e01b600052601160045260246000fd5b8181038181111561035157610351610a8e565b600080835481600182811c915080831680610ad357607f831692505b60208084108203610af257634e487b7160e01b86526022600452602486fd5b818015610b065760018114610b1b57610b48565b60ff1986168952841515850289019650610b48565b60008a81526020902060005b86811015610b405781548b820152908501908301610b27565b505084890196505b509498975050505050505050565b8082018082111561035157610351610a8e56feddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa2646970667358221220146f326df5e8aaab16e727f4438a25906cdf309b263c5beb358ce55ea0fd293164736f6c63430008100033a26469706673582212203f5804432f6d1f887a8125d02d798f05515840c81faa43f923c8c3c43a57af0b64736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}