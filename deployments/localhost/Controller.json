{
  "address": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_creator_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_interep_address",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "MarketInitiated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "_getValidators",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "ad_to_id",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_marketId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_tokenAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_tokenId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_maxAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_borrowAmount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "_isERC20",
          "type": "bool"
        }
      ],
      "name": "addAcceptedCollateral",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "approvalCondition",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "beforeResolve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "bondAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collateral_amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "budget",
          "type": "uint256"
        }
      ],
      "name": "calcImpliedProbability",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "underlying",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_onlyVerified",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "_r",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_asset_limit",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_total_asset_limit",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "N",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "sigma",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "alpha",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "omega",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "delta",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "r",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "s",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "steak",
              "type": "uint256"
            }
          ],
          "internalType": "struct MarketManager.MarketParameters",
          "name": "default_params",
          "type": "tuple"
        }
      ],
      "name": "createVault",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "deduct_selling_fee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "validator",
          "type": "address"
        }
      ],
      "name": "deniedValidator",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "collateral_amount",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "denyMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "emergency",
          "type": "bool"
        }
      ],
      "name": "forceCloseInstrument",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "randomWords",
          "type": "uint256[]"
        }
      ],
      "name": "fulfillRandomWords",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getApprovalData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "managers_stake",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "approved_principal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "approved_yield",
              "type": "uint256"
            }
          ],
          "internalType": "struct Controller.ApprovalData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getFinalStake",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getInitialStake",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "getMarketId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        }
      ],
      "name": "getMarketIds",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getNumApproved",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getNumResolved",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getTotalStaked",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getTotalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getTotalValidatorSales",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "trader",
          "type": "address"
        }
      ],
      "name": "getTraderScore",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getValidatorCap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getValidatorPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getValidatorRequiredCollateral",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getVault",
      "outputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "getVaultAd",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        }
      ],
      "name": "getVaultfromId",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "validator",
          "type": "address"
        }
      ],
      "name": "hasApproved",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "id_parent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "name",
              "type": "bytes32"
            },
            {
              "internalType": "bool",
              "name": "isPool",
              "type": "bool"
            },
            {
              "internalType": "bool",
              "name": "trusted",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "faceValue",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "marketId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principal",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "expectedYield",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "duration",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "instrument_address",
              "type": "address"
            },
            {
              "internalType": "enum Vault.InstrumentType",
              "name": "instrument_type",
              "type": "uint8"
            },
            {
              "internalType": "uint256",
              "name": "maturityDate",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "saleAmount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "initPrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "promisedReturn",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "inceptionTime",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "inceptionPrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "leverageFactor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "managementFee",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Vault.PoolData",
              "name": "poolData",
              "type": "tuple"
            }
          ],
          "internalType": "struct Vault.InstrumentData",
          "name": "instrumentData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "vaultId",
          "type": "uint256"
        }
      ],
      "name": "initiateMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "r",
          "type": "uint256"
        }
      ],
      "name": "isReputable",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "isValidator",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "isVerified",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "marketCondition",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "marketIdToVaultId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "marketId_to_vaultId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "market_data",
      "outputs": [
        {
          "internalType": "address",
          "name": "instrument_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "utilizer",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "pullLeverage",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "validator",
          "type": "address"
        }
      ],
      "name": "redeemValidator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "redeem_transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "resolveCondition",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "resolveMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "riskTransferPenalty",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_marketManager",
          "type": "address"
        }
      ],
      "name": "setMarketManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_poolFactory",
          "type": "address"
        }
      ],
      "name": "setPoolFactory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_reputationManager",
          "type": "address"
        }
      ],
      "name": "setReputationManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_vaultFactory",
          "type": "address"
        }
      ],
      "name": "setVaultFactory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "testApproveMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "testResolveMarket",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "testVerifyAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "unlockValidatorStake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "trader",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "increment",
          "type": "bool"
        }
      ],
      "name": "updateReputation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "validatorApprove",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "validatorResolve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "validator_data",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "val_cap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "avg_price",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "requested",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "totalSales",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalStaked",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numApproved",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "initialStake",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "finalStake",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numResolved",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "vault_to_marketIds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "vaults",
      "outputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "verified",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "marketId",
          "type": "uint256"
        }
      ],
      "name": "viewValidators",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb049b1adb8067d404cfe204c8ce37bad187c2ca810253e0b6af21c079a8a2d6b",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
    "transactionIndex": 0,
    "gasUsed": "5363775",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd350de5581c0db5570dd10d71a9a6391e96020c6a53bda2c81dd0a9c7a2fcd17",
    "transactionHash": "0xb049b1adb8067d404cfe204c8ce37bad187c2ca810253e0b6af21c079a8a2d6b",
    "logs": [],
    "blockNumber": 2,
    "cumulativeGasUsed": "5363775",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "0x0000000000000000000000000000000000000000"
  ],
  "numDeployments": 1,
  "solcInputHash": "2d53558506ccf879b09e18a2ffbd9289",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_interep_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"MarketInitiated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"_getValidators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ad_to_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isERC20\",\"type\":\"bool\"}],\"name\":\"addAcceptedCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"approvalCondition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"beforeResolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"budget\",\"type\":\"uint256\"}],\"name\":\"calcImpliedProbability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_onlyVerified\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_asset_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_asset_limit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"N\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sigma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alpha\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"omega\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"steak\",\"type\":\"uint256\"}],\"internalType\":\"struct MarketManager.MarketParameters\",\"name\":\"default_params\",\"type\":\"tuple\"}],\"name\":\"createVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"deduct_selling_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"deniedValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"denyMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"emergency\",\"type\":\"bool\"}],\"name\":\"forceCloseInstrument\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"fulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getApprovalData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"managers_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approved_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"approved_yield\",\"type\":\"uint256\"}],\"internalType\":\"struct Controller.ApprovalData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getFinalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getInitialStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getMarketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getMarketIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getNumApproved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getNumResolved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getTotalValidatorSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"}],\"name\":\"getTraderScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getValidatorCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getValidatorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getValidatorRequiredCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getVault\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"getVaultAd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultfromId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"hasApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"id_parent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isPool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"trusted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"faceValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedYield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"instrument_address\",\"type\":\"address\"},{\"internalType\":\"enum Vault.InstrumentType\",\"name\":\"instrument_type\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"saleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"promisedReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inceptionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inceptionPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leverageFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managementFee\",\"type\":\"uint256\"}],\"internalType\":\"struct Vault.PoolData\",\"name\":\"poolData\",\"type\":\"tuple\"}],\"internalType\":\"struct Vault.InstrumentData\",\"name\":\"instrumentData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"initiateMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"isReputable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"marketCondition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"marketIdToVaultId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"marketId_to_vaultId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"market_data\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"instrument_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"utilizer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pullLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"redeemValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"redeem_transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"resolveCondition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"resolveMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskTransferPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketManager\",\"type\":\"address\"}],\"name\":\"setMarketManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolFactory\",\"type\":\"address\"}],\"name\":\"setPoolFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reputationManager\",\"type\":\"address\"}],\"name\":\"setReputationManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultFactory\",\"type\":\"address\"}],\"name\":\"setVaultFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"testApproveMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"testResolveMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testVerifyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"unlockValidatorStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"increment\",\"type\":\"bool\"}],\"name\":\"updateReputation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"validatorApprove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"validatorResolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validator_data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"val_cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avg_price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"requested\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numApproved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numResolved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vault_to_marketIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"verified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"}],\"name\":\"viewValidators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_getValidators(uint256)\":{\"details\":\"for now called on market initialization\"},\"beforeResolve(uint256)\":{\"details\":\"Prepare market/instrument for closing, called separately before resolveMarket this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest or, in the event of a default, by validators who deem the principal recouperation is finished and need to collect remaining funds by redeeming ZCB\"},\"calcImpliedProbability(uint256,uint256,uint256)\":{\"params\":{\"budget\":\"of trader in collateral decimals\"}},\"createVault(address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"params\":{\"_asset_limit\":\": max number of shares for a single address\",\"_onlyVerified\":\": only verified users can mint shares\",\"_r\":\": minimum reputation score to mint shares\",\"_total_asset_limit\":\": max number of shares for entire vault\",\"default_params\":\": default params for markets created by vault\",\"underlying\":\": underlying asset for vault\"}},\"denyMarket(uint256)\":{\"details\":\"called by validator denial of market.\"},\"forceCloseInstrument(uint256,bool)\":{\"details\":\"withdraws all balance from the instrument. If assets in instrument is not in underlying, need all balances to be divested to underlying Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\",\"params\":{\"emergency\":\"ascribes cases where the instrument should be forcefully liquidated back to the vault\"}},\"fulfillRandomWords(uint256,uint256[])\":{\"details\":\"TODO => can be called by anyone?\"},\"initiateMarket(address,(bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)),uint256)\":{\"details\":\"Instrument should already be deployed\",\"params\":{\"instrumentData\":\": instrument arguments\",\"recipient\":\": utilizer for the associated instrument\",\"vaultId\":\": vault identifier\"}},\"resolveMarket(uint256)\":{\"details\":\"validators call this function from market manager any funds left for the instrument, irrespective of whether it is in profit or inloss.\"},\"validatorApprove(uint256)\":{\"details\":\"get val_cap, the total amount of zcb for sale and each validators should buy val_cap/num validators zcb They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly correlated instruments triggers controller.approveMarket\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_getValidators(uint256)\":{\"notice\":\"randomly choose validators for market approval, async operation => fulfillRandomness is the callback function.\"},\"addAcceptedCollateral(uint256,address,uint256,uint256,uint256,bool)\":{\"notice\":\"pool instrumentcalled by utilizer during assessment\"},\"approvalCondition(uint256)\":{\"notice\":\"conditions for approval => validator zcb stake fulfilled + validators have all approved\"},\"beforeResolve(uint256)\":{\"notice\":\"Resolve function 1\"},\"calcImpliedProbability(uint256,uint256,uint256)\":{\"notice\":\"calculates implied probability of the trader, used to update the reputation score by brier scoring mechanism\"},\"createVault(address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))\":{\"notice\":\"creates vault\"},\"deduct_selling_fee(uint256)\":{\"notice\":\"deduce fees for non vault stakers, should go down as maturity time approach 0\"},\"deniedValidator(uint256,address)\":{\"notice\":\"called by marketManager.redeemDeniedMarket, redeems the discounted ZCB\"},\"forceCloseInstrument(uint256,bool)\":{\"notice\":\"function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc. After, the resolveMarket function should be called in a new block\"},\"fulfillRandomWords(uint256,uint256[])\":{\"notice\":\"chainlink callback function, sets validators.\"},\"initiateMarket(address,(bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)),uint256)\":{\"notice\":\"initiates market, called by frontend loan proposal or instrument form submit button.\"},\"isValidator(uint256,address)\":{\"notice\":\"returns true if user is validator for corresponding market\"},\"marketCondition(uint256)\":{\"notice\":\"returns true if amount bought is greater than the insurance threshold\"},\"redeem_transfer(uint256,address,uint256)\":{\"notice\":\"called only when redeeming, transfer funds from vault\"},\"resolveCondition(uint256)\":{\"notice\":\"condition for resolving market, met when all the validators chosen for the market have voted to resolve.\"},\"resolveMarket(uint256)\":{\"notice\":\"Resolve function 2main function called at maturity OR premature resolve of instrument(from early default)\"},\"testApproveMarket(uint256)\":{\"notice\":\"GOD FUNCTION\"},\"unlockValidatorStake(uint256)\":{\"notice\":\"called by validators when the market is resolved or denied to retrieve their stake.\"},\"updateReputation(uint256,address,bool)\":{\"notice\":\"when market is resolved(maturity/early default), calculates score and update each assessment phase trader's reputation, called by individual traders when redeeming\"},\"validatorApprove(uint256)\":{\"notice\":\"allows validators to buy at a discount + automatically stake a percentage of the principal They can only buy a fixed amount of ZCB, usually a at lot larger amount\"},\"validatorResolve(uint256)\":{\"notice\":\"called by validators to approve resolving the market, after approval.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/controller.sol\":\"Controller\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363732363639393231363434\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/bonds/GBC.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n// Uncomment this line to use console.log\\n// import \\\"hardhat/console.sol\\\";\\n// import {ERC20} from \\\"./aave/Libraries.sol\\\"; \\nimport {SafeCast, FixedPointMath, ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice AMM for a token pair (trade, base), only tracks price denominated in trade/base  \\n/// and point-bound(limit order) and range-bound(multiple points, also known as concentrated) liquidity \\n/// @dev all funds will be handled in the child contract \\ncontract GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using Tick for mapping(uint16 => Tick.Info);\\n    using Position for mapping(bytes32 => Position.Info);\\n    using Position for Position.Info;\\n    using SafeCast for uint256; \\n\\n\\n    modifier onlyEntry(){\\n        require(entry == msg.sender  ,\\\"Not Entry\\\"); \\n        _;\\n    }\\n    \\n    bool private _mutex;\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    constructor(\\n        address _baseToken,\\n        address _tradeToken\\n        //uint256 _priceDelta\\n        ) {\\n        tradeToken = _tradeToken; \\n        baseToken = _baseToken; \\n        //priceDelta = _priceDelta; \\n        fee =0; \\n        factory = address(0); \\n        tickSpacing = 0; \\n        //Start liquidity \\n        liquidity = 100 * uint128(PRECISION); \\n\\n        owner = msg.sender; \\n    }\\n\\n    address public immutable owner; \\n    uint24 public immutable  fee;\\n    Slot0 public slot0; // global state?\\n    address public immutable  factory;\\n    address public immutable  tradeToken;\\n    address public immutable  baseToken;\\n    int24 public immutable  tickSpacing; // only ticks/price points divisible by tickSpacing can be initialized.\\n\\n    uint128 public liquidity;\\n\\n    mapping(uint16 => Tick.Info) public  ticks;\\n\\n    mapping(bytes32 => Position.Info) public  positions;\\n\\n    // mapping(uint16=> PricePoint) Points; \\n\\n    uint256 public  constant priceDelta = 1e16; //difference in price for two adjacent ticks => 0.01 base token.\\n    uint256 public constant ROUNDLIMIT = 1e4; \\n    uint256 public constant PRECISION = 1e18; \\n    address public entry; \\n\\n    /// @notice previliged function called by the market maker \\n    /// if he is the one providing all the liquidity \\n    function setLiquidity(uint128 liq) internal  \\n    //onlyEntry\\n    {\\n        liquidity = liq; \\n    }\\n\\n    function setEntry(address _entry) external onlyEntry{\\n        entry = _entry; \\n    }\\n    function lock() external onlyEntry{\\n        slot0.unlocked = !slot0.unlocked; \\n    }\\n\\n    function positionIsFilled(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk\\n    ) \\n        public view returns(bool){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        return (liq>0 && numCross > crossId); \\n    }\\n\\n    function setPriceAndPoint(uint256 price) internal  \\n    //onlyOwner\\n    {\\n        slot0.point = priceToPoint(price);         \\n        slot0.curPrice = price.toUint160(); \\n    }\\n\\n    function getCurPrice() external view returns(uint256){\\n        return slot0.curPrice; \\n    }\\n\\n    function getOneTimeLiquidity(uint16 point, bool moveUp) external view returns(uint256){\\n        return uint256(ticks.oneTimeLiquidity(point)); \\n    }    \\n\\n    function getNumCross(uint16 point, bool moveUp) external view returns(uint256){\\n        return ticks.getNumCross(point, moveUp); \\n    }\\n\\n\\n    struct Slot0 {\\n        // the current price\\n        uint160 curPrice;\\n        // the current tick\\n        uint16 point;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n\\n        // Whether liquidity provision is amortized \\n        bool amortized; \\n\\n        // Where to modify liquidity \\n        uint16 modifyLiqPoint; \\n    }\\n\\n    // the top level state of the swap, the results of which are recorded in storage at the end\\n    struct SwapState {\\n        // the amount remaining to be swapped in/out of the input/output asset\\n        int256 amountSpecifiedRemaining;\\n        // the amount already swapped out/in of the output/input asset\\n        uint256 amountCalculated;\\n        // current sqrt(price)\\n        uint256 curPrice;\\n        // the tick associated with the current price\\n        uint16 point;\\n        // the global fee growth of the input token\\n        uint256 feeGrowthGlobal;\\n        // amount of input token paid as protocol fee\\n        uint128 protocolFee;\\n        // the current liquidity in range\\n        uint128 liquidity;\\n        uint128 liquidityStart; \\n\\n\\n    }\\n\\n    struct StepComputations {\\n        // the price at the beginning of the step\\n        uint256 priceStart;\\n        // the next tick to swap to from the current tick in the swap direction\\n        uint16 pointNext;\\n        // whether tickNext is initialized or not\\n        bool initialized;\\n        // price for the next tick (1/0)\\n        uint256 priceNextLimit;\\n        // how much is being swapped in in this step\\n        uint256 amountIn;\\n        // how much is being swapped out\\n        uint256 amountOut;\\n        // how much fee is being paid in\\n        uint256 feeAmount;\\n\\n        uint128 liqDir; \\n    }\\n\\n    struct swapVars{\\n        uint256 a;\\n        uint256 s; \\n        uint256 b; \\n    }\\n\\n    /// param +amountSpecified is in base if moveUp, else is in trade (+ if input asset, - if output asset)\\n    /// -amountSpecified is in trade if moveUp, else is in base \\n    /// returns amountIn if moveUp, cash, else token\\n    /// returns amountOut if moveUp, token, else cash \\n    function trade(\\n        address recipient, \\n        bool moveUp, \\n        int256 amountSpecified, \\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) public onlyEntry _lock_ returns(uint256 amountIn, uint256 amountOut){\\n        console.logString('---New Trade---'); \\n\\n        Slot0 memory slot0Start = slot0; \\n        uint256 pDelta = priceDelta; \\n\\n        SwapState memory state = SwapState({\\n            amountSpecifiedRemaining: amountSpecified, \\n            amountCalculated: 0, \\n            curPrice: uint256(slot0Start.curPrice),\\n            feeGrowthGlobal: moveUp? feeGrowthGlobalBase: feeGrowthGlobalTrade,//moveup is base in for trade out\\n            protocolFee: 0, \\n            liquidity: liquidity, \\n            liquidityStart: liquidity,\\n            point: slot0.point\\n            }); \\n        swapVars memory vars = swapVars({\\n            a:0,\\n            b:0,\\n            s:0\\n            });\\n\\n        bool exactInput = amountSpecified > 0;\\n\\n        // increment price by 1/1e18 if at boundary, and go back up a point,\\n        // should be negligible compared to fees TODO \\n        if (mod0(state.curPrice, pDelta) && !moveUp) {\\n            state.curPrice += 1; \\n            state.point = priceToPoint(state.curPrice);\\n            slot0.point = state.point; \\n            slot0Start.point = state.point; \\n        }\\n\\n        while (state.amountSpecifiedRemaining !=0 && state.curPrice != priceLimit){\\n            StepComputations memory step; \\n\\n            step.priceStart = state.curPrice; \\n            step.priceNextLimit = getNextPriceLimit(state.point, pDelta, moveUp); \\n            step.pointNext = moveUp? state.point + 1 : state.point-1; \\n\\n            // Need liquidity for both move up and move down for path independence within a \\n            // given point range. Either one of them should be 0 \\n            step.liqDir = ticks.oneTimeLiquidity(state.point);\\n            vars.a = exactInput \\n                ? inv(state.liquidity + step.liqDir)\\n                : invRoundUp(state.liquidity + step.liqDir); \\n            vars.b = yInt(state.curPrice, moveUp); \\n            vars.s = xMax(state.curPrice, vars.b, vars.a); \\n\\n            //If moveup, amountIn is in cash, amountOut is token and vice versa \\n            (state.curPrice, step.amountIn, step.amountOut, step.feeAmount) = LinearCurve.swapStep(\\n                state.curPrice, \\n                step.priceNextLimit,    \\n                state.amountSpecifiedRemaining, \\n                fee, \\n                vars               \\n                ); \\n\\n            {console.log('________'); \\n            console.log('CURPRICE', state.curPrice); \\n            console.log('trading; liquidity, amountleft', state.liquidity); \\n            console.log(uint256(-state.amountSpecifiedRemaining));\\n            console.log('nextpricelimit/pointnext', step.priceNextLimit, step.pointNext);           \\n            console.log('a', vars.a); }\\n            console.log('amountinandout', step.amountIn, step.amountOut); \\n            console.log('s,b', vars.s, vars.b); \\n\\n            if (exactInput){\\n                state.amountSpecifiedRemaining -= int256(step.amountIn); \\n            }\\n            else{\\n                state.amountSpecifiedRemaining += int256(step.amountIn); \\n            }\\n            state.amountCalculated += step.amountOut; \\n\\n            if (state.liquidity>0)\\n                state.feeGrowthGlobal += step.feeAmount.divWadDown(uint256(state.liquidity)); \\n\\n            // If next limit reached, cross price range and change slope(liquidity)\\n            if (state.curPrice == step.priceNextLimit){\\n\\n                // If crossing UP, asks are all filled so need to set askLiquidity to 0 and increment numCross\\n                // Else if crossing DOWN, bids are all filled \\n                if (step.liqDir!=0) ticks.deleteOneTimeLiquidity(state.point, moveUp); \\n\\n                int128 liquidityNet = ticks.cross(\\n                    step.pointNext, \\n                    feeGrowthGlobalBase,\\n                    feeGrowthGlobalTrade\\n                    ); \\n\\n                if (!slot0Start.amortized && step.pointNext == slot0Start.modifyLiqPoint)\\n                    liquidityNet = liquidityNet += dynamicLiq[step.pointNext]; \\n                    console.log('dynamicLiq', uint256(int256(dynamicLiq[step.pointNext])), uint256(int256(liquidityNet))); \\n\\n                if (!moveUp) liquidityNet = -liquidityNet; \\n\\n\\n                state.liquidity = addDelta(state.liquidity,liquidityNet);\\n\\n                state.point = step.pointNext;  \\n            }\\n        }\\n\\n        slot0.curPrice = state.curPrice.toUint160(); \\n        if(state.point != slot0Start.point) slot0.point = state.point; \\n            \\n        if (state.liquidityStart != state.liquidity) liquidity = state.liquidity;\\n\\n        if (moveUp) feeGrowthGlobalBase = state.feeGrowthGlobal; \\n            \\n        // (amountIn, amountOut) = exactInput\\n        //                         ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) + ROUNDLIMIT, state.amountCalculated)//TODO roundfixes\\n        //                                  : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n        //                         : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n\\n        (amountIn, amountOut) = exactInput\\n                                ? moveUp ? (uint256(amountSpecified-state.amountSpecifiedRemaining ) , state.amountCalculated)//TODO roundfixes\\n                                         : (uint256(amountSpecified-state.amountSpecifiedRemaining ), state.amountCalculated)\\n                                : (state.amountCalculated + ROUNDLIMIT, uint256(-amountSpecified+state.amountSpecifiedRemaining )); \\n    }\\n\\n    function placeLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk  \\n        ) public onlyEntry _lock_ returns(uint256 amountToEscrow, uint128 numCross ){   \\n        //TODO mint NFT \\n        // Should only accept asks for price above the current point range\\n        if(isAsk && pointToPrice(point) <= slot0.curPrice) revert(\\\"ask below prie\\\"); \\n        else if(!isAsk && pointToPrice(point) >= slot0.curPrice) revert(\\\"bids above prie\\\"); \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        numCross = ticks.getNumCross(point, isAsk); \\n        position.updateLimit(int128(amount), isAsk, numCross); \\n\\n        ticks.updateOneTimeLiquidity( point, int128(amount), isAsk); \\n\\n        // If placing bids, need to escrow baseAsset, vice versa \\n        address tokenToEscrow = isAsk? tradeToken : baseToken;\\n\\n        amountToEscrow = isAsk\\n                ? tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    )\\n            \\n                : baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) \\n                    ); \\n\\n        console.log('amountbid', amountToEscrow); \\n\\n    }\\n\\n    function reduceLimitOrder(\\n        address recipient, \\n        uint16 point, \\n        uint128 amount,\\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 amountToReturn) {\\n        require(priceToPoint(uint256(slot0.curPrice)) != point, \\\"Can't reduce order for current tick\\\"); \\n\\n        Position.Info storage position = positions.get(msg.sender, point, point+1);\\n\\n        position.updateLimit(-int128(amount), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(amount), isAsk); \\n\\n        address tokenToReturn = isAsk? tradeToken : baseToken;\\n        \\n        amountToReturn = isAsk\\n            ? tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                )\\n         \\n            : baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(amount) \\n                );\\n    }\\n\\n    /// @notice called when maker wants to claim when the the price is at the \\n    /// point he submitted the order\\n    function claimPartiallyFilledOrder(\\n        address recipient, \\n        uint16 point,\\n        bool isAsk\\n        ) public onlyEntry _lock_ returns(uint256 baseAmount, uint256 tradeAmount){\\n        Slot0 memory _slot0 = slot0; \\n\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n        require(priceToPoint(uint256(slot0.curPrice)) == point, \\\"Not current price\\\"); \\n\\n        // Assume trying to withdraw all liquidity provided \\n        uint128 liqToWithdraw = isAsk ? position.askLiq : position.bidLiq; \\n       \\n        position.updateLimit(-int128(liqToWithdraw), isAsk, 0); \\n\\n        ticks.updateOneTimeLiquidity(point, -int128(liqToWithdraw), isAsk); \\n\\n        // Get total trade filled OR remaining\\n        tradeAmount = tradeGivenLiquidity(\\n            pointToPrice(point+1),\\n            _slot0.curPrice, \\n            liqToWithdraw\\n        ); \\n           \\n        // Get total base filled OR remaining \\n        baseAmount = baseGivenLiquidity(\\n            _slot0.curPrice, \\n            pointToPrice(point), \\n            liqToWithdraw\\n            ); \\n\\n    }\\n\\n    /// @notice Need to check if the ask/bids were actually filled, which is equivalent to\\n    /// the condition that numCross > crossId, because numCross only increases when crossUp \\n    /// or crossDown \\n    function claimFilledOrder(\\n        address recipient, \\n        uint16 point, \\n        bool isAsk \\n        ) public onlyEntry _lock_  returns(uint256 claimedAmount){\\n        Position.Info storage position = positions.get(recipient, point, point+1);\\n\\n        uint128 numCross = ticks.getNumCross(point, isAsk); \\n        uint128 crossId = isAsk? position.askCrossId : position.bidCrossId; \\n        require(numCross > crossId, \\\"Position not filled\\\");\\n\\n        uint128 liq = isAsk? position.askLiq : position.bidLiq;\\n\\n        // Sold to base when asks are filled\\n        if(isAsk) claimedAmount = baseGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        // Bought when bids are filled so want tradeTokens\\n        else claimedAmount = tradeGivenLiquidity(\\n                pointToPrice(point+1), \\n                pointToPrice(point), \\n                uint256(liq) \\n                ); \\n\\n        position.updateLimit(-int128(liq), isAsk, 0); \\n        \\n        // Need to burn AND \\n\\n    }\\n\\n    struct ModifyPositionParams {\\n        // the address that owns the position\\n        address owner;\\n        // the lower and upper tick of the position\\n        uint16 pointLower;\\n        uint16 pointUpper;\\n        // any change in liquidity\\n        int128 liquidityDelta;\\n    }\\n\\n    /// @notice provides liquidity in range or adds limit order if pointUpper = pointLower + 1\\n    function provide(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount, \\n        bytes calldata data \\n        ) public onlyEntry _lock_ returns(uint256 amount0, uint256 amount1 ){\\n        require(amount > 0, \\\"0 amount\\\"); \\n\\n        (,  amount0,  amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        //mintCallback\\n\\n    }\\n\\n    function remove(\\n        address recipient, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        uint128 amount\\n        ) public onlyEntry _lock_ returns(uint256 , uint256 ){\\n\\n        (Position.Info storage position,  uint256 amount0, uint256 amount1) = _modifyPosition(\\n            ModifyPositionParams({\\n                owner: recipient, \\n                pointLower : pointLower, \\n                pointUpper: pointUpper, \\n                liquidityDelta: -int128(amount)//.toInt128()\\n                })\\n            ); \\n\\n        if(amount0>0 || amount1> 0){\\n            (position.tokensOwed0, position.tokensOwed1) = (\\n                position.tokensOwed0 + amount0,\\n                position.tokensOwed1 + amount1\\n            );\\n        }\\n        return (amount0, amount1); \\n    }\\n\\n    function collect(\\n        address recipient,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) public onlyEntry _lock_  returns (uint256 amount0, uint256 amount1) {\\n        // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\\n        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\\n\\n        amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\\n        amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\\n\\n        if (amount0 > 0) {\\n            position.tokensOwed0 -= amount0;\\n        }\\n        if (amount1 > 0) {\\n            position.tokensOwed1 -= amount1;\\n        }\\n    }\\n\\n\\n    function _modifyPosition(ModifyPositionParams memory params)\\n    private \\n    returns(\\n        Position.Info storage position, \\n        uint256 baseAmount, \\n        uint256 tradeAmount\\n        )\\n    {\\n        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization\\n\\n        position = _updatePosition(\\n            params.owner,\\n            params.pointLower,\\n            params.pointUpper,\\n            params.liquidityDelta,\\n            _slot0.point\\n        );\\n\\n        if (params.liquidityDelta != 0){\\n            if (_slot0.point < params.pointLower){\\n                // in case where liquidity is just asks waiting to be sold into, \\n                // so need to only provide tradeAsset \\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n            } else if( _slot0.point < params.pointUpper){\\n                uint128 liquidityBefore = liquidity; \\n\\n                // Get total asks to be submitted above current price\\n                tradeAmount = tradeGivenLiquidity(\\n                    pointToPrice(params.pointUpper),\\n                    _slot0.curPrice, \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Get total bids to be submitted below current price \\n                baseAmount = baseGivenLiquidity(\\n                    _slot0.curPrice, \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                    ); \\n\\n                // Slope changes since current price is in this range \\n                liquidity = addDelta(liquidityBefore, params.liquidityDelta);\\n\\n            } else{\\n                // liquidity is just bids waiting to be bought into \\n                baseAmount = baseGivenLiquidity(\\n                    pointToPrice(params.pointUpper), \\n                    pointToPrice(params.pointLower), \\n                    params.liquidityDelta >= 0\\n                        ? uint256(int256(params.liquidityDelta))\\n                        : uint256(int256(-params.liquidityDelta))\\n                ); \\n            }\\n        }\\n    }\\n\\n    uint256 public feeGrowthGlobalBase;\\n    uint256 public feeGrowthGlobalTrade;\\n\\n    function _updatePosition(\\n        address owner, \\n        uint16 pointLower, \\n        uint16 pointUpper, \\n        int128 liquidityDelta, \\n        uint16 point \\n        ) private returns(Position.Info storage position){\\n\\n        position = positions.get(owner, pointLower, pointUpper); \\n\\n        uint256 _feeGrowthGlobalBase = feeGrowthGlobalBase; \\n        uint256 _feeGrowthGlobalTrade = feeGrowthGlobalTrade; \\n\\n        if(liquidityDelta != 0){\\n\\n            ticks.update(\\n                pointLower, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                false\\n                ); \\n\\n            ticks.update(\\n                pointUpper, \\n                point, \\n                liquidityDelta, \\n                feeGrowthGlobalBase,\\n                feeGrowthGlobalTrade,\\n                true\\n                ); \\n        } \\n        (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) =\\n            ticks.getFeeGrowthInside(pointLower, pointUpper, point, _feeGrowthGlobalBase, _feeGrowthGlobalTrade);\\n        position.update(liquidityDelta, feeGrowthInsideBase,feeGrowthInsideTrade); \\n    }\\n\\n\\n    mapping(uint16=> int128) dynamicLiq; \\n    function setDynamicLiquidity(uint16 point, int128 liq) internal {\\n        dynamicLiq[point] = liq; \\n    }\\n    function setModifyLiqPoint(uint16 point) internal{\\n        slot0.modifyLiqPoint = point;  \\n    }\\n    function amortizeLiq() internal{\\n        slot0.amortized = true; \\n    }\\n\\n    function tradeGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return (p2-p1).mulWadDown(L); \\n    }\\n\\n    function baseGivenLiquidity(uint256 p2, uint256 p1, uint256 L) public pure returns(uint256) {\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return LinearCurve.areaUnderCurve(tradeGivenLiquidity(p2, p1, L), 0, inv(L), p1); \\n    }\\n\\n    function liquidityGivenTrade(uint256 p2, uint256 p1, uint256 T) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return T.divWadDown(p2-p1); \\n    }\\n    function liquidityGivenBase(uint256 p2, uint256 p1, uint256 B) public pure returns(uint256){\\n        require(p2>=p1, \\\"price ERR\\\"); \\n        return B.divWadDown((p2-p1).mulWadDown((p2+p1)/2)); \\n    }\\n\\n    function pointToPrice(uint16 point) public pure returns(uint160){\\n        return(uint256(point) * priceDelta).toUint160(); \\n    }\\n\\n    /// @notice will round down to nearest integer \\n    function priceToPoint(uint256 price) public pure returns(uint16){\\n        return uint16((price.divWadDown(priceDelta))/PRECISION); \\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n    function xMaxRoundUp(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        return (curPrice-b).divWadUp(a); \\n    }\\n\\n    /// @notice get the lower bound of the given price range, or the y intercept of the curve of\\n    /// the current point\\n    function yInt(uint256 curPrice, bool moveUp) public pure returns(uint256){\\n        uint16 point = priceToPoint(curPrice); \\n\\n        // If at boundary when moving down, decrement point by one\\n        return (!moveUp && (curPrice%point == 0))? pointToPrice(point-1) : pointToPrice(point); \\n    }\\n\\n    function getNextPriceLimit(uint16 point, uint256 pDelta, bool moveUp) public pure returns(uint256){\\n        if (moveUp) return uint256(point+1) * pDelta; \\n        else return uint256(point) * pDelta; \\n    }\\n\\n    function inv(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadDown(l+1) : PRECISION.divWadDown(l) ; \\n    }\\n    function invRoundUp(uint256 l) internal pure returns(uint256){\\n        return l==0? PRECISION.divWadUp(l+1) : PRECISION.divWadUp(l) ; \\n    }\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n    function mod0(uint256 a, uint256 b) internal pure returns(bool){\\n        return (a%b ==0); \\n    }\\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\\n    /// @param x The liquidity before change\\n    /// @param y The delta by which liquidity should be changed\\n    /// @return z The liquidity delta\\n    function addDelta(uint128 x, int128 y) public pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n    function getLiq(address to, uint16 point, bool isAsk) public view returns(uint128){\\n        return  isAsk\\n                ? positions.get(to, point, point+1).askLiq\\n                : positions.get(to, point, point+1).bidLiq; \\n    }\\n\\n}\\n\\nlibrary LinearCurve{\\n    uint256 public constant PRECISION = 1e18; \\n    using FixedPointMath for uint256; \\n\\n\\n    /// @notice Compute results of swap given amount in and params\\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\\n    /// b is 0 and s is curPrice/a during variable liquidity phase\\n    function swapStep(\\n        uint256 curPrice, \\n        uint256 targetPrice, \\n        int256 amountRemaining, \\n        uint24 feePips,    \\n        GranularBondingCurve.swapVars memory vars       \\n        ) \\n        public \\n        pure \\n        returns(uint256 nextPrice, uint256 amountIn, uint256 amountOut, uint256 feeAmount ){\\n\\n        bool moveUp = targetPrice >= curPrice; \\n        bool exactInput = amountRemaining >= 0; \\n\\n        // If move up and exactInput, amountIn is base, amountOut is trade \\n        if (exactInput){\\n            // uint256 amountRemainingLessFee = uint256(amountRemaining).mulDivDown(1e6-feePips, 1e6);\\n\\n            if (moveUp){\\n                (amountOut, nextPrice) = amountOutGivenIn(uint256(amountRemaining),vars.s,vars.a,vars.b, true); \\n\\n                // If overshoot go to next point\\n                if (nextPrice >= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out for a given price range is Pdelta / a \\n                    amountOut = (targetPrice - curPrice).divWadDown(vars.a); \\n                    amountIn = areaUnderCurve(amountOut, vars.s,vars.a,vars.b).mulDivDown(1e6+feePips, 1e6); \\n                }            \\n                else {\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }   \\n            }\\n\\n            // amountIn is trade, amountOut is base \\n            else {\\n                // If amount is greater than s, then need to cap it \\n                (amountOut, nextPrice) = amountOutGivenIn(min(uint256(amountRemaining),vars.s), vars.s,vars.a,vars.b,false); \\n                // If undershoot go to previous point \\n                if(nextPrice <= targetPrice){\\n                    nextPrice = targetPrice; \\n\\n                    // max amount out is area under curve \\n                    amountIn = (curPrice - targetPrice).divWadDown(vars.a);\\n                    amountOut = areaUnderCurve(amountIn, 0,vars.a,vars.b); \\n                    amountIn = amountIn.mulDivDown(1e6+feePips, 1e6); \\n\\n                }\\n                else{\\n                    amountIn = uint256(amountRemaining).mulDivDown(1e6+feePips, 1e6); \\n                }\\n            }\\n            feeAmount = amountIn.mulDivDown(uint256(feePips).mulDivDown(1e6,1e6+feePips), 1e6); \\n        }\\n\\n        else {\\n            if(moveUp){\\n                uint256 remaining = uint256(-amountRemaining); \\n                nextPrice = vars.a.mulWadUp(remaining) + curPrice; \\n\\n                // if overshoot\\n                if(nextPrice>=targetPrice){\\n                    amountIn = xMax(targetPrice, curPrice,  vars.a); \\n                    nextPrice = targetPrice; \\n\\n                    // Prevent stuck cases where point is almost filled but not quite \\n                    if(remaining - amountIn<=1e4){\\n                        amountIn = remaining; \\n                    } \\n                }\\n                else amountIn = remaining; \\n\\n                amountOut = areaUnderCurveRoundUp(amountIn, 0, vars.a, curPrice); //you want this to be more, so round up\\n\\n            }\\n            else{\\n                //TODO \\n            }\\n            feeAmount = amountOut.mulDivDown(feePips, 1e6);\\n            amountOut = amountOut + feeAmount;\\n        }\\n    }\\n\\n\\n    /// @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\\n    /// @param amount: amount of base in\\n    /// returns amountDelta wanted token returned \\n    function amountOutGivenIn( \\n        uint256 amount,\\n        uint256 s, \\n        uint256 a, \\n        uint256 b, \\n        bool up) \\n        public \\n        pure \\n        returns(uint256 amountDelta, uint256 resultPrice) {\\n        \\n        // If liquidity is not infinite \\n        if(a > 0){\\n            if (up){\\n                //TODO overflow on small amount \\n                uint256 x = ((a.mulWadDown(s) + b) ** 2)/PRECISION; \\n                uint256 y = 2*( a.mulWadDown(amount)); \\n                uint256 x_y_sqrt = ((x+y)*PRECISION).sqrt();\\n                uint256 z = (a.mulWadDown(s) + b); \\n                amountDelta = (x_y_sqrt-z).divWadDown(a);\\n                resultPrice = a.mulWadDown(amountDelta + s) + b; \\n            }\\n\\n            else{\\n                uint256 z = b + a.mulWadDown(s) - a.mulWadDown(amount)/2;  \\n                amountDelta = amount.mulWadDown(z); \\n                resultPrice = a.mulWadDown(s-amount) + b; \\n            }\\n        }\\n\\n        // When a = 0, infinite liquidity and constant price\\n        else{\\n            amountDelta = amount.divWadDown(b); \\n            resultPrice = b; \\n        }\\n\\n    }\\n\\n    /// @notice calculates area under the curve from s to s+amount\\n     /// result = a * amount / 2  * (2* supply + amount) + b * amount\\n     /// returned in collateral decimals\\n    function areaUnderCurve(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        area = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \\n    }\\n    function areaUnderCurveRoundUp(\\n        uint256 amount, \\n        uint256 s, \\n        uint256 a, \\n        uint256 b) \\n        public\\n        pure \\n        returns(uint256 area){\\n        // you want area to be big for a given amount \\n        area = ( a.mulWadUp(amount) / 2 ).mulWadUp(2 * s + amount) + b.mulWadUp(amount); \\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function xMax(uint256 curPrice, uint256 b, uint256 a) public pure returns(uint256){\\n        if(a==0) return type(uint256).max; \\n        return (curPrice-b).divWadDown(a); \\n    }\\n\\n}\\n\\n/// @title Position\\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\\n/// @dev Positions store additional state for tracking fees owed to the position\\nlibrary Position {\\n    using FixedPointMath for uint256;\\n\\n    // info stored for each user's position\\n    struct Info {\\n        uint128 bidCrossId; \\n        uint128 askCrossId; \\n        uint128 askLiq; \\n        uint128 bidLiq; \\n\\n        // the amount of liquidity owned by this position\\n        uint128 liquidity;\\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\\n        uint256 feeGrowthInside0LastX128;\\n        uint256 feeGrowthInside1LastX128;\\n        // the fees owed to the position owner in token0/token1\\n        uint256 tokensOwed0;\\n        uint256 tokensOwed1;\\n\\n        \\n    }\\n\\n    function updateLimit(\\n        Info storage self,\\n        int128 limitLiqudityDelta, \\n        bool isAsk, \\n        uint128 crossId\\n        ) internal {\\n\\n        if (isAsk) {\\n            self.askLiq = addDelta(self.askLiq, limitLiqudityDelta);\\n            if( limitLiqudityDelta > 0) self.askCrossId = crossId; \\n        } \\n\\n        else {\\n            self.bidLiq = addDelta(self.bidLiq, limitLiqudityDelta); \\n            if( limitLiqudityDelta > 0) self.bidCrossId = crossId; \\n        }\\n    }\\n\\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\\n    /// @param self The mapping containing all user positions\\n    /// @param owner The address of the position owner\\n    /// @param tickLower The lower tick boundary of the position\\n    /// @param tickUpper The upper tick boundary of the position\\n    /// @return position The position info struct of the given owners' position\\n    function get(\\n        mapping(bytes32 => Info) storage self,\\n        address owner,\\n        uint16 tickLower,\\n        uint16 tickUpper\\n    ) internal view returns (Position.Info storage position) {\\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\\n    }\\n\\n    /// @notice Credits accumulated fees to a user's position\\n    /// @param self The individual position to update\\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\\n    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\\n    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\\n    function update(\\n        Info storage self,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthInside0X128,\\n        uint256 feeGrowthInside1X128\\n    ) internal {\\n        Info memory _self = self;\\n\\n        uint128 liquidityNext;\\n        if (liquidityDelta == 0) {\\n            require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions\\n            liquidityNext = _self.liquidity;\\n        } else {\\n            liquidityNext = addDelta(_self.liquidity, liquidityDelta);\\n        }\\n\\n        // calculate accumulated fees\\n        uint128 tokensOwed0 = uint128(\\n                (feeGrowthInside0X128-_self.feeGrowthInside0LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n        uint128 tokensOwed1 =uint128(\\n                (feeGrowthInside1X128-_self.feeGrowthInside1LastX128)\\n                .mulDivDown(uint256(_self.liquidity), 1e18)\\n            );\\n            \\n        // update the position\\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\\n            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees\\n            self.tokensOwed0 += tokensOwed0;\\n            self.tokensOwed1 += tokensOwed1;\\n        }\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n}\\n\\n/// @title Tick\\n/// @notice Contains functions for managing tick processes and relevant calculations\\nlibrary Tick {\\n    using FixedPointMath for uint256;\\n\\n    using SafeCast for int256;\\n\\n    // info stored for each initialized individual tick\\n    struct Info {\\n        // the total position liquidity that references this tick\\n        uint128 liquidityGross;\\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\\n        int128 liquidityNet;\\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint256 feeGrowthOutsideBase;\\n        uint256 feeGrowthOutsideTrade;\\n        // the cumulative tick value on the other side of the tick\\n        int56 tickCumulativeOutside;\\n        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint160 secondsPerLiquidityOutsideX128;\\n        // the seconds spent on the other side of the tick (relative to the current tick)\\n        // only has relative meaning, not absolute \\u2014 the value depends on when the tick is initialized\\n        uint32 secondsOutside;\\n        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\\n        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\\n        bool initialized;\\n\\n        uint128 askLiquidityGross; \\n        uint128 bidLiquidityGross;\\n        uint128 askNumCross; \\n        uint128 bidNumCross; \\n    }\\n\\n    function getNumCross(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal view returns(uint128){\\n        return isAsk? self[tick].askNumCross : self[tick].bidNumCross; \\n    }\\n\\n    function oneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick \\n        ) internal view returns(uint128){\\n        Tick.Info memory info = self[tick]; \\n        assert(info.askLiquidityGross==0 || info.bidLiquidityGross==0); \\n        return info.askLiquidityGross + info.bidLiquidityGross; \\n    }\\n\\n    function deleteOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        bool isAsk\\n        ) internal {\\n        Tick.Info storage info = self[tick]; \\n        if(isAsk) {\\n            info.askLiquidityGross = 0;\\n            info.askNumCross++; \\n            console.log('tick??', tick); \\n        }\\n        else {\\n            info.bidLiquidityGross = 0; \\n            info.bidNumCross++; \\n        }\\n    }\\n\\n    function updateOneTimeLiquidity(\\n        mapping(uint16=> Tick.Info) storage self, \\n        uint16 tick, \\n        int128 oneTimeLiquidityDelta,\\n        bool isAsk\\n        ) internal {\\n        if (isAsk) self[tick].askLiquidityGross = addDelta(self[tick].askLiquidityGross, oneTimeLiquidityDelta); \\n        else self[tick].bidLiquidityGross = addDelta(self[tick].bidLiquidityGross, oneTimeLiquidityDelta);\\n    }\\n\\n    function update(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick,\\n        uint16 tickCurrent,\\n        int128 liquidityDelta,\\n        uint256 feeGrowthGlobalBase, \\n        uint256 feeGrowthGlobalTrade, \\n        bool upper\\n    ) internal returns (bool flipped) {\\n        Tick.Info storage info = self[tick];\\n\\n        uint128 liquidityGrossBefore = info.liquidityGross; \\n        uint128 liquidityGrossAfter = addDelta(liquidityGrossBefore, liquidityDelta); \\n\\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\\n\\n        if(liquidityGrossBefore == 0) {\\n            if(tick<=tickCurrent){\\n            info.feeGrowthOutsideBase = feeGrowthGlobalBase; \\n            info.feeGrowthOutsideTrade = feeGrowthGlobalTrade; \\n            }\\n            info.initialized = true; \\n        }\\n        info.liquidityGross = liquidityGrossAfter;\\n\\n        info.liquidityNet = upper \\n            ? (int256(info.liquidityNet)-liquidityDelta).toInt128()\\n            : (int256(info.liquidityNet)+liquidityDelta).toInt128(); \\n    }\\n\\n    function clear(mapping(uint16 => Tick.Info) storage self, uint16 tick) internal {\\n        delete self[tick];\\n    }\\n\\n    function cross(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tick, \\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal returns (int128 liquidityNet) {\\n        Tick.Info storage info = self[tick]; \\n\\n        liquidityNet = info.liquidityNet; \\n        info.feeGrowthOutsideBase = feeGrowthGlobalBase - info.feeGrowthOutsideBase; \\n        info.feeGrowthOutsideTrade = feeGrowthGlobalTrade - info.feeGrowthOutsideTrade;\\n    }\\n\\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\\n        if (y < 0) {\\n            require((z = x - uint128(-y)) < x, 'LS');\\n        } else {\\n            require((z = x + uint128(y)) >= x, 'LA');\\n        }\\n    }\\n\\n    function getFeeGrowthInside(\\n        mapping(uint16 => Tick.Info) storage self,\\n        uint16 tickLower,\\n        uint16 tickUpper,\\n        uint16 tickCurrent,\\n        uint256 feeGrowthGlobalBase,\\n        uint256 feeGrowthGlobalTrade\\n    ) internal view returns (uint256 feeGrowthInsideBase, uint256 feeGrowthInsideTrade) {\\n        Info storage lower = self[tickLower];\\n        Info storage upper = self[tickUpper];\\n\\n        // calculate fee growth below\\n        uint256 feeGrowthBelowBase;\\n        uint256 feeGrowthBelowTrade;\\n        if (tickCurrent >= tickLower) {\\n            feeGrowthBelowBase = lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = lower.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthBelowBase = feeGrowthGlobalBase - lower.feeGrowthOutsideBase;\\n            feeGrowthBelowTrade = feeGrowthGlobalTrade - lower.feeGrowthOutsideTrade;\\n        }\\n\\n        // calculate fee growth above\\n        uint256 feeGrowthAboveBase;\\n        uint256 feeGrowthAboveTrade;\\n        if (tickCurrent < tickUpper) {\\n            feeGrowthAboveBase = upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = upper.feeGrowthOutsideTrade;\\n        } else {\\n            feeGrowthAboveBase = feeGrowthGlobalBase - upper.feeGrowthOutsideBase;\\n            feeGrowthAboveTrade = feeGrowthGlobalTrade - upper.feeGrowthOutsideTrade;\\n        }\\n\\n        feeGrowthInsideBase = feeGrowthGlobalBase - feeGrowthBelowBase - feeGrowthAboveBase;\\n        feeGrowthInsideTrade = feeGrowthGlobalTrade - feeGrowthBelowTrade - feeGrowthAboveTrade;\\n    }\\n}\\n\\n\\ncontract SpotPool is GranularBondingCurve{\\n\\n    ERC20 BaseToken; //junior\\n    ERC20 TradeToken; //senior \\n    // GranularBondingCurve public pool; \\n\\n    constructor(\\n        address _baseToken, \\n        address _tradeToken\\n        )GranularBondingCurve(_baseToken,_tradeToken){\\n        BaseToken = ERC20(_baseToken); \\n        TradeToken = ERC20(_tradeToken); \\n        // pool = new GranularBondingCurve(_baseToken,_tradeToken); \\n    }\\n\\n    function handleBuys(address recipient, uint256 amountOut, uint256 amountIn, bool up) internal {\\n\\n        if(up){\\n            console.log('balances', TradeToken.balanceOf(address(this)), BaseToken.balanceOf(address(this)));\\n            console.log('togive', amountOut, amountIn); \\n            TradeToken.transfer(recipient, amountOut); \\n            console.log('balofre', BaseToken.balanceOf(recipient));\\n            BaseToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n\\n        else{\\n            BaseToken.transfer(recipient, amountOut); \\n            TradeToken.transferFrom(recipient, address(this), amountIn);\\n        }\\n    }\\n\\n    // function getCurPrice() external view returns(uint256){\\n    //     return uint256(pool.getCurPrice());\\n    // }\\n\\n    /// @notice if buyTradeForBase, move up, and vice versa \\n    function takerTrade(\\n        address recipient, \\n        bool buyTradeForBase, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data        \\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        (poolamountIn, poolamountOut) = this.trade(\\n            recipient, \\n            buyTradeForBase, \\n            amountIn,  \\n            priceLimit, \\n            data\\n        ); \\n        handleBuys(recipient, poolamountOut, poolamountIn, buyTradeForBase); \\n    }\\n\\n    /// @notice specify how much trade trader intends to sell/buy \\n    function makerTrade(\\n        bool buyTradeForBase,\\n        uint256 amountIn,\\n        uint16 point\\n        ) external {\\n        (uint256 toEscrowAmount, uint128 crossId) \\n                = this.placeLimitOrder(msg.sender, \\n                    point, \\n                    uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amountIn)), \\n                    !buyTradeForBase); \\n\\n        // Collateral for bids\\n        if (buyTradeForBase) BaseToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n\\n        // or asks\\n        else TradeToken.transferFrom(msg.sender, address(this), toEscrowAmount); \\n    }\\n\\n    function makerClaim(\\n        uint16 point, \\n        bool buyTradeForBase\\n        ) external {\\n        uint256 claimedAmount = this.claimFilledOrder(\\n            msg.sender, \\n            point, \\n            !buyTradeForBase\\n        ); \\n\\n        if (buyTradeForBase) TradeToken.transfer(msg.sender, claimedAmount);\\n        else BaseToken.transfer(msg.sender, claimedAmount); \\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\",\"keccak256\":\"0x67020109e3f611764965eb19488ba0e3795f1c088f6a3c539803814fe72d11af\",\"license\":\"UNLICENSED\"},\"contracts/bonds/boundedDerivatives.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport \\\"./GBC.sol\\\"; \\n// import {BoundedDerivativesPool, LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/// @notice Uses AMM as a derivatives market,where the price is bounded between two price\\n/// and mints/burns tradeTokens. \\n/// stores all baseTokens for trading, and also stores tradetokens when providing liquidity, \\n/// @dev Short loss is bounded as the price is bounded, no need to program liquidations logic \\ncontract BoundedDerivativesPool is GranularBondingCurve{\\n    using FixedPointMath for uint256;\\n    using SafeCast for uint256; \\n    // using Position for Position.Info;\\n    // uint256 constant PRECISION = 1e18; \\n    ERC20 public  BaseToken; \\n    ERC20 public  TradeToken; \\n    ERC20 public  s_tradeToken; \\n    uint256 public constant maxPrice = 1e18; \\n\\n    bool immutable noCallBack; \\n    constructor(\\n        address base, \\n        address trade, \\n        address s_trade, \\n        bool _noCallBack\\n        // address _pool \\n        ) GranularBondingCurve(base, trade){\\n        BaseToken =  ERC20(base);\\n        TradeToken = ERC20(trade);\\n        s_tradeToken = ERC20(s_trade);\\n        noCallBack = _noCallBack; \\n    }\\n\\n    /// @notice recipient recieves amountOut in exchange for giving this contract amountIn (base)\\n    function mintAndPull(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        \\n        // Mint and Pull \\n        if(isLong) TradeToken.mint(recipient, amountOut); \\n        else s_tradeToken.mint(recipient, amountOut); \\n        BaseToken.transferFrom(recipient,address(this), amountIn); \\n    }\\n\\n    function burnAndPush(address recipient, uint256 amountOut, uint256 amountIn, bool isLong) internal  {\\n        // Burn and Push \\n        if(isLong) TradeToken.burn(recipient, amountIn); \\n        else s_tradeToken.burn(recipient, amountIn); \\n   \\n        BaseToken.transfer(recipient, amountOut); \\n    }\\n\\n    function baseBal() public view returns(uint256){\\n        return BaseToken.balanceOf(address(this)); \\n    }\\n\\n    /// @notice Long up the curve, or short down the curve \\n    /// @param amountIn is base if long, trade if short\\n    /// @param priceLimit is slippage tolerance\\n    function takerOpen(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external  returns(uint256 poolamountIn, uint256 poolamountOut ){\\n        if(isLong){\\n            // Buy up \\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            if (noCallBack) mintAndPull(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else {\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountIn, data); \\n                require(baseBal() >= poolamountIn + bal, \\\"balERR\\\"); \\n                TradeToken.mint(abi.decode(data, (address)), poolamountOut); \\n            }\\n        }\\n\\n        else{\\n            // just shift pool state\\n            (poolamountIn, poolamountOut) = trade(\\n                address(this), \\n                false, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountOut = poolamountOut; \\n            // poolamountIn is the number of short tokens minted, poolamountIn * maxprice - poolamountOut is the collateral escrowed\\n            poolamountOut = poolamountIn.mulWadDown(maxPrice) - poolamountOut;\\n\\n            // One s_tradeToken is a representation of debt+sell of one tradetoken\\n            // Escrow collateral required for shorting, where price for long + short = maxPrice, \\n            // so (maxPrice-price of trade) * quantity\\n            if (noCallBack) mintAndPull(msg.sender, poolamountIn, poolamountOut, false);\\n\\n            else{\\n                uint256 bal = baseBal(); \\n                iTradeCallBack(msg.sender).tradeCallBack(poolamountOut, data); \\n                require(baseBal() >= poolamountOut + bal, \\\"balERR\\\"); \\n                s_tradeToken.mint(abi.decode(data,(address)), poolamountIn); \\n\\n                // need to send cached poolamountOut(the area under the curve) data for accounting purposes\\n                poolamountIn = cached_poolamountOut; \\n            }\\n\\n            // BaseToken.transferFrom(msg.sender, address(this), poolamountIn.mulWadDown(maxPrice) - poolamountOut); \\n            // s_tradeToken.mint(msg.sender, uint256(amountIn)); \\n        }\\n\\n    }\\n\\n    /// @param amountIn is trade if long, ALSO trade if short, since getting rid of s_trade \\n    function takerClose(\\n        bool isLong, \\n        int256 amountIn,\\n        uint256 priceLimit, \\n        bytes calldata data\\n        ) external returns(uint256 poolamountIn, uint256 poolamountOut){\\n\\n        // Sell down\\n        if(isLong){\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender,\\n                false, \\n                amountIn, //this should be trade tokens\\n                priceLimit, \\n                data\\n            ); \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountOut, poolamountIn, true);\\n\\n            else burnAndPush(abi.decode(data, (address)), poolamountOut, poolamountIn, true );                             \\n        }\\n\\n        else{            \\n            // buy up with the baseToken that was transferred to this contract when opened, in is base out is trade\\n            (poolamountIn, poolamountOut) = trade(\\n                msg.sender, \\n                true, \\n                amountIn, \\n                priceLimit, \\n                data\\n            ); \\n            uint256 cached_poolamountIn = poolamountIn; \\n\\n            // collateral used to buy short \\n            poolamountIn = poolamountOut.mulWadDown(maxPrice) - poolamountIn; \\n\\n            if (noCallBack) burnAndPush(msg.sender, poolamountIn,poolamountOut, false);\\n            else {\\n                burnAndPush(abi.decode(data, (address)), poolamountIn, poolamountOut,false ); \\n                poolamountOut = cached_poolamountIn; \\n            }\\n\\n            // s_tradeToken.burn(msg.sender, poolamountOut); \\n            // BaseToken.transfer(msg.sender, poolamountOut.mulWadDown(maxPrice) - poolamountIn);\\n        }\\n    }\\n\\n    /// @notice provides oneTimeliquidity in the range (point,point+1)\\n    /// @param amount is in base if long, trade if in short  \\n    function makerOpen(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong,\\n        address recipient\\n        )external  returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // escrowAmount is base \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient,\\n                point, \\n                uint128(liquidityGivenBase(pointToPrice(point+1), pointToPrice(point), amount)), \\n                false\\n                ); \\n            BaseToken.transferFrom(recipient, address(this), toEscrowAmount); \\n        }\\n\\n        // need to set limit for sells, but claiming process is different then regular sells \\n        else{\\n            // escrowAmount is trade \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)) , \\n                true\\n                ); \\n\\n            // escrow amount is (maxPrice - avgPrice) * quantity \\n            uint256 escrowCollateral = toEscrowAmount - baseGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    uint256(amount) //positive since adding asks, not subtracting \\n                    ); \\n            BaseToken.transferFrom(recipient, address(this), escrowCollateral); \\n            toEscrowAmount = escrowCollateral; \\n        }\\n\\n    }\\n\\n    function makerClaimOpen(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            uint256 claimedAmount = claimFilledOrder(recipient, point, false ); \\n\\n            // user already escrowed funds, so need to send him tradeTokens \\n            TradeToken.mint(recipient, claimedAmount);          \\n        }\\n\\n        else{           \\n            s_tradeToken.mint(recipient, \\n                tradeGivenLiquidity(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point), \\n                    getLiq(msg.sender, point, true)\\n                    )\\n                ); \\n\\n            // open short is filled sells, check if sells are filled. If it is,\\n            // claimedAmount of basetokens should already be in this contract \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n        }\\n\\n    }\\n    /// @notice amount is trade if long, but ALSO trade if short(since trade quantity also coincides\\n    /// with shortTrade quantity )\\n    function makerClose(\\n        uint16 point, \\n        uint256 amount,\\n        bool isLong, \\n        address recipient\\n        )external returns(uint256 toEscrowAmount, uint128 crossId){\\n\\n        if(isLong){\\n            // close long is putting up trades for sells, \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point, \\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                true\\n                ); \\n            //maybe burn it when claiming, and just escrow? \\n            TradeToken.burn(recipient, toEscrowAmount); \\n        }\\n\\n        else{\\n            // Place limit orders for buys \\n            (toEscrowAmount, crossId) = placeLimitOrder(\\n                recipient, \\n                point,\\n                uint128(liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point),amount)), \\n                false\\n                ); \\n\\n            // burn s_tradeTokens, \\n            s_tradeToken.burn(recipient, amount); \\n\\n        }\\n    }\\n\\n    function makerClaimClose(\\n        uint16 point, \\n        bool isLong, \\n        address recipient\\n        ) external returns(uint256 claimedAmount){\\n\\n        if(isLong){\\n            // Sell is filled, so need to transfer back base \\n            claimedAmount = claimFilledOrder(recipient, point, true ); \\n            BaseToken.transfer(recipient, claimedAmount); \\n        }\\n        else{\\n            uint128 liq = getLiq(recipient, point, false); \\n\\n            // Buy is filled, which means somebody burnt trade, so claimedAmount is in trade\\n            claimedAmount = claimFilledOrder(recipient, point, false);\\n            claimedAmount = claimedAmount.mulWadDown(maxPrice) \\n                            - baseGivenLiquidity(\\n                            pointToPrice(point+1), \\n                            pointToPrice(point), \\n                            liq); \\n            BaseToken.transfer(recipient, claimedAmount);\\n        }\\n    }    \\n\\n    function makerPartiallyClaim(\\n        uint16 point, \\n        bool isLong,\\n        bool open, \\n        address recipient\\n        ) external returns(uint256 baseAmount, uint256 tradeAmount){\\n   \\n        if(open){\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true);\\n        }\\n        else{\\n            if(isLong)(baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, true); \\n            else (baseAmount, tradeAmount) = claimPartiallyFilledOrder(recipient, point, false);\\n        }\\n        \\n        BaseToken.transfer(recipient, baseAmount);\\n        TradeToken.mint(recipient, tradeAmount); \\n    }\\n\\n    /// @notice amount is in base if long, trade if short \\n    function makerReduceOpen(\\n        uint16 point, \\n        uint256 amount, \\n        bool isLong, \\n        address recipient\\n        ) external{\\n    \\n        if(isLong){\\n            uint256 returned_amount =reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenBase(\\n                    pointToPrice(point+1), \\n                    pointToPrice(point),\\n                    amount\\n                    ).toUint128(), \\n                false\\n                ); \\n            // need to send base back \\n            BaseToken.transfer(recipient, returned_amount); \\n        }\\n        else {\\n            uint128 liq = liquidityGivenTrade(pointToPrice(point+1), pointToPrice(point), amount).toUint128(); \\n            // Reduce asks \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liq, \\n                true\\n                ); \\n\\n            // Need to send escrowed basetoken back, which is shortTrade quantity - baseGivenLiquidity \\n            BaseToken.transfer(recipient, \\n                amount - baseGivenLiquidity(pointToPrice(point+1), pointToPrice(point), liq));\\n        }\\n    }\\n\\n    /// @notice amount is in trade if long, ALSO trade if short \\n    function makerReduceClose(      \\n        uint16 point, \\n        uint256 amount, \\n        bool isLong,\\n        address recipient\\n        ) external{\\n\\n        if(isLong){\\n            uint256 returned_amount = reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                true\\n                ); \\n            // need to send trade back \\n            TradeToken.mint(recipient, returned_amount); \\n        }\\n\\n        else{\\n            // reduce limit bids \\n            reduceLimitOrder(\\n                recipient, \\n                point, \\n                liquidityGivenTrade(\\n                    uint256(pointToPrice(point+1)), \\n                    uint256(pointToPrice(point)), amount).toUint128(), \\n                false\\n            ); \\n             \\n            s_tradeToken.mint(recipient, amount); \\n        }\\n    }\\n\\n    function provideLiquidity(\\n        uint16 pointLower,\\n        uint16 pointUpper,\\n        uint128 amount, \\n        bytes calldata data \\n        ) external {\\n\\n        (uint256 amount0, uint256 amount1) = provide(\\n            msg.sender, \\n            pointLower, \\n            pointUpper, \\n            amount, \\n            data \\n        ); \\n        BaseToken.transferFrom(msg.sender, address(this), amount0); \\n        // TradeToken.transferFrom(msg.sender, address(this), amount1);\\n        TradeToken.burn(msg.sender, amount1);\\n    }\\n\\n    function withdrawLiquidity(\\n        uint16 pointLower,\\n        uint16 pointUpper,\\n        uint128 amount, \\n        bytes calldata data \\n        )external{\\n\\n        (uint256 amountBase, uint256 amountTrade) = remove(\\n            msg.sender, \\n            pointLower, \\n            pointUpper, \\n            amount\\n        ); \\n      \\n        collect(\\n            msg.sender, \\n            pointLower,\\n            pointUpper,\\n            type(uint128).max,\\n            type(uint128).max\\n        ); \\n\\n        BaseToken.transfer(msg.sender,  amountBase); \\n        TradeToken.mint(msg.sender, amountTrade); \\n    }\\n    function getTraderPosition()external view{}\\n\\n    //TODO fees, skipping uninit for gas, below functions\\n    // possible attacks: manipulation of price with no liquidityregions, add a bid/ask and a naive \\n    // trader fills, and immediately submit a ask much higher/lower\\n    // gas scales with number of loops, so need to set ticks apart large, or provide minimal liquidity in each tick\\n\\n}\\n\\ninterface iTradeCallBack{\\n    function tradeCallBack(\\n        uint256 amount0,\\n bytes calldata data    ) external;\\n} \\n\",\"keccak256\":\"0x34fc6c2553c937d54825817e73b13e66583059001d9ed4bcbd1ad4ac5b953324\"},\"contracts/bonds/libraries.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMath {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    // function toUint256(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint256(y)) == y);\\n    // }\\n    // function toUint210(uint256 y)internal pure returns (uint160 z) {\\n    //     require((z = uint160(y)) == y);\\n    // }\\n    function toUint128(uint256 y)internal pure returns (uint128 z) {\\n        require((z = uint128(y)) == y);\\n    }\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param y The uint256 to be downcasted\\n    /// @return z The downcasted integer, now type uint160\\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\\n        require((z = uint160(y)) == y);\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param y The int256 to be downcasted\\n    /// @return z The downcasted integer, now type int128\\n    function toInt128(int256 y) internal pure returns (int128 z) {\\n        require((z = int128(y)) == y);\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param y The uint256 to be casted\\n    /// @return z The casted integer, now type int256\\n    function toInt256(uint256 y) internal pure returns (int256 z) {\\n        require(y < 2**255);\\n        z = int256(y);\\n    }\\n}\\n\\n\\ncontract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n    function mint(address to, uint256 amount) public {\\n      _mint(to, amount); \\n    }\\n    function burn(address to, uint256 amount) public {\\n      _burn(to, amount); \\n    }\\n}\",\"keccak256\":\"0x6f4b41b0a3a677144ec92ae040f756a7af61ffe54f497f92d7f20a729b3cb091\"},\"contracts/bonds/synthetic.sol\":{\"content\":\"pragma solidity ^0.8.9;\\nimport { LinearCurve} from \\\"./GBC.sol\\\"; \\nimport {BoundedDerivativesPool} from \\\"./boundedDerivatives.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {ERC20} from \\\"./libraries.sol\\\"; \\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\ncontract ZCBFactory{\\n    function newBond(\\n        string memory name, \\n        string memory description \\n        ) public returns(address) {\\n        ERC20 bondToken = new ERC20(name,description, 18);\\n        return address(bondToken); \\n    }\\n\\n}\\ncontract SyntheticZCBPoolFactory{\\n    address public immutable controller;\\n    address public immutable zcbFactory; \\n    constructor(address _controller, address _zcbFactory){\\n        controller = _controller; \\n        zcbFactory = _zcbFactory; \\n    }\\n\\n\\n    /// @notice param base is the collateral used in pool \\n    function newPool(\\n        address base, \\n        address entry\\n        ) external returns(address longZCB, address shortZCB, SyntheticZCBPool pool){\\n        longZCB = ZCBFactory(zcbFactory).newBond(\\\"longZCB\\\", \\\"long\\\");\\n        shortZCB = ZCBFactory(zcbFactory).newBond(\\\"shortZCB\\\", \\\"short\\\");\\n\\n        pool = new SyntheticZCBPool(\\n            base, longZCB, shortZCB, entry, controller\\n        ); \\n    }\\n}\\n\\ncontract SyntheticZCBPool is BoundedDerivativesPool{\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 public a_initial;\\n    uint256 public b_initial; // b without discount cap \\n    uint256 public b;\\n    uint256 public discount_cap; \\n    uint256 public discountedReserves; \\n\\n    address public immutable controller; \\n    uint256 public constant precision = 1e18; \\n    constructor(address base, \\n        address trade, \\n        address s_trade, \\n        address _entry, \\n        address _controller\\n        )BoundedDerivativesPool(base,trade,s_trade, false){\\n        entry = _entry; \\n        controller = _controller; \\n        }\\n\\n    /// @notice calculate and store initial curve params that takes into account\\n    /// validator rewards(from discounted zcb). For validator rewards, just skew up the initial price\\n    /// These params are used for utilizer bond issuance, but a is set to 0 after issuance phase \\n    /// @param sigma is the proportion of P that is going to be bought at a discount  \\n    function calculateInitCurveParams(\\n        uint256 P, \\n        uint256 I, \\n        uint256 sigma) external {\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        b_initial = (2*P).divWadDown(P+I) - precision; \\n        a_initial = (precision-b_initial).divWadDown(P+I); \\n\\n        // Calculate and store maximum tokens for discounts, and get new initial price after saving for discounts\\n        (discount_cap, b) = LinearCurve.amountOutGivenIn(P.mulWadDown(sigma), 0, a_initial, b_initial, true);\\n\\n        // Set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a_initial))); \\n        setPriceAndPoint(b);\\n    }\\n\\n    /// @notice calculates initparams for pool based instruments \\n    /// param endPrice is the inception Price of longZCB, or its price when there is no discount\\n    function calculateInitCurveParamsPool(\\n        uint256 saleAmount, \\n        uint256 initPrice, \\n        uint256 endPrice, \\n        uint256 sigma\\n        ) external returns(uint256 managementFee){\\n        require(msg.sender == controller, \\\"unauthorized\\\"); \\n        //TODO these fails at some inputs\\n        uint256 saleAmountQty = (2*saleAmount).divWadDown(initPrice +endPrice); \\n        uint256 a = (endPrice - initPrice).divWadDown(saleAmountQty); \\n        \\n        //Set discount cap as saleAmount * sigma \\n        (discount_cap, ) = LinearCurve.amountOutGivenIn(saleAmount.mulWadDown(sigma),0, a, initPrice,true ); \\n        b = initPrice; \\n\\n        // How much total discounts are validators and managers getting\\n        managementFee = discount_cap.mulWadDown(endPrice) \\n            - saleAmount.mulWadDown(sigma) + saleAmountQty.mulWadDown(endPrice) - saleAmount ; \\n\\n        // set initial liquidity and price \\n        setLiquidity(uint128(precision.divWadDown(a))); \\n        setPriceAndPoint(b); \\n        setDynamicLiquidity(priceToPoint(endPrice), type(int128).max); \\n        setModifyLiqPoint(priceToPoint(endPrice)); \\n    }\\n\\n    /// @notice computes area between the curve and max price for given storage parameters\\n    function areaBetweenCurveAndMax(uint256 amount) public view returns(uint256){\\n        (uint256 amountDelta, ) = LinearCurve.amountOutGivenIn(amount, 0, a_initial, b_initial, true); \\n        return amountDelta.mulWadDown(maxPrice) - amount; \\n    }\\n\\n    /// @notice mints new zcbs \\n    function trustedDiscountedMint(\\n        address receiver, \\n        uint256 amount \\n        ) external{\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        TradeToken.mint(receiver, amount);\\n        discountedReserves += amount;  \\n    }\\n\\n\\n    function trustedBurn(\\n        address trader, \\n        uint256 amount, \\n        bool long\\n        ) external {\\n        require(msg.sender == entry, \\\"entryERR\\\"); \\n\\n        if (long) TradeToken.burn(trader, amount); \\n        else s_tradeToken.burn(trader, amount);\\n    }\\n\\n    function flush(address flushTo, uint256 amount) external {\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        if (amount == type(uint256).max) BaseToken.transfer(flushTo, baseBal()); \\n        else BaseToken.transfer(flushTo, amount); \\n    }\\n\\n    /// @notice resets AMM liquidity to 0 and make it ready to be liq provisioned \\n    /// by anyone \\n    function resetLiq() external{\\n        require(msg.sender == controller, \\\"entryERR\\\"); \\n        setLiquidity(0); \\n        amortizeLiq(); \\n    }\\n\\n    function cBal() external view returns(uint256){\\n        return BaseToken.balanceOf(address(this)); \\n    }\\n}\\n\",\"keccak256\":\"0x02b4ca9573984a966b4fb0a12cb112013733605ee5b011a87afaf7db2754c1df\"},\"contracts/chainlink/VRFConsumerBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\",\"keccak256\":\"0xd4697556c95e0f2e5055eea0b07b4d476887052d95dbf838b3cf7c32436c71d1\",\"license\":\"MIT\"},\"contracts/chainlink/VRFCoordinatorV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\",\"keccak256\":\"0xadc1f1babaa7202145a22d82c85176cbe7f1fae993f2c11dabdf6058aebea6b2\",\"license\":\"MIT\"},\"contracts/instruments/IRateCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity >=0.8.16;\\n\\ninterface IRateCalculator {\\n    function name() external pure returns (string memory);\\n\\n    function requireValidInitData(bytes calldata _initData) external pure;\\n\\n    function getConstants() external pure returns (bytes memory _calldata);\\n\\n    function getNewRate(bytes calldata _data, bytes calldata _initData) external pure returns (uint64 _newRatePerSec);\\n}\\n\",\"keccak256\":\"0xf12adc4ffcf31a867fabcc2cfcebf8edf7bc35def82f9dbfdcb9eccf3e0e14a6\",\"license\":\"ISC\"},\"contracts/instruments/VaultAccount.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity ^0.8.16;\\n\\nstruct VaultAccount {\\n    uint128 amount; // Total amount, analogous to market cap\\n    uint128 shares; // Total shares, analogous to shares outstanding\\n}\\n\\n/// @title VaultAccount Library\\n/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto\\n/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations\\n/// @dev Uses uint128 to save on storage\\nlibrary VaultAccountingLibrary {\\n    /// @notice Calculates the shares value in relationship to `amount` and `total`\\n    /// @dev Given an amount, return the appropriate number of shares\\n    function toShares(\\n        VaultAccount memory total,\\n        uint256 amount,\\n        bool roundUp\\n    ) internal pure returns (uint256 shares) {\\n        if (total.amount == 0) {\\n            shares = amount;\\n        } else {\\n            shares = (amount * total.shares) / total.amount;\\n            if (roundUp && (shares * total.amount) / total.shares < amount) {\\n                shares = shares + 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the amount value in relationship to `shares` and `total`\\n    /// @dev Given a number of shares, returns the appropriate amount\\n    function toAmount(\\n        VaultAccount memory total,\\n        uint256 shares,\\n        bool roundUp\\n    ) internal pure returns (uint256 amount) {\\n        if (total.shares == 0) {\\n            amount = shares;\\n        } else {\\n            amount = (shares * total.amount) / total.shares;\\n            if (roundUp && (amount * total.shares) / total.amount < shares) {\\n                amount = amount + 1;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb751d82f4ebf9b19781e9f69d748eef5ffedd97445492ae7904abc5b2341fdff\",\"license\":\"ISC\"},\"contracts/instruments/poolConstants.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\n// taken from https://github.com/FraxFinance/fraxlend\\nabstract contract PoolConstants {\\n    uint256 internal constant LTV_PRECISION = 1e5; // 5 decimals\\n    uint256 internal constant LIQ_PRECISION = 1e5;\\n    uint256 internal constant UTIL_PREC = 1e5;\\n    uint256 internal constant FEE_PRECISION = 1e5;\\n    uint256 internal constant EXCHANGE_PRECISION = 1e18;\\n    uint64 internal constant DEFAULT_INT = 158049988; // 0.5% annual rate 1e18 precision\\n}\",\"keccak256\":\"0xa6d79d0014ff7e7b0b28ec3e9ded940ba9749a72a5f5509d24738f7d531049e4\"},\"contracts/instruments/poolInstrument.sol\":{\"content\":\"pragma solidity ^0.8.16;\\nimport {Instrument} from \\\"../vaults/instrument.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {ERC721} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {PoolConstants} from \\\"./poolConstants.sol\\\";\\nimport {VaultAccount, VaultAccountingLibrary} from \\\"./VaultAccount.sol\\\";\\nimport {SafeCastLib} from \\\"lib/solmate/src/utils/SafeCastLib.sol\\\";\\nimport {IRateCalculator} from \\\"./IRateCalculator.sol\\\";\\nimport {ReentrancyGuard} from \\\"lib/solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {Pausable} from \\\"lib/openzeppelin-contracts/contracts/security/Pausable.sol\\\";\\nimport {ERC4626} from \\\"lib/solmate/src/mixins/ERC4626.sol\\\";\\nimport {ERC721TokenReceiver} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n// import \\\"@prb/math/SD59x18.sol\\\";\\n\\n// https://github.com/FraxFinance/fraxlend\\n/// ****THIS IS A PROOF OF CONCEPT INSTRUMENT.\\ncontract PoolInstrument is ERC4626, Instrument, PoolConstants, ReentrancyGuard, Pausable, ERC721TokenReceiver {\\n    using SafeTransferLib for ERC20;\\n    using VaultAccountingLibrary for VaultAccount;\\n    using SafeCastLib for uint256;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    /// @param lastBlock last block number\\n    /// @param lastTimestamp last block.timestamp\\n    /// @param ratePerSec rate per second of interest accrual\\n    struct CurrentRateInfo {\\n        uint64 lastBlock;\\n        uint64 lastTimestamp;\\n        uint64 ratePerSec;\\n    }\\n\\n    /// @param tokenAddress collateral token address\\n    /// @param tokenId collateral tokenId, 0 for ERC20.\\n    struct CollateralLabel {\\n        address tokenAddress;\\n        uint256 tokenId;\\n    }\\n\\n    /// @param totalCollateral total amount of collateral for a given ERC20 asset, will be zero for NFTs\\n    /// @param maxAmount max amount in underlying that a user can \\\"owe\\\" per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\\n    /// should always be more than the maxBorrowAmount, acts as buffer for protocol and borrower. this is the value to determine whether\\n    /// a borrower is liquidatable\\n    /// @param maxBorrowAmount max amount in underlying that a user can borrow per base unit of collateral (unit = 1 for NFTs, 1e18 for ERC20s)\\n    struct Collateral {\\n        uint256 totalCollateral; \\n        uint256 maxAmount;\\n        uint256 maxBorrowAmount;\\n        bool isERC20;\\n    }\\n\\n    /// @notice dutch auctions for NFTs, GDA for illiquid ERC20s.\\n    /// @param borrower address of borrower\\n    /// @param collateral address of collateral\\n    /// @param tokenId tokenId of collateral, 0 for ERC20\\n    /// @param initialPrice initial price of collateral currently is (account liquidity / collateral amount) + maxAmount.\\n    /// @param decayConstant parameter that controls price decay, stored as a 59x18 fixed precision number\\n    /// @param startTime for dutch auction: start time of auction, for GDA: time of last auction.\\n    /// @param emissionRate for dutch auction: 0, for GDA: amount of collateral to be auctioned off per second.\\n    // struct Auction {\\n    //     address borrower;\\n    //     address collateral;\\n    //     uint256 tokenId;\\n    //     SD59x18 initialPrice;\\n    //     SD59x18 minimumPrice;\\n    //     SD59x18 decayConstant;\\n    //     SD59x18 startTime;\\n    //     // SD59x18 emissionRate;\\n    //     bool alive;\\n    // }\\n\\n    /// @notice amount: asset token borrowed, shares = total shares outstanding\\n    VaultAccount public totalBorrow;\\n    /// @notice amount: total asset supplied + interest earned, shares = total shares outstanding\\n    VaultAccount public totalAsset;\\n\\n    mapping(address=>mapping(uint256 => Collateral)) public collateralData; // collateral address => tokenId (0 for erc20) => collateral data.\\n    mapping(address=>mapping(uint256=>bool)) public approvedCollateral;\\n    mapping(address=>mapping(address=>uint256)) public userCollateralERC20; // per collateral, user balance of collateral.\\n    mapping(address=>mapping(uint256 => address)) public userCollateralNFTs; // nft addr => tokenId => owner.\\n    mapping(address=>uint256) public userBorrowShares;\\n    mapping(address=>uint256) public userAuctionId; // user => current auction id, if 0 then no auction.\\n    \\n    /// @dev auction id => order of creation.\\n    // mapping(uint256=>Auction) public auctions; // auction id => auction data, auction id is in order of creation.\\n\\n    uint256 public numAuctions; // number of auction ids.\\n\\n    IRateCalculator public rateContract;\\n\\n    /// @dev depends on rateCalculator used\\n    bytes public rateInitCallData;\\n    \\n    CurrentRateInfo public currentRateInfo;\\n    CollateralLabel[] collaterals; //approved collaterals.\\n    address controller;\\n    \\n    constructor (\\n        address _vault,\\n        address _controller,\\n        address _utilizer,\\n        address _asset,\\n        string memory _name,\\n        string memory _symbol,\\n        address _rateCalculator,\\n        bytes memory _rateInitCallData\\n    ) Instrument(_vault, _utilizer) ERC4626(ERC20(_asset), _name, _symbol) {\\n        controller = _controller;\\n        rateContract = IRateCalculator(_rateCalculator);\\n        rateInitCallData = _rateInitCallData;\\n        rateContract.requireValidInitData(_rateInitCallData);\\n\\n    }\\n\\n    // should be gated function\\n    /// tokenId 0 for ERC20.\\n    function initialize(\\n    ) external {\\n\\n    }\\n\\n    function getAcceptedCollaterals() view public returns (CollateralLabel[] memory) {\\n        return collaterals;\\n    }\\n\\n    // legacy for tests, remove later.\\n    function addAcceptedCollateral(\\n        address _collateral,\\n        uint256 _tokenId,\\n        uint256 _maxAmount,\\n        uint256 _maxBorrowAmount,\\n        bool _isERC20\\n    ) external  {\\n        require(msg.sender == controller, \\\"only controller\\\");\\n        if (approvedCollateral[_collateral][_tokenId]) return; \\n        require(_maxAmount > _maxBorrowAmount, \\\"maxAmount must be greater than maxBorrowAmount\\\");\\n        approvedCollateral[_collateral][_tokenId] = true;\\n        collaterals.push(CollateralLabel(_collateral, _tokenId));\\n        collateralData[_collateral][_tokenId] = Collateral(0,_maxAmount, _maxBorrowAmount, _isERC20);\\n    }\\n\\n    // INTERNAL HELPERS\\n\\n    modifier onlyApprovedCollateral(address _collateral, uint256 _tokenId) {\\n        require(approvedCollateral[_collateral][_tokenId], \\\"collateral not approved\\\");\\n        _;\\n    }\\n\\n    function _totalAssetAvailable(VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return _totalAsset.amount - _totalBorrow.amount;\\n    }\\n\\n    // INTEREST RATE LOGIC\\n    event InterestAdded(uint256 indexed timestamp, uint256 interestEarned, uint256 feesAmount, uint256 feesShare, uint64 newRate);\\n\\n    function addInterest()\\n        external\\n        nonReentrant\\n        returns (\\n            uint256 _interestEarned,\\n            uint256 _feesAmount,\\n            uint256 _feesShare,\\n            uint64 _newRate\\n        )\\n    {\\n        return _addInterest();\\n    }\\n\\n    function _addInterest() internal\\n        returns (\\n            uint256 _interestEarned,\\n            uint256 _feesAmount,\\n            uint256 _feesShare,\\n            uint64 _newRate\\n        )\\n    {\\n        // Add interest only once per block\\n        CurrentRateInfo memory _currentRateInfo = currentRateInfo;\\n        if (_currentRateInfo.lastTimestamp == block.timestamp) {\\n            _newRate = _currentRateInfo.ratePerSec;\\n            return (_interestEarned, _feesAmount, _feesShare, _newRate);\\n        }\\n\\n        // Pull some data from storage to save gas\\n        VaultAccount memory _totalAsset = totalAsset;\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n        console.log(\\\"total borrower shares: \\\", totalBorrow.shares);\\n\\n        // If there are no borrows or contract is paused, no interest adds and we reset interest rate\\n        if (_totalBorrow.shares == 0 || paused()) {\\n            if (!paused()) {\\n                _currentRateInfo.ratePerSec = DEFAULT_INT;\\n            }\\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\\n            _currentRateInfo.lastBlock = uint64(block.number);\\n\\n            // Effects: write to storage\\n            currentRateInfo = _currentRateInfo;\\n        } else {\\n            // We know totalBorrow.shares > 0\\n            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;\\n\\n            // NOTE: Violates Checks-Effects-Interactions pattern\\n            // Be sure to mark external version NONREENTRANT (even though rateContract is trusted)\\n            // Calc new rate\\n            uint256 _utilizationRate = (UTIL_PREC * _totalBorrow.amount) / _totalAsset.amount;\\n            // console.log(\\\"_utilizationRate: \\\", _utilizationRate);\\n            bytes memory _rateData = abi.encode(\\n                    _currentRateInfo.ratePerSec,\\n                    _deltaTime,\\n                    _utilizationRate,\\n                    block.number - _currentRateInfo.lastBlock\\n                );\\n                _newRate = IRateCalculator(rateContract).getNewRate(_rateData, rateInitCallData);\\n\\n            // Effects: bookkeeping\\n            _currentRateInfo.ratePerSec = _newRate;\\n            _currentRateInfo.lastTimestamp = uint64(block.timestamp);\\n            _currentRateInfo.lastBlock = uint64(block.number);\\n\\n            // Calculate interest addd\\n            _interestEarned = (_deltaTime * _totalBorrow.amount * _currentRateInfo.ratePerSec) / 1e18;\\n\\n            // Accumulate interest and fees, only if no overflow upon casting\\n            if (\\n                _interestEarned + _totalBorrow.amount <= type(uint128).max &&\\n                _interestEarned + _totalAsset.amount <= type(uint128).max\\n            ) {\\n                _totalBorrow.amount += uint128(_interestEarned);\\n                _totalAsset.amount += uint128(_interestEarned);\\n            }\\n\\n            // Effects: write to storage\\n            totalAsset = _totalAsset;\\n            currentRateInfo = _currentRateInfo;\\n            totalBorrow = _totalBorrow;\\n        }\\n        console.log(\\\"_interestEarned: \\\", _interestEarned);\\n        emit InterestAdded(block.timestamp, _interestEarned, _feesAmount, _feesShare, _newRate);\\n        // console.log(\\\"ratePerSec: \\\", _currentRateInfo.ratePerSec);\\n    }\\n\\n    // SOLVENCY* LOGIC\\n\\n    /// @notice Checks if total amount of asset user borrowed is less than max borrow threshold AFTER executing contract code\\n    modifier canBorrow(address _borrower) {\\n        _;\\n        require(_canBorrow(_borrower), \\\"borrower is insolvent\\\");\\n    }\\n\\n\\n    /// @notice checks if the borrower is can borrow\\n    /// @dev collateral value is in asset, summed across all approved collaterals.\\n    /// @dev will return true if the borrower has no collateral and also has no borrower shares.\\n    /// @dev 0 addr cannot borrow.\\n    function _canBorrow(address _borrower) public view returns (bool) {\\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower);\\n\\n        if (userBorrowShares[_borrower] == 0) {\\n            return true;\\n        }\\n        if (_maxBorrowableAmount == 0) {\\n            return false;\\n        }\\n        return _maxBorrowableAmount >= totalBorrow.toAmount(userBorrowShares[_borrower], false);\\n    }\\n\\n    function getMaxBorrow(address _borrower) public view returns(uint256 _maxBorrowableAmount){\\n\\n        for (uint256 i; i < collaterals.length; i++) {\\n            CollateralLabel memory _collateral = collaterals[i];\\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxBorrowAmount / (10**_d); // <= precision of collateral.\\n            } else {\\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\\n                    _maxBorrowableAmount += _collateralData.maxBorrowAmount;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice returns how much collateral can be removed, given the borrower's current debt condition\\n    function removeableCollateral(address _borrower, uint256 tokenId, address collateral) public view returns(uint256){\\n        //800 borrowable = 800 * 1, 600borrowed (800-x)*1 - 600 = 0 x=? \\n        //800*1-x*1-600 , x = (800*1 - 600)/1\\n        uint256 _maxBorrowableAmount = getMaxBorrow(_borrower); \\n        uint256 perUnitMaxBorrowAmount = collateralData[collateral][tokenId].maxBorrowAmount; \\n        //check solvency\\n        return (_maxBorrowableAmount - totalBorrow.toAmount(userBorrowShares[_borrower], true)) \\n            * 1e18/ perUnitMaxBorrowAmount; \\n    }  \\n\\n    // BORROW LOGIC\\n    event Borrow(address indexed _borrower, uint256 _amount, uint256 _shares);\\n\\n    /// @param _borrowAmount amount of asset to borrow\\n    /// @param _collateralAmount amount of collateral to add\\n    /// @param _collateral address of collateral, \\n    /// @param _reciever address of reciever of asset\\n    function borrow(\\n        uint256 _borrowAmount,\\n        address _collateral,\\n        uint256 _tokenId,\\n        uint256 _collateralAmount,\\n        address _reciever\\n    ) canBorrow(msg.sender) nonReentrant whenNotPaused external returns (uint256 _shares) {\\n        _addInterest();\\n\\n        if (_collateral != address(0) && (_collateralAmount > 0 || _tokenId > 0)) {\\n            require(approvedCollateral[_collateral][_tokenId], \\\"unapproved collateral\\\");\\n            _addCollateral(msg.sender, _collateral, _collateralAmount, msg.sender, _tokenId);\\n        }\\n        // borrow asset.\\n        _shares = _borrow(_borrowAmount.safeCastTo128(), _reciever);\\n    }\\n\\n    function _borrow(\\n        uint128 _borrowAmount,\\n        address _receiver\\n    ) internal returns (uint256 _shares) {\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n\\n        // Check available capital\\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\\n        if (_assetsAvailable < _borrowAmount) {\\n            revert(\\\"insufficient contract asset balance\\\");\\n        }\\n\\n        // Effects: Bookkeeping to add shares & amounts to total Borrow accounting\\n        _shares = _totalBorrow.toShares(_borrowAmount, true);\\n        _totalBorrow.amount += _borrowAmount;\\n        _totalBorrow.shares += uint128(_shares);\\n        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128\\n\\n        // Effects: write back to storage\\n        totalBorrow = _totalBorrow;\\n        userBorrowShares[msg.sender] += _shares;\\n\\n        emit Borrow(msg.sender, _borrowAmount, _shares);\\n\\n        // Interactions\\n        if (_receiver != address(this)) {\\n            asset.safeTransfer(_receiver, _borrowAmount);\\n        }\\n    }\\n\\n    // REPAY LOGIC\\n    event Repay(address indexed borrower, uint256 amount, uint256 shares);\\n\\n    function repayWithAmount(\\n        uint256 _amount, \\n        address _borrower\\n        )   external nonReentrant returns (uint256 _sharesToRepay){\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n        _sharesToRepay = _totalBorrow.toShares(_amount, true); \\n        _repay(_totalBorrow, _amount.safeCastTo128(), _sharesToRepay.safeCastTo128(), msg.sender, _borrower);\\n    }\\n\\n    function repay(\\n        uint256 _shares,\\n        address _borrower\\n    ) external nonReentrant returns (uint256 _amountToRepay) {\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n        _amountToRepay = _totalBorrow.toAmount(_shares, true);\\n        console.log(\\\"amount to repay: \\\", _amountToRepay);\\n        _repay(_totalBorrow, _amountToRepay.safeCastTo128(), _shares.safeCastTo128(), msg.sender, _borrower);\\n    }\\n\\n    function _repay(\\n        VaultAccount memory _totalBorrow,\\n        uint128 _amountToRepay,\\n        uint128 _shares,\\n        address _payer,\\n        address _borrower\\n    ) internal {\\n        console.log(\\\"_shares: \\\", _shares);\\n        console.log(\\\"_amountToRepay: \\\", _amountToRepay);\\n        console.log(\\\"userBorrowShares[_borrower]: \\\", userBorrowShares[_borrower]);\\n        // Effects: Bookkeeping\\n        _totalBorrow.amount -= _amountToRepay;\\n        _totalBorrow.shares -= _shares;\\n\\n        // Effects: write to state\\n        userBorrowShares[_borrower] -= _shares;\\n        totalBorrow = _totalBorrow;\\n\\n        emit Repay(_borrower, _amountToRepay, _shares);\\n\\n        // Interactions\\n        if (_payer != address(this)) {\\n            asset.safeTransferFrom(_payer, address(this), _amountToRepay);\\n        }\\n    }\\n\\n\\n    // ADD/REMOVE COLLATERAL LOGIC\\n    event AddCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\\n    event RemoveCollateral(address indexed borrower, address collateral, uint256 tokenId, uint256 amount);\\n\\n    \\n    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position\\n    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation, or ERC721.approve().\\n    /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position\\n    /// @param _borrower The account to be credited\\n    function addCollateral(\\n        address _collateral,\\n        uint256 _tokenId,\\n        uint256 _collateralAmount,\\n        address _borrower\\n    ) external onlyApprovedCollateral(_collateral, _tokenId) nonReentrant {\\n        _addInterest();\\n        _addCollateral(msg.sender, _collateral, _collateralAmount, _borrower, _tokenId);\\n    }\\n\\n    function _addCollateral(\\n        address _sender,\\n        address _collateral,\\n        uint256 _collateralAmount,\\n        address _borrower,\\n        uint256 _tokenId\\n    ) internal {\\n\\n        // Interactions\\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\\n    \\n        if (_sender != address(this)) {\\n            if (_isERC20)  {\\n                userCollateralERC20[_collateral][_borrower] += _collateralAmount;\\n                collateralData[_collateral][0].totalCollateral += _collateralAmount;\\n                ERC20(_collateral).safeTransferFrom(_sender, address(this), _collateralAmount);\\n            } else {\\n                userCollateralNFTs[_collateral][_tokenId] = _borrower;\\n                ERC721(_collateral).safeTransferFrom(_sender, address(this), _tokenId);\\n            }\\n        }\\n        emit AddCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\\n    }\\n\\n    function removeAvailableCollateral(\\n        address _collateral, \\n        uint256 _tokenId,\\n        address _receiver\\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) returns(uint256 removeable){\\n        _addInterest();\\n\\n        removeable = removeableCollateral(msg.sender,  _tokenId,  _collateral); \\n\\n        _removeCollateral(_collateral, \\n            removeable,\\n            _tokenId, msg.sender, _receiver);\\n    }\\n\\n    function removeCollateral(\\n        address _collateral, \\n        uint256 _tokenId,\\n        uint256 _collateralAmount,\\n        address _receiver\\n    ) external nonReentrant canBorrow(msg.sender) onlyApprovedCollateral(_collateral, _tokenId) {\\n        _addInterest();\\n\\n        // Note: exchange rate is irrelevant when borrower has no debt shares\\n        _removeCollateral(_collateral, _collateralAmount, _tokenId, msg.sender, _receiver);\\n    }\\n\\n    function _removeCollateral(\\n        address _collateral,\\n        uint256 _collateralAmount,\\n        uint256 _tokenId,\\n        address _borrower,\\n        address _receiver\\n    ) internal {\\n\\n        // Interactions\\n        bool _isERC20 = collateralData[_collateral][_tokenId].isERC20;\\n        if (_receiver != address(this)) {\\n            if (_isERC20) {\\n                console.log(\\\"removing erc20 collateral\\\");\\n                console.log(\\\"userCollateralerc20: \\\", userCollateralERC20[_collateral][_borrower] );\\n                console.log(\\\"collateralAmount: \\\", _collateralAmount);\\n                console.log(\\\"total: \\\", collateralData[_collateral][0].totalCollateral);\\n                userCollateralERC20[_collateral][_borrower] -= _collateralAmount;\\n                collateralData[_collateral][0].totalCollateral -= _collateralAmount;\\n                ERC20(_collateral).safeTransfer(_receiver, _collateralAmount);\\n            } else {\\n                require(userCollateralNFTs[_collateral][_tokenId] == _borrower, \\\"not owner of nft\\\");\\n                delete userCollateralNFTs[_collateral][_tokenId];\\n                ERC721(_collateral).safeTransferFrom(address(this), _receiver, _tokenId);\\n            }\\n        }\\n        emit RemoveCollateral(_borrower, _collateral, _tokenId, _collateralAmount);\\n    }\\n\\n    // liquidation logic\\n\\n    /// @notice collateral should be auctioned off at a minimum price chosen by the managers\\n    /// underlying balance, collateral balance, what do we know about the user?\\n    /// if the user's borrow shares are equal to an amount of asset that is greater than the maximum amount they can borrow, \\n    /// they are suceptible to liquidation\\n    /// how to determine what collateral should be auctioned off?\\n    /// maxBorrowAmount\\n    function _isLiquidatable(address _borrower) public view returns (bool, int256 accountLiq) {\\n        uint256 _maxBorrowableAmount;\\n\\n        for (uint256 i; i < collaterals.length; i++) {\\n            CollateralLabel memory _collateral = collaterals[i];\\n            Collateral memory _collateralData = collateralData[_collateral.tokenAddress][_collateral.tokenId];\\n            if (_collateralData.isERC20 && userCollateralERC20[_collateral.tokenAddress][_borrower] > 0) {\\n                uint256 _d = ERC20(_collateral.tokenAddress).decimals();\\n                _maxBorrowableAmount += userCollateralERC20[_collateral.tokenAddress][_borrower] * _collateralData.maxAmount / (10**_d); // <= precision of collateral.\\n            } else {\\n                if (userCollateralNFTs[_collateral.tokenAddress][_collateral.tokenId] == _borrower) {\\n                    _maxBorrowableAmount += _collateralData.maxAmount;\\n                }\\n            }\\n        }\\n\\n\\n        return (_maxBorrowableAmount < totalBorrow.toAmount(userBorrowShares[_borrower], false), \\n            int256(_maxBorrowableAmount) - int256(totalBorrow.toAmount(userBorrowShares[_borrower], false))\\n        );\\n    }\\n\\n    /// AUCTION LOGIC\\n\\n    event AuctionCreated(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\\n    event AuctionClosed(uint256 indexed id, address indexed borrower, address indexed collateral, uint256 tokenId);\\n    event CollateralPurchased(uint256 indexed id, address indexed buyer, address indexed collateral, uint256 tokenId, uint256 amount);\\n\\n    function liquidate(\\n        address _borrower\\n    ) external nonReentrant returns (CollateralLabel memory _collateral, uint256 _auctionId){\\n        _addInterest();\\n        \\n        (bool _liquidatable, int256 _accountLiq) = _isLiquidatable(_borrower);\\n        require(_liquidatable, \\\"borrower is not liquidatable\\\");\\n        require(userAuctionId[_borrower] == 0, \\\"auction already exists\\\");\\n        // _accountLiq < 0 if _liquidatable.\\n        //(_collateral, _auctionId) = _createAuction(_borrower, uint256(-_accountLiq));\\n    }\\n\\n    // since we don't know the price of the collateral, will just use largest maxAmount collateral, presumably the most \\\"liquid\\\"\\n    /// @dev _accountLiq in wad.\\n    // function _createAuction(address _borrower, uint256 _accountLiq) internal returns (CollateralLabel memory _collateral, uint256 _auctionId) {\\n    //     CollateralLabel[] memory _collaterals = collaterals;\\n\\n    //     uint256 maxBorrowableAmount;\\n    //     for (uint256 i; i<_collaterals.length; i++) {\\n    //         CollateralLabel memory _collateralLabel = _collaterals[i];\\n    //         Collateral memory _collateralData = collateralData[_collateralLabel.tokenAddress][_collateralLabel.tokenId];\\n    //         if (_collateralData.isERC20) {\\n    //             uint256 _amount = userCollateralERC20[_collateralLabel.tokenAddress][_borrower] * _collateralData.maxAmount / 1e18; // <= precision of collateral.\\n    //             if (_amount > maxBorrowableAmount) {\\n    //                 maxBorrowableAmount = _amount;\\n    //                 _collateral = _collateralLabel;\\n    //             }\\n    //         } else {\\n    //             if (userCollateralNFTs[_collateralLabel.tokenAddress][_collateralLabel.tokenId] == _borrower) {\\n    //                 if (_collateralData.maxAmount > maxBorrowableAmount) {\\n    //                     maxBorrowableAmount = _collateralData.maxAmount;\\n    //                     _collateral = _collateralLabel;\\n    //                 }\\n    //             }\\n    //         }\\n    //     }\\n\\n    //     // creates auction for collateral user collateral.\\n    //     Collateral memory _data = collateralData[_collateral.tokenAddress][_collateral.tokenId];\\n\\n    //     uint256 _id = numAuctions + 1;\\n\\n    //     SD59x18 _balance;\\n    //     if (_data.isERC20) {\\n    //         uint256 _d = ERC20(_collateral.tokenAddress).decimals();\\n    //         _balance = sd(int256(userCollateralERC20[_collateral.tokenAddress][_borrower] * 10**(18-_d)));\\n    //     } else {\\n    //         _balance = toSD59x18(1);\\n    //     }\\n    //     console.log(\\\"accountLiq: \\\", _accountLiq);\\n    //     console.logInt(SD59x18.unwrap(_balance));\\n    //     console.log(\\\"maxAmount: \\\", _data.maxAmount);\\n    //     console.logInt(int256(_data.maxAmount));\\n\\n    //     SD59x18 _initialPrice = sd(int256(_accountLiq)).div(_balance).add(sd(int256(_data.maxAmount))); // per collateral token.\\n    //     // console.logInt(SD59x18.unwrap(_initialPrice));\\n\\n    //     console.log(\\\"shares: \\\", totalBorrow.toShares(uint256(SD59x18.unwrap(_initialPrice)), true));\\n    //     console.log(\\\"total.shares: \\\", totalBorrow.shares);\\n    //     console.log(\\\"total.amount: \\\", totalBorrow.amount);\\n\\n    //     SD59x18 _decayConstant = sd(1e17).div(toSD59x18(86400));// decayConstant * deltaTime * initial price = discount.\\n    //     SD59x18 _minimumPrice = _initialPrice.div(toSD59x18(4)); // minimum price is 1/4 of initial price.\\n        \\n    //     // sd(1219450412706); // 10% a day. 1.219450412706322930873853944899453684098615428047153617638... \\u00d7 10^-6\\n    //     // SD59x18 _emissionRate = _balance.div(toSD59x18(86400).div(toSD59x18(2))); // 1/2 balance in a day, tokens per second.\\n    //     auctions[_id] = Auction({\\n    //         collateral: _collateral.tokenAddress,\\n    //         tokenId: _collateral.tokenId,\\n    //         borrower: _borrower,\\n    //         initialPrice: _initialPrice,\\n    //         minimumPrice: _minimumPrice,\\n    //         decayConstant: _decayConstant,\\n    //         startTime: toSD59x18(int256(block.timestamp)),\\n    //         //emissionRate: _emissionRate,\\n    //         alive: true\\n    //     });\\n    \\n    //     numAuctions = numAuctions + 1;\\n    //     _auctionId = _id;\\n    //     userAuctionId[_borrower] = _auctionId;\\n\\n    //     emit AuctionCreated(_id, _borrower, _collateral.tokenAddress, _collateral.tokenId);\\n    // }\\n\\n    \\n    // function closeAuction(address _borrower) public {\\n    //     uint256 _id = userAuctionId[_borrower];\\n    //     (bool _liquidatable, ) = _isLiquidatable(auctions[_id].borrower);\\n    //     require(_id != 0, \\\"no auction exists\\\");\\n\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //     }\\n    // }\\n\\n    // function _closeAuction(uint256 _id) internal {\\n    //     address _borrower = auctions[_id].borrower;\\n    //     emit AuctionClosed(_id, _borrower, auctions[_id].collateral, auctions[_id].tokenId);\\n    //     delete userAuctionId[_borrower];\\n    //     delete auctions[_id];\\n    // }\\n\\n    // function purchaseERC20Collateral(uint256 _id, uint256 _amount) external returns (uint256 _totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n\\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //         revert(\\\"auction closed\\\");\\n    //     }\\n        \\n    //     _totalCost = purchasePriceERC20(_id, _amount);\\n    //     console.log(\\\"totalCost: \\\", _totalCost);\\n\\n    //     VaultAccount memory _totalBorrow = totalBorrow;\\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\\n       \\n    //    // will revert if not enough collateral in user collateral balance.\\n    //    _removeCollateral(_auction.collateral, _amount, _auction.tokenId, _auction.borrower, msg.sender);\\n\\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //     }\\n    //     if (userCollateralERC20[_auction.collateral][_auction.borrower] == 0) {\\n    //         delete userAuctionId[_auction.borrower];\\n    //         delete auctions[_id];\\n    //     }\\n        \\n    // }\\n\\n    // function purchasePriceERC20(uint256 _id, uint256 _numTokens) public view returns (uint256 totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n    //     require(_auction.alive, \\\"auction is not alive\\\");\\n\\n    //     uint256 _d = ERC20(_auction.collateral).decimals();\\n        \\n    //     SD59x18 _quantity = sd(int256(_numTokens * (10 ** (18 - _d))));\\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime)).mul(_auction.initialPrice);\\n    //     SD59x18 _price = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) // is initial price > minimum price + discount => initial price - discount > minimum price\\n    //         ? _auction.initialPrice.sub(_discount) : _auction.minimumPrice;\\n    //     totalCost = uint256(SD59x18.unwrap(_price.mul(_quantity)));\\n    // }\\n\\n    // /// @param _id is the auction id to purchase the collateral from\\n    // function purchaseERC721Collateral(uint256 _id) external returns (uint256 _totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n\\n    //     (bool _liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _auction.alive = false;\\n    //         auctions[_id] = _auction;\\n    //         delete userAuctionId[_auction.borrower];\\n    //         revert(\\\"auction closed\\\");\\n    //     }\\n        \\n    //     _totalCost = purchasePriceERC721(_id);\\n\\n    //     VaultAccount memory _totalBorrow = totalBorrow;\\n    //     _repay(_totalBorrow, _totalCost.safeCastTo128(), _totalBorrow.toShares(_totalCost, false).safeCastTo128(), msg.sender, _auction.borrower);\\n       \\n    //    // will revert if not enough collateral in user collateral balance.\\n    //    _removeCollateral(_auction.collateral, 0, _auction.tokenId, _auction.borrower, msg.sender);\\n\\n    //     (_liquidatable, ) = _isLiquidatable(_auction.borrower);\\n    //     if (!_liquidatable) {\\n    //         _closeAuction(_id);\\n    //     }\\n    //     if (userCollateralNFTs[_auction.collateral][_auction.tokenId] == address(0)) {\\n    //         delete userAuctionId[_auction.borrower];\\n    //         delete auctions[_id];\\n    //     }\\n    // }\\n\\n    // function purchasePriceERC721(uint256 _id) public view returns (uint256 totalCost) {\\n    //     Auction memory _auction = auctions[_id];\\n    //     require(_auction.alive, \\\"auction is not alive\\\");\\n\\n    //     SD59x18 _discount = _auction.decayConstant.mul(toSD59x18(int256(block.timestamp)).sub(_auction.startTime));\\n\\n    //     totalCost = SD59x18.unwrap(_auction.initialPrice) > SD59x18.unwrap(_auction.minimumPrice.add(_discount)) ? \\n    //     uint256(SD59x18.unwrap(_auction.initialPrice.sub(_discount))) : uint256(SD59x18.unwrap(_auction.minimumPrice));\\n        \\n    // }\\n\\n    // instrument functions\\n    function instrumentApprovalCondition() public override virtual view returns (bool) {\\n        return true;\\n    }\\n\\n    function borrowLiquidityAvailable(uint256 _borrowAmount) public view returns (bool){\\n        VaultAccount memory _totalBorrow = totalBorrow;\\n\\n        uint256 _assetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow);\\n        if (_assetsAvailable < _borrowAmount) {\\n            return false;\\n        }\\n        return true; \\n    }\\n\\n    function totalAssetAvailable() public view returns(uint256){\\n        return _totalAssetAvailable(totalAsset, totalBorrow); \\n    }\\n\\n\\n    // ERC4626 functions.\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal override virtual {\\n        require(msg.sender == address(vault), \\\"Not Vault\\\"); // only the vault can withdraw\\n        // check if there is enough asset to cover the withdraw.\\n        uint256 totalAvailableAsset = _totalAssetAvailable(totalAsset, totalBorrow);\\n        require(totalAvailableAsset >= assets, \\\"not enough asset\\\");\\n\\n        VaultAccount memory _totalAsset = totalAsset;\\n\\n        _totalAsset.amount -= assets.safeCastTo128();\\n        _totalAsset.shares -= shares.safeCastTo128();\\n\\n        totalAsset = _totalAsset;\\n\\n    }\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal override virtual {\\n        require(msg.sender == address(vault), \\\"Not Vault\\\"); // only the vault can deposit\\n        VaultAccount memory _totalAsset = totalAsset;\\n\\n        _totalAsset.amount += assets.safeCastTo128();\\n        _totalAsset.shares += shares.safeCastTo128();\\n\\n        totalAsset = _totalAsset;\\n    }\\n\\n    function getUserSnapshot(address _address)\\n        external\\n        view\\n        returns (\\n            uint256 _userAssetShares,\\n            uint256 _userAssetAmount,\\n            uint256 _userBorrowShares,\\n            uint256 _userBorrowAmount,\\n            int256 _userAccountLiquidity\\n        )\\n    {\\n        _userAssetShares = balanceOf[_address];\\n        _userAssetAmount = totalAsset.toAmount(_userAssetShares, false);\\n        _userBorrowShares = userBorrowShares[_address];\\n        _userBorrowAmount = totalBorrow.toAmount(_userBorrowShares, false);\\n        (, _userAccountLiquidity) = _isLiquidatable(_address);\\n    }\\n\\n    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\\n        return totalBorrow.toShares(_amount, _roundUp);\\n    }\\n\\n    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\\n        return totalBorrow.toAmount(_shares, _roundUp);\\n    }\\n\\n    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256) {\\n        return totalAsset.toAmount(_shares, _roundUp);\\n    }\\n\\n    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256) {\\n        return totalAsset.toShares(_amount, _roundUp);\\n    }\\n\\n    function totalAssets() public view override virtual returns (uint256) {\\n        return totalAsset.amount;\\n    }\\n\\n    function convertToShares(uint256 assets) public view override virtual returns (uint256) {\\n        return totalAsset.toShares(assets, false);\\n    }\\n\\n    function convertToAssets(uint256 shares) public view override virtual returns (uint256) {\\n        return totalAsset.toAmount(shares, false);\\n    }\\n\\n\\n    function previewMint(uint256 shares) public view override virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view override virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewRedeem(uint256 shares) public view override virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n}\\n\\n/**\\nnonReentrant\\ndeposit asset\\nredeem/withdraw\\nborrow\\nadd collateral,\\nremove collateral,\\nliquidate,\\nrepay,\\nrepay behalf,\\nupdate exchange rate,\\nupdate interest rate,\\nonlyVault\\nupdate oracle,\\nupdate rateCalculator\\n\\nminting, redeeming, depositing\\n\\n add collateral in batches\\n batch liquidation\\n update exchange rate + accue interest when *necessary\\n\\n virtual function, is approved borrower.\\n\\n instrument functions to override: \\n function estimatedTotalAssets() public view virtual returns (uint256){}\\n prepareWithdraw\\n liquidatePosition => protocol liquidation for all outstanding debt.\\n */\",\"keccak256\":\"0x53dbce145f39066ecaf532d1381ef022e9b478b80679ba5a560f134b5c957304\"},\"contracts/protocol/controller.sol\":{\"content\":\"pragma solidity ^0.8.16;\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\n// import {ReputationNFT} from \\\"./reputationtoken.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {Instrument} from \\\"../vaults/instrument.sol\\\";\\nimport {Strings} from \\\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {VaultFactory} from \\\"./factories.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n// import \\\"@interep/contracts/IInterep.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\n// import \\\"@interep/contracts/IInterep.sol\\\";\\nimport {SyntheticZCBPoolFactory, SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ReputationManager} from \\\"./reputationmanager.sol\\\";\\nimport {PoolInstrument} from \\\"../instruments/poolInstrument.sol\\\";\\n\\ncontract Controller {\\n    using SafeMath for uint256;\\n    using FixedPointMathLib for uint256;\\n    using SafeTransferLib for ERC20;\\n\\n    struct MarketData {\\n        address instrument_address;\\n        address utilizer;\\n    }\\n\\n    struct ApprovalData {\\n        uint256 managers_stake;\\n        uint256 approved_principal;\\n        uint256 approved_yield;\\n    }\\n\\n    event MarketInitiated(uint256 marketId, address recipient);\\n\\n    mapping(uint256 => ApprovalData) approvalDatas;\\n\\n    function getApprovalData(uint256 marketId)\\n        public\\n        view\\n        returns (ApprovalData memory)\\n    {\\n        approvalDatas[marketId];\\n    }\\n\\n    mapping(address => bool) public verified;\\n    mapping(uint256 => MarketData) public market_data; // id => recipient\\n    mapping(address => uint256) public ad_to_id; //utilizer address to marketId\\n    mapping(uint256 => Vault) public vaults; // vault id to Vault contract\\n    mapping(uint256 => uint256) public id_parent; //marketId-> vaultId\\n    mapping(uint256 => uint256[]) public vault_to_marketIds;\\n\\n    address creator_address;\\n\\n    // IInterep interep;\\n    // TrustedMarketFactoryV3 marketFactory;\\n    MarketManager marketManager;\\n    // ReputationNFT repNFT;\\n    VaultFactory vaultFactory;\\n    SyntheticZCBPoolFactory poolFactory;\\n    ReputationManager reputationManager;\\n\\n    uint256 constant TWITTER_UNRATED_GROUP_ID =\\n        16106950158033643226105886729341667676405340206102109927577753383156646348711;\\n    bytes32 private constant signal = bytes32(\\\"twitter-unrated\\\");\\n    uint256 constant MIN_DURATION = 1 days;\\n\\n    /* ========== MODIFIERS ========== */\\n    modifier onlyValidator(uint256 marketId) {\\n        require(\\n            isValidator(marketId, msg.sender) || msg.sender == creator_address,\\n            \\\"!Val\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyManager() {\\n        require(\\n            msg.sender == address(marketManager) ||\\n                msg.sender == creator_address,\\n            \\\"!manager\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _creator_address,\\n        address _interep_address //TODO\\n    ) {\\n        creator_address = _creator_address;\\n    }\\n\\n    /*----Setup Functions----*/\\n\\n    function setMarketManager(address _marketManager) public onlyManager {\\n        require(_marketManager != address(0));\\n        marketManager = MarketManager(_marketManager);\\n    }\\n\\n    function setReputationManager(address _reputationManager)\\n        public\\n        onlyManager\\n    {\\n        reputationManager = ReputationManager(_reputationManager);\\n    }\\n\\n    function setVaultFactory(address _vaultFactory) public onlyManager {\\n        vaultFactory = VaultFactory(_vaultFactory);\\n    }\\n\\n    function setPoolFactory(address _poolFactory) public onlyManager {\\n        poolFactory = SyntheticZCBPoolFactory(_poolFactory);\\n    }\\n\\n    // function verifyAddress(\\n    //     uint256 nullifier_hash,\\n    //     uint256 external_nullifier,\\n    //     uint256[8] calldata proof\\n    // ) external  {\\n    //     require(!verified[msg.sender], \\\"address already verified\\\");\\n    //     interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\\n    //     verified[msg.sender] = true;\\n    // }\\n\\n    function testVerifyAddress() external {\\n        verified[msg.sender] = true;\\n    }\\n\\n    /// @notice called only when redeeming, transfer funds from vault\\n    function redeem_transfer(\\n        uint256 amount,\\n        address to,\\n        uint256 marketId\\n    ) external onlyManager {\\n        vaults[id_parent[marketId]].trusted_transfer(amount, to);\\n    }\\n\\n    /// @notice creates vault\\n    /// @param underlying: underlying asset for vault\\n    /// @param _onlyVerified: only verified users can mint shares\\n    /// @param _r: minimum reputation score to mint shares\\n    /// @param _asset_limit: max number of shares for a single address\\n    /// @param _total_asset_limit: max number of shares for entire vault\\n    /// @param default_params: default params for markets created by vault\\n    function createVault(\\n        address underlying,\\n        bool _onlyVerified,\\n        uint256 _r,\\n        uint256 _asset_limit,\\n        uint256 _total_asset_limit,\\n        MarketManager.MarketParameters memory default_params\\n    ) public {\\n        (Vault newVault, uint256 vaultId) = vaultFactory.newVault(\\n            underlying,\\n            address(this),\\n            _onlyVerified,\\n            _r,\\n            _asset_limit,\\n            _total_asset_limit,\\n            default_params\\n        );\\n\\n        vaults[vaultId] = newVault;\\n    }\\n\\n    /// @notice initiates market, called by frontend loan proposal or instrument form submit button.\\n    /// @dev Instrument should already be deployed\\n    /// @param recipient: utilizer for the associated instrument\\n    /// @param instrumentData: instrument arguments\\n    /// @param vaultId: vault identifier\\n    function initiateMarket(\\n        address recipient,\\n        Vault.InstrumentData memory instrumentData,\\n        uint256 vaultId\\n    ) external {\\n        require(recipient != address(0), \\\"address0\\\");\\n        require(instrumentData.instrument_address != address(0), \\\"address0\\\");\\n        require(address(vaults[vaultId]) != address(0), \\\"address0\\\");\\n\\n        Vault vault = vaults[vaultId];\\n        uint256 marketId = marketManager.marketCount();\\n        id_parent[marketId] = vaultId;\\n        vault_to_marketIds[vaultId].push(marketId);\\n        market_data[marketId] = MarketData(\\n            instrumentData.instrument_address,\\n            recipient\\n        );\\n        marketManager.setParameters(\\n            vault.get_vault_params(),\\n            vault.utilizationRate(),\\n            marketId\\n        ); //TODO non-default\\n\\n        // Create new pool and bonds and store initial price and liquidity for the pool\\n        (address longZCB, address shortZCB, SyntheticZCBPool pool) = poolFactory\\n            .newPool(\\n                address(vaults[vaultId].UNDERLYING()),\\n                address(marketManager)\\n            );\\n\\n        if (instrumentData.isPool) {\\n            instrumentData.poolData.inceptionTime = block.timestamp;\\n\\n            instrumentData.poolData.managementFee = pool\\n                .calculateInitCurveParamsPool(\\n                    instrumentData.poolData.saleAmount,\\n                    instrumentData.poolData.initPrice,\\n                    instrumentData.poolData.inceptionPrice,\\n                    marketManager.getParameters(marketId).sigma\\n                );\\n\\n            marketManager.newMarket(\\n                marketId,\\n                pool,\\n                longZCB,\\n                shortZCB,\\n                instrumentData.description,\\n                true\\n            );\\n\\n            // set validators\\n            _validatorSetup(\\n                marketId,\\n                instrumentData.poolData.saleAmount,\\n                instrumentData.isPool\\n            );\\n        } else {\\n            pool.calculateInitCurveParams(\\n                instrumentData.principal,\\n                instrumentData.expectedYield,\\n                marketManager.getParameters(marketId).sigma\\n            );\\n\\n            marketManager.newMarket(\\n                marketId,\\n                pool,\\n                longZCB,\\n                shortZCB,\\n                instrumentData.description,\\n                false\\n            );          \\n\\n            // set validators\\n            _validatorSetup(\\n                marketId,\\n                instrumentData.principal,\\n                instrumentData.isPool\\n            );\\n        }\\n\\n        // add vault proposal\\n        instrumentData.marketId = marketId;\\n        vault.addProposal(instrumentData);\\n\\n        emit MarketInitiated(marketId, recipient);\\n        ad_to_id[recipient] = marketId; //only for testing purposes, one utilizer should be able to create multiple markets\\n    }\\n\\n    /// @notice Resolve function 1\\n    /// @dev Prepare market/instrument for closing, called separately before resolveMarket\\n    /// this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest\\n    /// or, in the event of a default, by validators who deem the principal recouperation is finished\\n    /// and need to collect remaining funds by redeeming ZCB\\n    function beforeResolve(uint256 marketId) external //onlyValidator(marketId)\\n    {\\n        (bool duringMarketAssessment, , , bool alive, , ) = marketManager\\n            .restriction_data(marketId);\\n        require(!duringMarketAssessment && alive, \\\"market conditions not met\\\");\\n        require(\\n            resolveCondition(marketId),\\n            \\\"not enough validators have voted to resolve\\\"\\n        );\\n        vaults[id_parent[marketId]].beforeResolve(marketId);\\n    }\\n\\n    // function testBeforeResolve(uint256 marketId) external {\\n    //   (bool duringMarketAssessment, , , bool alive, , ) = marketManager\\n    //         .restriction_data(marketId);\\n    //     require(!duringMarketAssessment && alive, \\\"market conditions not met\\\");\\n    //     vaults[id_parent[marketId]].beforeResolve(marketId);\\n    // }\\n\\n    function testResolveMarket(uint256 marketId) external {\\n      vaults[id_parent[marketId]].beforeResolve(marketId);\\n      (\\n            bool atLoss,\\n            uint256 extra_gain,\\n            uint256 principal_loss,\\n            bool premature\\n        ) = vaults[id_parent[marketId]].resolveInstrument(marketId);\\n\\n        updateRedemptionPrice(\\n            marketId,\\n            atLoss,\\n            extra_gain,\\n            principal_loss,\\n            premature\\n        );\\n        _updateValidatorStake(\\n            marketId,\\n            approvalDatas[marketId].approved_principal,\\n            principal_loss\\n        );\\n        cleanUpDust(marketId);\\n    }\\n\\n    /// Resolve function 2\\n    /// @notice main function called at maturity OR premature resolve of instrument(from early default)\\n    /// @dev validators call this function from market manager\\n    /// any funds left for the instrument, irrespective of whether it is in profit or inloss.\\n    function resolveMarket(uint256 marketId) external onlyValidator(marketId) {\\n        (\\n            bool atLoss,\\n            uint256 extra_gain,\\n            uint256 principal_loss,\\n            bool premature\\n        ) = vaults[id_parent[marketId]].resolveInstrument(marketId);\\n\\n        updateRedemptionPrice(\\n            marketId,\\n            atLoss,\\n            extra_gain,\\n            principal_loss,\\n            premature\\n        );\\n        _updateValidatorStake(\\n            marketId,\\n            approvalDatas[marketId].approved_principal,\\n            principal_loss\\n        );\\n        cleanUpDust(marketId);\\n    }\\n\\n    /// @dev Redemption price, as calculated (only once) at maturity,\\n    /// depends on total_repayed/(principal + predetermined yield)\\n    /// If total_repayed = 0, redemption price is 0\\n    /// @param atLoss: defines circumstances where expected returns are higher than actual\\n    /// @param loss: facevalue - returned amount => non-negative always?\\n    /// @param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\\n    function updateRedemptionPrice(\\n        uint256 marketId,\\n        bool atLoss,\\n        uint256 extra_gain,\\n        uint256 loss,\\n        bool premature\\n    ) internal {\\n        if (atLoss) assert(extra_gain == 0);\\n\\n        uint256 total_supply = marketManager.getZCB(marketId).totalSupply();\\n        uint256 total_shorts = (extra_gain > 0)\\n            ? marketManager.getShortZCB(marketId).totalSupply()\\n            : 0;\\n        uint256 redemption_price;\\n        if (!atLoss)\\n            redemption_price =\\n                config.WAD +\\n                extra_gain.divWadDown(total_supply + total_shorts);\\n        else {\\n            if (config.WAD <= loss.divWadDown(total_supply)) {\\n                redemption_price = 0;\\n            } else {\\n                redemption_price = config.WAD - loss.divWadDown(total_supply);\\n            }\\n        }\\n\\n        marketManager.deactivateMarket(\\n            marketId,\\n            atLoss,\\n            !premature,\\n            redemption_price\\n        );\\n\\n        // TODO edgecase redemption price calculations\\n    }\\n\\n    uint256 public constant riskTransferPenalty = 1e17;\\n\\n    /// @notice deduce fees for non vault stakers, should go down as maturity time approach 0\\n    function deduct_selling_fee(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        // Linearly decreasing fee\\n        uint256 normalizedTime = ((getVault(marketId)\\n            .fetchInstrumentData(marketId)\\n            .maturityDate - block.timestamp) * config.WAD) /\\n            getVault(marketId).fetchInstrumentData(marketId).duration;\\n        return normalizedTime.mulWadDown(riskTransferPenalty);\\n    }\\n\\n    /// @notice When market resolves, should collect remaining liquidity and/or dust from\\n    /// the pool and send them back to the vault\\n    /// @dev should be called before redeem_transfer is allowed\\n    function cleanUpDust(uint256 marketId) internal {\\n        marketManager.getPool(marketId).flush(\\n            getVaultAd(marketId),\\n            type(uint256).max\\n        );\\n    }\\n\\n    /// @notice when market is resolved(maturity/early default), calculates score\\n    /// and update each assessment phase trader's reputation, called by individual traders when redeeming\\n    function updateReputation(\\n        uint256 marketId,\\n        address trader,\\n        bool increment\\n    ) external onlyManager {\\n        uint256 implied_probs = marketManager.assessment_probs(\\n            marketId,\\n            trader\\n        );\\n        // int256 scoreToUpdate = increment ? int256(implied_probs.mulDivDown(implied_probs, config.WAD)) //experiment\\n        //                                  : -int256(implied_probs.mulDivDown(implied_probs, config.WAD));\\n        uint256 change = implied_probs.mulDivDown(implied_probs, config.WAD);\\n\\n        if (increment) {\\n            reputationManager.incrementScore(trader, change);\\n        } else {\\n            reputationManager.decrementScore(trader, change);\\n        }\\n    }\\n\\n    /// @notice function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast\\n    /// or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc.\\n    /// After, the resolveMarket function should be called in a new block\\n    /// @dev withdraws all balance from the instrument.\\n    /// If assets in instrument is not in underlying, need all balances to be divested to underlying\\n    /// Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\\n    /// @param emergency ascribes cases where the instrument should be forcefully liquidated back to the vault\\n    function forceCloseInstrument(uint256 marketId, bool emergency)\\n        external\\n        returns (bool)\\n    {\\n        Vault vault = vaults[id_parent[marketId]];\\n\\n        // Prepare for close\\n        vault.closeInstrument(marketId);\\n\\n        // Harvests/records all profit & losses\\n        vault.beforeResolve(marketId);\\n        return true;\\n    }\\n\\n    /// @notice returns true if amount bought is greater than the insurance threshold\\n    function marketCondition(uint256 marketId) public view returns (bool) {\\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\\n\\n        // TODO add vault balances as well \\n        if (isPool) {\\n            return (marketManager.loggedCollaterals(marketId) >=\\n                getVault(marketId)\\n                    .fetchInstrumentData(marketId)\\n                    .poolData\\n                    .saleAmount);\\n        } else {\\n            uint256 principal = getVault(marketId)\\n                .fetchInstrumentData(marketId)\\n                .principal;\\n            return (marketManager.loggedCollaterals(marketId) >=\\n                principal.mulWadDown(\\n                    marketManager.getParameters(marketId).alpha\\n                ));\\n        }\\n    }\\n\\n    /// GOD FUNCTION\\n    function testApproveMarket(uint256 marketId) public {\\n        require(marketCondition(marketId), \\\"market condition not met\\\");\\n        approveMarket(marketId);\\n        marketManager.approveMarket(marketId);\\n    }\\n\\n    /// @notice called by the validator from validatorApprove when market conditions are met\\n    /// need to move the collateral in the wCollateral to\\n    function approveMarket(uint256 marketId) internal {\\n        Vault vault = vaults[id_parent[marketId]];\\n        SyntheticZCBPool pool = marketManager.getPool(marketId);\\n\\n        require(\\n            marketManager.getCurrentMarketPhase(marketId) == 3,\\n            \\\"!marketCondition\\\"\\n        );\\n        require(\\n            vault.instrumentApprovalCondition(marketId),\\n            \\\"!instrumentCondition\\\"\\n        );\\n\\n        (, , , , , , bool isPool) = marketManager.markets(marketId);\\n        uint256 managerCollateral = marketManager.loggedCollaterals(marketId);\\n\\n        if (isPool) {\\n            poolApproval(\\n                marketId,\\n                marketManager.getZCB(marketId).totalSupply(),\\n                vault.fetchInstrumentData(marketId).poolData\\n            );\\n        } else {\\n            if (vault.getInstrumentType(marketId) == 0)\\n                creditApproval(marketId, pool);\\n            else generalApproval(marketId);\\n        }\\n\\n        approvalDatas[marketId].managers_stake = managerCollateral;\\n\\n        // TODO vault exchange rate should not change\\n        // pull from pool to vault, which will be used to fund the instrument\\n        pool.flush(address(this), managerCollateral);\\n        pool.BaseToken().approve(\\n            address(vault.Instruments(marketId)),\\n            managerCollateral\\n        );\\n        vault.Instruments(marketId).pullRawFunds(managerCollateral);\\n\\n        // Trust and deposit to the instrument contract\\n        vault.trustInstrument(marketId, approvalDatas[marketId], isPool);\\n\\n        // Since funds are transfered from pool to vault, set default liquidity in pool to 0\\n        pool.resetLiq();\\n    }\\n\\n    function poolApproval(\\n        uint256 marketId,\\n        uint256 juniorSupply,\\n        Vault.PoolData memory data\\n    ) internal {\\n        require(data.leverageFactor > 0, \\\"0 LEV_FACTOR\\\");\\n        approvalDatas[marketId] = ApprovalData(\\n            0,\\n            juniorSupply\\n                .mulWadDown(config.WAD + data.leverageFactor)\\n                .mulWadDown(data.inceptionPrice),\\n            0\\n        );\\n        console.log(\\n            \\\"principal\\\",\\n            juniorSupply\\n                .mulWadDown(config.WAD + data.leverageFactor)\\n                .mulWadDown(data.inceptionPrice)\\n        );\\n    }\\n\\n    /// @notice receives necessary market information. Only applicable for creditlines\\n    /// required for market approval such as max principal, quoted interest rate\\n    function creditApproval(uint256 marketId, SyntheticZCBPool pool) internal {\\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\\n            id_parent[marketId]\\n        ].viewPrincipalAndYield(marketId);\\n\\n        // get max_principal which is (s+1) * total long bought for creditline, or just be\\n        // proposed principal for other instruments\\n        uint256 max_principal = min(\\n            (marketManager.getParameters(marketId).s + config.WAD).mulWadDown(\\n                marketManager.loggedCollaterals(marketId)\\n            ),\\n            proposed_principal\\n        );\\n\\n        // Required notional yield amount denominated in underlying  given credit determined by managers\\n        uint256 quoted_interest = min(\\n            pool.areaBetweenCurveAndMax(max_principal),\\n            proposed_yield\\n        );\\n\\n        approvalDatas[marketId] = ApprovalData(\\n            0,\\n            max_principal,\\n            quoted_interest\\n        );\\n    }\\n\\n    function generalApproval(uint256 marketId) internal {\\n        (uint256 proposed_principal, uint256 proposed_yield) = vaults[\\n            id_parent[marketId]\\n        ].viewPrincipalAndYield(marketId);\\n        approvalDatas[marketId] = ApprovalData(\\n            0,\\n            proposed_principal,\\n            proposed_yield\\n        );\\n    }\\n\\n    /**\\n   @dev called by validator denial of market.\\n   */\\n    function denyMarket(uint256 marketId) external onlyValidator(marketId) {\\n        vaults[id_parent[marketId]].denyInstrument(marketId);\\n        cleanUpDust(marketId);\\n        marketManager.denyMarket(marketId);\\n    }\\n\\n    /*----Validator Logic----*/\\n    struct ValidatorData {\\n        mapping(address => uint256) sales; // amount of zcb bought per validator\\n        mapping(address => bool) staked; // true if address has staked vt (approved)\\n        mapping(address => bool) resolved; // true if address has voted to resolve the market\\n        address[] validators;\\n        uint256 val_cap; // total zcb validators can buy at a discount\\n        uint256 avg_price; //price the validators can buy zcb at a discount\\n        bool requested; // true if already requested random numbers from array.\\n        uint256 totalSales; // total amount of zcb bought;\\n        uint256 totalStaked; // total amount of vault token staked.\\n        uint256 numApproved;\\n        uint256 initialStake; // amount staked\\n        uint256 finalStake; // amount of stake recoverable post resolve\\n        uint256 numResolved; // number of validators calling resolve on early resolution.\\n    }\\n\\n    mapping(uint256 => uint256) requestToMarketId;\\n    mapping(uint256 => ValidatorData) public validator_data;\\n\\n    /// @notice sets the validator cap + valdiator amount\\n    /// param prinicipal is saleAmount for pool based instruments\\n    /// @dev called by controller to setup the validator scheme\\n    function _validatorSetup(\\n        uint256 marketId,\\n        uint256 principal,\\n        bool isPool\\n    ) internal {\\n        require(principal != 0, \\\"0 principal\\\");\\n        _getValidators(marketId);\\n        _setValidatorCap(marketId, principal, isPool);\\n        _setValidatorStake(marketId, principal);\\n    }\\n\\n    function getValidatorPrice(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].avg_price;\\n    }\\n\\n    function getValidatorCap(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].val_cap;\\n    }\\n\\n    function viewValidators(uint256 marketId)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        return validator_data[marketId].validators;\\n    }\\n\\n    function getNumApproved(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].numApproved;\\n    }\\n\\n    function getNumResolved(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].numResolved;\\n    }\\n\\n    function getTotalStaked(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].totalStaked;\\n    }\\n\\n    function getTotalValidatorSales(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return validator_data[marketId].totalSales;\\n    }\\n\\n    function getInitialStake(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].initialStake;\\n    }\\n\\n    function getFinalStake(uint256 marketId) public view returns (uint256) {\\n        return validator_data[marketId].finalStake;\\n    }\\n\\n    /**\\n   @notice randomly choose validators for market approval, async operation => fulfillRandomness is the callback function.\\n   @dev for now called on market initialization\\n   */\\n    function _getValidators(uint256 marketId) public {\\n        // retrieve traders that meet requirement.\\n        // address instrument = market_data[marketId].instrument_address;\\n        address utilizer = market_data[marketId].utilizer;\\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\\n        address[] memory selected = reputationManager.filterTraders(\\n            r,\\n            utilizer\\n        );\\n\\n        // if there are not enough traders, set validators to all selected traders.\\n        if (selected.length <= N) {\\n            validator_data[marketId].validators = selected;\\n\\n            if (selected.length < N) {\\n                marketManager.setN(marketId, selected.length);\\n                revert(\\\"not enough rated traders\\\");\\n            }\\n\\n            return;\\n        }\\n\\n        validator_data[marketId].requested = true;\\n\\n        uint256 _requestId = 1;\\n        // uint256 _requestId = COORDINATOR.requestRandomWords(\\n        //   keyHash,\\n        //   subscriptionId,\\n        //   requestConfirmations,\\n        //   callbackGasLimit,\\n        //   uint32(parameters[marketId].N)\\n        // );\\n\\n        requestToMarketId[_requestId] = marketId;\\n    }\\n\\n    /**\\n   @notice chainlink callback function, sets validators.\\n   @dev TODO => can be called by anyone?\\n   */\\n    function fulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords //internal\\n    ) public //override\\n    {\\n        uint256 marketId = requestToMarketId[requestId];\\n        (uint256 N, , , , , uint256 r, , ) = marketManager.parameters(marketId);\\n\\n        assert(randomWords.length == N);\\n\\n        // address instrument = market_data[marketId].instrument_address;\\n        address utilizer = market_data[marketId].utilizer;\\n\\n        address[] memory temp = reputationManager.filterTraders(r, utilizer);\\n        uint256 length = temp.length;\\n\\n        // get validators\\n        for (uint8 i = 0; i < N; i++) {\\n            uint256 j = _weightedRetrieve(temp, length, randomWords[i]);\\n            validator_data[marketId].validators.push(temp[j]);\\n            temp[j] = temp[length - 1];\\n            length--;\\n        }\\n    }\\n\\n    function _weightedRetrieve(\\n        address[] memory group,\\n        uint256 length,\\n        uint256 randomWord\\n    ) internal view returns (uint256) {\\n        uint256 sum_weights;\\n\\n        for (uint8 i = 0; i < length; i++) {\\n            sum_weights += getTraderScore(group[i]); //repToken.getReputationScore(group[i]);\\n        }\\n\\n        uint256 tmp = randomWord % sum_weights;\\n\\n        for (uint8 i = 0; i < length; i++) {\\n            uint256 wt = getTraderScore(group[i]);\\n            if (tmp < wt) {\\n                return i;\\n            }\\n            unchecked {\\n                tmp -= wt;\\n            }\\n        }\\n    }\\n\\n    /// @notice allows validators to buy at a discount + automatically stake a percentage of the principal\\n    /// They can only buy a fixed amount of ZCB, usually a at lot larger amount\\n    /// @dev get val_cap, the total amount of zcb for sale and each validators should buy\\n    /// val_cap/num validators zcb\\n    /// They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly\\n    /// correlated instruments triggers controller.approveMarket\\n    function validatorApprove(uint256 marketId) external returns (uint256) {\\n        require(isValidator(marketId, msg.sender), \\\"!Val\\\");\\n        require(marketCondition(marketId), \\\"!condition\\\");\\n\\n        ValidatorData storage valdata = validator_data[marketId];\\n        require(!valdata.staked[msg.sender], \\\"!staked\\\");\\n\\n        // staking logic, TODO optional since will throw error on transfer.\\n        // require(ERC20(getVaultAd(marketId)).balanceOf(msg.sender) >= valdata.initialStake, \\\"not enough tokens to stake\\\");\\n\\n        // staked vault tokens go to controller\\n        ERC20(getVaultAd(marketId)).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            valdata.initialStake\\n        );\\n\\n        valdata.totalStaked += valdata.initialStake;\\n        valdata.staked[msg.sender] = true;\\n\\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\\n        uint256 zcb_for_sale = valdata.val_cap / N;\\n        uint256 collateral_required = zcb_for_sale.mulWadDown(\\n            valdata.avg_price\\n        );\\n\\n        require(valdata.sales[msg.sender] <= zcb_for_sale, \\\"approved\\\");\\n\\n        valdata.sales[msg.sender] += zcb_for_sale;\\n        valdata.totalSales += (zcb_for_sale + 1); //since division rounds down ??\\n        valdata.numApproved += 1;\\n\\n        // marketManager actions on validatorApprove, transfers collateral to marketManager.\\n        marketManager.validatorApprove(\\n            marketId,\\n            collateral_required,\\n            zcb_for_sale,\\n            msg.sender\\n        );\\n\\n        // Last validator pays more gas, is fair because earlier validators are more uncertain\\n        if (approvalCondition(marketId)) {\\n            approveMarket(marketId);\\n            marketManager.approveMarket(marketId); // For market to go to a post assessment stage there always needs to be a lower bound set\\n        }\\n\\n        return collateral_required;\\n    }\\n\\n    /**\\n   @notice conditions for approval => validator zcb stake fulfilled + validators have all approved\\n   */\\n    function approvalCondition(uint256 marketId) public view returns (bool) {\\n        return (validator_data[marketId].totalSales >=\\n            validator_data[marketId].val_cap &&\\n            validator_data[marketId].validators.length ==\\n            validator_data[marketId].numApproved);\\n    }\\n\\n    /**\\n   @notice returns true if user is validator for corresponding market\\n   */\\n    function isValidator(uint256 marketId, address user)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        address[] storage _validators = validator_data[marketId].validators;\\n        for (uint256 i = 0; i < _validators.length; i++) {\\n            if (_validators[i] == user) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n   @notice condition for resolving market, met when all the validators chosen for the market\\n   have voted to resolve.\\n   */\\n    function resolveCondition(uint256 marketId) public view returns (bool) {\\n        return (validator_data[marketId].numResolved ==\\n            validator_data[marketId].validators.length);\\n    }\\n\\n    /**\\n   @notice updates the validator stake, burned in proportion to loss.\\n   principal and principal loss are in the underlying asset of the vault => must be converted to vault shares.\\n   @dev called by resolveMarket\\n   */\\n    function _updateValidatorStake(\\n        uint256 marketId,\\n        uint256 principal,\\n        uint256 principal_loss\\n    ) internal {\\n        if (principal_loss == 0) {\\n            validator_data[marketId].finalStake = validator_data[marketId]\\n                .initialStake;\\n            return;\\n        }\\n\\n        ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n        uint256 p_shares = vault.convertToShares(principal);\\n        uint256 p_loss_shares = vault.convertToShares(principal_loss);\\n\\n        uint256 totalStaked = validator_data[marketId].totalStaked;\\n        uint256 newTotal = totalStaked /\\n            2 +\\n            (p_shares - p_loss_shares).divWadDown(p_shares).mulWadDown(\\n                totalStaked / 2\\n            );\\n\\n        ERC4626(getVaultAd(marketId)).burn(totalStaked - newTotal);\\n        validator_data[marketId].totalStaked = newTotal;\\n\\n        validator_data[marketId].finalStake =\\n            newTotal /\\n            validator_data[marketId].validators.length;\\n    }\\n\\n    /**\\n   @notice called by validators to approve resolving the market, after approval.\\n   */\\n    function validatorResolve(uint256 marketId) external {\\n        require(isValidator(marketId, msg.sender), \\\"!val\\\");\\n        require(!validator_data[marketId].resolved[msg.sender], \\\"voted\\\");\\n\\n        validator_data[marketId].resolved[msg.sender] = true;\\n        validator_data[marketId].numResolved++;\\n    }\\n\\n    /**\\n   @notice called by validators when the market is resolved or denied to retrieve their stake.\\n   */\\n    function unlockValidatorStake(uint256 marketId) external {\\n        require(isValidator(marketId, msg.sender), \\\"!validator\\\");\\n        require(validator_data[marketId].staked[msg.sender], \\\"!stake\\\");\\n        (bool duringMarketAssessment, , , , , ) = marketManager\\n            .restriction_data(marketId);\\n\\n        // market early denial, no loss.\\n        ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n        if (duringMarketAssessment) {\\n            ERC20(getVaultAd(marketId)).safeTransfer(\\n                msg.sender,\\n                validator_data[marketId].initialStake\\n            );\\n            validator_data[marketId].totalStaked -= validator_data[marketId]\\n                .initialStake;\\n        } else {\\n            // market resolved.\\n            ERC20(getVaultAd(marketId)).safeTransfer(\\n                msg.sender,\\n                validator_data[marketId].finalStake\\n            );\\n            validator_data[marketId].totalStaked -= validator_data[marketId]\\n                .finalStake;\\n        }\\n\\n        validator_data[marketId].staked[msg.sender] = false;\\n    }\\n\\n    /// @notice called when market initialized, calculates the average price and quantities of zcb\\n    /// validators will buy at a discount when approving\\n    /// valcap = sigma * princpal.\\n    function _setValidatorCap(\\n        uint256 marketId,\\n        uint256 principal,\\n        bool isPool //??\\n    ) internal {\\n        SyntheticZCBPool bondingPool = marketManager.getPool(marketId);\\n        (, uint256 sigma, , , , , , ) = marketManager.parameters(marketId);\\n        require(config.isInWad(sigma) && config.isInWad(principal), \\\"paramERR\\\");\\n        ValidatorData storage valdata = validator_data[marketId];\\n\\n        uint256 valColCap = (sigma.mulWadDown(principal));\\n\\n        // Get how much ZCB validators need to buy in total, which needs to be filled for the market to be approved\\n        uint256 discount_cap = bondingPool.discount_cap();\\n        uint256 avgPrice = valColCap.divWadDown(discount_cap);\\n\\n        valdata.val_cap = discount_cap;\\n        valdata.avg_price = avgPrice;\\n    }\\n\\n    /**\\n   @notice sets the amount of vt staked by a single validator for a specific market\\n   @dev steak should be between 1-0 wad.\\n   */\\n    function _setValidatorStake(uint256 marketId, uint256 principal) internal {\\n        //get vault\\n        ERC4626 vault = ERC4626(vaults[id_parent[marketId]]);\\n        uint256 shares = vault.convertToShares(principal);\\n        (, , , , , , , uint256 steak) = marketManager.parameters(marketId);\\n        validator_data[marketId].initialStake = steak.mulWadDown(shares);\\n    }\\n\\n    function hasApproved(uint256 marketId, address validator)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return validator_data[marketId].staked[validator];\\n    }\\n\\n    /**\\n   @notice called by marketManager.redeemDeniedMarket, redeems the discounted ZCB\\n   */\\n    function deniedValidator(uint256 marketId, address validator)\\n        external\\n        onlyManager\\n        returns (uint256 collateral_amount)\\n    {\\n        //??? is this correct\\n        collateral_amount = validator_data[marketId]\\n            .sales[validator]\\n            .mulWadDown(validator_data[marketId].avg_price);\\n        delete validator_data[marketId].sales[validator];\\n    }\\n\\n    function redeemValidator(uint256 marketId, address validator)\\n        external\\n        onlyManager\\n    {\\n        delete validator_data[marketId].sales[validator];\\n    }\\n\\n    function getValidatorRequiredCollateral(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 val_cap = validator_data[marketId].val_cap;\\n        (uint256 N, , , , , , , ) = marketManager.parameters(marketId);\\n        uint256 zcb_for_sale = val_cap / N;\\n        return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price);\\n    }\\n\\n    function getTraderScore(address trader) public view returns (uint256) {\\n        return reputationManager.trader_scores(trader);\\n    }\\n\\n    function isReputable(address trader, uint256 r) public view returns (bool) {\\n      return reputationManager.isReputable(trader, r);\\n    }\\n\\n    /// @notice calculates implied probability of the trader, used to\\n    /// update the reputation score by brier scoring mechanism\\n    /// @param budget of trader in collateral decimals\\n    function calcImpliedProbability(\\n        uint256 bondAmount,\\n        uint256 collateral_amount,\\n        uint256 budget\\n    ) public pure returns (uint256) {\\n      // TODO underflows when avgprice bigger than wad\\n        uint256 avg_price = collateral_amount.divWadDown(bondAmount);\\n        uint256 b = avg_price.mulWadDown(config.WAD - avg_price);\\n        uint256 ratio = bondAmount.divWadDown(budget);\\n\\n        return ratio.mulWadDown(b) + avg_price;\\n    }\\n\\n    /// @notice pool instrument\\n    /// @notice called by utilizer during assessment\\n    function addAcceptedCollateral(\\n        uint256 _marketId,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _maxAmount,\\n        uint256 _borrowAmount,\\n        bool _isERC20\\n    ) external {\\n        require(\\n            msg.sender == address(market_data[_marketId].utilizer),\\n            \\\"only utilizer can call this function\\\"\\n        );\\n        require(marketManager.getCurrentMarketPhase(_marketId) == 1, \\\"is during assessment\\\");\\n        \\n        Vault.InstrumentData memory _data = getVault(_marketId).fetchInstrumentData(_marketId);\\n        require(_data.isPool, \\\"instrument is not pool\\\");\\n        \\n        PoolInstrument(address(getVault(_marketId).fetchInstrument(_marketId))).addAcceptedCollateral(\\n            _tokenAddress,\\n            _tokenId,\\n            _maxAmount,\\n            _borrowAmount,\\n            _isERC20\\n        );\\n\\n\\n        // Instrument instrument = fetchInstrument(_marketId);\\n        // instrument.addAcceptedCollateral(\\n        //     _tokenAddress,\\n        //     _tokenId,\\n        //     _maxAmount,\\n        //     _borrowAmount\\n        // );\\n    }\\n\\n    function pullLeverage(uint256 marketId, uint256 amount)\\n        external\\n        onlyManager\\n    {\\n        getVault(marketId).trusted_transfer(amount, address(marketManager));\\n    }\\n\\n    function getTotalSupply(uint256 marketId) external view returns (uint256) {\\n        return marketManager.getZCB(marketId).totalSupply();\\n    }\\n\\n    function getMarketId(address recipient) public view returns (uint256) {\\n        return ad_to_id[recipient];\\n    }\\n\\n    function getVault(uint256 marketId) public view returns (Vault) {\\n        return vaults[id_parent[marketId]];\\n    }\\n\\n    function getVaultAd(uint256 marketId) public view returns (address) {\\n        return address(vaults[id_parent[marketId]]);\\n    }\\n\\n    function isVerified(address addr) public view returns (bool) {\\n        return verified[addr];\\n    }\\n\\n    function getVaultfromId(uint256 vaultId) public view returns (address) {\\n        return address(vaults[vaultId]);\\n    }\\n\\n    function marketId_to_vaultId(uint256 marketId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return id_parent[marketId];\\n    }\\n\\n    function marketIdToVaultId(uint256 marketId) public view returns (uint256) {\\n        return id_parent[marketId];\\n    }\\n\\n    function getMarketIds(uint256 vaultId)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return vault_to_marketIds[vaultId];\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0xbfb744e6452ec5e9f05fbe26a42ddb99d6e453ee8c4168492e68cf6d82372e9e\"},\"contracts/protocol/factories.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\nimport {Vault} from \\\"../vaults/vault.sol\\\";\\nimport {MarketManager} from \\\"./marketmanager.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\n\\n\\n/// @notice Anyone can create a vault. These can be users who  \\n/// a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans)\\n/// b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers)\\n/// c) a vault for any long-tailed assets \\n/// d) managers who wants leverage for yield opportunities on a specific asset \\n/// e) uncollateralized lending platforms that wants to delegate the risk underwriting \\n/// etc\\n/// They need to specify \\n/// 1. Vault mint conditions-> such as verified LPs(managers) only, \\n/// 2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers)\\n/// 3. Vault underlying \\n/// @dev only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\\n\\ncontract VaultFactory{\\n\\n  address owner; \\n  mapping(address=>bool) private _isVault; \\n\\n  uint256 public numVaults; \\n  Controller controller; \\n\\n  constructor(address _controller){\\n    owner = msg.sender; \\n    controller = Controller(_controller);\\n  }\\n\\n  function isVault(address v) external view returns(bool){\\n    return _isVault[v]; \\n  }\\n\\n  modifier onlyController(){\\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"is not controller\\\"); \\n      _;\\n  }\\n\\n  /**\\n   @notice creates vault\\n   @param underlying: underlying asset for vault\\n   @param _controller: protocol controller\\n   @param _onlyVerified: only verified users can mint shares\\n   @param _r: minimum reputation score to mint shares\\n   @param _asset_limit: max number of shares for a single address\\n   @param _total_asset_limit: max number of shares for entire vault\\n   @param default_params: default params for markets created by vault\\n   */\\n  function newVault(\\n    address underlying, \\n    address _controller,\\n    bool _onlyVerified, \\n    uint256 _r, \\n    uint256 _asset_limit,\\n    uint256 _total_asset_limit,\\n    MarketManager.MarketParameters memory default_params\\n  ) external onlyController returns(Vault, uint256) {\\n    require(default_params.alpha >= 1e16, \\\"Alpha too small\\\"); \\n    \\n    Vault vault = new Vault(\\n      underlying,\\n       _controller, \\n       owner, \\n       //Params \\n       _onlyVerified,  _r, _asset_limit, _total_asset_limit,\\n       default_params \\n\\n       ); \\n    _isVault[address(vault)] = true; \\n    numVaults++; \\n\\n    return (vault, numVaults); \\n    // vaultId is numVaults after new creation of the vault.\\n\\n  }\\n}\",\"keccak256\":\"0xb2a4a70361bc856444096dbc2ff050b9749eb8518db1648bca1f6d8f8e5b6ea6\"},\"contracts/protocol/marketmanager.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\nimport \\\"./reputationtoken.sol\\\"; \\nimport {Controller} from \\\"./controller.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\nimport {VRFConsumerBaseV2} from \\\"../chainlink/VRFConsumerBaseV2.sol\\\";\\nimport {VRFCoordinatorV2Interface} from \\\"../chainlink/VRFCoordinatorV2Interface.sol\\\";\\nimport {config} from \\\"../utils/helpers.sol\\\";\\nimport {SyntheticZCBPool} from \\\"../bonds/synthetic.sol\\\"; \\nimport {ERC4626} from \\\"../vaults/mixins/ERC4626.sol\\\";\\nimport {Vault} from \\\"../vaults/vault.sol\\\"; \\n\\ncontract MarketManager \\n // VRFConsumerBaseV2 \\n {\\n  using FixedPointMathLib for uint256;\\n  using SafeTransferLib for ERC20;\\n\\n  // Chainlink state variables\\n  // VRFCoordinatorV2Interface COORDINATOR;\\n  // uint64 private immutable subscriptionId;\\n  // bytes32 private keyHash;\\n  // uint32 private callbackGasLimit = 100000;\\n  // uint16 private requestConfirmations = 3;\\n  // uint256 total_validator_bought; // should be a mapping no?\\n  bool private _mutex;\\n\\n  // ReputationNFT repToken;\\n  Controller controller;\\n  CoreMarketData[] public markets;\\n  address public owner; \\n\\n  // mapping(uint256 => uint256) requestToMarketId; // chainlink request id to marketId\\n  // mapping(uint256 => ValidatorData) validator_data;\\n  mapping(uint256=>uint256) public redemption_prices; //redemption price for each market, set when market resolves \\n  mapping(uint256=>mapping(address=>uint256)) private assessment_prices; \\n  mapping(uint256=>mapping(address=>bool)) private assessment_trader;\\n  mapping(uint256=>mapping(address=>uint256) ) public assessment_probs; \\n  mapping(uint256=> MarketPhaseData) public restriction_data; // market ID => restriction data\\n  mapping(uint256=> MarketParameters) public parameters; //marketId-> params\\n  mapping(uint256=> mapping(address=>bool)) private redeemed; \\n  mapping(uint256=> mapping(address=>uint256)) public longTrades; \\n  mapping(uint256=> mapping(address=>uint256)) public shortTrades;\\n  mapping(uint256=> uint256) public loggedCollaterals;\\n\\n  struct CoreMarketData {\\n    SyntheticZCBPool bondPool; \\n    ERC20 longZCB;\\n    ERC20 shortZCB; \\n    string description; // instrument description\\n    uint256 creationTimestamp;\\n    uint256 resolutionTimestamp;\\n    bool isPool; \\n  }\\n\\n  struct MarketPhaseData {\\n    bool duringAssessment;\\n    bool onlyReputable;\\n    bool resolved;\\n    bool alive;\\n    bool atLoss;\\n    // uint256 min_rep_score;\\n    uint256 base_budget;\\n  }\\n\\n  /// @param N: upper bound on number of validators chosen.\\n  /// @param sigma: validators' stake\\n  /// @param alpha: minimum managers' stake\\n  /// @param omega: high reputation's stake \\n  /// @param delta: Upper and lower bound for price which is added/subtracted from alpha \\n  /// @param r: reputation percentile for reputation constraint phase\\n  /// @param s: senior coefficient; how much senior capital the managers can attract at approval \\n  /// @param steak: steak*approved_principal is the staking amount.\\n  /// param beta: how much volatility managers are absorbing \\n  /// param leverage: how much leverage managers can apply \\n  /// param base_budget: higher base_budget means lower decentralization, \\n  /// @dev omega always <= alpha\\n  struct MarketParameters{\\n    uint256 N;\\n    uint256 sigma; \\n    uint256 alpha; \\n    uint256 omega;\\n    uint256 delta; \\n    uint256 r;\\n    uint256 s;\\n    uint256 steak;\\n  }\\n\\n  modifier onlyController(){\\n    require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \\\"!controller\\\"); \\n    _;\\n  }\\n\\n\\n  modifier _lock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  constructor(\\n    address _creator_address,\\n    address _controllerAddress,\\n    address _vrfCoordinator, // 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\\n    bytes32 _keyHash, // 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\\n    uint64 _subscriptionId // 1713, \\n  ) \\n    //VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) \\n  {\\n    controller = Controller(_controllerAddress);\\n    // keyHash = bytes32(0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f);\\n    // subscriptionId = 1713;\\n    // COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);\\n    \\n    // push empty market\\n    markets.push(\\n      makeEmptyMarketData()\\n    );\\n\\n    owner = msg.sender; \\n  }\\n//TODO setcontroller\\n  function makeEmptyMarketData() public pure returns (CoreMarketData memory) {\\n    return CoreMarketData(\\n        SyntheticZCBPool(address(0)),\\n        ERC20(address(0)),\\n        ERC20(address(0)),\\n        \\\"\\\",\\n        0,\\n        0, \\n        false\\n      );\\n  }    \\n\\n  function marketCount() public view returns (uint256) {\\n    return markets.length;\\n  }\\n\\n  function getMarket(uint256 _id) public view returns (CoreMarketData memory) {\\n    if (_id >= markets.length) {\\n        return makeEmptyMarketData();\\n    } else {\\n        return markets[_id];\\n    }\\n  }\\n\\n  /// @notice parameters have to be set prior \\n  function newMarket(\\n    uint256 marketId,\\n    SyntheticZCBPool bondPool,  \\n    address _longZCB, \\n    address _shortZCB, \\n    string calldata _description, \\n    // uint256 _duration, \\n    bool isPool\\n    ) external onlyController {\\n    uint256 creationTimestamp = block.timestamp;\\n\\n    markets.push(CoreMarketData(\\n      bondPool, \\n      ERC20(_longZCB),\\n      ERC20(_shortZCB),  \\n      _description,\\n      creationTimestamp,\\n      0, //TODO resolution timestamp, \\n      isPool \\n    ));\\n\\n    uint256 base_budget = 1000 * config.WAD; //TODO \\n    setMarketPhase(marketId, true, true, base_budget);\\n\\n   // _validatorSetup(marketId, principal, creationTimestamp, _duration, isPool);\\n  }\\n\\n\\n  /*----Phase Functions----*/\\n\\n  /// @notice list of parameters in this system for each market, should vary for each instrument \\n  /// @dev calculates market driven s from utilization rate. If u-r high,  then s should be low, as 1) it disincentivizes \\n  /// managers to approving as more proportion of the profit goes to the LP, and 2) disincentivizes the borrower \\n  /// to borrow as it lowers approved principal and increases interest rate \\n  function setParameters(\\n    MarketParameters memory param,\\n    uint256 utilizationRate,\\n    uint256 marketId \\n    ) public onlyController{\\n    parameters[marketId] = param; \\n    parameters[marketId].s = param.s.mulWadDown(config.WAD - utilizationRate); // experiment\\n  }\\n\\n  /**\\n   @dev in the event that the number of traders in X percentile is less than the specified number of validators\\n   parameter N is changed to reflect this\\n   */\\n  function setN(uint256 marketId, uint256 _N) public onlyController {\\n    parameters[marketId].N = _N;\\n  }\\n\\n  /// @notice sets market phase data\\n  /// @dev called on market initialization by controller\\n  /// @param base_budget: base budget (amount of vault tokens to spend) as a market manager during the assessment stage\\n  function setMarketPhase(\\n    uint256 marketId, \\n    bool duringAssessment,\\n    bool _onlyReputable,\\n    uint256 base_budget\\n    ) public onlyController{\\n    MarketPhaseData storage data = restriction_data[marketId]; \\n    data.onlyReputable = _onlyReputable; \\n    data.duringAssessment = duringAssessment;\\n    // data.min_rep_score = calcMinRepScore(marketId);\\n    data.base_budget = base_budget;\\n    data.alive = true;\\n  }\\n\\n  /// @notice used to transition from reputationphases \\n  function setReputationPhase(\\n    uint256 marketId,\\n    bool _onlyReputable\\n  ) public onlyController {\\n    restriction_data[marketId].onlyReputable = _onlyReputable;\\n  }\\n\\n  /// @notice Called when market should end, a) when denied b) when maturity \\n  /// @param resolve is true when instrument does not resolve prematurely\\n  function deactivateMarket(\\n    uint256 marketId, \\n    bool atLoss, \\n    bool resolve, \\n    uint256 rp) public onlyController{\\n    restriction_data[marketId].resolved = resolve; \\n    restriction_data[marketId].atLoss = atLoss; \\n    restriction_data[marketId].alive = false;\\n    redemption_prices[marketId] = rp; \\n\\n  } \\n\\n  /// @notice called by validator only\\n  function denyMarket(\\n    uint256 marketId\\n  ) external onlyController {\\n    //TODO should validators be able to deny even though they've approved.\\n    require(restriction_data[marketId].duringAssessment, \\\"!assessment\\\");\\n    MarketPhaseData storage data = restriction_data[marketId]; \\n    data.alive = false;\\n    data.resolved = true;\\n  }\\n\\n  /// @notice main approval function called by controller\\n  /// @dev if market is alive and market is not during assessment, it is approved. \\n  function approveMarket(uint256 marketId) onlyController external {\\n    restriction_data[marketId].duringAssessment = false;    \\n  }\\n\\n  function getPhaseData(\\n    uint256 marketId\\n  ) public view returns (MarketPhaseData memory)  {\\n    return restriction_data[marketId];\\n  }\\n\\n  \\n\\n  function isMarketApproved(uint256 marketId) public view returns(bool){\\n    return(!restriction_data[marketId].duringAssessment && restriction_data[marketId].alive);  \\n  }\\n\\n\\n\\n  /// @notice returns whether current market is in phase \\n  /// 1: onlyReputable, which also means market is in assessment\\n  /// 2: not onlyReputable but in asseessment \\n  /// 3: in assessment but canbeapproved \\n  /// 4: post assessment(accepted or denied), amortized liquidity \\n  function getCurrentMarketPhase(uint256 marketId) public view returns(uint256){\\n    if (restriction_data[marketId].onlyReputable){\\n      assert(!controller.marketCondition(marketId) && !isMarketApproved(marketId) && restriction_data[marketId].duringAssessment ); \\n      return 1; \\n    }\\n\\n    else if (restriction_data[marketId].duringAssessment && !restriction_data[marketId].onlyReputable){\\n      assert(!isMarketApproved(marketId)); \\n      if (controller.marketCondition(marketId)) return 3; \\n      return 2; \\n    }\\n\\n    else if (isMarketApproved( marketId)){\\n      assert (!restriction_data[marketId].duringAssessment && controller.marketCondition(marketId)); \\n      return 4; \\n    }\\n  }\\n\\n  /// @notice get trade budget = f(reputation), returns in collateral_dec\\n  /// sqrt for now\\n  function getTraderBudget(uint256 marketId, address trader) public view returns(uint256){\\n    //uint256 repscore = repToken.getReputationScore(trader); \\n    uint256 repscore = controller.getTraderScore(trader);\\n    \\n    if (repscore==0) return 0; \\n\\n    return restriction_data[marketId].base_budget + (repscore*config.WAD).sqrt();\\n  }\\n \\n\\n  function getParameters(uint256 marketId) public view returns(MarketParameters memory){\\n    return parameters[marketId]; \\n  }\\n\\n  function getPool(uint256 marketId) public view returns(SyntheticZCBPool){\\n    return markets[marketId].bondPool; \\n  }\\n\\n  function getZCB(uint256 marketId) public view returns (ERC20) {\\n    return markets[marketId].longZCB;\\n  }\\n\\n  function getShortZCB(uint256 marketId) public view returns (ERC20) {\\n    return markets[marketId].shortZCB;\\n  }\\n  \\n\\n  /// @notice whether new longZCB can be issued \\n  function _canIssue(\\n    address trader,\\n    int256 amount,\\n    uint256 marketId\\n    ) internal view {\\n    //TODO per market queue \\n    //if(queuedRepUpdates[trader] > queuedRepThreshold)\\n    //  revert(\\\"rep queue\\\"); \\n\\n    // if (!controller.isVerified(trader)) \\n    //   revert(\\\"!verified\\\");\\n\\n    if (getTraderBudget(marketId, trader) <= uint256(amount))\\n      revert(\\\"budget\\\");\\n\\n    if (controller.getTraderScore(trader) == 0)\\n      revert(\\\"!rep\\\"); \\n  }\\n\\n  /// @notice performs checks for buy function\\n  /// @param amount: collateral used to buy ZCB.\\n  function _canBuy(\\n    address trader,\\n    int256 amount,\\n    uint256 marketId\\n  ) internal view {\\n    //If after assessment there is a set buy threshold, people can't buy above this threshold\\n    require(restriction_data[marketId].alive, \\\"!Active\\\");\\n\\n    // TODO: check if this is correct\\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \\\"market maturity reached\\\");\\n    // TODO: check if enough liquidity \\n    bool _duringMarketAssessment = restriction_data[marketId].duringAssessment;\\n    bool _onlyReputable =  restriction_data[marketId].onlyReputable;\\n\\n    if(amount>0){\\n      if (_duringMarketAssessment){\\n        _canIssue(trader, amount, marketId); \\n      }\\n    }\\n\\n    //During the early risk assessment phase only reputable can buy \\n    if (_onlyReputable){\\n      if (!controller.isReputable(trader, parameters[marketId].r)){\\n        revert(\\\"insufficient rep\\\");\\n      }\\n    }\\n  }\\n\\n  /// @notice amount is in zcb_amount_in TODO \\n  function _canSell(\\n    address trader,\\n    uint256 amount, \\n    uint256 marketId\\n  ) internal view returns(bool) {\\n    require(restriction_data[marketId].alive, \\\"!Active\\\");\\n\\n    //TODO: check if this is correct\\n    // require(controller.getVault(marketId).fetchInstrumentData(marketId).maturityDate > block.timestamp, \\\"market maturity reached\\\");\\n\\n    if(restriction_data[marketId].duringAssessment) {\\n      // restrict attacking via disapproving the utilizer by just shorting a bunch\\n     // if(amount>= hedgeAmount) return false; \\n\\n      //else return true;\\n    }\\n    else{\\n      // restrict naked CDS amount\\n      \\n      // \\n    } \\n\\n    return true; \\n  }\\n\\n  // VALIDATOR FUNCTIONS\\n\\n  /**\\n   @notice called when the validator votes to approve the market => stakes vt + recieves discounted ZCB\\n   the staked amount goes to the controller while the discounted ZCB goes to the market manager.\\n   */\\n  function validatorApprove(\\n    uint256 marketId, \\n    uint256 collateral_required,\\n    uint256 zcb_for_sale,\\n    address validator\\n  ) external onlyController {\\n    loggedCollaterals[marketId] += collateral_required;\\n    SyntheticZCBPool bondPool = getPool(marketId); \\n    bondPool.BaseToken().transferFrom(validator, address(bondPool), collateral_required); \\n    bondPool.trustedDiscountedMint(validator, zcb_for_sale);\\n  }\\n\\n\\n\\n  /// @notice log how much collateral trader has at stake, \\n  /// to be used for redeeming, restricting trades\\n  function _logTrades(\\n    uint256 marketId,\\n    address trader, \\n    uint256 collateral,\\n    uint256 shortCollateral,  \\n    bool isBuy, \\n    bool isLong\\n    ) internal {\\n\\n    if (isLong){\\n      // TODO queuerep needs to be per market \\n      // If buying bond during assessment, trader is manager, so should update \\n      if (isBuy) {\\n        longTrades[marketId][trader] += collateral; \\n        loggedCollaterals[marketId] += collateral; \\n        queuedRepUpdates[trader] += 1; \\n        } else {\\n        longTrades[marketId][trader] -= collateral;\\n        loggedCollaterals[marketId] -= collateral; \\n        } \\n      } else{\\n      if (isBuy) {\\n        // shortCollateral is amount trader pays to buy shortZCB\\n        shortTrades[marketId][trader] += shortCollateral;\\n\\n        // collateral is the area under the curve that is subtracted due to the (short)selling\\n        loggedCollaterals[marketId] -= collateral; \\n        } else {\\n        // revert if underflow, which means trader sold short at a profit, which is not allowed during assessment \\n        shortTrades[marketId][trader] -= shortCollateral; \\n        loggedCollaterals[marketId] += collateral; \\n      } \\n    }\\n  }\\n\\n  /// @notice general limitorder claim + liquidity provision funnels used post-assessment, \\n  /// which will be recorded if necessary \\n  /// param type: 1 if open long, 2 if close long, 3 if open short, 4 if close short\\n  /// type 5: partially claim , TODO do all possible trading functions \\n  function claimFunnel(\\n    uint256 marketId, \\n    uint16 point, \\n    uint256 funnel\\n    ) external returns(uint256 claimedAmount){\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    // if (funnel == 1) claimedAmount = bondPool.makerClaimOpen(point,true, msg.sender); \\n    // else if (funnel == 2) claimedAmount = bondPool.makerClaimClose(point,true, msg.sender);\\n    // else if (funnel == 3) claimedAmount = bondPool.makerClaimOpen(point,false, msg.sender); \\n    // else if (funnel == 4) claimedAmount = bondPool.makerClaimClose(point,false, msg.sender); \\n  }\\n\\n  /// @notice called by pool when buying, transfers funds from trader to pool \\n  function tradeCallBack(uint256 amount, bytes calldata data) external{\\n    SyntheticZCBPool(msg.sender).BaseToken().transferFrom(abi.decode(data, (address)), msg.sender, amount); \\n  }\\n\\n\\n  /// @notice after assessment, let managers buy newly issued longZCB if the instrument is pool based \\n  /// funds + funds * levFactor will be directed to the instrument \\n  function issuePoolBond(\\n    uint256 _marketId, \\n    uint256 _amountIn\\n    ) external _lock_ returns(uint256 issueQTY){\\n    require(!restriction_data[_marketId].duringAssessment, \\\"Pre Approval\\\"); \\n    _canIssue(msg.sender, int256(_amountIn), _marketId);  \\n    Vault vault = controller.getVault(_marketId); \\n    ERC20 underlying = ERC20(address(markets[_marketId].bondPool.BaseToken())); \\n\\n    // Get price and sell longZCB with this price\\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(_marketId);\\n\\n    underlying.transferFrom(msg.sender, address(this), _amountIn);\\n    underlying.approve(address(vault.Instruments(_marketId)), _amountIn); \\n    vault.Instruments(_marketId).pullRawFunds(_amountIn); \\n\\n    issueQTY = _amountIn.divWadDown(pju); \\n    markets[_marketId].bondPool.trustedDiscountedMint(msg.sender, issueQTY); \\n\\n    // Need to transfer funds automatically to the instrument, seniorAmount is longZCB * levFactor * psu  \\n    vault.depositIntoInstrument(_marketId, issueQTY.mulWadDown(levFactor).mulWadDown(psu), true); \\n    console.log('how much??', issueQTY.mulWadDown(levFactor).mulWadDown(psu)); \\n    //TODO Need totalAssets and exchange rate to remain same assertion \\n    //TODO reputation logs \\n  }\\n\\n  /// @notice when a manager redeems a poollongzcb, redeemAmount*levFactor are automatically \\n  /// withdrawn from the instrument\\n  function redeemPoolLongZCB(\\n    uint256 marketId, \\n    uint256 redeemAmount\\n    ) external _lock_ returns(uint256 collateral_redeem_amount, uint256 seniorAmount){\\n    // TODO conditions \\n    Vault vault = controller.getVault(marketId); \\n    CoreMarketData memory market = markets[marketId]; \\n\\n    require(market.isPool, \\\"!pool\\\"); \\n    require(market.longZCB.balanceOf(msg.sender) > redeemAmount, \\\"insufficient bal\\\"); \\n\\n    (uint256 psu, uint256 pju, uint256 levFactor ) = vault.poolZCBValue(marketId);\\n    collateral_redeem_amount = pju.mulWadDown(redeemAmount); \\n    seniorAmount = redeemAmount.mulWadDown(levFactor).mulWadDown(psu); \\n\\n    // Need to check if redeemAmount*levFactor can be withdrawn from the pool and do so\\n    vault.withdrawFromPoolInstrument(marketId, collateral_redeem_amount, msg.sender, seniorAmount); \\n\\n    // TODO update reputation \\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }\\n    market.bondPool.trustedBurn(msg.sender, redeemAmount, true); \\n\\n    // TODO assert pju stays same \\n    // TODO assert need totalAssets and exchange rate to remain same \\n  }\\n\\n  mapping(address => uint8) public queuedRepUpdates; \\n  uint8 public constant queuedRepThreshold = 3; // at most 3 simultaneous assessment per manager\\n\\n  /// @notice main entry point for longZCB buys \\n  /// @param _amountIn is negative if specified in zcb quantity\\n  function buyBond(\\n    uint256 _marketId, \\n    int256 _amountIn, \\n    uint256 _priceLimit, \\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    _canBuy(msg.sender, _amountIn, _marketId);\\n    //TODO return readable error on why it reverts\\n    CoreMarketData memory marketData = markets[_marketId]; \\n    SyntheticZCBPool bondPool = marketData.bondPool; \\n    \\n    // During assessment, real bonds are issued from utilizer, they are the sole LP \\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender)); \\n      //Need to log assessment trades for updating reputation scores or returning collateral when market denied \\n      _logTrades(_marketId, msg.sender, amountIn, 0, true, true);\\n\\n      // Get implied probability estimates by summing up all this manager bought for this market \\n      assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\\n          getZCB(_marketId).balanceOf(msg.sender) + leveragePosition[_marketId][msg.sender].amount, \\n          longTrades[_marketId][msg.sender], \\n          getTraderBudget(_marketId, msg.sender) \\n      ); \\n\\n      // Phase Transitions when conditions met\\n      if(restriction_data[_marketId].onlyReputable){\\n        uint256 total_bought = loggedCollaterals[_marketId];\\n\\n        if (total_bought >= parameters[_marketId].omega.mulWadDown(\\n              controller\\n              .getVault(_marketId)\\n              .fetchInstrumentData(_marketId)\\n              .principal)\\n        ) {\\n          restriction_data[_marketId].onlyReputable = false;\\n        }\\n      }\\n    }\\n\\n    // Synthetic bonds are issued (liquidity provision are amortized as counterparties)\\n    else{\\n      // TODO check liquidity, revert if not \\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if(isTaker)\\n        (amountIn, amountOut) = bondPool.takerOpen(true, _amountIn, _priceLimit, abi.encode(msg.sender));\\n      else{\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), true, msg.sender); \\n      }\\n    }\\n  }\\n\\n  /// @notice longZCB sells  \\n  /// @param _amountIn quantity in longZCB \\n  function sellBond(\\n      uint256 _marketId,\\n      uint256 _amountIn, \\n      uint256 _priceLimit, \\n      bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    // if (duringMarketAssessment(_marketId)) revert(\\\"can't close during assessment\\\"); \\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    require(_canSell(msg.sender, _amountIn, _marketId),\\\"Restricted\\\");\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      (amountIn, amountOut) = bondPool.takerClose(\\n                                    true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountIn, 0, false, true );                                          \\n\\n    }\\n    else{\\n      controller.deduct_selling_fee( _marketId ); //TODO, if validator or manager, deduct reputation \\n\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if(isTaker) (amountIn, amountOut) = bondPool.takerClose(\\n              true, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      else {\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, uint256(_amountIn), true, msg.sender);        \\n      }\\n    }\\n  } \\n\\n  /// @param _amountIn: amount of short trader is willing to buy\\n  /// @param _priceLimit: slippage tolerance on trade\\n  function shortBond(\\n    uint256 _marketId,\\n    uint256 _amountIn, \\n    uint256 _priceLimit,\\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    require(_canSell(msg.sender, _amountIn, _marketId),\\\"Restricted\\\");\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      // amountOut is base collateral down the curve, amountIn is collateral used to buy shortZCB \\n      (amountOut, amountIn) = bondPool.takerOpen(false, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false);\\n\\n    }\\n    else{\\n      //deduct_selling_fee(); //if naked CDS( staked vault)\\n\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if (isTaker)\\n        (amountOut, amountIn) = bondPool.takerOpen(false, int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      \\n      else{\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerOpen(point, uint256(_amountIn), false, msg.sender);\\n      }\\n    }\\n  }\\n\\n  /// @param _amountIn is amount of short trader is willing to cover \\n  function coverBondShort(\\n    uint256 _marketId, \\n    uint256 _amountIn, \\n    uint256 _priceLimit,\\n    bytes calldata _tradeRequestData \\n    ) external _lock_ returns (uint256 amountIn, uint256 amountOut){\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    if (restriction_data[_marketId].duringAssessment){\\n\\n      // amountOut is collateral up the curve, amountIn is collateral returned from closing  \\n      (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n\\n      _logTrades(_marketId, msg.sender, amountOut, amountIn, true, false); \\n     // deduct_selling_fee(); \\n    }\\n    else{\\n      (uint16 point, bool isTaker) = abi.decode(_tradeRequestData, (uint16,bool ));\\n      if (isTaker)\\n        (amountOut, amountIn) = bondPool.takerClose(false, -int256(_amountIn), _priceLimit, abi.encode(msg.sender));\\n      \\n      else{\\n        (uint256 escrowAmount, uint128 crossId) = bondPool.makerClose(point, _amountIn, false, msg.sender);\\n      }\\n    }\\n  }\\n\\n\\n  /// @notice called by traders when market is denied before approval TODO\\n  /// ??? if the market is denied, this function is called and everything is redeemed \\n  /// validator will need to call this on denial + isLong = true to redeem their collateral.\\n  function redeemDeniedMarket(\\n    uint256 marketId, \\n    bool isLong\\n  ) external _lock_ {\\n    require(!restriction_data[marketId].alive, \\\"Market Still During Assessment\\\"); // TODO\\n    require(restriction_data[marketId].duringAssessment, \\\"Market has been approved\\\");\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    uint256 collateral_amount;\\n    uint256 balance; \\n    // Get collateral at stake in shorts, which will be directly given back to traders\\n    if(!isLong){\\n      balance = markets[marketId].shortZCB.balanceOf(msg.sender); \\n      require(balance >= 0, \\\"Empty\\\");\\n\\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n      collateral_amount = shortTrades[marketId][msg.sender]; \\n      delete shortTrades[marketId][msg.sender]; \\n\\n      //Burn all their balance\\n      bondPool.trustedBurn(msg.sender, balance, false);\\n    } \\n\\n    // Get collateral at stake in longs, which will be directly given back to traders\\n    else {\\n      balance = markets[marketId].longZCB.balanceOf(msg.sender); \\n      require(balance >= 0, \\\"Empty\\\");\\n\\n      // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n      if (controller.isValidator(marketId, msg.sender) && controller.hasApproved(marketId, msg.sender)) {\\n        collateral_amount = controller.deniedValidator(marketId, msg.sender);\\n      }\\n      else{\\n        collateral_amount = longTrades[marketId][msg.sender]; \\n        delete longTrades[marketId][msg.sender]; \\n      }\\n\\n      // Burn all their balance \\n      bondPool.trustedBurn(msg.sender, balance, true); \\n      \\n      // This means that the sender is a manager\\n      if (queuedRepUpdates[msg.sender] > 0){\\n        unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n      }    \\n    }\\n\\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\\n    controller.redeem_transfer(collateral_amount, msg.sender, marketId);\\n    //TODO need to check if last redeemer, so can kill market.\\n  }\\n\\n  /// @notice trader will redeem entire balance of ZCB\\n  /// Needs to be called at maturity, market needs to be resolved first(from controller)\\n  function redeem(\\n    uint256 marketId\\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\\n    require(!restriction_data[marketId].alive, \\\"!Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender);\\n\\n    uint256 zcb_redeem_amount = markets[marketId].longZCB.balanceOf(msg.sender); \\n    uint256 redemption_price = redemption_prices[marketId]; \\n    collateral_redeem_amount = redemption_price.mulWadDown(zcb_redeem_amount); \\n\\n    if (!controller.isValidator(marketId, msg.sender)) { // TODO should validators get reputation if they do ok.\\n      bool increment = redemption_price >= config.WAD? true: false;\\n      controller.updateReputation(marketId, msg.sender, increment);\\n    }\\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n   }\\n\\n    bondPool.trustedBurn(msg.sender, zcb_redeem_amount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n\\n  }\\n\\n  /// @notice called by short buyers when market is resolved  \\n  function redeemShortZCB(\\n    uint256 marketId \\n    ) external _lock_ returns(uint256 collateral_redeem_amount){\\n    require(!restriction_data[marketId].alive, \\\"Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    SyntheticZCBPool bondPool = markets[marketId].bondPool; \\n\\n    uint256 shortZCB_redeem_amount = markets[marketId].shortZCB.balanceOf(msg.sender); \\n    uint256 long_redemption_price = redemption_prices[marketId];\\n    uint256 redemption_price = long_redemption_price >= config.WAD \\n                               ? 0 \\n                               : config.WAD - long_redemption_price; \\n    collateral_redeem_amount = redemption_price.mulWadDown(shortZCB_redeem_amount);\\n\\n    bondPool.trustedBurn(msg.sender, shortZCB_redeem_amount, false); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  /// @notice returns the manager's maximum leverage \\n  function getMaxLeverage(address manager) public view returns(uint256){\\n    //return (repToken.getReputationScore(manager) * config.WAD).sqrt(); //TODO experiment \\n    return (controller.getTraderScore(manager) * config.WAD).sqrt();\\n  }\\n\\n  mapping(uint256=>mapping(address=> LeveredBond)) public leveragePosition; \\n  struct LeveredBond{\\n    uint128 debt; //how much collateral borrowed from vault \\n    uint128 amount; // how much bonds were bought with the given leverage\\n  }\\n\\n  /// @notice for managers that are a) meet certain reputation threshold and b) choose to be more\\n  /// capital efficient with their zcb purchase. \\n  /// @param _amountIn (in collateral) already accounts for the leverage, so the actual amount manager is transferring\\n  /// is _amountIn/_leverage \\n  /// @dev the marketmanager should take custody of the quantity bought with leverage\\n  /// and instead return notes of the levered position \\n  /// TODO do + instead of creating new positions and implied prob cumulative \\n  function buyBondLevered(\\n    uint256 _marketId, \\n    uint256 _amountIn, \\n    uint256 _priceLimit, \\n    uint256 _leverage //in 18 dec \\n    ) external _lock_ returns(uint256 amountIn, uint256 amountOut){\\n    require(restriction_data[_marketId].duringAssessment, \\\"PhaseERR\\\"); \\n    require(!restriction_data[_marketId].resolved, \\\"!resolved\\\");\\n    require(_leverage <= getMaxLeverage(msg.sender) && _leverage >= config.WAD, \\\"!leverage\\\");\\n    _canBuy(msg.sender, int256(_amountIn), _marketId);\\n    SyntheticZCBPool bondPool = markets[_marketId].bondPool; \\n\\n    // stack collateral from trader and borrowing from vault \\n    uint256 amountPulled = _amountIn.divWadDown(_leverage); \\n    bondPool.BaseToken().transferFrom(msg.sender, address(this), amountPulled); \\n    controller.pullLeverage(_marketId, _amountIn - amountPulled); \\n\\n    // Buy with leverage, zcb transferred here\\n    bondPool.BaseToken().approve(address(this), _amountIn); \\n    (amountIn, amountOut) = bondPool.takerOpen(true, int256(_amountIn), _priceLimit, abi.encode(address(this))); \\n\\n    //Need to log assessment trades for updating reputation scores or returning collateral when market denied \\n    _logTrades(_marketId, msg.sender, _amountIn, 0, true, true);\\n\\n    // Get implied probability estimates by summing up all this managers bought for this market \\n    assessment_probs[_marketId][msg.sender] = controller.calcImpliedProbability(\\n        amountOut, \\n        amountIn, \\n        getTraderBudget(_marketId, msg.sender) \\n    ); \\n\\n    // Phase Transitions when conditions met\\n    if(restriction_data[_marketId].onlyReputable){\\n      uint256 total_bought = loggedCollaterals[_marketId];\\n\\n      if (total_bought >= parameters[_marketId].omega.mulWadDown(\\n            controller\\n            .getVault(_marketId)\\n            .fetchInstrumentData(_marketId)\\n            .principal)\\n      ) {\\n        restriction_data[_marketId].onlyReputable = false;\\n      }\\n    }\\n    // create note to trader \\n    leveragePosition[_marketId][msg.sender] = LeveredBond(uint128(_amountIn - amountPulled ),uint128(amountOut)) ; \\n  }\\n\\n  function redeemLeveredBond(uint256 marketId) public{\\n    require(!restriction_data[marketId].alive, \\\"!Active\\\"); \\n    require(restriction_data[marketId].resolved, \\\"!resolved\\\"); \\n    require(!redeemed[marketId][msg.sender], \\\"Redeemed\\\");\\n    redeemed[marketId][msg.sender] = true; \\n\\n    if (controller.isValidator(marketId, msg.sender)) controller.redeemValidator(marketId, msg.sender); \\n\\n    LeveredBond memory position = leveragePosition[marketId][msg.sender]; \\n    require(position.amount>0, \\\"ERR\\\"); \\n\\n    uint256 redemption_price = redemption_prices[marketId]; \\n    uint256 collateral_back = redemption_price.mulWadDown(position.amount) ; \\n    uint256 collateral_redeem_amount = collateral_back >= uint256(position.debt)  \\n        ? collateral_back - uint256(position.debt) : 0; \\n\\n    if (!controller.isValidator(marketId, msg.sender)) {\\n      bool increment = redemption_price >= config.WAD? true: false;\\n      controller.updateReputation(marketId, msg.sender, increment);\\n    }\\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n     unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }\\n\\n    leveragePosition[marketId][msg.sender].amount = 0; \\n    markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \\n  }\\n\\n  function redeemDeniedLeveredBond(uint256 marketId) public returns(uint collateral_amount){\\n    LeveredBond memory position = leveragePosition[marketId][msg.sender]; \\n    require(position.amount>0, \\\"ERR\\\"); \\n    leveragePosition[marketId][msg.sender].amount = 0; \\n\\n    // TODO this means if trader's loss will be refunded if loss was realized before denied market\\n    if (controller.isValidator(marketId, msg.sender)) {\\n      collateral_amount = controller.deniedValidator(marketId, msg.sender);\\n    }\\n    else{\\n      collateral_amount = longTrades[marketId][msg.sender]; \\n      delete longTrades[marketId][msg.sender]; \\n    }\\n\\n    // Burn all their position, \\n    markets[marketId].bondPool.trustedBurn(address(this), position.amount, true); \\n\\n    // This means that the sender is a manager\\n    if (queuedRepUpdates[msg.sender] > 0){\\n      unchecked{queuedRepUpdates[msg.sender] -= 1;} \\n    }    \\n\\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\\n    controller.redeem_transfer(collateral_amount - uint256(position.debt), msg.sender, marketId);\\n  }\\n}\\n\\n\",\"keccak256\":\"0xa10a09a191af580e0450476805a3db8bdc214b5d652527854bbdfe0d0bdc5202\"},\"contracts/protocol/reputationmanager.sol\":{\"content\":\"pragma solidity ^0.8.16;\\nimport {config} from \\\"../utils/helpers.sol\\\"; \\nimport {FixedPointMathLib} from \\\"lib/solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\ncontract ReputationManager {\\n    using FixedPointMathLib for uint256;\\n\\n    mapping(address=>uint256) public trader_scores; // trader address => score\\n    mapping(address=>bool) public isRated;\\n    address[] public traders;\\n\\n    address controller;\\n    address marketManager;\\n\\n    address deployer;\\n\\n    modifier onlyProtocol() {\\n        require(msg.sender == controller || msg.sender == marketManager || msg.sender == deployer, \\\"ReputationManager: !protocol\\\");\\n        _;\\n    }\\n\\n    \\n\\n    constructor(\\n        address _controller,\\n        address _marketManager\\n    ) {\\n       controller = _controller;\\n       marketManager = _marketManager;\\n       deployer = msg.sender;\\n    }\\n\\n    function calculateMinScore(uint256 percentile) view external returns (uint256) {\\n        uint256 l = traders.length * config.WAD;\\n        if (percentile / 1e2 == 0) {\\n        return 0;\\n        }\\n        uint256 x = l.mulWadDown(percentile / 1e2);\\n        x /= config.WAD;\\n        return trader_scores[traders[x - 1]];\\n    }\\n\\n    // change visiblity, external only for testing.\\n    function setTraderScore(address trader, uint256 score) external {\\n        uint256 prev_score = trader_scores[trader];\\n        if (score > prev_score) {\\n        incrementScore(trader, score - prev_score);\\n        } else if (score < prev_score) {\\n        decrementScore(trader, prev_score - score);\\n        }\\n    }\\n    \\n    function isReputable(address trader, uint256 percentile) view external returns (bool) {\\n        uint256 k = findTrader(trader);\\n        uint256 n = (traders.length - (k+1))*config.WAD;\\n        uint256 N = traders.length*config.WAD;\\n        uint256 p = uint256(n).divWadDown(N)*10**2;\\n\\n        if (p >= percentile) {\\n        return true;\\n        } else {\\n        return false;\\n        }\\n    }\\n\\n    /**\\n    @dev percentile is is wad 0-100\\n    @notice returns a list of top X percentile traders excluding the utilizer. \\n    */\\n    function filterTraders(uint256 percentile, address utilizer) view public returns (address[] memory) {\\n        uint256 l = traders.length * config.WAD;\\n        \\n        // if below minimum percentile, return all traders excluding the utilizer\\n        if (percentile / 1e2 == 0) {\\n        if (isRated[utilizer]) {\\n            address[] memory result = new address[](traders.length - 1);\\n\\n            uint256 j = 0;\\n            for (uint256 i=0; i<traders.length; i++) {\\n            if (utilizer == traders[i]) {\\n                j = 1;\\n                continue;\\n            }\\n            result[i - j] = traders[i];\\n            }\\n            return result;\\n        } else {\\n            return traders;\\n        }\\n        }\\n\\n        uint256 x = l.mulWadDown((config.WAD*100 - percentile) / 1e2);\\n        x /= config.WAD;\\n\\n        address[] memory selected; \\n        if (utilizer == address(0) || !isRated[utilizer]) {\\n        selected = new address[](x);\\n        for (uint256 i=0; i<x; i++) {\\n            selected[i] = traders[i];\\n        }\\n        } else {\\n        selected = new address[](x - 1);\\n        uint256 j=0;\\n        for (uint256 i = 0; i<x; i++) {\\n            if (traders[i] == utilizer) {\\n            j = 1;\\n            continue;\\n            }\\n            selected[i - j] = traders[i];\\n        }\\n        }\\n\\n        return selected;\\n    }\\n\\n    function getTraders() view public returns (address[] memory) {\\n        return traders;\\n    }\\n\\n    /**\\n    @notice increments trader's score\\n    @dev score >= 0, update > 0\\n    */\\n    function incrementScore(address trader, uint256 update) onlyProtocol public {\\n        trader_scores[trader] += update;\\n        _updateRanking(trader, true);\\n    }\\n\\n    function testIncrementScore(uint256 update) public {\\n        trader_scores[msg.sender] += update;\\n        _updateRanking(msg.sender, true);\\n    }\\n\\n    /**\\n    @notice decrements trader's score\\n    @dev score >= 0, update > 0\\n    */\\n    function decrementScore(address trader, uint256 update) onlyProtocol public {\\n        if (update >= trader_scores[trader]) {\\n        trader_scores[trader] = 0;\\n        } else {\\n        trader_scores[trader] -= update;\\n        }\\n        _updateRanking(trader, false);\\n    }\\n\\n    /**\\n    @notice updates top trader array\\n    @dev holy moly is this ugly\\n    */\\n    function _updateRanking(address trader, bool increase) internal {\\n        uint256 score = trader_scores[trader];\\n\\n        if (!isRated[trader]) {\\n        isRated[trader] = true;\\n        if (traders.length == 0) {\\n            traders.push(trader);\\n            return;\\n        }\\n        for (uint256 i=0; i<traders.length; i++) {\\n            if (score > trader_scores[traders[i]]) {\\n            traders.push(address(0));\\n            _shiftRight(i, traders.length-1);\\n            traders[i] = trader;\\n            return;\\n            }\\n            if (i == traders.length - 1) {\\n            traders.push(trader);\\n            return;\\n            }\\n        }\\n        } else {\\n        uint256 k = findTrader(trader);\\n        //swap places with someone.\\n        if ((k == 0 && increase)\\n        || (k == traders.length - 1 && !increase)) {\\n            return;\\n        }\\n\\n        if (increase) {\\n            for (uint256 i=0; i<k; i++) {\\n            if (score > trader_scores[traders[i]]) {\\n                _shiftRight(i,k);\\n                traders[i] = trader;\\n                return;\\n            }\\n            }\\n        } else {\\n            for (uint256 i=traders.length - 1; i>k; i--) {\\n            if (score < trader_scores[traders[i]]) {\\n                _shiftLeft(k, i);\\n                traders[i] = trader;\\n                return;\\n            }\\n            }\\n        }\\n        }\\n    }\\n\\n    function findTrader(address trader) public view returns (uint256) {\\n    for (uint256 i=0; i<traders.length; i++) {\\n        if (trader == traders[i]) {\\n            return i;\\n        }\\n        }\\n    }\\n\\n    /**\\n    @notice helpers\\n    */\\n    function _shiftRight(uint256 pos, uint256 end) internal {\\n        for (uint256 i=end; i>pos; i--) {\\n        traders[i] = traders[i-1];\\n        }\\n    }\\n\\n    function _shiftLeft(uint256 pos, uint256 end) internal {\\n        for (uint256 i=pos; i<end; i++) {\\n        traders[i] = traders[i+1];\\n        }\\n    }\\n    \\n}\",\"keccak256\":\"0x85059f4a653280cde12198506118cae74b59807569ad60d56a9dba9ee3ca7f19\"},\"contracts/protocol/reputationtoken.sol\":{\"content\":\"pragma solidity ^0.8.16; \\n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\\nimport {ERC721} from \\\"lib/solmate/src/tokens/ERC721.sol\\\";\\nimport {Controller} from \\\"./controller.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\n\\ncontract ReputationNFT is ERC721 {\\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\\n  mapping(address => uint256) internal _ownerToId;\\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\\n\\n  uint256 private nonce = 1;\\n  Controller controller;\\n  uint256 SCALE = 1e18;\\n\\n\\n  struct ReputationData {\\n    uint256 n; // number of markets participated in => regular uint256\\n    uint256 score; \\n  }\\n\\n  struct TraderData { // for each market\\n    address trader;\\n    uint256 tokensBought;\\n  }\\n\\n  struct TopReputation{\\n    address trader; \\n    uint256 score; \\n  }\\n\\n  uint256 private constant topRep = 100; \\n  TopReputation[topRep] topReputations; \\n\\n  mapping(uint256=>mapping(address=>bool)) canTrade; //marketID-> address-> cantrade\\n  mapping(uint256=>bool) allowAll; \\n  mapping(address=>bool) isUnique; \\n  address[] unique_traders; \\n  mapping(uint256=>mapping(address=>uint256)) public balances; // marketId => market manager address => how much collateral already bought.\\n\\n  modifier onlyController() {\\n    require(msg.sender == address(controller));\\n    _;\\n  }\\n\\n  constructor (\\n    address _controller\\n  ) ERC721(\\\"Debita Reputation Token\\\", \\\"DRT\\\") {\\n    controller = Controller(_controller);\\n  }\\n\\n  /**\\n   @notice incrementBalance\\n   */\\n  function incrementBalance(uint256 marketId, address trader, uint256 amount) external onlyController {\\n    balances[marketId][trader] += amount;\\n  }\\n\\n  /**\\n   @notice called post reputation update\\n   */\\n  function removeBalance(uint256 marketId, address trader) external onlyController {\\n    delete balances[marketId][trader];\\n  }\\n\\n  function _baseURI() internal pure returns (string memory baseURI) {\\n    baseURI = \\\"\\\";\\n  }\\n\\n  function tokenURI(uint256 id) public view override returns (string memory) {\\n    require(_ownerOf[id] != address(0), \\\"Invalid Identifier\\\");\\n\\n    string memory baseURI = _baseURI();\\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \\\"\\\";\\n  }\\n\\n  function mint(address to) external {\\n    require(_ownerToId[to] == uint256(0), \\\"can only mint one reputation token\\\");\\n    super._mint(to, nonce);\\n    _ownerToId[to] = nonce;\\n\\n    // Set default score, if this goes to 0 cannot trade\\n    _reputation[_ownerToId[to]].score = 1e18; \\n\\n    nonce++;\\n  }\\n\\n  function getReputationScore(address owner) view external returns (uint256){\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score;\\n  }\\n\\n  function setReputationScore(address owner, uint256 score) external returns (uint256) \\n  //onlyOwner\\n  {\\n    require(_ownerToId[owner] != uint256(0), \\\"No Id found\\\");\\n    return _reputation[_ownerToId[owner]].score = score;\\n  }\\n\\n\\n  function updateScore(address to, int256 score) external onlyController{\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    if (score > 0) data.score = data.score + uint256(score);\\n    else{\\n        if (data.score <= uint256(-score)) data.score = 0; \\n        else data.score = data.score - uint256(-score);\\n      } \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n\\n  function addScore(address to, uint256 score) external onlyController\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    data.score = data.score + score; \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n  function decrementScore(address to, uint256 score) external onlyController\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    if (data.score <= score) data.score = 0; \\n    else data.score = data.score - score; \\n\\n    storeTopX(data.score, to); \\n  }\\n\\n  function addAverageScore(address to, uint256 score) external onlyController\\n\\n   {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n\\n    ReputationData storage data = _reputation[_ownerToId[to]];\\n    \\n    if (data.n == 0) {\\n      data.score = score;\\n    } else {\\n      data.score = (data.score / data.n + score) / (data.n + 1);\\n    }\\n\\n    data.n++;\\n  }\\n\\n  /**\\n   @notice reset scores\\n   */\\n  function resetScore(address to) external {\\n    require(_ownerToId[to] != uint256(0), \\\"No Id found\\\");\\n    delete _reputation[_ownerToId[to]];\\n  }\\n\\n  /// @notice called by controller when initiating market,\\n  function storeTopReputation(uint256 topX, uint256 marketId) external onlyController{\\n    if (getAvailableTopX() < topX) {\\n      allowAll[marketId] =true; \\n      return; \\n    }\\n\\n    for (uint256 i; i<topX; i++){\\n      canTrade[marketId][topReputations[i].trader] = true;\\n    }\\n\\n  }\\n\\n  /// @notice gets the x's ranked score from all reputation scores \\n  /// @dev returns 0 if topX is greater then avaiable nonzero rep scores-> everyone is allowed\\n  /// during reputation constraint periods \\n  function getMinRepScore(uint256 topX) public view returns(uint256) {\\n    if (getAvailableTopX() < topX) {\\n      return 0; \\n    }\\n    return topReputations[topX].score;\\n  }\\n\\n  function getAvailableTopX() public view returns(uint256){\\n    return unique_traders.length; \\n  }\\n\\n  function getAvailableTraderNum() public view returns(uint256){\\n    return nonce -1; \\n  }\\n\\n  /// @notice whether trader is above reputation threshold \\n  function traderCanTrade(uint256 marketId, address trader) external returns(bool){\\n    return allowAll[marketId]? true : canTrade[marketId][trader]; \\n  }\\n\\n  /// @notice called whenever a score is incremented   \\n  function storeTopX(uint256 score, address trader) internal {\\n    uint256 i = 0;\\n\\n    for(i; i < topReputations.length; i++) {\\n      if(topReputations[i].score < score) {\\n        break;\\n      }\\n    }\\n    // shifting the array of position (getting rid of the last element) \\n    for(uint j = topReputations.length - 1; j > i; j--) {\\n        topReputations[j].score = topReputations[j - 1].score;\\n        topReputations[j].trader = topReputations[j - 1].trader;\\n    }\\n    // update the new max element \\n    topReputations[i].score = score;\\n    topReputations[i].trader = trader;\\n\\n    if (isUnique[trader]) return; \\n    isUnique[trader] = true; \\n    unique_traders.push(trader);\\n\\n  }\\n\\n  function testStore() public view {\\n    for (uint i=0; i<10; i++){\\n      console.log('score', topReputations[i].score); \\n    }\\n  }  \\n}\",\"keccak256\":\"0xecaf77b1bd3c0c68f9e4181314fb094cfce1d1f9445f432a9bf68c9138e860b1\"},\"contracts/utils/helpers.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nlibrary config{\\n\\n  uint256 public constant WAD_PRECISION = 18; \\n  uint256 public constant WAD = 1e18; \\n  uint256 public constant USDC_dec = 1e6; \\n  uint256 public constant roundLimit = 1e14; //0.0001 \\n\\n  //Max amount in one transaction \\n  uint256 private constant max_amount = 1e8 * WAD; \\n\\n  //Min amount in one transaction \\n  uint256 private constant min_amount = WAD/1e4; \\n\\n  function convertToWad(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\\n    //number should not be 18 dec, but in collateral_dec\\n    new_number = number * (10 ** (WAD_PRECISION - dec));\\n    assert(new_number <= max_amount); \\n  }\\n\\n  function wadToDec(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\\n    // number should be 18 dec \\n    assert(isInWad(number)); \\n    new_number = number/(10 ** (WAD_PRECISION - dec)); \\n\\n  }\\n\\n  function isInWad(uint256 number) internal pure returns(bool){\\n    return (number >= min_amount); \\n  }\\n\\n\\n\\n\\n}\",\"keccak256\":\"0xd30e0b9fdc4387086c91449032c63c8190e50bd580306e1e2a0b0dccbf735779\"},\"contracts/vaults/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n    mapping(address=>bool) Authorized; \\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return(user == owner || Authorized[user]);\\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setNewAuthority(address newAuthority) public {\\n        require(msg.sender == owner );\\n        Authorized[newAuthority] = true; \\n\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x46c0e8d518396b50d7dc7f0050d716a5643afad9320b0cd27490fd8e00689dc7\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/instrument.sol\":{\"content\":\"\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.16;\\n\\nimport \\\"./vault.sol\\\";\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\nabstract contract Instrument {\\n\\n    modifier onlyUtilizer() {\\n        require(msg.sender == Utilizer, \\\"!Utilizer\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(msg.sender == vault.owner() || isValidator[msg.sender], \\\"!authorized\\\");\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == address(vault), \\\"caller must be vault\\\");\\n        _;\\n    }\\n\\n    modifier notLocked() {\\n        require(!locked); \\n        _; \\n    }\\n\\n    constructor (\\n        address _vault,\\n        address _Utilizer\\n    ) {\\n        vault = Vault(_vault);\\n        underlying = ERC20(vault.UNDERLYING());\\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \\n        Utilizer = _Utilizer;\\n    }\\n\\n\\n    ERC20 public underlying;\\n    Vault public vault; \\n    bool locked; \\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n    uint256 private maturity_balance; \\n    uint256 rawFunds; \\n\\n    /// @notice address of user who submits the liquidity proposal \\n    address public Utilizer; \\n    address[] public validators; //set when deployed, but can't be ch\\n    mapping(address=>bool) isValidator; \\n\\n    /**\\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\\n     */\\n    function onMarketApproval(uint256 principal, uint256 yield) virtual external {}\\n\\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\\n        require(_Utilizer != address(0));\\n        Utilizer = _Utilizer;\\n    }\\n\\n    // function setValidator(address _validator) external {\\n    //     require(msg.sender == vault.owner(), \\\"Not owner\\\"); \\n    //     validators.push(_validator); \\n    //     isValidator[_validator] = true;     \\n    // }\\n    function setVault(address newVault) external onlyAuthorized {\\n        vault = Vault(newVault); \\n    }\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\\n        //TODO if this is pool redeemig to vault, need to redeem pool shares \\n        return underlying.transfer(address(vault), amount); \\n    }\\n\\n    /// @notice Returns a user's Instrument balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Instrument balance in underlying tokens.\\n    /// @dev May mutate the state of the Instrument by accruing interest.\\n    /// TODO need to incorporate the capital supplied by pool bond issuers\\n    function balanceOfUnderlying(address user) public view virtual returns (uint256){\\n        if(user == address(this)) return underlying.balanceOf(user) - rawFunds;\\n        return underlying.balanceOf(user); \\n    }\\n\\n    /// @notice raw funds should not be harvested by the vault\\n    function pullRawFunds(uint256 amount) public {\\n        underlying.transferFrom(msg.sender,address(this), amount); \\n        rawFunds += amount; \\n    }\\n\\n\\n    /**\\n     * @notice\\n     *  Provide an accurate estimate for the total amount of assets\\n     *  (principle + return) that this Instrument is currently managing,\\n     *  denominated in terms of Underlying tokens.\\n     *\\n     *  This total should be \\\"realizable\\\" e.g. the total value that could\\n     *  *actually* be obtained from this Instrument if it were to divest its\\n     *  entire position based on current on-chain conditions.\\n     * @dev\\n     *  Care must be taken in using this function, since it relies on external\\n     *  systems, which could be manipulated by the attacker to give an inflated\\n     *  (or reduced) value produced by this function, based on current on-chain\\n     *  conditions (e.g. this function is possible to influence through\\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\\n     *  mechanisms).\\n     *\\n     *  It is up to governance to use this function to correctly order this\\n     *  Instrument relative to its peers in the withdrawal queue to minimize\\n     *  losses for the Vault based on sudden withdrawals. This value should be\\n     *  higher than the total debt of the Instrument and higher than its expected\\n     *  value to be \\\"safe\\\".\\n     *  Estimated Total assets should be \\n\\n     * @return The estimated total assets in this Strategy.\\n     */\\n    function estimatedTotalAssets() public view virtual returns (uint256){}\\n\\n\\n    /// @notice Free up returns for vault to pull,  checks if the instrument is ready to be withdrawed, i.e all \\n    /// loans have been paid, all non-underlying have been liquidated, etc\\n    function readyForWithdrawal() public view virtual returns(bool){\\n        return true; \\n    }\\n\\n    /// @notice checks whether the vault can withdraw and record profit from this instrument \\n    /// for this instrument to resolve \\n    /// For creditlines, all debts should be repaid\\n    /// for strategies, all assets should be divested + converted to Underlying\\n    /// this function is important in preventing manipulations, \\n    /// @dev prepareWithdraw->vault.beforeResolve->vault.resolveInstrument in separate txs\\n    function prepareWithdraw()\\n        external \\n        onlyVault \\n        virtual\\n        returns (\\n            uint256 _profit,\\n            uint256 _loss,\\n            uint256 _debtPayment\\n        ){\\n            require(readyForWithdrawal(), \\\"not ready to withdraw\\\"); \\n\\n            // Lock additional drawdowns or usage of instrument balance \\n            lockLiquidityFlow();    \\n\\n        }\\n\\n    /**\\n     * Liquidate up to `_amountNeeded` of `underlying` of this strategy's positions,\\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\\n     * This function should return the amount of `underlying` tokens made available by the\\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\\n     * difference is due to a realized loss, or if there is some other sitution at play\\n     * (e.g. locked funds) where the amount made available is less than what is needed.\\n     *\\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\\n     */\\n    function liquidatePosition(uint256 _amountNeeded) public  virtual returns (uint256 _liquidatedAmount, uint256 _loss){}\\n\\n    /**\\n     * Liquidate everything and returns the amount that got freed.\\n     * This function is used during emergency exit instead of `prepareReturn()` to\\n     * liquidate all of the instrument's positions back to the Vault.\\n     */\\n    function liquidateAllPositions() public  virtual returns (uint256 _amountFreed){}\\n\\n    function lockLiquidityFlow() internal{\\n        locked = true; \\n    }\\n\\n    function isLocked() public view returns(bool){\\n        return locked; \\n    }\\n\\n\\n    function transfer_liq(address to, uint256 amount) internal notLocked {\\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \\n        underlying.transfer(to, amount);\\n    }\\n\\n    function transfer_liq_from(address from, address to, uint256 amount) internal notLocked {\\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \\n        underlying.transferFrom(from, to, amount);\\n    }\\n\\n    /// @notice called before resolve, to avoid calculating redemption price based on manipulations \\n    function store_internal_balance() external onlyVault{\\n\\n        maturity_balance = balanceOfUnderlying(address(this)); \\n        if (vault.decimal_mismatch()) maturity_balance = vault.decAssetsToShares(maturity_balance); \\n\\n    }\\n\\n    function getMaturityBalance() public view returns(uint256){\\n        return maturity_balance; \\n    }\\n\\n    function isLiquid(uint256 amount) public virtual view returns(bool){\\n        //TODO \\n        return balanceOfUnderlying(address(this)) >= amount; \\n    }\\n\\n    // function beforeApprove(Vault.InstrumentData memory _instrumentData) onlyVault virtual external  {}\\n\\n\\n    /// @notice Before supplying liquidity from the vault to this instrument,\\n    /// which is done automatically when instrument is trusted, \\n    /// need to check if certain conditions that are required to this specific \\n    /// instrument is met. For example, for a creditline with a collateral \\n    /// requirement need to check if this address has the specific amount of collateral\\n    /// @dev called to be checked at the approve phase from controller  \\n    function instrumentApprovalCondition() public virtual view returns(bool); \\n}\\n\\n\\n\\n \\n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\\n/// approved borrowers will interact with this contract to borrow, repay. \\n/// and vault will supply principal and harvest principal/interest \\ncontract CreditLine is Instrument {\\n    using FixedPointMathLib for uint256;\\n    address public immutable borrower; \\n\\n    //  variables initiated at creation\\n    uint256 principal;\\n    uint256 notionalInterest; \\n    uint256 faceValue; //total amount due, i.e principal+interest\\n    uint256 duration; // normalized to a year 1 means 1 year, 0.5 means 6 month \\n    uint256 interestAPR; \\n\\n    // Modify-able Global Variables during repayments, borrow\\n    uint256 totalOwed; \\n    uint256 principalOwed; \\n    uint256 interestOwed;\\n    uint256 accumulated_interest; \\n    uint256 principalRepayed;\\n    uint256 interestRepayed; \\n\\n    // Collateral Info \\n    enum CollateralType{\\n        liquidateAble, \\n        nonLiquid, \\n        ownership ,        \\n        none\\n\\n\\n    }\\n    address public collateral; \\n    address public oracle; \\n    uint256 public collateral_balance; \\n    CollateralType public collateral_type; \\n\\n    uint256 drawdown_block; \\n    bool didDrawdown; \\n\\n    uint256 gracePeriod; \\n    uint256 resolveBlock; \\n    uint256 constant DUST = 1e18; //1usd\\n\\n    enum LoanStatus{\\n        notApproved,\\n        approvedNotDrawdowned,\\n        drawdowned, \\n        partially_repayed,\\n        prepayment_fulfilled, \\n        matured, \\n        grace_period, \\n        isDefault\\n    }\\n\\n    LoanStatus public loanStatus; \\n\\n    uint256 lastRepaymentTime; \\n    uint256 gracePeriodStart; \\n    Proxy proxy; \\n\\n    /// @notice both _collateral and _oracle could be 0\\n    /// address if fully uncollateralized or does not have a price oracle \\n    /// param _notionalInterest and _principal is initialized as desired variables\\n    constructor(\\n        address vault,\\n        address _borrower, \\n        uint256 _principal,\\n        uint256 _notionalInterest, \\n        uint256 _duration,\\n        uint256 _faceValue,\\n        address _collateral, //collateral for the dao, could be their own native token or some tokenized revenue \\n        address _oracle, // oracle for price of collateral \\n        uint256 _collateral_balance, //promised collateral balance\\n        uint256 _collateral_type\\n    )  Instrument(vault, _borrower) {\\n        borrower = _borrower; \\n        principal = DUST* _principal; \\n        notionalInterest =DUST* _notionalInterest; \\n        duration = _duration;   \\n        faceValue = DUST*_faceValue;\\n\\n        collateral = _collateral; \\n        oracle = _oracle; \\n        collateral_balance = DUST*_collateral_balance; \\n        collateral_type = CollateralType(_collateral_type); \\n\\n        loanStatus = LoanStatus.notApproved; \\n\\n        proxy = new Proxy(address(this), _borrower); \\n    }\\n\\n    function getCurrentTime() internal view returns(uint256){\\n        return block.timestamp + 31536000/2; \\n    }\\n    function getProxy() public view returns(address){\\n        return address(proxy); \\n    }\\n\\n    /// @notice checks if the creditline is ready to be withdrawed, i.e all \\n    /// loans have been paid, all non-underlying have been liquidated, etc\\n    function readyForWithdrawal() public view override returns(bool){\\n        if (loanStatus == LoanStatus.matured || loanStatus == LoanStatus.isDefault\\n            || loanStatus == LoanStatus.prepayment_fulfilled) return true; \\n        return true; \\n        //return false  \\n    }\\n\\n    function getApprovedBorrowConditions() public view returns(uint256, uint256){\\n        if (vault.isTrusted(this)) return(principal, notionalInterest) ;\\n\\n        return (0,0); \\n    }\\n\\n    /// @notice if possible, and borrower defaults, liquidates given collateral to underlying\\n    /// and push back to vault. If not possible, push the collateral back to\\n    function liquidateAndPushToVault() internal  {}\\n    function auctionAndPushToVault() internal {} \\n    function isLiquidatable(address collateral) public view returns(bool){}\\n\\n    /// @notice if collateral is liquidateable and has oracle, fetch value of collateral \\n    /// and return ratio to principal \\n    function getCollateralRatio() public view returns(uint256){\\n\\n    }\\n    /// @notice After grace period auction off ownership to some other party and transfer the funds back to vault \\n    /// @dev assumes collateral has already been transferred to vault, needs to be checked by the caller \\n    function liquidateOwnership(address buyer) public virtual onlyAuthorized{\\n        // TODO implement auction \\n        proxy.changeOwnership(buyer);\\n    }\\n\\n    /// @notice transfers collateral back to vault when default \\n    function pushCollateralToVault(uint256 amount, address to) public virtual onlyAuthorized{\\n        require(loanStatus == LoanStatus.isDefault); \\n        ERC20(collateral).transfer(to, amount); \\n    }\\n\\n\\n\\n    /// @notice validators have to check these conditions at a human level too before approving \\n    function instrumentApprovalCondition() public override view returns(bool){\\n        // check if borrower has correct identity \\n\\n        // check if enough collateral has been added as agreed   \\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid){\\n            require(ERC20(collateral).balanceOf(address(this)) >= collateral_balance, \\\"Insufficient collateral\\\"); \\n        }\\n\\n        // // check if validator(s) are set \\n        // if (validators.length == 0) {revert(\\\"No validators\\\"); }\\n\\n        // Check if proxy has been given ownership\\n        if (collateral_type == CollateralType.ownership && proxy.numContracts() == 0) revert(\\\"Ownership \\\"); \\n\\n        return true; \\n    } \\n\\n    /// @notice borrower deposit promised collateral  \\n    function depositCollateral(uint256 amount) external onlyUtilizer {\\n        require(collateral!= address(0)); \\n        ERC20(collateral).transferFrom(msg.sender, address(this), amount); \\n    }\\n\\n    /// @notice can only redeem collateral when debt is fully paid \\n    function releaseAllCollateral() internal {\\n        require(loanStatus == LoanStatus.matured || loanStatus == LoanStatus.prepayment_fulfilled, \\\"Loan status err\\\"); \\n\\n        ERC20(collateral).transfer(msg.sender,collateral_balance); \\n    }\\n\\n\\n\\n    /// @notice should only be called when (portion of) principal is repayed\\n    function adjustInterestOwed() internal {\\n\\n        uint256 remainingDuration = (drawdown_block + toSeconds(duration)) - getCurrentTime();\\n\\n        interestOwed = interestAPR.mulWadDown(toYear(remainingDuration).mulWadDown(principalOwed)); \\n    }\\n\\n    /// @param quoted_yield is in notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \\n    /// where area under curve is max_principal \\n    function onMarketApproval(uint256 max_principal, uint256 quoted_yield)  external override onlyVault {\\n        principal = max_principal; \\n        notionalInterest = quoted_yield; //this accounts for duration as well\\n        interestAPR = quoted_yield.divWadDown(duration.mulWadDown(principal)); \\n\\n        loanStatus = LoanStatus.approvedNotDrawdowned;\\n    }\\n\\n    function onMaturity() external onlyUtilizer {\\n        require(loanStatus == LoanStatus.prepayment_fulfilled || loanStatus == LoanStatus.matured,\\\"Not matured\\\"); \\n        require(block.number > resolveBlock, \\\"Block equal\\\"); \\n\\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid ){\\n            releaseAllCollateral(); \\n        }\\n\\n        else proxy.changeOwnership(borrower);\\n        \\n        bool isPrepaid = loanStatus == LoanStatus.prepayment_fulfilled? true:false;\\n        // Write to storage resolve details (principal+interest repaid, is prepaid, etc) \\n        vault.pingMaturity(address(this), isPrepaid); \\n\\n    }\\n\\n    /// @notice borrower can see how much to repay now starting from last repayment time, also used to calculated\\n    /// how much interest to repay for the current principalOwed, which can be changed \\n    function interestToRepay() public view returns(uint256){\\n\\n        // Normalized to year\\n        uint256 elapsedTime = toYear(getCurrentTime() - lastRepaymentTime);\\n        // Owed interest from last timestamp till now  + any unpaid interest that has accumulated\\n        return elapsedTime.mulWadDown(interestAPR.mulWadDown(principalOwed)) + accumulated_interest ; \\n    }\\n     \\n    /// @notice Allows a borrower to borrow on their creditline.\\n    /// This creditline allows only lump sum drawdowns, all approved principal needs to be borrowed\\n    /// which would start the interest timer \\n    function drawdown() external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        require(loanStatus == LoanStatus.approvedNotDrawdowned, \\\"Already borrowed\\\"); \\n        loanStatus = LoanStatus.drawdowned; \\n\\n        drawdown_block = block.timestamp; \\n        lastRepaymentTime = block.timestamp;//-31536000/2; \\n\\n        totalOwed = principal + notionalInterest; \\n        principalOwed = principal; \\n        interestOwed = notionalInterest;\\n\\n        transfer_liq(msg.sender, principal); \\n    }\\n\\n    /// @notice allows a borrower to repay their loan\\n    /// Standard repayment structure is repaying interest for the owed principal periodically and\\n    /// whenever principal is repayed interest owed is decreased proportionally \\n    function repay( uint256 _repay_amount) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n\\n        uint256 owedInterest = interestToRepay(); \\n        uint256 repay_principal; \\n        uint256 repay_interest = _repay_amount; \\n\\n        // Push remaineder to repaying principal \\n        if (_repay_amount >= owedInterest){\\n            repay_principal += (_repay_amount - owedInterest);  \\n            repay_interest = owedInterest; \\n            accumulated_interest = 0; \\n        }\\n\\n        //else repay_amount is less than owed interest, accumulate the debt \\n        else accumulated_interest = owedInterest - repay_interest;\\n\\n        if(handleRepay(repay_principal, repay_interest)){\\n\\n            // Save resolve block, so that onMaturity can be called later\\n            resolveBlock = block.number; \\n\\n            // Prepayment //TODO cases where repayed a significant portion at the start but paid rest at maturity date\\n            if (isPaymentPremature()) loanStatus = LoanStatus.prepayment_fulfilled; \\n\\n            // Repayed at full maturity \\n            else loanStatus = LoanStatus.matured; \\n\\n        }\\n\\n        lastRepaymentTime = getCurrentTime();  \\n\\n        transfer_liq_from(msg.sender, address(this), _repay_amount);\\n\\n    }   \\n\\n    /// @notice updates balances after repayment\\n    /// need to remove min.\\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal returns(bool){\\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \\n        principalOwed -= Math.min(repay_principal, principalOwed);\\n        interestOwed -= Math.min(repay_interest, interestOwed);\\n\\n        principalRepayed += repay_principal;\\n        interestRepayed += repay_interest; \\n        if (repay_principal > 0) adjustInterestOwed(); \\n\\n        bool fullyRepayed = (principalOwed == 0 && interestOwed == 0)? true : false; \\n        return fullyRepayed; \\n    }\\n\\n    function setGracePeriod() external {}\\n\\n    /// @notice callable by anyone \\n    function beginGracePeriod() external {\\n       // require(block.timestamp >= drawdown_block + toSeconds(duration), \\\"time err\\\"); \\n        require(principalOwed > 0 && interestOwed > 0, \\\"repaid\\\"); \\n        gracePeriodStart = block.timestamp; \\n        loanStatus = LoanStatus.grace_period; \\n    }\\n\\n    function declareDefault() external onlyAuthorized {\\n       // require(gracePeriodStart + gracePeriod >= block.timestamp);\\n        require(loanStatus == LoanStatus.grace_period); \\n\\n        loanStatus = LoanStatus.isDefault; \\n    }\\n\\n    /// @notice should be called  at default by validators\\n    /// calling this function will go thorugh the necessary process\\n    /// to recoup bad debt, and will push the remaining funds to vault\\n    function onDefault() external onlyAuthorized{\\n        require(loanStatus == LoanStatus.isDefault); \\n\\n        // If collateral is liquidateable, liquidate at dex and push to vault\\n        if (isLiquidatable(collateral)) {\\n            liquidateAndPushToVault(); //TODO get pool \\n        }\\n\\n        // Else for non liquid governance tokens or ownership, should auction off \\n        else {\\n            auctionAndPushToVault(); \\n        }\\n\\n        //Testing purposes only \\n        underlying.transferFrom(msg.sender, address(this), principal/2); \\n\\n    }\\n\\n    /// @notice when principal/interest owed becomes 0, need to find out if this is prepaid\\n    function isPaymentPremature() internal returns(bool){\\n        // bool timeCondition = getCurrentTime() <= drawdown_block + toSeconds(duration); \\n        bool amountCondition = (principal+notionalInterest) > (principalRepayed + interestRepayed) + DUST; \\n\\n        // timeCondition implies amountCondition, but not the other way around \\n        return amountCondition; \\n    }\\n\\n\\n    function toYear(uint256 sec) internal pure returns(uint256){\\n        return (sec*1e18)/uint256(31536000); \\n    }\\n\\n    function toSeconds(uint256 y) internal pure returns(uint256){\\n        return uint256(31536000).mulWadDown(y); \\n    }\\n\\n    function getRemainingOwed() public view returns(uint256, uint256){\\n        return(principalOwed, interestOwed); \\n    }\\n\\n    function getCurrentLoanStatus() public view returns(uint256){}\\n\\n\\n\\n\\n\\n}\\n\\n\\ncontract Proxy{\\n    address owner; \\n    address delegator; \\n\\n    address[] public ownedContracts;\\n    mapping(address=>bytes4) public ownerTransferFunctions; \\n    mapping(address=>bool) public isValidContract; \\n\\n    /// @notice owner is first set to be the instrument contract\\n    /// and is meant to be changed back to the borrower or whoever is\\n    /// buying the ownership \\n    constructor(address _owner, address _delegator){\\n        owner = _owner; \\n        delegator = _delegator; \\n\\n    }\\n\\n    function changeOwnership(address newOwner) external {\\n        require(msg.sender == owner, \\\"Not owner\\\"); \\n        owner = newOwner; \\n    }\\n\\n    function numContracts() public view returns(uint256){\\n        return ownedContracts.length; \\n    }\\n\\n    /// @notice temporarily delegate ownership of relevant contract \\n    /// to this address, and stores the ownership transfering function\\n    /// called when initialized\\n    /// @param ownershipFunction is selector of the functions that transfers\\n    /// ownership \\n    /// @dev called by the borrower during assessment, after they had given ownership \\n    /// of the contract to this address first, \\n    /// but ownerTransferfunction/contract needs to be checked before approval by the validators\\n    /// Validators are responsible for checking if there isn't any other ownership transferring functions \\n    /// and check that the contract is legit, and think ways that the borrower can game the system. \\n    function delegateOwnership(\\n        address _contract, \\n        bytes4 ownershipFunction) external \\n    {\\n        ownedContracts.push(_contract); \\n        isValidContract[_contract] = true; \\n        ownerTransferFunctions[_contract] = ownershipFunction; \\n\\n    }\\n\\n    /// @notice transfers ownership to borrower or any other party if necessary\\n    function grantOwnership(\\n        address _contract, \\n        address newOwner,\\n        bytes calldata data, \\n        bool isSingleArgument) external{   \\n        require(msg.sender == owner);\\n        require(isValidContract[_contract]);\\n        if(newOwner != address(this)) isValidContract[_contract] = false; \\n\\n        if(isSingleArgument){\\n            (bool success, ) = _contract.call(\\n                abi.encodeWithSelector(\\n                    ownerTransferFunctions[_contract], \\n                    newOwner\\n                )\\n            );  \\n            require(success, \\\"!success\\\"); \\n        }\\n\\n        else{\\n            require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \\\"func not allowed\\\"); \\n            (bool success, ) = _contract.call(data);\\n            require(success, \\\"!success\\\"); \\n\\n        }\\n    }\\n\\n    /// @notice function that ownership delegators use to call functions \\n    /// in their contract other than the transferFunction contract \\n    function proxyFunc(address _contract, bytes calldata data) external{\\n        require(msg.sender == delegator); \\n        require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \\\"func not allowed\\\"); \\n\\n        (bool success, ) = _contract.call(data); \\n        require(success, \\\"!success\\\"); \\n\\n    }\\n\\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\\n        if (inBytes.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            outBytes4 := mload(add(inBytes, 4))\\n        }\\n    }\\n\\n    function getOwner() public view returns(address){\\n        return owner; \\n    }\\n}\\n\\n\\ncontract MockBorrowerContract{\\n\\n    address public owner; \\n    constructor(){\\n        owner = msg.sender;  \\n    }\\n\\n    function changeOwner(address newOwner) public {\\n        require(msg.sender == owner, \\\"notowner\\\"); \\n        owner = newOwner; \\n    } \\n\\n    function onlyOwnerFunction(uint256 a) public {\\n        console.log('msgsender', msg.sender, owner); \\n        require(msg.sender == owner, \\\"notowner\\\"); \\n        console.log('hello', a); \\n    }\\n\\n    function autoDelegate(address proxyad) public {\\n        Proxy(proxyad).delegateOwnership(address(this), this.changeOwner.selector); \\n    }\\n    fallback () external {\\n        console.log('hi?'); \\n    }\\n}\\n\",\"keccak256\":\"0x103d1ada1b7dd3755974d75a9c5d7cecb36da37d27b368bd80726fb7c39d0f64\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n// import {ERC20} from \\\"../../ERC20/ERC20.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    uint immutable underlying_decimals; \\n    uint8 constant default_decimals = 18; \\n    bool public decimal_mismatch; \\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, default_decimals) {\\n        asset = _asset;\\n\\n        underlying_decimals = _asset.decimals(); \\n        decimal_mismatch = (_asset.decimals() != default_decimals);\\n        if(decimal_mismatch) assert(_asset.decimals() < default_decimals);  \\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function burn(uint256 shares) public virtual {\\n        _burn(msg.sender, shares);\\n    }\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \\n                : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if(decimal_mismatch) shares = decSharesToAssets(shares); \\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \\n                : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \\n                : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \\n\\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \\n                : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function decAssetsToShares(uint256 assets) public view virtual returns(uint256) {\\n        return assets * (10 ** (default_decimals - underlying_decimals)); \\n    }\\n\\n    function decSharesToAssets(uint256 shares) public view virtual returns(uint256){\\n        return shares / (10**(default_decimals - underlying_decimals)); \\n    }\\n}\\n\",\"keccak256\":\"0xe3819a59ee062bb8a99e9ddddbdf15e3cef2e6eb3068072309d9d189243af5ff\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9faabac0803e077fb8d8950f5e2fec1984d3e6cd6ad5fc144609b5c9de83d169\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0x636e0f18c1b287c9342e14660a914b37a927d9f64d6c29e27016784979ce8d59\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/vault.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"./auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"./mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"./utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"./utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"./instrument.sol\\\";\\nimport {PoolInstrument} from \\\"../instruments/poolInstrument.sol\\\";\\nimport {Controller} from \\\"../protocol/controller.sol\\\";\\nimport {MarketManager} from \\\"../protocol/marketmanager.sol\\\"; \\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n\\ncontract Vault is ERC4626{\\n    using SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentHarvest(address indexed instrument, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal BASE_UNIT;\\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\\n    ERC20 public immutable UNDERLYING;\\n    Controller private controller;\\n    MarketManager.MarketParameters default_params; \\n\\n    ///// For Factory\\n    bool public onlyVerified; \\n    uint256 public r; //reputation ranking  \\n    uint256 public asset_limit; \\n    uint256 public total_asset_limit; \\n\\n    mapping(Instrument => InstrumentData) public instrument_data;\\n    mapping(address => uint256) public  num_proposals;\\n    mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\\n    mapping(uint256 => bool) resolveBeforeMaturity;\\n    mapping(uint256=>ResolveVar) prepareResolveBlock;\\n\\n    enum InstrumentType {\\n        CreditLine,\\n        CoveredCall,\\n        Pool, \\n        Other\\n    }\\n\\n\\n    /// @param trusted Whether the Instrument is trusted.\\n    /// @param balance The amount of underlying tokens held in the Instrument.\\n    struct InstrumentData {\\n      bytes32 name;\\n      bool isPool; \\n      // Used to determine if the Vault will operate on a Instrument.\\n      bool trusted;\\n      // Balance of the contract denominated in Underlying, \\n      // used to determine profit and loss during harvests of the Instrument.  \\n      // represents the amount of debt the Instrument has incurred from this vault   \\n      uint256 balance; // in underlying, IMPORTANT to get this number right as it modifies key states \\n      uint256 faceValue; // in underlying\\n      uint256 marketId;\\n      uint256 principal; //this is total available allowance in underlying\\n      uint256 expectedYield; // total interest paid over duration in underlying\\n      uint256 duration;\\n      string description;\\n      address instrument_address;\\n      InstrumentType instrument_type;\\n      uint256 maturityDate;\\n      PoolData poolData; \\n    }\\n\\n    /// @notice probably should have default parameters for each vault\\n    struct PoolData{\\n      uint256 saleAmount; \\n      uint256 initPrice; // init price of longZCB in the amm \\n      uint256 promisedReturn; //per unit time \\n      uint256 inceptionTime;\\n      uint256 inceptionPrice; // init price of longZCB after assessment \\n      uint256 leverageFactor; //leverageFactor * manager collateral = capital from vault to instrument\\n      uint256 managementFee; // sum of discounts for high reputation managers/validators\\n    }\\n\\n    struct ResolveVar{\\n        uint256 endBlock; \\n        bool isPrepared; \\n    }\\n    address public owner; \\n    constructor(\\n        address _UNDERLYING,\\n        address _controller, \\n        address _owner, \\n\\n        bool _onlyVerified, //\\n        uint256 _r, //reputation ranking\\n        uint256 _asset_limit, \\n        uint256 _total_asset_limit,\\n\\n        MarketManager.MarketParameters memory _default_params\\n    )\\n        ERC4626(\\n            ERC20(_UNDERLYING),\\n            string(abi.encodePacked(\\\"debita \\\", ERC20(_UNDERLYING).name(), \\\" Vault\\\")),\\n            string(abi.encodePacked(\\\"db\\\", ERC20(_UNDERLYING).symbol()))\\n        )  \\n\\n    {   \\n        owner = _owner; \\n        UNDERLYING = ERC20(_UNDERLYING);\\n        require(UNDERLYING.decimals() == 18, \\\"decimals\\\"); \\n        BASE_UNIT = 1e18; \\n        controller = Controller(_controller);\\n        set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \\n        default_params = _default_params; \\n    }\\n\\n    function getInstrumentType(uint256 marketId) public view returns(uint256){\\n        // return 0 if credit line //TODO \\n        return 0; \\n    }\\n\\n    function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\\n        return instrument_data[_instrument];\\n    }\\n    \\n    modifier onlyController(){\\n        require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \\\"is not controller\\\"); \\n        _;\\n    }\\n\\n    /// @notice called by controller at maturity \\n    function controller_burn(uint256 amount, address bc_address) external onlyController {\\n        _burn(bc_address,amount); \\n    }\\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\\n    function controller_mint(uint256 amount, address to) external onlyController {\\n        _mint(to , amount); \\n    }\\n    /// @notice amount is always in WAD, so need to convert if decimals mismatch\\n    function trusted_transfer(uint256 amount, address to) external onlyController{\\n        if (decimal_mismatch) amount = decSharesToAssets(amount); \\n        UNDERLYING.transfer(to, amount); \\n    }\\n\\n    function balanceInUnderlying(address ad) external view returns(uint256){\\n        return previewRedeem(balanceOf[ad]); \\n    }\\n\\n    /// @notice burns all balance of address \\n    function burnAll(address to) private{\\n      _burn(to, balanceOf[to]); \\n    }\\n\\n  struct localVars{\\n    uint256 promised_return; \\n    uint256 inceptionTime; \\n    uint256 inceptionPrice; \\n    uint256 leverageFactor; \\n    uint256 managementFee; \\n\\n    uint256 srpPlusOne; \\n    uint256 totalAssetsHeld; \\n    uint256 juniorSupply;\\n    uint256 seniorSupply; \\n\\n    bool belowThreshold; \\n  }\\n  /// @notice get programmatic pricing of a pool based longZCB \\n  /// returns psu: price of senior(VT's share of investment) vs underlying \\n  /// returns pju: price of junior(longZCB) vs underlying\\n  function poolZCBValue(uint256 marketId) \\n    public \\n    view\\n    returns(uint256 psu, uint256 pju, uint256 levFactor){\\n      //TODO should not tick during assessment \\n    localVars memory vars; \\n\\n    (vars.promised_return, vars.inceptionTime, vars.inceptionPrice, vars.leverageFactor, \\n      vars.managementFee) = fetchPoolTrancheData(marketId); \\n    levFactor = vars.leverageFactor; \\n\\n    require(vars.inceptionPrice > 0, \\\"0\\\"); \\n\\n    // Get senior redemption price that increments per unit time \\n    vars.srpPlusOne = vars.inceptionPrice.mulWadDown((BASE_UNIT+ vars.promised_return)\\n      .rpow(block.timestamp - vars.inceptionTime, BASE_UNIT));\\n\\n    // Get total assets held by the instrument \\n    vars.juniorSupply = controller.getTotalSupply(marketId); \\n    vars.seniorSupply = vars.juniorSupply.mulWadDown(vars.leverageFactor); \\n    vars.totalAssetsHeld = instrumentAssetOracle(marketId, vars.juniorSupply, vars.seniorSupply); \\n\\n    if (vars.seniorSupply == 0) return(vars.srpPlusOne,vars.srpPlusOne,levFactor); \\n    \\n    // Check if all seniors can redeem\\n    if (vars.totalAssetsHeld >= vars.srpPlusOne.mulWadDown(vars.seniorSupply))\\n      psu = vars.srpPlusOne; \\n    else{\\n      psu = vars.totalAssetsHeld.divWadDown(vars.seniorSupply);\\n      vars.belowThreshold = true;  \\n    }\\n\\n    // should be 0 otherwise \\n    if(!vars.belowThreshold) pju = (vars.totalAssetsHeld \\n      - vars.srpPlusOne.mulWadDown(vars.seniorSupply)).divWadDown(vars.juniorSupply); \\n\\n\\n    uint pju_ = (BASE_UNIT+ vars.leverageFactor).mulWadDown(previewMint(BASE_UNIT*8/10)) \\n      -  vars.srpPlusOne.mulWadDown(vars.leverageFactor);\\n    assert(pju_ >= pju-10 || pju_ <= pju+10); \\n    }\\n\\n    /// @notice Harvest a trusted Instrument, records profit/loss \\n    function harvest(address instrument) public {\\n      require(instrument_data[Instrument(instrument)].trusted, \\\"UNTRUSTED_Instrument\\\");\\n      InstrumentData storage data = instrument_data[Instrument(instrument)]; \\n\\n      uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \\n      uint256 balanceLastHarvest = data.balance;\\n      uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\\n      \\n      if (balanceLastHarvest == balanceThisHarvest) {\\n          return;\\n      }\\n\\n      data.balance = balanceThisHarvest;\\n\\n      uint256 delta;\\n      bool net_positive = balanceThisHarvest >= balanceLastHarvest;\\n      delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\\n      totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\\n\\n      emit InstrumentHarvest(instrument, balanceThisHarvest, delta, net_positive);\\n    }\\n\\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\\n    /// Called when market is approved. \\n    /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \\n    function depositIntoInstrument(\\n      uint256 marketId, \\n      uint256 underlyingAmount,\\n      bool isPool) public \\n  //onlyManager\\n    {\\n      Instrument instrument = fetchInstrument(marketId); \\n      require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n\\n      // if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \\n\\n      if (underlyingAmount > UNDERLYING.balanceOf(address(this))) revert(\\\"Not enough bal in vault\\\"); \\n\\n      totalInstrumentHoldings += underlyingAmount; \\n\\n      instrument_data[instrument].balance += underlyingAmount;\\n\\n      if(!isPool)\\n        require(UNDERLYING.transfer(address(instrument), underlyingAmount), \\\"DEPOSIT_FAILED\\\");\\n      else{\\n        // TODO keep track of all this \\n        UNDERLYING.approve(address(instrument), underlyingAmount); \\n        require(ERC4626(address(instrument)).deposit(underlyingAmount, address(this))>0, \\\"DEPOSIT_FAILED\\\");\\n      }\\n\\n      emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\\n    function withdrawFromInstrument(\\n      Instrument instrument, \\n      uint256 underlyingAmount, \\n      bool redeem) internal {\\n      require(instrument_data[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n      \\n      // if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \\n\\n      instrument_data[instrument].balance -= underlyingAmount;\\n      \\n      totalInstrumentHoldings -= underlyingAmount;\\n      \\n      if (redeem) require(instrument.redeemUnderlying(underlyingAmount), \\\"REDEEM_FAILED\\\");\\n\\n      emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\\n    }\\n\\n    function withdrawFromPoolInstrument(\\n      uint256 marketId, \\n      uint256 instrumentPullAmount, \\n      address pushTo, \\n      uint256 underlyingAmount\\n      ) external\\n    //onlyManager\\n    { \\n      // Send to withdrawer \\n      Instrument instrument = fetchInstrument( marketId); \\n      require(instrument.isLiquid(underlyingAmount + instrumentPullAmount), \\\"!liq\\\");\\n\\n      ERC4626(address(instrument)).withdraw(underlyingAmount + instrumentPullAmount, address(this), address(this)); \\n      // instrument.redeemUnderlying(instrumentPullAmount ); \\n      UNDERLYING.transfer(pushTo, instrumentPullAmount); \\n\\n      //TODO instrument balance should decrease to 0 and stay solvent  \\n      withdrawFromInstrument(fetchInstrument(marketId), underlyingAmount, false);\\n\\n    }\\n\\n    /// @notice Stores a Instrument as trusted when its approved\\n    function trustInstrument(\\n      uint256 marketId,\\n      Controller.ApprovalData memory data, \\n      bool isPool\\n      ) external onlyController{\\n      instrument_data[fetchInstrument(marketId)].trusted = true;\\n\\n      //Write to storage \\n      if(!isPool){\\n        InstrumentData storage instrumentData = instrument_data[Instruments[marketId]]; \\n        instrumentData.principal = data.approved_principal; \\n        instrumentData.expectedYield = data.approved_yield;\\n        instrumentData.faceValue = data.approved_principal + data.approved_yield; \\n\\n        depositIntoInstrument(marketId, data.approved_principal-data.managers_stake, false);\\n        \\n        setMaturityDate(marketId);\\n\\n        fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \\n\\n      } else{\\n        depositIntoInstrument(marketId, data.approved_principal-data.managers_stake, true);\\n      }\\n    }\\n\\n    /// @notice fetches how much asset the instrument has in underlying. \\n    function instrumentAssetOracle(uint256 marketId, uint256 juniorSupply, uint256 seniorSupply) public view returns(uint256){\\n      // Default balance oracle \\n      // return (juniorSupply + seniorSupply).mulWadDown(previewMint(BASE_UNIT*8/10)); \\n      return (juniorSupply + seniorSupply).mulWadDown(BASE_UNIT*8/10); \\n      //return instrument_data[Instruments[marketId]].balance; \\n      //TODO custom oracle \\n    }\\n\\n    /// @notice Stores a Instrument as untrusted\\n    function distrustInstrument(Instrument instrument) external onlyController {\\n      instrument_data[instrument].trusted = false; \\n    }\\n\\n    /// @notice returns true if Instrument is approved\\n    function isTrusted(Instrument instrument) public view returns(bool){\\n      return instrument_data[instrument].trusted; \\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \\n    function totalAssets() public view override returns(uint256){\\n      return totalInstrumentHoldings + totalFloat();\\n    }\\n\\n    function utilizationRate() public view returns(uint256){\\n\\n        if (totalInstrumentHoldings==0) return 0;  \\n        return totalInstrumentHoldings.divWadDown(totalAssets()); \\n\\n    }\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    function fetchInstrument(uint256 marketId) public view returns(Instrument){\\n      return Instruments[marketId]; \\n    }\\n\\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\\n      return instrument_data[Instruments[marketId]];\\n    }\\n\\n    function fetchPoolTrancheData(uint256 marketId) public view returns(uint256, uint256, uint256, uint256, uint256){\\n      InstrumentData memory data = instrument_data[Instruments[marketId]]; \\n      return (data.poolData.promisedReturn, data.poolData.inceptionTime, \\n            data.poolData.inceptionPrice, data.poolData.leverageFactor, data.poolData.managementFee); \\n    }\\n\\n    /**\\n     called on market denial + removal, maybe no chekcs?\\n     */\\n    function removeInstrument(uint256 marketId) internal {\\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\\n        require(data.marketId > 0, \\\"instrument doesn't exist\\\");\\n        delete instrument_data[Instruments[marketId]];\\n        delete Instruments[marketId];\\n        // emit event here;\\n    }\\n\\n    /// @notice add instrument proposal created by the Utilizer \\n    /// @dev Instrument instance should be created before this is called\\n    /// need to add authorization\\n    function addProposal(\\n        InstrumentData memory data\\n    ) external onlyController {\\n      if(!data.isPool){\\n        require(data.principal > 0, \\\"principal must be greater than 0\\\");\\n        require(data.duration > 0, \\\"duration must be greater than 0\\\");\\n        require(data.faceValue > 0, \\\"faceValue must be greater than 0\\\");\\n        require(data.principal >= BASE_UNIT, \\\"Needs to be in decimal format\\\"); \\n        require(data.marketId > 0, \\\"must be valid instrument\\\");\\n      }\\n        num_proposals[msg.sender] ++; \\n\\n        instrument_data[Instrument(data.instrument_address)] = data;  \\n\\n        Instruments[data.marketId] = Instrument(data.instrument_address);\\n    }\\n\\n    function setMaturityDate(uint256 marketId) internal {\\n\\n        instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\\n    }\\n\\n    /// @notice function called when instrument resolves from within\\n    function pingMaturity(address instrument, bool premature) external {\\n        require(msg.sender == instrument || isTrusted(Instrument(instrument))); \\n        uint256 marketId = instrument_data[Instrument(instrument)].marketId; \\n        beforeResolve(marketId); \\n        resolveBeforeMaturity[marketId] = premature; \\n    }\\n\\n    /// @notice RESOLVE FUNCTION #1\\n    /// Checks if instrument is ready to be resolved and locks capital.\\n    /// records blocknumber such that resolveInstrument is called after this function \\n    /// records balances+PnL of instrument\\n    /// @dev need to store internal balance that is used to calculate the redemption price \\n    function beforeResolve(uint256 marketId) public {\\n        Instrument _instrument = Instruments[marketId]; \\n\\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \\\"Not allowed\\\"); \\n        require(isTrusted( _instrument), \\\"Not trusted\\\"); \\n\\n        // Should revert if can't be resolved \\n        _instrument.prepareWithdraw();\\n\\n        // Record profit/loss used for calculation of redemption price \\n        harvest(address(_instrument));\\n\\n        _instrument.store_internal_balance(); \\n        prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \\n      }\\n\\n    /// @notice RESOLVE FUNCTION #2\\n    /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \\n    /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\\n    function resolveInstrument(\\n        uint256 marketId\\n    ) external onlyController\\n    returns(bool, uint256, uint256, bool) {\\n        Instrument _instrument = Instruments[marketId];\\n        ResolveVar memory rvar = prepareResolveBlock[marketId]; \\n        require(_instrument.isLocked(), \\\"Not Locked\\\");\\n        require(rvar.isPrepared && rvar.endBlock < block.number, \\\"can't resolve\\\"); \\n\\n        uint256 bal = UNDERLYING.balanceOf(address(this)); \\n        uint256 instrument_balance = _instrument.getMaturityBalance(); \\n\\n        InstrumentData memory data = instrument_data[_instrument];\\n\\n        bool prematureResolve = resolveBeforeMaturity[marketId]; \\n        bool atLoss; \\n        uint256 total_loss; \\n        uint256 extra_gain; \\n\\n        // If resolved at predetermined maturity date, loss is defined by\\n        // the event the instrument has paid out all its yield + principal \\n        if (!prematureResolve){\\n            atLoss = instrument_balance < data.faceValue;\\n            total_loss = atLoss ? data.faceValue - instrument_balance : 0;\\n            extra_gain = !atLoss ? instrument_balance - data.faceValue : 0;\\n        }\\n\\n        // If resolved before predetermined maturity date, loss is defined by \\n        // the event the instrument has balance less then principal \\n        else {\\n            atLoss = instrument_balance < data.principal; \\n            total_loss = atLoss? data.principal - instrument_balance :0; \\n        }\\n\\n        withdrawFromInstrument(_instrument, instrument_balance, true);\\n        removeInstrument(data.marketId);\\n\\n        return(atLoss, extra_gain, total_loss, prematureResolve); \\n    }\\n\\n    /// @notice when market resolves, send back pulled collateral from managers \\n    function repayDebt(address to, uint256 amount) external onlyController{\\n        UNDERLYING.transfer(to, amount); \\n    }\\n\\n    /**\\n     called on market denial by controller.\\n     */\\n    function denyInstrument(uint256 marketId) external onlyController {\\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\\n\\n        require(marketId > 0 && data.instrument_address != address(0), \\\"invalid instrument\\\");\\n\\n        require(!data.trusted, \\\"can't deny approved instrument\\\");\\n        \\n        removeInstrument(marketId);\\n    }\\n\\n\\n    function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\\n      return Instruments[marketId].instrumentApprovalCondition(); \\n    }\\n\\n    /// TODO \\n    function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\\n      return amount; \\n    }\\n\\n\\n    /// @notice types of restrictions are: \\n    /// a) verified address b) reputation scores \\n    function receiver_conditions(address receiver) public view returns(bool){\\n        return true; \\n    }\\n\\n    /// @notice called when constructed, params set by the creater of the vault \\n    function set_minting_conditions(\\n      bool _onlyVerified, \\n      uint256 _r, \\n      uint256 _asset_limit,\\n      uint256 _total_asset_limit) internal{\\n        onlyVerified = _onlyVerified; \\n        r = _r; \\n        asset_limit = _asset_limit; \\n        total_asset_limit = _total_asset_limit; \\n    } \\n\\n\\n    function get_vault_params() public view returns(MarketManager.MarketParameters memory){\\n      return default_params; \\n    }\\n\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\\n      require(enoughLiqudity(assets), \\\"Not enough liqudity in vault\\\"); \\n\\n    }\\n\\n    /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\\n    /// (excluding those supplied to existing instruments)\\n    /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\\n    /// should be (soft)maxed and tunable by a parameter \\n    function enoughLiqudity(uint256 amounts) public view returns(bool){\\n        return (UNDERLYING.balanceOf(address(this)) >= amounts); \\n    }\\n\\n\\n    /// @notice function that closes instrument prematurely \\n    function closeInstrument(uint256 marketId) external onlyController{\\n      Instrument instrument = fetchInstrument( marketId); \\n\\n      // If instrument has non-underlying tokens, liquidate them first. \\n      instrument.liquidateAllPositions(); \\n\\n    }\\n\\n    function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\\n        InstrumentData memory data = instrument_data[Instruments[marketId]];\\n        return (data.principal, data.expectedYield); \\n    }\\n\\n    /// @notice a minting restrictor is set for different vaults \\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\\n        if (!receiver_conditions(receiver)) revert(\\\"Minting Restricted\\\"); \\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n\\n    /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \\n     function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        assets = deduct_withdrawal_fees(assets); \\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n}\",\"keccak256\":\"0x0ebccea96196248d4691516227c0afd10784099dc7ddaa947a921e4b47b13cc0\"},\"lib/forge-std/src/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\",\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xa4d1d62251f8574deb032a35fc948386a9b4de74b812d4f545a1ac120486b48a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5d9242699672087b2f423dfab23a3b8326448f58da4e38cd9e4ba6a3e7e153a2\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa80cb30fccbba7c8ff72ac82cc898576a78d4c3031e85676840048f3fe195f5d\",\"license\":\"MIT\"},\"lib/solmate/src/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0xa404f6f45bd53f24a90cc5ffe95e16b52e3f2dfd88f0d7a1edcb35f815919a7b\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/tokens/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\",\"keccak256\":\"0x04af19f16f00ba65ae168d6d10da5210dc18da6bcec6974dccf984ba388aa22d\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b62af9baf5b8e991ed7531bc87f45550ba9d61e8dbff5caf237ccaf3a3fd843\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\",\"keccak256\":\"0xb282dd78aa7375d6b200b9a5d8dd214b2e5df1004f8217a4b4c2b07f0c5bfd01\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo16(uint256 x) internal pure returns (uint16 y) {\\n        require(x < 1 << 16);\\n\\n        y = uint16(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0xb784a14411858036491124e677aecde6d500e695b7a70c74aa8f1001bda2ccab\",\"license\":\"AGPL-3.0-only\"},\"lib/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xbadf3d708cf532b12f75f78a1d423135954b63774a6d4ba15914a551d348db8a\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506040516200605f3803806200605f833981016040819052620000349162000078565b50600780546001600160a01b0319166001600160a01b0392909216919091179055620000b0565b80516001600160a01b03811681146200007357600080fd5b919050565b600080604083850312156200008c57600080fd5b62000097836200005b565b9150620000a7602084016200005b565b90509250929050565b615f9f80620000c06000396000f3fe608060405234801561001057600080fd5b50600436106103af5760003560e01c80638c64ea4a116101f4578063b9209e331161011a578063d82aff11116100ad578063e8e3fbb71161007c578063e8e3fbb714610a53578063ebd4dc4614610a66578063f0fd1d3814610a89578063f25fcc9f14610a9c57600080fd5b8063d82aff1114610a07578063da0a697f14610a1a578063dda10bca14610a2d578063e8a7802614610a4057600080fd5b8063ce93ec67116100e9578063ce93ec671461046a578063d1227136146109be578063d466461c146109d1578063d65ec964146109f457600080fd5b8063b9209e33146108d5578063c3f956fa14610901578063c4abc650146107e8578063c8fa33e71461091457600080fd5b80639403b63411610192578063ad4e4e7011610161578063ad4e4e701461087c578063b1b7e1f21461088f578063b37eedcd146108af578063b743939b146108c257600080fd5b80639403b634146107e85780639fe1458b146107fb578063a40c63f714610824578063ac1b6b011461084757600080fd5b80638f5709a5116101ce5780638f5709a51461077f5780638fbbc8681461079257806392ab723e146107b2578063937b6feb146107c557600080fd5b80638c64ea4a146106d75780638d4f16d7146107185780638dc3d9b41461076c57600080fd5b80633ec8dc3b116102d957806356a837f411610277578063805798ac11610246578063805798ac1461065357806381e1b07c14610676578063830e2a02146106a1578063875e487e146106b457600080fd5b806356a837f4146105fe5780636399d03d1461061157806365bc5ef9146106245780637789ec5a1461063357600080fd5b8063482c0aa8116102b3578063482c0aa8146105b2578063494ef447146105c55780634c503980146105d85780634cb44087146105eb57600080fd5b80633ec8dc3b1461056c578063457a89f61461058c578063473597a01461059f57600080fd5b80632358d5a811610351578063340e04b311610320578063340e04b31461051057806337bc93b01461052357806338ba4614146105465780633ea7fbdb1461055957600080fd5b80632358d5a81461048a57806323f2a73f146104c75780632b858734146104da5780632f8899f3146104ed57600080fd5b806308ad90a51161038d57806308ad90a5146104215780630c33df18146104345780630db065f41461044757806314f2b14c1461046a57600080fd5b806303cccb35146103b457806305a1ce99146103d857806308a8333f14610400575b600080fd5b6103d6336000908152600160208190526040909120805460ff19169091179055565b005b6103eb6103e6366004614e47565b610ac5565b60405190151581526020015b60405180910390f35b61041361040e366004614e47565b610b08565b6040519081526020016103f7565b61041361042f366004614e88565b610c4e565b6103eb610442366004614ebe565b610cbd565b6103eb610455366004614e88565b60016020526000908152604090205460ff1681565b610413610478366004614e47565b60009081526005602052604090205490565b6103eb610498366004614eee565b6000828152600d602090815260408083206001600160a01b038516845260010190915290205460ff1692915050565b6103eb6104d5366004614eee565b610d98565b6103d66104e8366004614e47565b610e12565b6104136104fb366004614e47565b6000908152600d602052604090206008015490565b6103d661051e366004614fcb565b610fe0565b610413610531366004614e47565b6000908152600d602052604090206007015490565b6103d66105543660046150b9565b611099565b6103d6610567366004614e88565b6112e4565b61057f61057a366004614e47565b611345565b6040516103f7919061515b565b6103d661059a366004614e47565b6113b4565b6103d66105ad366004614e88565b611608565b6104136105c03660046151a8565b611669565b6103d66105d33660046151ca565b61169a565b6103d66105e636600461520c565b61183b565b6103d66105f9366004614e47565b611b26565b6103d661060c366004614e88565b611c46565b6103d661061f366004614e47565b611ca7565b61041367016345785d8a000081565b610413610641366004614e88565b60036020526000908152604090205481565b610413610661366004614e47565b6000908152600d602052604090206009015490565b6103eb610684366004614e47565b6000908152600d602052604090206003810154600c909101541490565b6104136106af366004614eee565b611dad565b6104136106c2366004614e47565b6000908152600d60205260409020600a015490565b6107006106e5366004614e47565b6004602052600090815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020016103f7565b61074c610726366004614e47565b600260205260009081526040902080546001909101546001600160a01b03918216911682565b604080516001600160a01b039384168152929091166020830152016103f7565b6103d661077a366004614e47565b611e4d565b6103d661078d366004614eee565b612066565b6104136107a0366004614e47565b60056020526000908152604090205481565b6104136107c0366004614e47565b6120cb565b6104136107d3366004614e47565b6000908152600d60205260409020600b015490565b6107006107f6366004614e47565b612176565b610700610809366004614e47565b6000908152600460205260409020546001600160a01b031690565b610413610832366004614e47565b6000908152600d602052604090206005015490565b61085a610855366004614e47565b61219e565b60408051825181526020808401519082015291810151908201526060016103f7565b6103d661088a366004614e47565b6121d0565b6108a261089d366004614e47565b6122a9565b6040516103f7919061526a565b6103d66108bd366004614e47565b61230a565b6103eb6108d0366004614e47565b6123c3565b6103eb6108e3366004614e88565b6001600160a01b031660009081526001602052604090205460ff1690565b6103d661090f366004614e47565b6126b6565b610974610922366004614e47565b600d602052600090815260409020600481015460058201546006830154600784015460088501546009860154600a870154600b880154600c909801549697959660ff9095169593949293919290919089565b60408051998a5260208a0198909852951515968801969096526060870193909352608086019190915260a085015260c084015260e0830191909152610100820152610120016103f7565b6104136109cc366004614e47565b6127f8565b6104136109df366004614e47565b6000908152600d602052604090206004015490565b610413610a02366004614e47565b612b60565b6103d6610a15366004614e88565b612c1b565b6103d6610a283660046151a8565b612c8f565b610413610a3b3660046152a2565b612d0f565b6103eb610a4e3660046152ce565b612d6c565b6103d6610a613660046153ed565b612de2565b610413610a74366004614e47565b6000908152600d60205260409020600c015490565b6103d6610a9736600461552f565b61357c565b610413610aaa366004614e88565b6001600160a01b031660009081526003602052604090205490565b6000818152600d60205260408120600481015460079091015410801590610b0257506000828152600d602052604090206009810154600390910154145b92915050565b600080610b1483612176565b6001600160a01b0316639ec4d40e846040518263ffffffff1660e01b8152600401610b4191815260200190565b600060405180830381865afa158015610b5e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610b86919081019061565b565b6101000151670de0b6b3a764000042610b9e86612176565b6001600160a01b0316639ec4d40e876040518263ffffffff1660e01b8152600401610bcb91815260200190565b600060405180830381865afa158015610be8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610c10919081019061565b565b6101800151610c1f9190615797565b610c2991906157aa565b610c3391906157df565b9050610c478167016345785d8a000061360e565b9392505050565b600b546040516344c7439360e01b81526001600160a01b03838116600483015260009216906344c7439390602401602060405180830381865afa158015610c99573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0291906157f3565b60008281526005602090815260408083205483526004918290528083205490516359dc5c6f60e01b81529182018590526001600160a01b03169081906359dc5c6f90602401600060405180830381600087803b158015610d1c57600080fd5b505af1158015610d30573d6000803e3d6000fd5b5050604051630ae161cd60e21b8152600481018790526001600160a01b0384169250632b8587349150602401600060405180830381600087803b158015610d7657600080fd5b505af1158015610d8a573d6000803e3d6000fd5b506001979650505050505050565b6000828152600d60205260408120600301815b8154811015610e0757836001600160a01b0316828281548110610dd057610dd061580c565b6000918252602090912001546001600160a01b031603610df557600192505050610b02565b80610dff81615822565b915050610dab565b506000949350505050565b600854604051638a6cac3d60e01b81526004810183905260009182916001600160a01b0390911690638a6cac3d9060240160c060405180830381865afa158015610e60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e84919061583b565b505093505050915081158015610e975750805b610ee85760405162461bcd60e51b815260206004820152601960248201527f6d61726b657420636f6e646974696f6e73206e6f74206d65740000000000000060448201526064015b60405180910390fd5b6000838152600d602052604090206003810154600c9091015414610f625760405162461bcd60e51b815260206004820152602b60248201527f6e6f7420656e6f7567682076616c696461746f7273206861766520766f74656460448201526a20746f207265736f6c766560a81b6064820152608401610edf565b600083815260056020908152604080832054835260049182905291829020549151630ae161cd60e21b81529081018590526001600160a01b0390911690632b858734906024015b600060405180830381600087803b158015610fc357600080fd5b505af1158015610fd7573d6000803e3d6000fd5b50505050505050565b60095460405163da33133360e01b815260009182916001600160a01b039091169063da33133390611021908b9030908c908c908c908c908c90600401615906565b60408051808303816000875af115801561103f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110639190615955565b600090815260046020526040902080546001600160a01b0319166001600160a01b03929092169190911790555050505050505050565b6000828152600c6020526040808220546008549151632a4a9dd160e01b81526004810182905290929182916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa1580156110f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111b9190615983565b5050955050505050915081845114611135576111356159e0565b60008381526002602052604080822060010154600b549151631535c04160e11b8152600481018590526001600160a01b039182166024820181905293929190911690632a6b808290604401600060405180830381865afa15801561119d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526111c591908101906159f6565b805190915060005b858160ff1610156112d957600061120184848b8560ff16815181106111f4576111f461580c565b6020026020010151613623565b9050600d600089815260200190815260200160002060030184828151811061122b5761122b61580c565b60209081029190910181015182546001808201855560009485529290932090920180546001600160a01b0319166001600160a01b039093169290921790915584906112769085615797565b815181106112865761128661580c565b60200260200101518482815181106112a0576112a061580c565b6001600160a01b0390921660209283029190910190910152826112c281615a85565b9350505080806112d190615a9c565b9150506111cd565b505050505050505050565b6008546001600160a01b031633148061130757506007546001600160a01b031633145b6113235760405162461bcd60e51b8152600401610edf90615abb565b600980546001600160a01b0319166001600160a01b0392909216919091179055565b6000818152600d60209081526040918290206003018054835181840281018401909452808452606093928301828280156113a857602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161138a575b50505050509050919050565b600081815260026020526040808220600101546008549151632a4a9dd160e01b8152600481018590526001600160a01b03918216939283921690632a4a9dd19060240161010060405180830381865afa158015611415573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114399190615983565b5050600b54604051631535c04160e11b8152600481018390526001600160a01b038b81166024830152979950919750600096169450632a6b8082935060440191506114819050565b600060405180830381865afa15801561149e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114c691908101906159f6565b9050828151116115b8576000858152600d6020908152604090912082516114f592600390920191840190614dcd565b5082815110156115b157600854815160405163555f8d2d60e01b81526004810188905260248101919091526001600160a01b039091169063555f8d2d90604401600060405180830381600087803b15801561154f57600080fd5b505af1158015611563573d6000803e3d6000fd5b505060405162461bcd60e51b815260206004820152601860248201527f6e6f7420656e6f7567682072617465642074726164657273000000000000000060448201526064019150610edf9050565b5050505050565b5050506000828152600d602090815260408220600601805460ff19166001908117909155909152600c9052507fd421a5181c571bba3f01190c922c3b2a896fc1d84e86c9f17ac10e67ebef8b5c55565b6008546001600160a01b031633148061162b57506007546001600160a01b031633145b6116475760405162461bcd60e51b8152600401610edf90615abb565b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b6006602052816000526040600020818154811061168557600080fd5b90600052602060002001600091509150505481565b6008546001600160a01b03163314806116bd57506007546001600160a01b031633145b6116d95760405162461bcd60e51b8152600401610edf90615abb565b600854604051632841c2b760e21b8152600481018590526001600160a01b038481166024830152600092169063a1070adc90604401602060405180830381865afa15801561172b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061174f91906157f3565b905060006117668280670de0b6b3a76400006136e6565b905082156117d957600b546040516370b2466960e11b81526001600160a01b038681166004830152602482018490529091169063e1648cd290604401600060405180830381600087803b1580156117bc57600080fd5b505af11580156117d0573d6000803e3d6000fd5b505050506115b1565b600b5460405163224e1c2d60e01b81526001600160a01b038681166004830152602482018490529091169063224e1c2d90604401600060405180830381600087803b15801561182757600080fd5b505af11580156112d9573d6000803e3d6000fd5b6000868152600260205260409020600101546001600160a01b031633146118b05760405162461bcd60e51b8152602060048201526024808201527f6f6e6c79207574696c697a65722063616e2063616c6c20746869732066756e636044820152633a34b7b760e11b6064820152608401610edf565b600854604051634bee760b60e11b8152600481018890526001600160a01b03909116906397dcec1690602401602060405180830381865afa1580156118f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191d91906157f3565b6001146119635760405162461bcd60e51b81526020600482015260146024820152731a5cc8191d5c9a5b99c8185cdcd95cdcdb595b9d60621b6044820152606401610edf565b600061196e87612176565b6001600160a01b0316639ec4d40e886040518263ffffffff1660e01b815260040161199b91815260200190565b600060405180830381865afa1580156119b8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526119e0919081019061565b565b90508060200151611a2c5760405162461bcd60e51b81526020600482015260166024820152751a5b9cdd1c9d5b595b9d081a5cc81b9bdd081c1bdbdb60521b6044820152606401610edf565b611a3587612176565b6001600160a01b031663edb53d3e886040518263ffffffff1660e01b8152600401611a6291815260200190565b602060405180830381865afa158015611a7f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aa39190615add565b604051634be085d960e01b81526001600160a01b03888116600483015260248201889052604482018790526064820186905284151560848301529190911690634be085d99060a401600060405180830381600087803b158015611b0557600080fd5b505af1158015611b19573d6000803e3d6000fd5b5050505050505050505050565b80611b318133610d98565b80611b4657506007546001600160a01b031633145b611b625760405162461bcd60e51b8152600401610edf90615afa565b60008281526005602090815260408083205483526004918290529182902054915163d746d3ef60e01b81529081018490526001600160a01b039091169063d746d3ef90602401600060405180830381600087803b158015611bc257600080fd5b505af1158015611bd6573d6000803e3d6000fd5b50505050611be382613704565b600854604051634cb4408760e01b8152600481018490526001600160a01b0390911690634cb44087906024015b600060405180830381600087803b158015611c2a57600080fd5b505af1158015611c3e573d6000803e3d6000fd5b505050505050565b6008546001600160a01b0316331480611c6957506007546001600160a01b031633145b611c855760405162461bcd60e51b8152600401610edf90615abb565b600b80546001600160a01b0319166001600160a01b0392909216919091179055565b80611cb28133610d98565b80611cc757506007546001600160a01b031633145b611ce35760405162461bcd60e51b8152600401610edf90615afa565b600082815260056020908152604080832054835260049182905280832054905163709a664160e11b81529182018590528291829182916001600160a01b039091169063e134cc82906024016080604051808303816000875af1158015611d4d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d719190615b18565b9350935093509350611d8686858585856137bc565b600086815260208190526040902060010154611da490879084613a72565b611c3e86613704565b6008546000906001600160a01b0316331480611dd357506007546001600160a01b031633145b611def5760405162461bcd60e51b8152600401610edf90615abb565b6000838152600d6020908152604080832060058101546001600160a01b0387168552925290912054611e209161360e565b6000938452600d602090815260408086206001600160a01b03909516865293905291832092909255919050565b611e578133610d98565b611e905760405162461bcd60e51b815260206004820152600a60248201526910bb30b634b230ba37b960b11b6044820152606401610edf565b6000818152600d6020908152604080832033845260010190915290205460ff16611ee55760405162461bcd60e51b8152602060048201526006602482015265217374616b6560d01b6044820152606401610edf565b600854604051638a6cac3d60e01b8152600481018390526000916001600160a01b031690638a6cac3d9060240160c060405180830381865afa158015611f2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f53919061583b565b50505060008581526005602090815260408083205483526004909152902054929350506001600160a01b0390911690508115611fee576000838152600d60205260409020600a0154611fba903390611faa86612176565b6001600160a01b03169190613c94565b6000838152600d60205260408120600a8101546008909101805491929091611fe3908490615797565b9091555061203e9050565b6000838152600d60205260409020600b015461200f903390611faa86612176565b6000838152600d60205260408120600b8101546008909101805491929091612038908490615797565b90915550505b50506000908152600d602090815260408083203384526001019091529020805460ff19169055565b6008546001600160a01b031633148061208957506007546001600160a01b031633145b6120a55760405162461bcd60e51b8152600401610edf90615abb565b6000918252600d602090815260408084206001600160a01b039093168452919052812055565b60085460405163054d50b360e21b8152600481018390526000916001600160a01b03169063153542cc90602401602060405180830381865afa158015612115573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121399190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c99573d6000803e3d6000fd5b600090815260056020908152604080832054835260049091529020546001600160a01b031690565b6121c260405180606001604052806000815260200160008152602001600081525090565b600091825260209190915290565b6121da8133610d98565b61220f5760405162461bcd60e51b8152600401610edf90602080825260049082015263085d985b60e21b604082015260600190565b6000818152600d6020908152604080832033845260020190915290205460ff16156122645760405162461bcd60e51b81526020600482015260056024820152641d9bdd195960da1b6044820152606401610edf565b6000818152600d60208181526040808420338552600281018352908420805460ff19166001179055848452919052600c018054916122a183615822565b919050555050565b6000818152600660209081526040918290208054835181840281018401909452808452606093928301828280156113a857602002820191906000526020600020905b8154815260200190600101908083116122eb5750505050509050919050565b612313816123c3565b61235f5760405162461bcd60e51b815260206004820152601860248201527f6d61726b657420636f6e646974696f6e206e6f74206d657400000000000000006044820152606401610edf565b61236881613d12565b60085460405163cabe2ae160e01b8152600481018390526001600160a01b039091169063cabe2ae1906024015b600060405180830381600087803b1580156123af57600080fd5b505af11580156115b1573d6000803e3d6000fd5b60085460405163b1283e7760e01b81526004810183905260009182916001600160a01b039091169063b1283e7790602401600060405180830381865afa158015612411573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124399190810190615b64565b9650505050505050801561253e5761245083612176565b6001600160a01b0316639ec4d40e846040518263ffffffff1660e01b815260040161247d91815260200190565b600060405180830381865afa15801561249a573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124c2919081019061565b565b6101a001515160085460405163661f1cf560e01b8152600481018690526001600160a01b039091169063661f1cf590602401602060405180830381865afa158015612511573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061253591906157f3565b10159392505050565b600061254984612176565b6001600160a01b0316639ec4d40e856040518263ffffffff1660e01b815260040161257691815260200190565b600060405180830381865afa158015612593573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526125bb919081019061565b565b60c0015160085460405163c6ceb96b60e01b81526004810187905291925061263f916001600160a01b039091169063c6ceb96b9060240161010060405180830381865afa158015612610573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126349190615c04565b60400151829061360e565b60085460405163661f1cf560e01b8152600481018790526001600160a01b039091169063661f1cf590602401602060405180830381865afa158015612688573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126ac91906157f3565b1015949350505050565b600081815260056020908152604080832054835260049182905291829020549151630ae161cd60e21b81529081018390526001600160a01b0390911690632b85873490602401600060405180830381600087803b15801561271657600080fd5b505af115801561272a573d6000803e3d6000fd5b505050600082815260056020908152604080832054835260049182905280832054905163709a664160e11b81529182018590529192508291829182916001600160a01b03169063e134cc82906024016080604051808303816000875af1158015612798573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127bc9190615b18565b93509350935093506127d185858585856137bc565b6000858152602081905260409020600101546127ef90869084613a72565b6115b185613704565b60006128048233610d98565b6128205760405162461bcd60e51b8152600401610edf90615afa565b612829826123c3565b6128625760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73234ba34b7b760b11b6044820152606401610edf565b6000828152600d60209081526040808320338452600181019092529091205460ff16156128bb5760405162461bcd60e51b8152602060048201526007602482015266085cdd185ad95960ca1b6044820152606401610edf565b6128df333083600a01546128ce87612176565b6001600160a01b0316929190614517565b80600a01548160080160008282546128f79190615c94565b909155505033600090815260018281016020526040808320805460ff19169092179091556008549051632a4a9dd160e01b8152600481018690526001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015612964573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129889190615983565b50505050505050905060008183600401546129a391906157df565b905060006129be84600501548361360e90919063ffffffff16565b33600090815260208690526040902054909150821015612a0b5760405162461bcd60e51b8152602060048201526008602482015267185c1c1c9bdd995960c21b6044820152606401610edf565b3360009081526020859052604081208054849290612a2a908490615c94565b90915550612a3b9050826001615c94565b846007016000828254612a4e9190615c94565b925050819055506001846009016000828254612a6a9190615c94565b909155505060085460405163334b11d360e11b81526004810188905260248101839052604481018490523360648201526001600160a01b039091169063669623a690608401600060405180830381600087803b158015612ac957600080fd5b505af1158015612add573d6000803e3d6000fd5b50505050612aea86610ac5565b15612b5757612af886613d12565b60085460405163cabe2ae160e01b8152600481018890526001600160a01b039091169063cabe2ae190602401600060405180830381600087803b158015612b3e57600080fd5b505af1158015612b52573d6000803e3d6000fd5b505050505b95945050505050565b6000818152600d60205260408082206004908101546008549251632a4a9dd160e01b81529182018590529183916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015612bc0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612be49190615983565b50505050505050905060008183612bfb91906157df565b6000868152600d6020526040902060050154909150612b5790829061360e565b6008546001600160a01b0316331480612c3e57506007546001600160a01b031633145b612c5a5760405162461bcd60e51b8152600401610edf90615abb565b6001600160a01b038116612c6d57600080fd5b600880546001600160a01b0319166001600160a01b0392909216919091179055565b6008546001600160a01b0316331480612cb257506007546001600160a01b031633145b612cce5760405162461bcd60e51b8152600401610edf90615abb565b612cd782612176565b600854604051633c16f3ed60e21b8152600481018490526001600160a01b03918216602482015291169063f05bcfb490604401611c10565b600080612d1c848661459a565b90506000612d3c612d3583670de0b6b3a7640000615797565b839061360e565b90506000612d4a878661459a565b905082612d57828461360e565b612d619190615c94565b979650505050505050565b600b54604051637453c01360e11b81526001600160a01b03848116600483015260248201849052600092169063e8a7802690604401602060405180830381865afa158015612dbe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c479190615ca7565b6001600160a01b038316612e085760405162461bcd60e51b8152600401610edf90615cc4565b6101408201516001600160a01b0316612e335760405162461bcd60e51b8152600401610edf90615cc4565b6000818152600460205260409020546001600160a01b0316612e675760405162461bcd60e51b8152600401610edf90615cc4565b600081815260046020818152604080842054600854825163764bc84160e11b815292516001600160a01b039283169695919092169363ec97908293808301939192908290030181865afa158015612ec2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ee691906157f3565b60008181526005602090815260408083208790558683526006825280832080546001818101835591855283852001859055815180830183526101408a01516001600160a01b0390811682528b8116828601908152878752600290955294839020905181549086166001600160a01b031991821617825593519101805491851691909316179091556008548151637572cb1f60e01b81529151939450821692634e042a5992861691637572cb1f916004808301926101009291908290030181865afa158015612fb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fdc9190615c04565b846001600160a01b0316636c321c8a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561301a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303e91906157f3565b846040518463ffffffff1660e01b815260040161305d93929190615ce6565b600060405180830381600087803b15801561307757600080fd5b505af115801561308b573d6000803e3d6000fd5b5050600a5460008681526004602081815260408084205481516362eb326360e11b8152915194975087965086956001600160a01b039081169563981f513695919092169363c5d664c693808301939192908290030181865afa1580156130f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131199190615add565b60085460405160e084901b6001600160e01b03191681526001600160a01b039283166004820152911660248201526044016060604051808303816000875af1158015613169573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061318d9190615d08565b925092509250866020015115613345576101a08701805142606090910152518051602082015160809092015160085460405163c6ceb96b60e01b8152600481018990526001600160a01b03868116956334327d8b95949093909291169063c6ceb96b9060240161010060405180830381865afa158015613211573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132359190615c04565b602001516040516001600160e01b031960e087901b16815260048101949094526024840192909252604483015260648201526084016020604051808303816000875af1158015613289573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132ad91906157f3565b6101a088015160c0015260085461012088015160405163080ec90d60e21b81526001600160a01b039092169163203b2434916132f6918891869189918991600190600401615d76565b600060405180830381600087803b15801561331057600080fd5b505af1158015613324573d6000803e3d6000fd5b5050505061334084886101a001516000015189602001516145af565b6134b0565b60c087015160e088015160085460405163c6ceb96b60e01b8152600481018890526001600160a01b03858116946375e2d946949093909291169063c6ceb96b9060240161010060405180830381865afa1580156133a6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133ca9190615c04565b602001516040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401600060405180830381600087803b15801561341457600080fd5b505af1158015613428573d6000803e3d6000fd5b50506008546101208a015160405163080ec90d60e21b81526001600160a01b03909216935063203b2434925061346b918891869189918991600090600401615d76565b600060405180830381600087803b15801561348557600080fd5b505af1158015613499573d6000803e3d6000fd5b505050506134b0848860c0015189602001516145af565b60a087018490526040516398d796e760e01b81526001600160a01b038616906398d796e7906134e3908a90600401615de7565b600060405180830381600087803b1580156134fd57600080fd5b505af1158015613511573d6000803e3d6000fd5b5050604080518781526001600160a01b038c1660208201527f5e2ab39d79551e4c4e66256d806dd566d4d015420519d2ed2621563488a5d2a8935001905060405180910390a15050506001600160a01b03909416600090815260036020526040902093909355505050565b6008546001600160a01b031633148061359f57506007546001600160a01b031633145b6135bb5760405162461bcd60e51b8152600401610edf90615abb565b600081815260056020908152604080832054835260049182905291829020549151633c16f3ed60e21b81529081018590526001600160a01b0384811660248301529091169063f05bcfb490604401610fa9565b6000610c478383670de0b6b3a76400006136e6565b60008060005b848160ff16101561367757613659868260ff168151811061364c5761364c61580c565b6020026020010151610c4e565b6136639083615c94565b91508061366f81615a9c565b915050613629565b5060006136848285615f0f565b905060005b858160ff1610156136dc5760006136ae888360ff168151811061364c5761364c61580c565b9050808310156136c6575060ff169250610c47915050565b90910390806136d481615a9c565b915050613689565b5050509392505050565b60008260001904841183021582026136fd57600080fd5b5091020490565b60085460405163068bcd8d60e01b8152600481018390526001600160a01b039091169063068bcd8d90602401602060405180830381865afa15801561374d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137719190615add565b6001600160a01b03166396fd1c4261378883612176565b6040516001600160e01b031960e084901b1681526001600160a01b0390911660048201526000196024820152604401612395565b83156137d05782156137d0576137d06159e0565b60085460405163054d50b360e21b8152600481018790526000916001600160a01b03169063153542cc90602401602060405180830381865afa15801561381a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061383e9190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561387b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061389f91906157f3565b905060008085116138b157600061397f565b60085460405163920f4e5560e01b8152600481018990526001600160a01b039091169063920f4e5590602401602060405180830381865afa1580156138fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061391e9190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561395b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061397f91906157f3565b90506000866139b55761399c6139958385615c94565b879061459a565b6139ae90670de0b6b3a7640000615c94565b90506139f4565b6139bf858461459a565b670de0b6b3a7640000116139d5575060006139f4565b6139df858461459a565b6139f190670de0b6b3a7640000615797565b90505b6008546040516361fa5af560e01b8152600481018a9052881515602482015285156044820152606481018390526001600160a01b03909116906361fa5af590608401600060405180830381600087803b158015613a5057600080fd5b505af1158015613a64573d6000803e3d6000fd5b505050505050505050505050565b80600003613a975750506000908152600d60205260409020600a810154600b90910155565b60008381526005602090815260408083205483526004918290528083205490516363737ac960e11b81529182018590526001600160a01b03169190829063c6e6f59290602401602060405180830381865afa158015613afa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b1e91906157f3565b6040516363737ac960e11b8152600481018590529091506000906001600160a01b0384169063c6e6f59290602401602060405180830381865afa158015613b69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b8d91906157f3565b6000878152600d6020526040812060080154919250613bca613bb06002846157df565b613bc486613bbe8782615797565b9061459a565b9061360e565b613bd56002846157df565b613bdf9190615c94565b9050613bea88612176565b6001600160a01b03166342966c68613c028385615797565b6040518263ffffffff1660e01b8152600401613c2091815260200190565b600060405180830381600087803b158015613c3a57600080fd5b505af1158015613c4e573d6000803e3d6000fd5b5050506000898152600d602052604090206008810183905560030154613c759150826157df565b6000988952600d6020526040909820600b019790975550505050505050565b600060405163a9059cbb60e01b8152836004820152826024820152602060006044836000895af13d15601f3d1160016000511416171691505080613d0c5760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610edf565b50505050565b600081815260056020908152604080832054835260049182905280832054600854915163068bcd8d60e01b81529283018590526001600160a01b03908116939291169063068bcd8d90602401602060405180830381865afa158015613d7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d9f9190615add565b600854604051634bee760b60e11b8152600481018690529192506001600160a01b0316906397dcec1690602401602060405180830381865afa158015613de9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613e0d91906157f3565b600314613e4f5760405162461bcd60e51b815260206004820152601060248201526f10b6b0b935b2ba21b7b73234ba34b7b760811b6044820152606401610edf565b60405163238f0e7560e11b8152600481018490526001600160a01b0383169063471e1cea90602401602060405180830381865afa158015613e94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613eb89190615ca7565b613efb5760405162461bcd60e51b815260206004820152601460248201527310b4b739ba393ab6b2b73a21b7b73234ba34b7b760611b6044820152606401610edf565b60085460405163b1283e7760e01b8152600481018590526000916001600160a01b03169063b1283e7790602401600060405180830381865afa158015613f45573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613f6d9190810190615b64565b60085460405163661f1cf560e01b8152600481018d9052919850600097506001600160a01b0316955063661f1cf594506024019250613faa915050565b602060405180830381865afa158015613fc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613feb91906157f3565b905081156141435760085460405163054d50b360e21b81526004810187905261413e9187916001600160a01b039091169063153542cc90602401602060405180830381865afa158015614042573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140669190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156140a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140c791906157f3565b604051634f626a0760e11b8152600481018990526001600160a01b03881690639ec4d40e90602401600060405180830381865afa15801561410c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052614134919081019061565b565b6101a00151614610565b6141c6565b6040516303d972f160e21b8152600481018690526001600160a01b03851690630f65cbc490602401602060405180830381865afa158015614188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141ac91906157f3565b6000036141bd5761413e858461470c565b6141c685614952565b6000858152602081905260409081902082905551634b7e8e2160e11b8152306004820152602481018290526001600160a01b038416906396fd1c4290604401600060405180830381600087803b15801561421f57600080fd5b505af1158015614233573d6000803e3d6000fd5b50505050826001600160a01b03166390f817026040518163ffffffff1660e01b8152600401602060405180830381865afa158015614275573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142999190615add565b6001600160a01b031663095ea7b3856001600160a01b03166350c6e6cf886040518263ffffffff1660e01b81526004016142d591815260200190565b602060405180830381865afa1580156142f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143169190615add565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602481018490526044016020604051808303816000875af1158015614363573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143879190615ca7565b506040516350c6e6cf60e01b8152600481018690526001600160a01b038516906350c6e6cf90602401602060405180830381865afa1580156143cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143f19190615add565b6001600160a01b031663d832f791826040518263ffffffff1660e01b815260040161441e91815260200190565b600060405180830381600087803b15801561443857600080fd5b505af115801561444c573d6000803e3d6000fd5b505050600086815260208190526040908190209051624e1afd60e81b8152600481018890528154602482015260018201546044820152600290910154606482015283151560848201526001600160a01b0386169150634e1afd009060a401600060405180830381600087803b1580156144c457600080fd5b505af11580156144d8573d6000803e3d6000fd5b50505050826001600160a01b0316638d01450f6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561182757600080fd5b60006040516323b872dd60e01b81528460048201528360248201528260448201526020600060648360008a5af13d15601f3d11600160005114161716915050806115b15760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610edf565b6000610c4783670de0b6b3a7640000846136e6565b816000036145ed5760405162461bcd60e51b815260206004820152600b60248201526a0c081c1c9a5b98da5c185b60aa1b6044820152606401610edf565b6145f6836113b4565b614601838383614a18565b61460b8383614bfa565b505050565b60008160a00151116146535760405162461bcd60e51b815260206004820152600c60248201526b18102622ab2fa320a1aa27a960a11b6044820152606401610edf565b60405180606001604052806000815260200161468f8360800151613bc48560a00151670de0b6b3a76400006146889190615c94565b879061360e565b8152600060209182018190528581528082526040908190208351815583830151600182015592810151600290930192909255815180830190925260098252681c1c9a5b98da5c185b60ba1b90820152608082015160a083015161460b929161470791613bc49061468890670de0b6b3a7640000615c94565b614d2d565b60008281526005602090815260408083205483526004918290528083205490516318353be960e21b815291820185905282916001600160a01b03909116906360d4efa4906024016040805180830381865afa15801561476f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147939190615f23565b60085460405163661f1cf560e01b81526004810188905292945090925060009161489b91614895916001600160a01b039091169063661f1cf590602401602060405180830381865afa1580156147ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061481191906157f3565b60085460405163c6ceb96b60e01b8152600481018a9052670de0b6b3a7640000916001600160a01b03169063c6ceb96b9060240161010060405180830381865afa158015614863573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906148879190615c04565b60c00151613bc49190615c94565b84614d76565b90506000614911856001600160a01b03166314e2b929846040518263ffffffff1660e01b81526004016148d091815260200190565b602060405180830381865afa1580156148ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061489591906157f3565b604080516060810182526000808252602080830196875282840194855299815298899052972096518755915160018701555051600290940193909355505050565b60008181526005602090815260408083205483526004918290528083205490516318353be960e21b815291820184905282916001600160a01b03909116906360d4efa4906024016040805180830381865afa1580156149b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906149d99190615f23565b60408051606081018252600080825260208083019586528284019485529781529687905295209451855590516001850155516002909301929092555050565b60085460405163068bcd8d60e01b8152600481018590526000916001600160a01b03169063068bcd8d90602401602060405180830381865afa158015614a62573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614a869190615add565b600854604051632a4a9dd160e01b8152600481018790529192506000916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015614ad6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614afa9190615983565b505050505050915050614b0c81614d8d565b8015614b1c5750614b1c84614d8d565b614b535760405162461bcd60e51b81526020600482015260086024820152673830b930b6a2a92960c11b6044820152606401610edf565b6000858152600d6020526040812090614b6c838761360e565b90506000846001600160a01b0316637063b06c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614bae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614bd291906157f3565b90506000614be0838361459a565b600485019290925550600590920191909155505050505050565b60008281526005602090815260408083205483526004918290528083205490516363737ac960e11b81529182018490526001600160a01b03169190829063c6e6f59290602401602060405180830381865afa158015614c5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614c8191906157f3565b600854604051632a4a9dd160e01b8152600481018790529192506000916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015614cd1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614cf59190615983565b975050505050505050614d11828261360e90919063ffffffff16565b6000958652600d6020526040909520600a019490945550505050565b614d728282604051602401614d43929190615f47565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b179052614dac565b5050565b600081831115614d865781610c47565b5090919050565b6000614da3612710670de0b6b3a76400006157df565b90911015919050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b828054828255906000526020600020908101928215614e22579160200282015b82811115614e2257825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190614ded565b50614e2e929150614e32565b5090565b5b80821115614e2e5760008155600101614e33565b600060208284031215614e5957600080fd5b5035919050565b6001600160a01b0381168114614e7557600080fd5b50565b8035614e8381614e60565b919050565b600060208284031215614e9a57600080fd5b8135610c4781614e60565b8015158114614e7557600080fd5b8035614e8381614ea5565b60008060408385031215614ed157600080fd5b823591506020830135614ee381614ea5565b809150509250929050565b60008060408385031215614f0157600080fd5b823591506020830135614ee381614e60565b634e487b7160e01b600052604160045260246000fd5b604051610100810167ffffffffffffffff81118282101715614f4d57614f4d614f13565b60405290565b60405160e0810167ffffffffffffffff81118282101715614f4d57614f4d614f13565b6040516101c0810167ffffffffffffffff81118282101715614f4d57614f4d614f13565b604051601f8201601f1916810167ffffffffffffffff81118282101715614fc357614fc3614f13565b604052919050565b6000806000806000808688036101a0811215614fe657600080fd5b8735614ff181614e60565b9650602088013561500181614ea5565b9550604088013594506060880135935060808801359250610100609f19820181131561502c57600080fd5b615034614f29565b915060a0890135825260c0890135602083015260e0890135604083015280890135606083015250610120880135608082015261014088013560a082015261016088013560c082015261018088013560e0820152809150509295509295509295565b600067ffffffffffffffff8211156150af576150af614f13565b5060051b60200190565b600080604083850312156150cc57600080fd5b8235915060208084013567ffffffffffffffff8111156150eb57600080fd5b8401601f810186136150fc57600080fd5b803561510f61510a82615095565b614f9a565b81815260059190911b8201830190838101908883111561512e57600080fd5b928401925b8284101561514c57833582529284019290840190615133565b80955050505050509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561519c5783516001600160a01b031683529284019291840191600101615177565b50909695505050505050565b600080604083850312156151bb57600080fd5b50508035926020909101359150565b6000806000606084860312156151df57600080fd5b8335925060208401356151f181614e60565b9150604084013561520181614ea5565b809150509250925092565b60008060008060008060c0878903121561522557600080fd5b86359550602087013561523781614e60565b945060408701359350606087013592506080870135915060a087013561525c81614ea5565b809150509295509295509295565b6020808252825182820181905260009190848201906040850190845b8181101561519c57835183529284019291840191600101615286565b6000806000606084860312156152b757600080fd5b505081359360208301359350604090920135919050565b600080604083850312156152e157600080fd5b82356152ec81614e60565b946020939093013593505050565b600067ffffffffffffffff82111561531457615314614f13565b50601f01601f191660200190565b600082601f83011261533357600080fd5b813561534161510a826152fa565b81815284602083860101111561535657600080fd5b816020850160208301376000918101602001919091529392505050565b60048110614e7557600080fd5b8035614e8381615373565b600060e0828403121561539d57600080fd5b6153a5614f53565b9050813581526020820135602082015260408201356040820152606082013560608201526080820135608082015260a082013560a082015260c082013560c082015292915050565b60008060006060848603121561540257600080fd5b833561540d81614e60565b9250602084013567ffffffffffffffff8082111561542a57600080fd5b90850190610280828803121561543f57600080fd5b615447614f76565b8235815261545760208401614eb3565b602082015261546860408401614eb3565b6040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e082015261010080840135818301525061012080840135838111156154bf57600080fd5b6154cb8a828701615322565b82840152505061014091506154e1828401614e78565b8282015261016091506154f5828401615380565b82820152610180915081830135828201526101a091506155178883850161538b565b82820152809450505050604084013590509250925092565b60008060006060848603121561554457600080fd5b83359250602084013561555681614e60565b929592945050506040919091013590565b8051614e8381614ea5565b60005b8381101561558d578181015183820152602001615575565b50506000910152565b600082601f8301126155a757600080fd5b81516155b561510a826152fa565b8181528460208386010111156155ca57600080fd5b6155db826020830160208701615572565b949350505050565b8051614e8381614e60565b8051614e8381615373565b600060e0828403121561560b57600080fd5b615613614f53565b9050815181526020820151602082015260408201516040820152606082015160608201526080820151608082015260a082015160a082015260c082015160c082015292915050565b60006020828403121561566d57600080fd5b815167ffffffffffffffff8082111561568557600080fd5b90830190610280828603121561569a57600080fd5b6156a2614f76565b825181526156b260208401615567565b60208201526156c360408401615567565b6040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e0820152610100808401518183015250610120808401518381111561571a57600080fd5b61572688828701615596565b828401525050610140915061573c8284016155e3565b8282015261016091506157508284016155ee565b82820152610180915081830151828201526101a09150615772868385016155f9565b91810191909152949350505050565b634e487b7160e01b600052601160045260246000fd5b81810381811115610b0257610b02615781565b60008160001904831182151516156157c4576157c4615781565b500290565b634e487b7160e01b600052601260045260246000fd5b6000826157ee576157ee6157c9565b500490565b60006020828403121561580557600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b60006001820161583457615834615781565b5060010190565b60008060008060008060c0878903121561585457600080fd5b865161585f81614ea5565b602088015190965061587081614ea5565b604088015190955061588181614ea5565b606088015190945061589281614ea5565b60808801519093506158a381614ea5565b8092505060a087015190509295509295509295565b805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c083015260e081015160e08301525050565b6001600160a01b038881168252871660208201528515156040820152606081018590526080810184905260a081018390526101c0810161594960c08301846158b8565b98975050505050505050565b6000806040838503121561596857600080fd5b825161597381614e60565b6020939093015192949293505050565b600080600080600080600080610100898b0312156159a057600080fd5b505086516020880151604089015160608a015160808b015160a08c015160c08d015160e0909d0151959e949d50929b919a50985090965094509092509050565b634e487b7160e01b600052600160045260246000fd5b60006020808385031215615a0957600080fd5b825167ffffffffffffffff811115615a2057600080fd5b8301601f81018513615a3157600080fd5b8051615a3f61510a82615095565b81815260059190911b82018301908381019087831115615a5e57600080fd5b928401925b82841015612d61578351615a7681614e60565b82529284019290840190615a63565b600081615a9457615a94615781565b506000190190565b600060ff821660ff8103615ab257615ab2615781565b60010192915050565b60208082526008908201526710b6b0b730b3b2b960c11b604082015260600190565b600060208284031215615aef57600080fd5b8151610c4781614e60565b6020808252600490820152630855985b60e21b604082015260600190565b60008060008060808587031215615b2e57600080fd5b8451615b3981614ea5565b8094505060208501519250604085015191506060850151615b5981614ea5565b939692955090935050565b600080600080600080600060e0888a031215615b7f57600080fd5b8751615b8a81614e60565b6020890151909750615b9b81614e60565b6040890151909650615bac81614e60565b606089015190955067ffffffffffffffff811115615bc957600080fd5b615bd58a828b01615596565b9450506080880151925060a0880151915060c0880151615bf481614ea5565b8091505092959891949750929550565b6000610100808385031215615c1857600080fd5b6040519081019067ffffffffffffffff82118183101715615c3b57615c3b614f13565b81604052835181526020840151602082015260408401516040820152606084015160608201526080840151608082015260a084015160a082015260c084015160c082015260e084015160e0820152809250505092915050565b80820180821115610b0257610b02615781565b600060208284031215615cb957600080fd5b8151610c4781614ea5565b602080825260089082015267061646472657373360c41b604082015260600190565b6101408101615cf582866158b8565b6101008201939093526101200152919050565b600080600060608486031215615d1d57600080fd5b8351615d2881614e60565b6020850151909350615d3981614e60565b604085015190925061520181614e60565b60008151808452615d62816020860160208601615572565b601f01601f19169290920160200192915050565b8681526001600160a01b03868116602083015285811660408301528416606082015260c060808201819052600090615db090830185615d4a565b905082151560a0830152979650505050505050565b60048110615de357634e487b7160e01b600052602160045260246000fd5b9052565b602081528151602082015260006020830151615e07604084018215159052565b50604083015180151560608401525060608301516080830152608083015160a083015260a083015160c083015260c083015160e083015260e083015161010081818501528085015191505061012081818501528085015191505061014061028081850152615e796102a0850183615d4a565b90850151909150610160615e97858201836001600160a01b03169052565b8501519050610180615eab85820183615dc5565b8501516101a08581019190915285015180516101c086015260208101516101e086015260408101516102008601526060810151610220860152608081015161024086015260a081015161026086015260c08101516102808601529050509392505050565b600082615f1e57615f1e6157c9565b500690565b60008060408385031215615f3657600080fd5b505080516020909101519092909150565b604081526000615f5a6040830185615d4a565b9050826020830152939250505056fea264697066735822122055c72d31c943c22a89ca8fedc75017f59a70087fd66af5bf1eec966dc25fc81064736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106103af5760003560e01c80638c64ea4a116101f4578063b9209e331161011a578063d82aff11116100ad578063e8e3fbb71161007c578063e8e3fbb714610a53578063ebd4dc4614610a66578063f0fd1d3814610a89578063f25fcc9f14610a9c57600080fd5b8063d82aff1114610a07578063da0a697f14610a1a578063dda10bca14610a2d578063e8a7802614610a4057600080fd5b8063ce93ec67116100e9578063ce93ec671461046a578063d1227136146109be578063d466461c146109d1578063d65ec964146109f457600080fd5b8063b9209e33146108d5578063c3f956fa14610901578063c4abc650146107e8578063c8fa33e71461091457600080fd5b80639403b63411610192578063ad4e4e7011610161578063ad4e4e701461087c578063b1b7e1f21461088f578063b37eedcd146108af578063b743939b146108c257600080fd5b80639403b634146107e85780639fe1458b146107fb578063a40c63f714610824578063ac1b6b011461084757600080fd5b80638f5709a5116101ce5780638f5709a51461077f5780638fbbc8681461079257806392ab723e146107b2578063937b6feb146107c557600080fd5b80638c64ea4a146106d75780638d4f16d7146107185780638dc3d9b41461076c57600080fd5b80633ec8dc3b116102d957806356a837f411610277578063805798ac11610246578063805798ac1461065357806381e1b07c14610676578063830e2a02146106a1578063875e487e146106b457600080fd5b806356a837f4146105fe5780636399d03d1461061157806365bc5ef9146106245780637789ec5a1461063357600080fd5b8063482c0aa8116102b3578063482c0aa8146105b2578063494ef447146105c55780634c503980146105d85780634cb44087146105eb57600080fd5b80633ec8dc3b1461056c578063457a89f61461058c578063473597a01461059f57600080fd5b80632358d5a811610351578063340e04b311610320578063340e04b31461051057806337bc93b01461052357806338ba4614146105465780633ea7fbdb1461055957600080fd5b80632358d5a81461048a57806323f2a73f146104c75780632b858734146104da5780632f8899f3146104ed57600080fd5b806308ad90a51161038d57806308ad90a5146104215780630c33df18146104345780630db065f41461044757806314f2b14c1461046a57600080fd5b806303cccb35146103b457806305a1ce99146103d857806308a8333f14610400575b600080fd5b6103d6336000908152600160208190526040909120805460ff19169091179055565b005b6103eb6103e6366004614e47565b610ac5565b60405190151581526020015b60405180910390f35b61041361040e366004614e47565b610b08565b6040519081526020016103f7565b61041361042f366004614e88565b610c4e565b6103eb610442366004614ebe565b610cbd565b6103eb610455366004614e88565b60016020526000908152604090205460ff1681565b610413610478366004614e47565b60009081526005602052604090205490565b6103eb610498366004614eee565b6000828152600d602090815260408083206001600160a01b038516845260010190915290205460ff1692915050565b6103eb6104d5366004614eee565b610d98565b6103d66104e8366004614e47565b610e12565b6104136104fb366004614e47565b6000908152600d602052604090206008015490565b6103d661051e366004614fcb565b610fe0565b610413610531366004614e47565b6000908152600d602052604090206007015490565b6103d66105543660046150b9565b611099565b6103d6610567366004614e88565b6112e4565b61057f61057a366004614e47565b611345565b6040516103f7919061515b565b6103d661059a366004614e47565b6113b4565b6103d66105ad366004614e88565b611608565b6104136105c03660046151a8565b611669565b6103d66105d33660046151ca565b61169a565b6103d66105e636600461520c565b61183b565b6103d66105f9366004614e47565b611b26565b6103d661060c366004614e88565b611c46565b6103d661061f366004614e47565b611ca7565b61041367016345785d8a000081565b610413610641366004614e88565b60036020526000908152604090205481565b610413610661366004614e47565b6000908152600d602052604090206009015490565b6103eb610684366004614e47565b6000908152600d602052604090206003810154600c909101541490565b6104136106af366004614eee565b611dad565b6104136106c2366004614e47565b6000908152600d60205260409020600a015490565b6107006106e5366004614e47565b6004602052600090815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020016103f7565b61074c610726366004614e47565b600260205260009081526040902080546001909101546001600160a01b03918216911682565b604080516001600160a01b039384168152929091166020830152016103f7565b6103d661077a366004614e47565b611e4d565b6103d661078d366004614eee565b612066565b6104136107a0366004614e47565b60056020526000908152604090205481565b6104136107c0366004614e47565b6120cb565b6104136107d3366004614e47565b6000908152600d60205260409020600b015490565b6107006107f6366004614e47565b612176565b610700610809366004614e47565b6000908152600460205260409020546001600160a01b031690565b610413610832366004614e47565b6000908152600d602052604090206005015490565b61085a610855366004614e47565b61219e565b60408051825181526020808401519082015291810151908201526060016103f7565b6103d661088a366004614e47565b6121d0565b6108a261089d366004614e47565b6122a9565b6040516103f7919061526a565b6103d66108bd366004614e47565b61230a565b6103eb6108d0366004614e47565b6123c3565b6103eb6108e3366004614e88565b6001600160a01b031660009081526001602052604090205460ff1690565b6103d661090f366004614e47565b6126b6565b610974610922366004614e47565b600d602052600090815260409020600481015460058201546006830154600784015460088501546009860154600a870154600b880154600c909801549697959660ff9095169593949293919290919089565b60408051998a5260208a0198909852951515968801969096526060870193909352608086019190915260a085015260c084015260e0830191909152610100820152610120016103f7565b6104136109cc366004614e47565b6127f8565b6104136109df366004614e47565b6000908152600d602052604090206004015490565b610413610a02366004614e47565b612b60565b6103d6610a15366004614e88565b612c1b565b6103d6610a283660046151a8565b612c8f565b610413610a3b3660046152a2565b612d0f565b6103eb610a4e3660046152ce565b612d6c565b6103d6610a613660046153ed565b612de2565b610413610a74366004614e47565b6000908152600d60205260409020600c015490565b6103d6610a9736600461552f565b61357c565b610413610aaa366004614e88565b6001600160a01b031660009081526003602052604090205490565b6000818152600d60205260408120600481015460079091015410801590610b0257506000828152600d602052604090206009810154600390910154145b92915050565b600080610b1483612176565b6001600160a01b0316639ec4d40e846040518263ffffffff1660e01b8152600401610b4191815260200190565b600060405180830381865afa158015610b5e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610b86919081019061565b565b6101000151670de0b6b3a764000042610b9e86612176565b6001600160a01b0316639ec4d40e876040518263ffffffff1660e01b8152600401610bcb91815260200190565b600060405180830381865afa158015610be8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610c10919081019061565b565b6101800151610c1f9190615797565b610c2991906157aa565b610c3391906157df565b9050610c478167016345785d8a000061360e565b9392505050565b600b546040516344c7439360e01b81526001600160a01b03838116600483015260009216906344c7439390602401602060405180830381865afa158015610c99573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0291906157f3565b60008281526005602090815260408083205483526004918290528083205490516359dc5c6f60e01b81529182018590526001600160a01b03169081906359dc5c6f90602401600060405180830381600087803b158015610d1c57600080fd5b505af1158015610d30573d6000803e3d6000fd5b5050604051630ae161cd60e21b8152600481018790526001600160a01b0384169250632b8587349150602401600060405180830381600087803b158015610d7657600080fd5b505af1158015610d8a573d6000803e3d6000fd5b506001979650505050505050565b6000828152600d60205260408120600301815b8154811015610e0757836001600160a01b0316828281548110610dd057610dd061580c565b6000918252602090912001546001600160a01b031603610df557600192505050610b02565b80610dff81615822565b915050610dab565b506000949350505050565b600854604051638a6cac3d60e01b81526004810183905260009182916001600160a01b0390911690638a6cac3d9060240160c060405180830381865afa158015610e60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e84919061583b565b505093505050915081158015610e975750805b610ee85760405162461bcd60e51b815260206004820152601960248201527f6d61726b657420636f6e646974696f6e73206e6f74206d65740000000000000060448201526064015b60405180910390fd5b6000838152600d602052604090206003810154600c9091015414610f625760405162461bcd60e51b815260206004820152602b60248201527f6e6f7420656e6f7567682076616c696461746f7273206861766520766f74656460448201526a20746f207265736f6c766560a81b6064820152608401610edf565b600083815260056020908152604080832054835260049182905291829020549151630ae161cd60e21b81529081018590526001600160a01b0390911690632b858734906024015b600060405180830381600087803b158015610fc357600080fd5b505af1158015610fd7573d6000803e3d6000fd5b50505050505050565b60095460405163da33133360e01b815260009182916001600160a01b039091169063da33133390611021908b9030908c908c908c908c908c90600401615906565b60408051808303816000875af115801561103f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110639190615955565b600090815260046020526040902080546001600160a01b0319166001600160a01b03929092169190911790555050505050505050565b6000828152600c6020526040808220546008549151632a4a9dd160e01b81526004810182905290929182916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa1580156110f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061111b9190615983565b5050955050505050915081845114611135576111356159e0565b60008381526002602052604080822060010154600b549151631535c04160e11b8152600481018590526001600160a01b039182166024820181905293929190911690632a6b808290604401600060405180830381865afa15801561119d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526111c591908101906159f6565b805190915060005b858160ff1610156112d957600061120184848b8560ff16815181106111f4576111f461580c565b6020026020010151613623565b9050600d600089815260200190815260200160002060030184828151811061122b5761122b61580c565b60209081029190910181015182546001808201855560009485529290932090920180546001600160a01b0319166001600160a01b039093169290921790915584906112769085615797565b815181106112865761128661580c565b60200260200101518482815181106112a0576112a061580c565b6001600160a01b0390921660209283029190910190910152826112c281615a85565b9350505080806112d190615a9c565b9150506111cd565b505050505050505050565b6008546001600160a01b031633148061130757506007546001600160a01b031633145b6113235760405162461bcd60e51b8152600401610edf90615abb565b600980546001600160a01b0319166001600160a01b0392909216919091179055565b6000818152600d60209081526040918290206003018054835181840281018401909452808452606093928301828280156113a857602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161138a575b50505050509050919050565b600081815260026020526040808220600101546008549151632a4a9dd160e01b8152600481018590526001600160a01b03918216939283921690632a4a9dd19060240161010060405180830381865afa158015611415573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114399190615983565b5050600b54604051631535c04160e11b8152600481018390526001600160a01b038b81166024830152979950919750600096169450632a6b8082935060440191506114819050565b600060405180830381865afa15801561149e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526114c691908101906159f6565b9050828151116115b8576000858152600d6020908152604090912082516114f592600390920191840190614dcd565b5082815110156115b157600854815160405163555f8d2d60e01b81526004810188905260248101919091526001600160a01b039091169063555f8d2d90604401600060405180830381600087803b15801561154f57600080fd5b505af1158015611563573d6000803e3d6000fd5b505060405162461bcd60e51b815260206004820152601860248201527f6e6f7420656e6f7567682072617465642074726164657273000000000000000060448201526064019150610edf9050565b5050505050565b5050506000828152600d602090815260408220600601805460ff19166001908117909155909152600c9052507fd421a5181c571bba3f01190c922c3b2a896fc1d84e86c9f17ac10e67ebef8b5c55565b6008546001600160a01b031633148061162b57506007546001600160a01b031633145b6116475760405162461bcd60e51b8152600401610edf90615abb565b600a80546001600160a01b0319166001600160a01b0392909216919091179055565b6006602052816000526040600020818154811061168557600080fd5b90600052602060002001600091509150505481565b6008546001600160a01b03163314806116bd57506007546001600160a01b031633145b6116d95760405162461bcd60e51b8152600401610edf90615abb565b600854604051632841c2b760e21b8152600481018590526001600160a01b038481166024830152600092169063a1070adc90604401602060405180830381865afa15801561172b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061174f91906157f3565b905060006117668280670de0b6b3a76400006136e6565b905082156117d957600b546040516370b2466960e11b81526001600160a01b038681166004830152602482018490529091169063e1648cd290604401600060405180830381600087803b1580156117bc57600080fd5b505af11580156117d0573d6000803e3d6000fd5b505050506115b1565b600b5460405163224e1c2d60e01b81526001600160a01b038681166004830152602482018490529091169063224e1c2d90604401600060405180830381600087803b15801561182757600080fd5b505af11580156112d9573d6000803e3d6000fd5b6000868152600260205260409020600101546001600160a01b031633146118b05760405162461bcd60e51b8152602060048201526024808201527f6f6e6c79207574696c697a65722063616e2063616c6c20746869732066756e636044820152633a34b7b760e11b6064820152608401610edf565b600854604051634bee760b60e11b8152600481018890526001600160a01b03909116906397dcec1690602401602060405180830381865afa1580156118f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061191d91906157f3565b6001146119635760405162461bcd60e51b81526020600482015260146024820152731a5cc8191d5c9a5b99c8185cdcd95cdcdb595b9d60621b6044820152606401610edf565b600061196e87612176565b6001600160a01b0316639ec4d40e886040518263ffffffff1660e01b815260040161199b91815260200190565b600060405180830381865afa1580156119b8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526119e0919081019061565b565b90508060200151611a2c5760405162461bcd60e51b81526020600482015260166024820152751a5b9cdd1c9d5b595b9d081a5cc81b9bdd081c1bdbdb60521b6044820152606401610edf565b611a3587612176565b6001600160a01b031663edb53d3e886040518263ffffffff1660e01b8152600401611a6291815260200190565b602060405180830381865afa158015611a7f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aa39190615add565b604051634be085d960e01b81526001600160a01b03888116600483015260248201889052604482018790526064820186905284151560848301529190911690634be085d99060a401600060405180830381600087803b158015611b0557600080fd5b505af1158015611b19573d6000803e3d6000fd5b5050505050505050505050565b80611b318133610d98565b80611b4657506007546001600160a01b031633145b611b625760405162461bcd60e51b8152600401610edf90615afa565b60008281526005602090815260408083205483526004918290529182902054915163d746d3ef60e01b81529081018490526001600160a01b039091169063d746d3ef90602401600060405180830381600087803b158015611bc257600080fd5b505af1158015611bd6573d6000803e3d6000fd5b50505050611be382613704565b600854604051634cb4408760e01b8152600481018490526001600160a01b0390911690634cb44087906024015b600060405180830381600087803b158015611c2a57600080fd5b505af1158015611c3e573d6000803e3d6000fd5b505050505050565b6008546001600160a01b0316331480611c6957506007546001600160a01b031633145b611c855760405162461bcd60e51b8152600401610edf90615abb565b600b80546001600160a01b0319166001600160a01b0392909216919091179055565b80611cb28133610d98565b80611cc757506007546001600160a01b031633145b611ce35760405162461bcd60e51b8152600401610edf90615afa565b600082815260056020908152604080832054835260049182905280832054905163709a664160e11b81529182018590528291829182916001600160a01b039091169063e134cc82906024016080604051808303816000875af1158015611d4d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d719190615b18565b9350935093509350611d8686858585856137bc565b600086815260208190526040902060010154611da490879084613a72565b611c3e86613704565b6008546000906001600160a01b0316331480611dd357506007546001600160a01b031633145b611def5760405162461bcd60e51b8152600401610edf90615abb565b6000838152600d6020908152604080832060058101546001600160a01b0387168552925290912054611e209161360e565b6000938452600d602090815260408086206001600160a01b03909516865293905291832092909255919050565b611e578133610d98565b611e905760405162461bcd60e51b815260206004820152600a60248201526910bb30b634b230ba37b960b11b6044820152606401610edf565b6000818152600d6020908152604080832033845260010190915290205460ff16611ee55760405162461bcd60e51b8152602060048201526006602482015265217374616b6560d01b6044820152606401610edf565b600854604051638a6cac3d60e01b8152600481018390526000916001600160a01b031690638a6cac3d9060240160c060405180830381865afa158015611f2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f53919061583b565b50505060008581526005602090815260408083205483526004909152902054929350506001600160a01b0390911690508115611fee576000838152600d60205260409020600a0154611fba903390611faa86612176565b6001600160a01b03169190613c94565b6000838152600d60205260408120600a8101546008909101805491929091611fe3908490615797565b9091555061203e9050565b6000838152600d60205260409020600b015461200f903390611faa86612176565b6000838152600d60205260408120600b8101546008909101805491929091612038908490615797565b90915550505b50506000908152600d602090815260408083203384526001019091529020805460ff19169055565b6008546001600160a01b031633148061208957506007546001600160a01b031633145b6120a55760405162461bcd60e51b8152600401610edf90615abb565b6000918252600d602090815260408084206001600160a01b039093168452919052812055565b60085460405163054d50b360e21b8152600481018390526000916001600160a01b03169063153542cc90602401602060405180830381865afa158015612115573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121399190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c99573d6000803e3d6000fd5b600090815260056020908152604080832054835260049091529020546001600160a01b031690565b6121c260405180606001604052806000815260200160008152602001600081525090565b600091825260209190915290565b6121da8133610d98565b61220f5760405162461bcd60e51b8152600401610edf90602080825260049082015263085d985b60e21b604082015260600190565b6000818152600d6020908152604080832033845260020190915290205460ff16156122645760405162461bcd60e51b81526020600482015260056024820152641d9bdd195960da1b6044820152606401610edf565b6000818152600d60208181526040808420338552600281018352908420805460ff19166001179055848452919052600c018054916122a183615822565b919050555050565b6000818152600660209081526040918290208054835181840281018401909452808452606093928301828280156113a857602002820191906000526020600020905b8154815260200190600101908083116122eb5750505050509050919050565b612313816123c3565b61235f5760405162461bcd60e51b815260206004820152601860248201527f6d61726b657420636f6e646974696f6e206e6f74206d657400000000000000006044820152606401610edf565b61236881613d12565b60085460405163cabe2ae160e01b8152600481018390526001600160a01b039091169063cabe2ae1906024015b600060405180830381600087803b1580156123af57600080fd5b505af11580156115b1573d6000803e3d6000fd5b60085460405163b1283e7760e01b81526004810183905260009182916001600160a01b039091169063b1283e7790602401600060405180830381865afa158015612411573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124399190810190615b64565b9650505050505050801561253e5761245083612176565b6001600160a01b0316639ec4d40e846040518263ffffffff1660e01b815260040161247d91815260200190565b600060405180830381865afa15801561249a573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526124c2919081019061565b565b6101a001515160085460405163661f1cf560e01b8152600481018690526001600160a01b039091169063661f1cf590602401602060405180830381865afa158015612511573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061253591906157f3565b10159392505050565b600061254984612176565b6001600160a01b0316639ec4d40e856040518263ffffffff1660e01b815260040161257691815260200190565b600060405180830381865afa158015612593573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526125bb919081019061565b565b60c0015160085460405163c6ceb96b60e01b81526004810187905291925061263f916001600160a01b039091169063c6ceb96b9060240161010060405180830381865afa158015612610573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126349190615c04565b60400151829061360e565b60085460405163661f1cf560e01b8152600481018790526001600160a01b039091169063661f1cf590602401602060405180830381865afa158015612688573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126ac91906157f3565b1015949350505050565b600081815260056020908152604080832054835260049182905291829020549151630ae161cd60e21b81529081018390526001600160a01b0390911690632b85873490602401600060405180830381600087803b15801561271657600080fd5b505af115801561272a573d6000803e3d6000fd5b505050600082815260056020908152604080832054835260049182905280832054905163709a664160e11b81529182018590529192508291829182916001600160a01b03169063e134cc82906024016080604051808303816000875af1158015612798573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127bc9190615b18565b93509350935093506127d185858585856137bc565b6000858152602081905260409020600101546127ef90869084613a72565b6115b185613704565b60006128048233610d98565b6128205760405162461bcd60e51b8152600401610edf90615afa565b612829826123c3565b6128625760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73234ba34b7b760b11b6044820152606401610edf565b6000828152600d60209081526040808320338452600181019092529091205460ff16156128bb5760405162461bcd60e51b8152602060048201526007602482015266085cdd185ad95960ca1b6044820152606401610edf565b6128df333083600a01546128ce87612176565b6001600160a01b0316929190614517565b80600a01548160080160008282546128f79190615c94565b909155505033600090815260018281016020526040808320805460ff19169092179091556008549051632a4a9dd160e01b8152600481018690526001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015612964573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129889190615983565b50505050505050905060008183600401546129a391906157df565b905060006129be84600501548361360e90919063ffffffff16565b33600090815260208690526040902054909150821015612a0b5760405162461bcd60e51b8152602060048201526008602482015267185c1c1c9bdd995960c21b6044820152606401610edf565b3360009081526020859052604081208054849290612a2a908490615c94565b90915550612a3b9050826001615c94565b846007016000828254612a4e9190615c94565b925050819055506001846009016000828254612a6a9190615c94565b909155505060085460405163334b11d360e11b81526004810188905260248101839052604481018490523360648201526001600160a01b039091169063669623a690608401600060405180830381600087803b158015612ac957600080fd5b505af1158015612add573d6000803e3d6000fd5b50505050612aea86610ac5565b15612b5757612af886613d12565b60085460405163cabe2ae160e01b8152600481018890526001600160a01b039091169063cabe2ae190602401600060405180830381600087803b158015612b3e57600080fd5b505af1158015612b52573d6000803e3d6000fd5b505050505b95945050505050565b6000818152600d60205260408082206004908101546008549251632a4a9dd160e01b81529182018590529183916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015612bc0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612be49190615983565b50505050505050905060008183612bfb91906157df565b6000868152600d6020526040902060050154909150612b5790829061360e565b6008546001600160a01b0316331480612c3e57506007546001600160a01b031633145b612c5a5760405162461bcd60e51b8152600401610edf90615abb565b6001600160a01b038116612c6d57600080fd5b600880546001600160a01b0319166001600160a01b0392909216919091179055565b6008546001600160a01b0316331480612cb257506007546001600160a01b031633145b612cce5760405162461bcd60e51b8152600401610edf90615abb565b612cd782612176565b600854604051633c16f3ed60e21b8152600481018490526001600160a01b03918216602482015291169063f05bcfb490604401611c10565b600080612d1c848661459a565b90506000612d3c612d3583670de0b6b3a7640000615797565b839061360e565b90506000612d4a878661459a565b905082612d57828461360e565b612d619190615c94565b979650505050505050565b600b54604051637453c01360e11b81526001600160a01b03848116600483015260248201849052600092169063e8a7802690604401602060405180830381865afa158015612dbe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c479190615ca7565b6001600160a01b038316612e085760405162461bcd60e51b8152600401610edf90615cc4565b6101408201516001600160a01b0316612e335760405162461bcd60e51b8152600401610edf90615cc4565b6000818152600460205260409020546001600160a01b0316612e675760405162461bcd60e51b8152600401610edf90615cc4565b600081815260046020818152604080842054600854825163764bc84160e11b815292516001600160a01b039283169695919092169363ec97908293808301939192908290030181865afa158015612ec2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ee691906157f3565b60008181526005602090815260408083208790558683526006825280832080546001818101835591855283852001859055815180830183526101408a01516001600160a01b0390811682528b8116828601908152878752600290955294839020905181549086166001600160a01b031991821617825593519101805491851691909316179091556008548151637572cb1f60e01b81529151939450821692634e042a5992861691637572cb1f916004808301926101009291908290030181865afa158015612fb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fdc9190615c04565b846001600160a01b0316636c321c8a6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561301a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303e91906157f3565b846040518463ffffffff1660e01b815260040161305d93929190615ce6565b600060405180830381600087803b15801561307757600080fd5b505af115801561308b573d6000803e3d6000fd5b5050600a5460008681526004602081815260408084205481516362eb326360e11b8152915194975087965086956001600160a01b039081169563981f513695919092169363c5d664c693808301939192908290030181865afa1580156130f5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131199190615add565b60085460405160e084901b6001600160e01b03191681526001600160a01b039283166004820152911660248201526044016060604051808303816000875af1158015613169573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061318d9190615d08565b925092509250866020015115613345576101a08701805142606090910152518051602082015160809092015160085460405163c6ceb96b60e01b8152600481018990526001600160a01b03868116956334327d8b95949093909291169063c6ceb96b9060240161010060405180830381865afa158015613211573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132359190615c04565b602001516040516001600160e01b031960e087901b16815260048101949094526024840192909252604483015260648201526084016020604051808303816000875af1158015613289573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132ad91906157f3565b6101a088015160c0015260085461012088015160405163080ec90d60e21b81526001600160a01b039092169163203b2434916132f6918891869189918991600190600401615d76565b600060405180830381600087803b15801561331057600080fd5b505af1158015613324573d6000803e3d6000fd5b5050505061334084886101a001516000015189602001516145af565b6134b0565b60c087015160e088015160085460405163c6ceb96b60e01b8152600481018890526001600160a01b03858116946375e2d946949093909291169063c6ceb96b9060240161010060405180830381865afa1580156133a6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133ca9190615c04565b602001516040516001600160e01b031960e086901b168152600481019390935260248301919091526044820152606401600060405180830381600087803b15801561341457600080fd5b505af1158015613428573d6000803e3d6000fd5b50506008546101208a015160405163080ec90d60e21b81526001600160a01b03909216935063203b2434925061346b918891869189918991600090600401615d76565b600060405180830381600087803b15801561348557600080fd5b505af1158015613499573d6000803e3d6000fd5b505050506134b0848860c0015189602001516145af565b60a087018490526040516398d796e760e01b81526001600160a01b038616906398d796e7906134e3908a90600401615de7565b600060405180830381600087803b1580156134fd57600080fd5b505af1158015613511573d6000803e3d6000fd5b5050604080518781526001600160a01b038c1660208201527f5e2ab39d79551e4c4e66256d806dd566d4d015420519d2ed2621563488a5d2a8935001905060405180910390a15050506001600160a01b03909416600090815260036020526040902093909355505050565b6008546001600160a01b031633148061359f57506007546001600160a01b031633145b6135bb5760405162461bcd60e51b8152600401610edf90615abb565b600081815260056020908152604080832054835260049182905291829020549151633c16f3ed60e21b81529081018590526001600160a01b0384811660248301529091169063f05bcfb490604401610fa9565b6000610c478383670de0b6b3a76400006136e6565b60008060005b848160ff16101561367757613659868260ff168151811061364c5761364c61580c565b6020026020010151610c4e565b6136639083615c94565b91508061366f81615a9c565b915050613629565b5060006136848285615f0f565b905060005b858160ff1610156136dc5760006136ae888360ff168151811061364c5761364c61580c565b9050808310156136c6575060ff169250610c47915050565b90910390806136d481615a9c565b915050613689565b5050509392505050565b60008260001904841183021582026136fd57600080fd5b5091020490565b60085460405163068bcd8d60e01b8152600481018390526001600160a01b039091169063068bcd8d90602401602060405180830381865afa15801561374d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137719190615add565b6001600160a01b03166396fd1c4261378883612176565b6040516001600160e01b031960e084901b1681526001600160a01b0390911660048201526000196024820152604401612395565b83156137d05782156137d0576137d06159e0565b60085460405163054d50b360e21b8152600481018790526000916001600160a01b03169063153542cc90602401602060405180830381865afa15801561381a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061383e9190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561387b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061389f91906157f3565b905060008085116138b157600061397f565b60085460405163920f4e5560e01b8152600481018990526001600160a01b039091169063920f4e5590602401602060405180830381865afa1580156138fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061391e9190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561395b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061397f91906157f3565b90506000866139b55761399c6139958385615c94565b879061459a565b6139ae90670de0b6b3a7640000615c94565b90506139f4565b6139bf858461459a565b670de0b6b3a7640000116139d5575060006139f4565b6139df858461459a565b6139f190670de0b6b3a7640000615797565b90505b6008546040516361fa5af560e01b8152600481018a9052881515602482015285156044820152606481018390526001600160a01b03909116906361fa5af590608401600060405180830381600087803b158015613a5057600080fd5b505af1158015613a64573d6000803e3d6000fd5b505050505050505050505050565b80600003613a975750506000908152600d60205260409020600a810154600b90910155565b60008381526005602090815260408083205483526004918290528083205490516363737ac960e11b81529182018590526001600160a01b03169190829063c6e6f59290602401602060405180830381865afa158015613afa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b1e91906157f3565b6040516363737ac960e11b8152600481018590529091506000906001600160a01b0384169063c6e6f59290602401602060405180830381865afa158015613b69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b8d91906157f3565b6000878152600d6020526040812060080154919250613bca613bb06002846157df565b613bc486613bbe8782615797565b9061459a565b9061360e565b613bd56002846157df565b613bdf9190615c94565b9050613bea88612176565b6001600160a01b03166342966c68613c028385615797565b6040518263ffffffff1660e01b8152600401613c2091815260200190565b600060405180830381600087803b158015613c3a57600080fd5b505af1158015613c4e573d6000803e3d6000fd5b5050506000898152600d602052604090206008810183905560030154613c759150826157df565b6000988952600d6020526040909820600b019790975550505050505050565b600060405163a9059cbb60e01b8152836004820152826024820152602060006044836000895af13d15601f3d1160016000511416171691505080613d0c5760405162461bcd60e51b815260206004820152600f60248201526e1514905394d1915497d19052531151608a1b6044820152606401610edf565b50505050565b600081815260056020908152604080832054835260049182905280832054600854915163068bcd8d60e01b81529283018590526001600160a01b03908116939291169063068bcd8d90602401602060405180830381865afa158015613d7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d9f9190615add565b600854604051634bee760b60e11b8152600481018690529192506001600160a01b0316906397dcec1690602401602060405180830381865afa158015613de9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613e0d91906157f3565b600314613e4f5760405162461bcd60e51b815260206004820152601060248201526f10b6b0b935b2ba21b7b73234ba34b7b760811b6044820152606401610edf565b60405163238f0e7560e11b8152600481018490526001600160a01b0383169063471e1cea90602401602060405180830381865afa158015613e94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613eb89190615ca7565b613efb5760405162461bcd60e51b815260206004820152601460248201527310b4b739ba393ab6b2b73a21b7b73234ba34b7b760611b6044820152606401610edf565b60085460405163b1283e7760e01b8152600481018590526000916001600160a01b03169063b1283e7790602401600060405180830381865afa158015613f45573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613f6d9190810190615b64565b60085460405163661f1cf560e01b8152600481018d9052919850600097506001600160a01b0316955063661f1cf594506024019250613faa915050565b602060405180830381865afa158015613fc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613feb91906157f3565b905081156141435760085460405163054d50b360e21b81526004810187905261413e9187916001600160a01b039091169063153542cc90602401602060405180830381865afa158015614042573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140669190615add565b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156140a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140c791906157f3565b604051634f626a0760e11b8152600481018990526001600160a01b03881690639ec4d40e90602401600060405180830381865afa15801561410c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052614134919081019061565b565b6101a00151614610565b6141c6565b6040516303d972f160e21b8152600481018690526001600160a01b03851690630f65cbc490602401602060405180830381865afa158015614188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141ac91906157f3565b6000036141bd5761413e858461470c565b6141c685614952565b6000858152602081905260409081902082905551634b7e8e2160e11b8152306004820152602481018290526001600160a01b038416906396fd1c4290604401600060405180830381600087803b15801561421f57600080fd5b505af1158015614233573d6000803e3d6000fd5b50505050826001600160a01b03166390f817026040518163ffffffff1660e01b8152600401602060405180830381865afa158015614275573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142999190615add565b6001600160a01b031663095ea7b3856001600160a01b03166350c6e6cf886040518263ffffffff1660e01b81526004016142d591815260200190565b602060405180830381865afa1580156142f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143169190615add565b6040516001600160e01b031960e084901b1681526001600160a01b039091166004820152602481018490526044016020604051808303816000875af1158015614363573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143879190615ca7565b506040516350c6e6cf60e01b8152600481018690526001600160a01b038516906350c6e6cf90602401602060405180830381865afa1580156143cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143f19190615add565b6001600160a01b031663d832f791826040518263ffffffff1660e01b815260040161441e91815260200190565b600060405180830381600087803b15801561443857600080fd5b505af115801561444c573d6000803e3d6000fd5b505050600086815260208190526040908190209051624e1afd60e81b8152600481018890528154602482015260018201546044820152600290910154606482015283151560848201526001600160a01b0386169150634e1afd009060a401600060405180830381600087803b1580156144c457600080fd5b505af11580156144d8573d6000803e3d6000fd5b50505050826001600160a01b0316638d01450f6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561182757600080fd5b60006040516323b872dd60e01b81528460048201528360248201528260448201526020600060648360008a5af13d15601f3d11600160005114161716915050806115b15760405162461bcd60e51b81526020600482015260146024820152731514905394d1915497d19493d357d1905253115160621b6044820152606401610edf565b6000610c4783670de0b6b3a7640000846136e6565b816000036145ed5760405162461bcd60e51b815260206004820152600b60248201526a0c081c1c9a5b98da5c185b60aa1b6044820152606401610edf565b6145f6836113b4565b614601838383614a18565b61460b8383614bfa565b505050565b60008160a00151116146535760405162461bcd60e51b815260206004820152600c60248201526b18102622ab2fa320a1aa27a960a11b6044820152606401610edf565b60405180606001604052806000815260200161468f8360800151613bc48560a00151670de0b6b3a76400006146889190615c94565b879061360e565b8152600060209182018190528581528082526040908190208351815583830151600182015592810151600290930192909255815180830190925260098252681c1c9a5b98da5c185b60ba1b90820152608082015160a083015161460b929161470791613bc49061468890670de0b6b3a7640000615c94565b614d2d565b60008281526005602090815260408083205483526004918290528083205490516318353be960e21b815291820185905282916001600160a01b03909116906360d4efa4906024016040805180830381865afa15801561476f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906147939190615f23565b60085460405163661f1cf560e01b81526004810188905292945090925060009161489b91614895916001600160a01b039091169063661f1cf590602401602060405180830381865afa1580156147ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061481191906157f3565b60085460405163c6ceb96b60e01b8152600481018a9052670de0b6b3a7640000916001600160a01b03169063c6ceb96b9060240161010060405180830381865afa158015614863573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906148879190615c04565b60c00151613bc49190615c94565b84614d76565b90506000614911856001600160a01b03166314e2b929846040518263ffffffff1660e01b81526004016148d091815260200190565b602060405180830381865afa1580156148ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061489591906157f3565b604080516060810182526000808252602080830196875282840194855299815298899052972096518755915160018701555051600290940193909355505050565b60008181526005602090815260408083205483526004918290528083205490516318353be960e21b815291820184905282916001600160a01b03909116906360d4efa4906024016040805180830381865afa1580156149b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906149d99190615f23565b60408051606081018252600080825260208083019586528284019485529781529687905295209451855590516001850155516002909301929092555050565b60085460405163068bcd8d60e01b8152600481018590526000916001600160a01b03169063068bcd8d90602401602060405180830381865afa158015614a62573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614a869190615add565b600854604051632a4a9dd160e01b8152600481018790529192506000916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015614ad6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614afa9190615983565b505050505050915050614b0c81614d8d565b8015614b1c5750614b1c84614d8d565b614b535760405162461bcd60e51b81526020600482015260086024820152673830b930b6a2a92960c11b6044820152606401610edf565b6000858152600d6020526040812090614b6c838761360e565b90506000846001600160a01b0316637063b06c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614bae573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614bd291906157f3565b90506000614be0838361459a565b600485019290925550600590920191909155505050505050565b60008281526005602090815260408083205483526004918290528083205490516363737ac960e11b81529182018490526001600160a01b03169190829063c6e6f59290602401602060405180830381865afa158015614c5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614c8191906157f3565b600854604051632a4a9dd160e01b8152600481018790529192506000916001600160a01b0390911690632a4a9dd19060240161010060405180830381865afa158015614cd1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614cf59190615983565b975050505050505050614d11828261360e90919063ffffffff16565b6000958652600d6020526040909520600a019490945550505050565b614d728282604051602401614d43929190615f47565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b179052614dac565b5050565b600081831115614d865781610c47565b5090919050565b6000614da3612710670de0b6b3a76400006157df565b90911015919050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b828054828255906000526020600020908101928215614e22579160200282015b82811115614e2257825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190614ded565b50614e2e929150614e32565b5090565b5b80821115614e2e5760008155600101614e33565b600060208284031215614e5957600080fd5b5035919050565b6001600160a01b0381168114614e7557600080fd5b50565b8035614e8381614e60565b919050565b600060208284031215614e9a57600080fd5b8135610c4781614e60565b8015158114614e7557600080fd5b8035614e8381614ea5565b60008060408385031215614ed157600080fd5b823591506020830135614ee381614ea5565b809150509250929050565b60008060408385031215614f0157600080fd5b823591506020830135614ee381614e60565b634e487b7160e01b600052604160045260246000fd5b604051610100810167ffffffffffffffff81118282101715614f4d57614f4d614f13565b60405290565b60405160e0810167ffffffffffffffff81118282101715614f4d57614f4d614f13565b6040516101c0810167ffffffffffffffff81118282101715614f4d57614f4d614f13565b604051601f8201601f1916810167ffffffffffffffff81118282101715614fc357614fc3614f13565b604052919050565b6000806000806000808688036101a0811215614fe657600080fd5b8735614ff181614e60565b9650602088013561500181614ea5565b9550604088013594506060880135935060808801359250610100609f19820181131561502c57600080fd5b615034614f29565b915060a0890135825260c0890135602083015260e0890135604083015280890135606083015250610120880135608082015261014088013560a082015261016088013560c082015261018088013560e0820152809150509295509295509295565b600067ffffffffffffffff8211156150af576150af614f13565b5060051b60200190565b600080604083850312156150cc57600080fd5b8235915060208084013567ffffffffffffffff8111156150eb57600080fd5b8401601f810186136150fc57600080fd5b803561510f61510a82615095565b614f9a565b81815260059190911b8201830190838101908883111561512e57600080fd5b928401925b8284101561514c57833582529284019290840190615133565b80955050505050509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561519c5783516001600160a01b031683529284019291840191600101615177565b50909695505050505050565b600080604083850312156151bb57600080fd5b50508035926020909101359150565b6000806000606084860312156151df57600080fd5b8335925060208401356151f181614e60565b9150604084013561520181614ea5565b809150509250925092565b60008060008060008060c0878903121561522557600080fd5b86359550602087013561523781614e60565b945060408701359350606087013592506080870135915060a087013561525c81614ea5565b809150509295509295509295565b6020808252825182820181905260009190848201906040850190845b8181101561519c57835183529284019291840191600101615286565b6000806000606084860312156152b757600080fd5b505081359360208301359350604090920135919050565b600080604083850312156152e157600080fd5b82356152ec81614e60565b946020939093013593505050565b600067ffffffffffffffff82111561531457615314614f13565b50601f01601f191660200190565b600082601f83011261533357600080fd5b813561534161510a826152fa565b81815284602083860101111561535657600080fd5b816020850160208301376000918101602001919091529392505050565b60048110614e7557600080fd5b8035614e8381615373565b600060e0828403121561539d57600080fd5b6153a5614f53565b9050813581526020820135602082015260408201356040820152606082013560608201526080820135608082015260a082013560a082015260c082013560c082015292915050565b60008060006060848603121561540257600080fd5b833561540d81614e60565b9250602084013567ffffffffffffffff8082111561542a57600080fd5b90850190610280828803121561543f57600080fd5b615447614f76565b8235815261545760208401614eb3565b602082015261546860408401614eb3565b6040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c082015260e083013560e082015261010080840135818301525061012080840135838111156154bf57600080fd5b6154cb8a828701615322565b82840152505061014091506154e1828401614e78565b8282015261016091506154f5828401615380565b82820152610180915081830135828201526101a091506155178883850161538b565b82820152809450505050604084013590509250925092565b60008060006060848603121561554457600080fd5b83359250602084013561555681614e60565b929592945050506040919091013590565b8051614e8381614ea5565b60005b8381101561558d578181015183820152602001615575565b50506000910152565b600082601f8301126155a757600080fd5b81516155b561510a826152fa565b8181528460208386010111156155ca57600080fd5b6155db826020830160208701615572565b949350505050565b8051614e8381614e60565b8051614e8381615373565b600060e0828403121561560b57600080fd5b615613614f53565b9050815181526020820151602082015260408201516040820152606082015160608201526080820151608082015260a082015160a082015260c082015160c082015292915050565b60006020828403121561566d57600080fd5b815167ffffffffffffffff8082111561568557600080fd5b90830190610280828603121561569a57600080fd5b6156a2614f76565b825181526156b260208401615567565b60208201526156c360408401615567565b6040820152606083015160608201526080830151608082015260a083015160a082015260c083015160c082015260e083015160e0820152610100808401518183015250610120808401518381111561571a57600080fd5b61572688828701615596565b828401525050610140915061573c8284016155e3565b8282015261016091506157508284016155ee565b82820152610180915081830151828201526101a09150615772868385016155f9565b91810191909152949350505050565b634e487b7160e01b600052601160045260246000fd5b81810381811115610b0257610b02615781565b60008160001904831182151516156157c4576157c4615781565b500290565b634e487b7160e01b600052601260045260246000fd5b6000826157ee576157ee6157c9565b500490565b60006020828403121561580557600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b60006001820161583457615834615781565b5060010190565b60008060008060008060c0878903121561585457600080fd5b865161585f81614ea5565b602088015190965061587081614ea5565b604088015190955061588181614ea5565b606088015190945061589281614ea5565b60808801519093506158a381614ea5565b8092505060a087015190509295509295509295565b805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c083015260e081015160e08301525050565b6001600160a01b038881168252871660208201528515156040820152606081018590526080810184905260a081018390526101c0810161594960c08301846158b8565b98975050505050505050565b6000806040838503121561596857600080fd5b825161597381614e60565b6020939093015192949293505050565b600080600080600080600080610100898b0312156159a057600080fd5b505086516020880151604089015160608a015160808b015160a08c015160c08d015160e0909d0151959e949d50929b919a50985090965094509092509050565b634e487b7160e01b600052600160045260246000fd5b60006020808385031215615a0957600080fd5b825167ffffffffffffffff811115615a2057600080fd5b8301601f81018513615a3157600080fd5b8051615a3f61510a82615095565b81815260059190911b82018301908381019087831115615a5e57600080fd5b928401925b82841015612d61578351615a7681614e60565b82529284019290840190615a63565b600081615a9457615a94615781565b506000190190565b600060ff821660ff8103615ab257615ab2615781565b60010192915050565b60208082526008908201526710b6b0b730b3b2b960c11b604082015260600190565b600060208284031215615aef57600080fd5b8151610c4781614e60565b6020808252600490820152630855985b60e21b604082015260600190565b60008060008060808587031215615b2e57600080fd5b8451615b3981614ea5565b8094505060208501519250604085015191506060850151615b5981614ea5565b939692955090935050565b600080600080600080600060e0888a031215615b7f57600080fd5b8751615b8a81614e60565b6020890151909750615b9b81614e60565b6040890151909650615bac81614e60565b606089015190955067ffffffffffffffff811115615bc957600080fd5b615bd58a828b01615596565b9450506080880151925060a0880151915060c0880151615bf481614ea5565b8091505092959891949750929550565b6000610100808385031215615c1857600080fd5b6040519081019067ffffffffffffffff82118183101715615c3b57615c3b614f13565b81604052835181526020840151602082015260408401516040820152606084015160608201526080840151608082015260a084015160a082015260c084015160c082015260e084015160e0820152809250505092915050565b80820180821115610b0257610b02615781565b600060208284031215615cb957600080fd5b8151610c4781614ea5565b602080825260089082015267061646472657373360c41b604082015260600190565b6101408101615cf582866158b8565b6101008201939093526101200152919050565b600080600060608486031215615d1d57600080fd5b8351615d2881614e60565b6020850151909350615d3981614e60565b604085015190925061520181614e60565b60008151808452615d62816020860160208601615572565b601f01601f19169290920160200192915050565b8681526001600160a01b03868116602083015285811660408301528416606082015260c060808201819052600090615db090830185615d4a565b905082151560a0830152979650505050505050565b60048110615de357634e487b7160e01b600052602160045260246000fd5b9052565b602081528151602082015260006020830151615e07604084018215159052565b50604083015180151560608401525060608301516080830152608083015160a083015260a083015160c083015260c083015160e083015260e083015161010081818501528085015191505061012081818501528085015191505061014061028081850152615e796102a0850183615d4a565b90850151909150610160615e97858201836001600160a01b03169052565b8501519050610180615eab85820183615dc5565b8501516101a08581019190915285015180516101c086015260208101516101e086015260408101516102008601526060810151610220860152608081015161024086015260a081015161026086015260c08101516102808601529050509392505050565b600082615f1e57615f1e6157c9565b500690565b60008060408385031215615f3657600080fd5b505080516020909101519092909150565b604081526000615f5a6040830185615d4a565b9050826020830152939250505056fea264697066735822122055c72d31c943c22a89ca8fedc75017f59a70087fd66af5bf1eec966dc25fc81064736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_getValidators(uint256)": {
        "details": "for now called on market initialization"
      },
      "beforeResolve(uint256)": {
        "details": "Prepare market/instrument for closing, called separately before resolveMarket this is either called automatically from the instrument when conditions are met i.e fully repaid principal + interest or, in the event of a default, by validators who deem the principal recouperation is finished and need to collect remaining funds by redeeming ZCB"
      },
      "calcImpliedProbability(uint256,uint256,uint256)": {
        "params": {
          "budget": "of trader in collateral decimals"
        }
      },
      "createVault(address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "params": {
          "_asset_limit": ": max number of shares for a single address",
          "_onlyVerified": ": only verified users can mint shares",
          "_r": ": minimum reputation score to mint shares",
          "_total_asset_limit": ": max number of shares for entire vault",
          "default_params": ": default params for markets created by vault",
          "underlying": ": underlying asset for vault"
        }
      },
      "denyMarket(uint256)": {
        "details": "called by validator denial of market."
      },
      "forceCloseInstrument(uint256,bool)": {
        "details": "withdraws all balance from the instrument. If assets in instrument is not in underlying, need all balances to be divested to underlying Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.",
        "params": {
          "emergency": "ascribes cases where the instrument should be forcefully liquidated back to the vault"
        }
      },
      "fulfillRandomWords(uint256,uint256[])": {
        "details": "TODO => can be called by anyone?"
      },
      "initiateMarket(address,(bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)),uint256)": {
        "details": "Instrument should already be deployed",
        "params": {
          "instrumentData": ": instrument arguments",
          "recipient": ": utilizer for the associated instrument",
          "vaultId": ": vault identifier"
        }
      },
      "resolveMarket(uint256)": {
        "details": "validators call this function from market manager any funds left for the instrument, irrespective of whether it is in profit or inloss."
      },
      "validatorApprove(uint256)": {
        "details": "get val_cap, the total amount of zcb for sale and each validators should buy val_cap/num validators zcb They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly correlated instruments triggers controller.approveMarket"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_getValidators(uint256)": {
        "notice": "randomly choose validators for market approval, async operation => fulfillRandomness is the callback function."
      },
      "addAcceptedCollateral(uint256,address,uint256,uint256,uint256,bool)": {
        "notice": "pool instrumentcalled by utilizer during assessment"
      },
      "approvalCondition(uint256)": {
        "notice": "conditions for approval => validator zcb stake fulfilled + validators have all approved"
      },
      "beforeResolve(uint256)": {
        "notice": "Resolve function 1"
      },
      "calcImpliedProbability(uint256,uint256,uint256)": {
        "notice": "calculates implied probability of the trader, used to update the reputation score by brier scoring mechanism"
      },
      "createVault(address,bool,uint256,uint256,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))": {
        "notice": "creates vault"
      },
      "deduct_selling_fee(uint256)": {
        "notice": "deduce fees for non vault stakers, should go down as maturity time approach 0"
      },
      "deniedValidator(uint256,address)": {
        "notice": "called by marketManager.redeemDeniedMarket, redeems the discounted ZCB"
      },
      "forceCloseInstrument(uint256,bool)": {
        "notice": "function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc. After, the resolveMarket function should be called in a new block"
      },
      "fulfillRandomWords(uint256,uint256[])": {
        "notice": "chainlink callback function, sets validators."
      },
      "initiateMarket(address,(bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)),uint256)": {
        "notice": "initiates market, called by frontend loan proposal or instrument form submit button."
      },
      "isValidator(uint256,address)": {
        "notice": "returns true if user is validator for corresponding market"
      },
      "marketCondition(uint256)": {
        "notice": "returns true if amount bought is greater than the insurance threshold"
      },
      "redeem_transfer(uint256,address,uint256)": {
        "notice": "called only when redeeming, transfer funds from vault"
      },
      "resolveCondition(uint256)": {
        "notice": "condition for resolving market, met when all the validators chosen for the market have voted to resolve."
      },
      "resolveMarket(uint256)": {
        "notice": "Resolve function 2main function called at maturity OR premature resolve of instrument(from early default)"
      },
      "testApproveMarket(uint256)": {
        "notice": "GOD FUNCTION"
      },
      "unlockValidatorStake(uint256)": {
        "notice": "called by validators when the market is resolved or denied to retrieve their stake."
      },
      "updateReputation(uint256,address,bool)": {
        "notice": "when market is resolved(maturity/early default), calculates score and update each assessment phase trader's reputation, called by individual traders when redeeming"
      },
      "validatorApprove(uint256)": {
        "notice": "allows validators to buy at a discount + automatically stake a percentage of the principal They can only buy a fixed amount of ZCB, usually a at lot larger amount"
      },
      "validatorResolve(uint256)": {
        "notice": "called by validators to approve resolving the market, after approval."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 10234,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "approvalDatas",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(ApprovalData)10223_storage)"
      },
      {
        "astId": 10251,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "verified",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 10256,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "market_data",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_struct(MarketData)10216_storage)"
      },
      {
        "astId": 10260,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "ad_to_id",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 10265,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "vaults",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_contract(Vault)28595)"
      },
      {
        "astId": 10269,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "id_parent",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 10274,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "vault_to_marketIds",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 10276,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "creator_address",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 10279,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "marketManager",
        "offset": 0,
        "slot": "8",
        "type": "t_contract(MarketManager)16115"
      },
      {
        "astId": 10282,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "vaultFactory",
        "offset": 0,
        "slot": "9",
        "type": "t_contract(VaultFactory)13183"
      },
      {
        "astId": 10285,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "poolFactory",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(SyntheticZCBPoolFactory)5852"
      },
      {
        "astId": 10288,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "reputationManager",
        "offset": 0,
        "slot": "11",
        "type": "t_contract(ReputationManager)16918"
      },
      {
        "astId": 11567,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "requestToMarketId",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 11572,
        "contract": "contracts/protocol/controller.sol:Controller",
        "label": "validator_data",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_uint256,t_struct(ValidatorData)11563_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(MarketManager)16115": {
        "encoding": "inplace",
        "label": "contract MarketManager",
        "numberOfBytes": "20"
      },
      "t_contract(ReputationManager)16918": {
        "encoding": "inplace",
        "label": "contract ReputationManager",
        "numberOfBytes": "20"
      },
      "t_contract(SyntheticZCBPoolFactory)5852": {
        "encoding": "inplace",
        "label": "contract SyntheticZCBPoolFactory",
        "numberOfBytes": "20"
      },
      "t_contract(Vault)28595": {
        "encoding": "inplace",
        "label": "contract Vault",
        "numberOfBytes": "20"
      },
      "t_contract(VaultFactory)13183": {
        "encoding": "inplace",
        "label": "contract VaultFactory",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_uint256,t_contract(Vault)28595)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => contract Vault)",
        "numberOfBytes": "32",
        "value": "t_contract(Vault)28595"
      },
      "t_mapping(t_uint256,t_struct(ApprovalData)10223_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Controller.ApprovalData)",
        "numberOfBytes": "32",
        "value": "t_struct(ApprovalData)10223_storage"
      },
      "t_mapping(t_uint256,t_struct(MarketData)10216_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Controller.MarketData)",
        "numberOfBytes": "32",
        "value": "t_struct(MarketData)10216_storage"
      },
      "t_mapping(t_uint256,t_struct(ValidatorData)11563_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Controller.ValidatorData)",
        "numberOfBytes": "32",
        "value": "t_struct(ValidatorData)11563_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(ApprovalData)10223_storage": {
        "encoding": "inplace",
        "label": "struct Controller.ApprovalData",
        "members": [
          {
            "astId": 10218,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "managers_stake",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 10220,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "approved_principal",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 10222,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "approved_yield",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(MarketData)10216_storage": {
        "encoding": "inplace",
        "label": "struct Controller.MarketData",
        "members": [
          {
            "astId": 10213,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "instrument_address",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 10215,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "utilizer",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(ValidatorData)11563_storage": {
        "encoding": "inplace",
        "label": "struct Controller.ValidatorData",
        "members": [
          {
            "astId": 11533,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "sales",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 11537,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "staked",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 11541,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "resolved",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 11544,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "validators",
            "offset": 0,
            "slot": "3",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 11546,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "val_cap",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 11548,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "avg_price",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 11550,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "requested",
            "offset": 0,
            "slot": "6",
            "type": "t_bool"
          },
          {
            "astId": 11552,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "totalSales",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 11554,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "totalStaked",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 11556,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "numApproved",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 11558,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "initialStake",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 11560,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "finalStake",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          },
          {
            "astId": 11562,
            "contract": "contracts/protocol/controller.sol:Controller",
            "label": "numResolved",
            "offset": 0,
            "slot": "12",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "416"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}